
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.29.0' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /**
     * @typedef {Object} WrappedComponent
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {function(): Promise<SvelteComponent>} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {Object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {Object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {Object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function regexparam (str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules\svelte-spa-router\Router.svelte generated by Svelte v3.29.0 */

    const { Error: Error_1, Object: Object_1, console: console_1 } = globals;

    // (209:0) {:else}
    function create_else_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(209:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (202:0) {#if componentParams}
    function create_if_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(202:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap$1(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn("Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading");

    	return wrap({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf("#/");

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: "/";

    	// Check if there's a querystring
    	const qsPosition = location.indexOf("?");

    	let querystring = "";

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener("hashchange", update, false);

    	return function stop() {
    		window.removeEventListener("hashchange", update, false);
    	};
    });

    const location$1 = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == "#" ? "" : "#") + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == "#" ? "" : "#") + location;

    	try {
    		window.history.replaceState(undefined, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn("Caught exception while replacing the current page. If you're running this in the Svelte REPL, please note that the `replace` method might not work in this environment.");
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event("hashchange"));
    }

    function link(node, hrefVar) {
    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != "a") {
    		throw Error("Action \"link\" can only be used with <a> tags");
    	}

    	updateLink(node, hrefVar || node.getAttribute("href"));

    	return {
    		update(updated) {
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, href) {
    	// Destination must start with '/'
    	if (!href || href.length < 1 || href.charAt(0) != "/") {
    		throw Error("Invalid value for \"href\" attribute: " + href);
    	}

    	// Add # to the href attribute
    	node.setAttribute("href", "#" + href);

    	node.addEventListener("click", scrollstateHistoryHandler);
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {HTMLElementEventMap} event - an onclick event attached to an anchor tag
     */
    function scrollstateHistoryHandler(event) {
    	// Prevent default anchor onclick behaviour
    	event.preventDefault();

    	const href = event.currentTarget.getAttribute("href");

    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Router", slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = "" } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != "function" && (typeof component != "object" || component._sveltesparouter !== true)) {
    				throw Error("Invalid component object");
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == "string" && (path.length < 1 || path.charAt(0) != "/" && path.charAt(0) != "*") || typeof path == "object" && !(path instanceof RegExp)) {
    				throw Error("Invalid value for \"path\" argument");
    			}

    			const { pattern, keys } = regexparam(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == "object" && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, remove it before we run the matching
    			if (prefix) {
    				if (typeof prefix == "string" && path.startsWith(prefix)) {
    					path = path.substr(prefix.length) || "/";
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || "/";
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || "") || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {Object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {bool} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	if (restoreScrollState) {
    		window.addEventListener("popstate", event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		});

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.scrollX, previousScrollState.scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick("conditionsFailed", detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoading", Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == "object" && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    	});

    	const writable_props = ["routes", "prefix", "restoreScrollState"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble($$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		derived,
    		tick,
    		_wrap: wrap,
    		wrap: wrap$1,
    		getLocation,
    		loc,
    		location: location$1,
    		querystring,
    		push,
    		pop,
    		replace,
    		link,
    		updateLink,
    		scrollstateHistoryHandler,
    		createEventDispatcher,
    		afterUpdate,
    		regexparam,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		lastLoc,
    		componentObj
    	});

    	$$self.$inject_state = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("componentParams" in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ("props" in $$props) $$invalidate(2, props = $$props.props);
    		if ("previousScrollState" in $$props) previousScrollState = $$props.previousScrollState;
    		if ("lastLoc" in $$props) lastLoc = $$props.lastLoc;
    		if ("componentObj" in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			 history.scrollRestoration = restoreScrollState ? "manual" : "auto";
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance, create_fragment, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function e(e){this.message=e;}e.prototype=new Error,e.prototype.name="InvalidCharacterError";var r="undefined"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,"");if(t.length%4==1)throw new e("'atob' failed: The string to be decoded is not correctly encoded.");for(var n,o,a=0,i=0,c="";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o);return c};function t(e){var t=e.replace(/-/g,"+").replace(/_/g,"/");switch(t.length%4){case 0:break;case 2:t+="==";break;case 3:t+="=";break;default:throw "Illegal base64url string!"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t="0"+t),"%"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e;}function o(e,r){if("string"!=typeof e)throw new n("Invalid token specified");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(".")[o]))}catch(e){throw new n("Invalid token specified: "+e.message)}}n.prototype=new Error,n.prototype.name="InvalidTokenError";

    var bind$1 = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    /*global toString:true*/

    // utils is a library of generic helper functions non-specific to axios

    var toString = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a plain Object
     *
     * @param {Object} val The value to test
     * @return {boolean} True if value is a plain Object, otherwise false
     */
    function isPlainObject(val) {
      if (toString.call(val) !== '[object Object]') {
        return false;
      }

      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind$1(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     * @return {string} content value without BOM
     */
    function stripBOM(content) {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }
      return content;
    }

    var utils = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isPlainObject: isPlainObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      extend: extend,
      trim: trim,
      stripBOM: stripBOM
    };

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });

      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    var cookies = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));

              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }

              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }

              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }

              if (secure === true) {
                cookie.push('secure');
              }

              document.cookie = cookie.join('; ');
            },

            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },

            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :

      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    var buildFullPath = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };

    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });

      return parsed;
    };

    var isURLSameOrigin = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;

            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }

            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }

          originURL = resolveURL(window.location.href);

          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );

    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        // Listen for ready state
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }

          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        };

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError('Request aborted', config, 'ECONNABORTED', request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies.read(config.xsrfCookieName) :
            undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config.responseType !== 'json') {
              throw e;
            }
          }
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (!requestData) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
      }
      return adapter;
    }

    var defaults = {
      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');
        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (e) { /* Ignore */ }
        }
        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,
      maxBodyLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults;

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );

      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    var mergeConfig = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};

      var valueFromConfig2Keys = ['url', 'method', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
      var defaultToConfig2Keys = [
        'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
        'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
      ];
      var directMergeKeys = ['validateStatus'];

      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }

      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      }

      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        }
      });

      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys)
        .concat(directMergeKeys);

      var otherKeys = Object
        .keys(config1)
        .concat(Object.keys(config2))
        .filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });

      utils.forEach(otherKeys, mergeDeepProperties);

      return config;
    };

    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig(this.defaults, config);

      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }

      // Hook up interceptors middleware
      var chain = [dispatchRequest, undefined];
      var promise = Promise.resolve(config);

      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });

      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }

      return promise;
    };

    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: (config || {}).data
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Determines whether the payload is an error thrown by Axios
     *
     * @param {*} payload The value to test
     * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
     */
    var isAxiosError = function isAxiosError(payload) {
      return (typeof payload === 'object') && (payload.isAxiosError === true);
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind$1(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios.Axios = Axios_1;

    // Factory for creating new instances
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios.Cancel = Cancel_1;
    axios.CancelToken = CancelToken_1;
    axios.isCancel = isCancel;

    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;

    // Expose isAxiosError
    axios.isAxiosError = isAxiosError;

    var axios_1 = axios;

    // Allow use of default import syntax in TypeScript
    var _default = axios;
    axios_1.default = _default;

    var axios$1 = axios_1;

    // const url = 'https://xmconsulta.cthrics.com/api'
    // const url = 'http://localhost:3000/api'
    // const url = 'http://serenidad.xmedical.online:1337/api';
    // const url = 'https://consulta.xmedical.online/api';
    const url = 'http://localhost:1337/api';

    const isLogin = () => {
        if(localStorage.getItem('auth')){
            return true
        }
        else
        {
            return false
        }
    };

    const logout = () => { 
        localStorage.removeItem('auth');
        return push('/login')
    };

    const user = () => {
        const decoded = o(localStorage.getItem('auth'));
        return decoded;
    };

    const calcularEdad = (fecha) => {
        let hoy = new Date();
        let cumpleanos = new Date(fecha);
        let edad = hoy.getFullYear() - cumpleanos.getFullYear();
        let m = hoy.getMonth() - cumpleanos.getMonth();

        if (m < 0 || (m === 0 && hoy.getDate() < cumpleanos.getDate())) {
          edad--;
        }

        return edad;
    };

    const search = (timeout, cb) => {
        if (timeout) {
            window.clearTimeout(timeout);
        }
        
        timeout = setTimeout(function () { cb(); }, 300);
    };



    let ciudades = [
        {id: 'Distrito Nacional', nombre: 'Distrito Nacional'},
        {id: 'Santiago de los Caballeros', nombre: 'Santiago de los Caballeros'},
        {id: 'Santo Domingo Este', nombre: 'Santo Domingo Este'},
        {id: 'Santo Domingo Norte', nombre: 'Santo Domingo Norte'},
        {id: 'Santo Domingo Oeste', nombre: 'Santo Domingo Oeste'},
        {id: 'San Felipe de Puerto Plata', nombre: 'San Felipe de Puerto Plata'},
        {id: 'Higey', nombre: 'Higey'},
        {id: 'San Francisco de Macors', nombre: 'San Francisco de Macors'},
        {id: 'San Cristbal', nombre: 'San Cristbal'},
        {id: 'San Pedro de Macoris', nombre: 'San Pedro de Macoris'},
        {id: 'Los Alcarrizos', nombre: 'Los Alcarrizos'},
        {id: 'La Vega', nombre: 'La Vega'},
        {id: 'La Romana', nombre: 'La Romana'},
        {id: 'Moca', nombre: 'Moca'},
        {id: 'Villa Altagracia', nombre: 'Villa Altagracia'},
        {id: 'San Juan de La Maguana', nombre: 'San Juan de La Maguana'},
        {id: 'Haina', nombre: 'Haina'},
        {id: 'Bonao', nombre: 'Bonao'},
        {id: 'Cotu', nombre: 'Cotu'},
        {id: 'Ban', nombre: 'Ban'},
        {id: 'Santa Cruz de Barahona', nombre: 'Santa Cruz de Barahona'},
        {id: 'Azua de Compostela', nombre: 'Azua de Compostela'},
        {id: 'Boca Chica', nombre: 'Boca Chica'},
        {id: 'Villa hermosa', nombre: 'Villa hermosa'},
        {id: 'Mao', nombre: 'Mao'},
        {id: 'Pedro Brand', nombre: 'Pedro Brand'},
        {id: 'San Antonio de Guerra', nombre: 'San Antonio de Guerra'},
        {id: 'San Ignacio de Sabaneta', nombre: 'San Ignacio de Sabaneta'},
        {id: 'Santa Cruz del Seibo', nombre: 'Santa Cruz del Seibo'},
        {id: 'Tamboril', nombre: 'Tamboril'},
        {id: 'Nagua', nombre: 'Nagua'},
        {id: 'Pual', nombre: 'Pual'},
        {id: 'Hato', nombre: 'Hato'},
        {id: 'Esperanza', nombre: 'Esperanza'},
        {id: 'Sosa', nombre: 'Sosa'},
        {id: 'Jarabacoa', nombre: 'Jarabacoa'},
        {id: 'San Jos de las Matas', nombre: 'San Jos de las Matas'},
        {id: 'Yamas', nombre: 'Yamas'},
        {id: 'Monte Plata', nombre: 'Monte Plata'},
        {id: 'Villa Gonzlez', nombre: 'Villa Gonzlez'},
    ];

    let provincias = [
        {id: 'Santiago', nombre: 'Santiago'},
        {id: 'Puerto Plata', nombre: 'Puerto Plata'},
        {id: 'La Altagracia', nombre: 'La Altagracia'},
        {id: 'Duarte', nombre: 'Duarte'},
        {id: 'San Cristbal', nombre: 'San Cristbal'},
        {id: 'San pedro de Macoris', nombre: 'San pedro de Macoris'},
        {id: 'La vega', nombre: 'La vega'},
        {id: 'La Romana', nombre: 'La Romana'},
        {id: 'Espaillat', nombre: 'Espaillat'},
        {id: 'San Cristbal', nombre: 'San Cristbal'},
        {id: 'San Juan de La Maguana', nombre: 'San Juan de La Maguana'},
        {id: 'San Cristbal', nombre: 'San Cristbal'},
        {id: 'Monseor Nouel', nombre: 'Monseor Nouel'},
        {id: 'Snchez Ramrez', nombre: 'Snchez Ramrez'},
        {id: 'Peravia	', nombre: 'Peravia	'},
        {id: 'Barahona', nombre: 'Barahona'},
        {id: 'Azua', nombre: 'Azua'},
        {id: 'La Romana', nombre: 'La Romana'},
        {id: 'Valverde', nombre: 'Valverde'},
        {id: 'Santo Domingo', nombre: 'Santo Domingo'},
        {id: 'Santiago Rodrguez', nombre: 'Santiago Rodrguez'},
        {id: 'El Seibo', nombre: 'El Seibo'},
        {id: 'Santiago', nombre: 'Santiago'},
        {id: 'Maria Trinidad Sanchez', nombre: 'Maria Trinidad Sanchez'},
        {id: 'Santiago', nombre: 'Santiago'},
        {id: 'Mayor del Rey	Hato Mayor', nombre: 'Mayor del Rey	Hato Mayor'},
        {id: 'Valverde Mao', nombre: 'Valverde Mao'},
        {id: 'Puerto Plata', nombre: 'Puerto Plata'},
        {id: 'La vega', nombre: 'La vega'},
        {id: 'Santiago', nombre: 'Santiago'},
        {id: 'Monte plata	', nombre: 'Monte plata	'},
        {id: 'Monte Plata', nombre: 'Monte Plata'},
        {id: 'Santiago', nombre: 'Santiago'},
    ];
    let nacionalidades = [
        {id: 'afgano', nombre: 'afgano'},
        {id: 'alemn', nombre: 'alemn'},
        {id: 'rabe', nombre: 'rabe'},
        {id: 'argentino', nombre: 'argentino'},
        {id: 'australiano', nombre: 'australiano'},
        {id: 'belga', nombre: 'belga'},
        {id: 'boliviano', nombre: 'boliviano'},
        {id: 'brasileo', nombre: 'brasileo'},
        {id: 'camboyano', nombre: 'camboyano'},
        {id: 'canadiense', nombre: 'canadiense'},
        {id: 'chileno', nombre: 'chileno'},
        {id: 'chino', nombre: 'chino'},
        {id: 'colombiano', nombre: 'colombiano'},
        {id: 'coreano', nombre: 'coreano'},
        {id: 'costarricense', nombre: 'costarricense'},
        {id: 'cubano', nombre: 'cubano'},
        {id: 'dans', nombre: 'dans'},
        {id: 'ecuatoriano', nombre: 'ecuatoriano'},
        {id: 'egipcio', nombre: 'egipcio'},
        {id: 'salvadoreo', nombre: 'salvadoreo'},
        {id: 'escocs', nombre: 'escocs'},
        {id: 'espaol', nombre: 'espaol'},
        {id: 'estadounidense', nombre: 'estadounidense'},
        {id: 'estonio', nombre: 'estonio'},
        {id: 'etiope', nombre: 'etiope'},
        {id: 'filipino', nombre: 'filipino'},
        {id: 'finlands', nombre: 'finlands'},
        {id: 'francs', nombre: 'francs'},
        {id: 'gals', nombre: 'gals'},
        {id: 'griego', nombre: 'griego'},
        {id: 'guatemalteco', nombre: 'guatemalteco'},
        {id: 'haitiano', nombre: 'haitiano'},
        {id: 'holands', nombre: 'holands'},
        {id: 'hondureo', nombre: 'hondureo'},
        {id: 'indons', nombre: 'indons'},
        {id: 'ingls', nombre: 'ingls'},
        {id: 'iraqu', nombre: 'iraqu'},
        {id: 'iran', nombre: 'iran'},
        {id: 'irlands', nombre: 'irlands'},
        {id: 'israel', nombre: 'israel'},
        {id: 'italiano', nombre: 'italiano'},
        {id: 'japons', nombre: 'japons'},
        {id: 'jordano', nombre: 'jordano'},
        {id: 'laosiano', nombre: 'laosiano'},
        {id: 'letn', nombre: 'letn'},
        {id: 'letons', nombre: 'letons'},
        {id: 'malayo', nombre: 'malayo'},
        {id: 'marroqu', nombre: 'marroqu'},
        {id: 'mexicano', nombre: 'mexicano'},
        {id: 'nicaragense', nombre: 'nicaragense'},
        {id: 'noruego', nombre: 'noruego'},
        {id: 'neozelands', nombre: 'neozelands'},
        {id: 'panameo', nombre: 'panameo'},
        {id: 'paraguayo', nombre: 'paraguayo'},
        {id: 'peruano', nombre: 'peruano'},
        {id: 'polaco', nombre: 'polaco'},
        {id: 'portugus', nombre: 'portugus'},
        {id: 'puertorriqueo', nombre: 'puertorriqueo'},
        {id: 'dominicano', nombre: 'dominicano'},
        {id: 'rumano', nombre: 'rumano'},
        {id: 'ruso', nombre: 'ruso'},
        {id: 'sueco', nombre: 'sueco'},
        {id: 'suizo', nombre: 'suizo'},
        {id: 'tailands', nombre: 'tailands'},
        {id: 'taiwanes', nombre: 'taiwanes'},
        {id: 'turco', nombre: 'turco'},
        {id: 'ucraniano', nombre: 'ucraniano'},
        {id: 'uruguayo', nombre: 'uruguayo'},
        {id: 'venezolano', nombre: 'venezolano'},
        {id: 'vietnamita', nombre: 'vietnamita'},
    ];

    /* src\componentes\Loading.svelte generated by Svelte v3.29.0 */

    const file = "src\\componentes\\Loading.svelte";

    function create_fragment$1(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "svelte-44tycx");
    			add_location(div0, file, 1, 4, 30);
    			attr_dev(div1, "class", "svelte-44tycx");
    			add_location(div1, file, 2, 4, 43);
    			attr_dev(div2, "class", "lds-ripple svelte-44tycx");
    			add_location(div2, file, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Loading", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Loading> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Loading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loading",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src\componentes\Modals\ModalChangePassword.svelte generated by Svelte v3.29.0 */

    const { console: console_1$1 } = globals;
    const file$1 = "src\\componentes\\Modals\\ModalChangePassword.svelte";

    // (108:20) {#if cargando}
    function create_if_block_1(ctx) {
    	let div;
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loading.$$.fragment);
    			attr_dev(div, "class", "cargando");
    			add_location(div, file$1, 108, 24, 3435);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loading, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(108:20) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    // (128:20) {#if msgError}
    function create_if_block$1(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*msgError*/ ctx[0]);
    			attr_dev(div, "class", "alert alert-danger");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$1, 128, 24, 4685);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*msgError*/ 1) set_data_dev(t, /*msgError*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(128:20) {#if msgError}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let form;
    	let div14;
    	let div13;
    	let div12;
    	let div0;
    	let h5;
    	let t1;
    	let button0;
    	let span;
    	let t3;
    	let div5;
    	let t4;
    	let div4;
    	let div1;
    	let label0;
    	let t6;
    	let input0;
    	let t7;
    	let div2;
    	let label1;
    	let t9;
    	let input1;
    	let t10;
    	let div3;
    	let label2;
    	let t12;
    	let input2;
    	let t13;
    	let t14;
    	let br;
    	let t15;
    	let div11;
    	let div10;
    	let div7;
    	let a;
    	let h30;
    	let t16;
    	let div6;
    	let t18;
    	let div9;
    	let button1;
    	let h31;
    	let t19;
    	let div8;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*cargando*/ ctx[1] && create_if_block_1(ctx);
    	let if_block1 = /*msgError*/ ctx[0] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			form = element("form");
    			div14 = element("div");
    			div13 = element("div");
    			div12 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Cambiar contrasea";
    			t1 = space();
    			button0 = element("button");
    			span = element("span");
    			span.textContent = "";
    			t3 = space();
    			div5 = element("div");
    			if (if_block0) if_block0.c();
    			t4 = space();
    			div4 = element("div");
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Contrasea anterior";
    			t6 = space();
    			input0 = element("input");
    			t7 = space();
    			div2 = element("div");
    			label1 = element("label");
    			label1.textContent = "Nueva contrasea";
    			t9 = space();
    			input1 = element("input");
    			t10 = space();
    			div3 = element("div");
    			label2 = element("label");
    			label2.textContent = "Repetir Nueva contrasea";
    			t12 = space();
    			input2 = element("input");
    			t13 = space();
    			if (if_block1) if_block1.c();
    			t14 = space();
    			br = element("br");
    			t15 = space();
    			div11 = element("div");
    			div10 = element("div");
    			div7 = element("div");
    			a = element("a");
    			h30 = element("h3");
    			t16 = space();
    			div6 = element("div");
    			div6.textContent = "Cerrar";
    			t18 = space();
    			div9 = element("div");
    			button1 = element("button");
    			h31 = element("h3");
    			t19 = space();
    			div8 = element("div");
    			div8.textContent = "Crear";
    			attr_dev(h5, "class", "modal-title");
    			attr_dev(h5, "id", "modalInterconsulta");
    			add_location(h5, file$1, 94, 20, 2871);
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$1, 103, 24, 3243);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$1, 97, 20, 3019);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$1, 93, 16, 2823);
    			attr_dev(label0, "for", "");
    			attr_dev(label0, "class", "text-primary");
    			add_location(label0, file$1, 114, 28, 3690);
    			attr_dev(input0, "type", "password");
    			attr_dev(input0, "class", "form-control");
    			input0.required = true;
    			attr_dev(input0, "autocomplete", "current-password");
    			add_location(input0, file$1, 115, 28, 3789);
    			attr_dev(div1, "class", "form-group col-md-12");
    			add_location(div1, file$1, 113, 24, 3626);
    			attr_dev(label1, "for", "");
    			attr_dev(label1, "class", "text-primary");
    			add_location(label1, file$1, 118, 28, 4021);
    			attr_dev(input1, "type", "password");
    			attr_dev(input1, "class", "form-control");
    			input1.required = true;
    			attr_dev(input1, "autocomplete", "new-password");
    			add_location(input1, file$1, 119, 28, 4117);
    			attr_dev(div2, "class", "form-group col-md-12");
    			add_location(div2, file$1, 117, 24, 3957);
    			attr_dev(label2, "for", "");
    			attr_dev(label2, "class", "text-primary");
    			add_location(label2, file$1, 122, 28, 4345);
    			attr_dev(input2, "type", "password");
    			attr_dev(input2, "class", "form-control");
    			input2.required = true;
    			attr_dev(input2, "autocomplete", "new-password");
    			add_location(input2, file$1, 123, 28, 4449);
    			attr_dev(div3, "class", "form-group col-md-12");
    			add_location(div3, file$1, 121, 24, 4281);
    			attr_dev(div4, "class", "form-row");
    			add_location(div4, file$1, 112, 20, 3578);
    			add_location(br, file$1, 132, 20, 4851);
    			attr_dev(div5, "class", "modal-body");
    			add_location(div5, file$1, 106, 16, 3349);
    			attr_dev(h30, "class", "mdi mdi-close-outline");
    			add_location(h30, file$1, 143, 32, 5349);
    			attr_dev(div6, "class", "text-overline");
    			add_location(div6, file$1, 144, 32, 5419);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "text-danger");
    			attr_dev(a, "data-dismiss", "modal");
    			add_location(a, file$1, 137, 28, 5056);
    			attr_dev(div7, "class", "col");
    			add_location(div7, file$1, 136, 24, 5009);
    			attr_dev(h31, "class", "mdi mdi-send");
    			add_location(h31, file$1, 153, 32, 5886);
    			attr_dev(div8, "class", "text-overline");
    			add_location(div8, file$1, 154, 32, 5947);
    			attr_dev(button1, "class", "text-success");
    			set_style(button1, "border", "none");
    			set_style(button1, "background-color", "transparent");
    			add_location(button1, file$1, 148, 28, 5597);
    			attr_dev(div9, "class", "col");
    			add_location(div9, file$1, 147, 24, 5550);
    			attr_dev(div10, "class", "row text-center p-b-10");
    			add_location(div10, file$1, 135, 20, 4947);
    			attr_dev(div11, "class", "modal-footer");
    			add_location(div11, file$1, 134, 16, 4899);
    			attr_dev(div12, "class", "modal-content");
    			add_location(div12, file$1, 92, 12, 2778);
    			attr_dev(div13, "class", "modal-dialog");
    			attr_dev(div13, "role", "document");
    			add_location(div13, file$1, 91, 8, 2722);
    			attr_dev(div14, "class", "modal fade modal-slide-right");
    			attr_dev(div14, "id", "modalChangePassword");
    			attr_dev(div14, "tabindex", "-1");
    			attr_dev(div14, "role", "dialog");
    			attr_dev(div14, "aria-labelledby", "modalInterconsulta");
    			set_style(div14, "display", "none");
    			set_style(div14, "padding-right", "16px");
    			attr_dev(div14, "aria-modal", "true");
    			add_location(div14, file$1, 82, 4, 2449);
    			attr_dev(form, "class", "col-md-12");
    			add_location(form, file$1, 81, 0, 2377);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div14);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div0);
    			append_dev(div0, h5);
    			append_dev(div0, t1);
    			append_dev(div0, button0);
    			append_dev(button0, span);
    			append_dev(div12, t3);
    			append_dev(div12, div5);
    			if (if_block0) if_block0.m(div5, null);
    			append_dev(div5, t4);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, label0);
    			append_dev(div1, t6);
    			append_dev(div1, input0);
    			set_input_value(input0, /*oldPassword*/ ctx[2]);
    			append_dev(div4, t7);
    			append_dev(div4, div2);
    			append_dev(div2, label1);
    			append_dev(div2, t9);
    			append_dev(div2, input1);
    			set_input_value(input1, /*newPassword*/ ctx[3]);
    			append_dev(div4, t10);
    			append_dev(div4, div3);
    			append_dev(div3, label2);
    			append_dev(div3, t12);
    			append_dev(div3, input2);
    			set_input_value(input2, /*repeatNewPassword*/ ctx[4]);
    			append_dev(div5, t13);
    			if (if_block1) if_block1.m(div5, null);
    			append_dev(div5, t14);
    			append_dev(div5, br);
    			append_dev(div12, t15);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, div7);
    			append_dev(div7, a);
    			append_dev(a, h30);
    			append_dev(a, t16);
    			append_dev(a, div6);
    			append_dev(div10, t18);
    			append_dev(div10, div9);
    			append_dev(div9, button1);
    			append_dev(button1, h31);
    			append_dev(button1, t19);
    			append_dev(button1, div8);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[6]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[7]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[8]),
    					listen_dev(form, "submit", prevent_default(/*changePassword*/ ctx[5]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*cargando*/ ctx[1]) {
    				if (if_block0) {
    					if (dirty & /*cargando*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div5, t4);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*oldPassword*/ 4 && input0.value !== /*oldPassword*/ ctx[2]) {
    				set_input_value(input0, /*oldPassword*/ ctx[2]);
    			}

    			if (dirty & /*newPassword*/ 8 && input1.value !== /*newPassword*/ ctx[3]) {
    				set_input_value(input1, /*newPassword*/ ctx[3]);
    			}

    			if (dirty & /*repeatNewPassword*/ 16 && input2.value !== /*repeatNewPassword*/ ctx[4]) {
    				set_input_value(input2, /*repeatNewPassword*/ ctx[4]);
    			}

    			if (/*msgError*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$1(ctx);
    					if_block1.c();
    					if_block1.m(div5, t14);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ModalChangePassword", slots, []);

    	const Toast = Swal.mixin({
    		toast: true,
    		position: "top-end",
    		showConfirmButton: false,
    		timer: 3000,
    		timerProgressBar: true,
    		didOpen: toast => {
    			toast.addEventListener("mouseenter", Swal.stopTimer);
    			toast.addEventListener("mouseleave", Swal.resumeTimer);
    		}
    	});

    	let msgError = "";
    	let cargando = false;
    	let oldPassword = "";
    	let newPassword = "";
    	let repeatNewPassword = "";

    	const changePassword = () => {
    		$$invalidate(1, cargando = true);
    		const data = { newPassword, password: oldPassword };

    		const config = {
    			method: "post",
    			url: `${url}/usuarios/reset`,
    			data,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		$$invalidate(0, msgError = "");

    		if (newPassword.length < 6) {
    			$$invalidate(1, cargando = false);
    			return $$invalidate(0, msgError = "La contrasea debe tener al menos 6 carcteres");
    		}

    		if (newPassword !== repeatNewPassword) {
    			$$invalidate(1, cargando = false);
    			return $$invalidate(0, msgError = "Las contraseas no coinciden");
    		}

    		axios$1(config).then(res => {
    			$$invalidate(1, cargando = false);
    			$$invalidate(2, oldPassword = "");
    			$$invalidate(3, newPassword = "");
    			$$invalidate(4, repeatNewPassword = "");

    			if (res.status === 200) {
    				localStorage.removeItem("auth");
    				localStorage.setItem("auth", res.data);

    				Toast.fire({
    					icon: "success",
    					title: "Se ha cambiado la contrasea"
    				});
    			}
    		}).catch(err => {
    			$$invalidate(2, oldPassword = "");
    			$$invalidate(3, newPassword = "");
    			$$invalidate(4, repeatNewPassword = "");
    			$$invalidate(0, msgError = "Ocurrio un error al contactar al servidor, comuniquese con el administrador");
    			$$invalidate(1, cargando = false);
    			console.error(err);
    		});

    		return console.log("cambiando");
    	};

    	onMount(() => {
    		
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<ModalChangePassword> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		oldPassword = this.value;
    		$$invalidate(2, oldPassword);
    	}

    	function input1_input_handler() {
    		newPassword = this.value;
    		$$invalidate(3, newPassword);
    	}

    	function input2_input_handler() {
    		repeatNewPassword = this.value;
    		$$invalidate(4, repeatNewPassword);
    	}

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		onMount,
    		url,
    		Loading,
    		Toast,
    		msgError,
    		cargando,
    		oldPassword,
    		newPassword,
    		repeatNewPassword,
    		changePassword
    	});

    	$$self.$inject_state = $$props => {
    		if ("msgError" in $$props) $$invalidate(0, msgError = $$props.msgError);
    		if ("cargando" in $$props) $$invalidate(1, cargando = $$props.cargando);
    		if ("oldPassword" in $$props) $$invalidate(2, oldPassword = $$props.oldPassword);
    		if ("newPassword" in $$props) $$invalidate(3, newPassword = $$props.newPassword);
    		if ("repeatNewPassword" in $$props) $$invalidate(4, repeatNewPassword = $$props.repeatNewPassword);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		msgError,
    		cargando,
    		oldPassword,
    		newPassword,
    		repeatNewPassword,
    		changePassword,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler
    	];
    }

    class ModalChangePassword extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalChangePassword",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src\Layout\Header.svelte generated by Svelte v3.29.0 */
    const file$2 = "src\\Layout\\Header.svelte";

    function create_fragment$3(ctx) {
    	let header;
    	let a0;
    	let t0;
    	let nav0;
    	let ul0;
    	let li0;
    	let a1;
    	let i0;
    	let t1;
    	let nav1;
    	let ul1;
    	let li1;
    	let div10;
    	let a2;
    	let i1;
    	let t2;
    	let span0;
    	let t3;
    	let div9;
    	let div0;
    	let a3;
    	let t4;
    	let span1;
    	let t6;
    	let a4;
    	let t7;
    	let div8;
    	let div1;
    	let t9;
    	let a5;
    	let div3;
    	let div2;
    	let i2;
    	let t10;
    	let t11;
    	let a6;
    	let div5;
    	let div4;
    	let i3;
    	let t12;
    	let t13;
    	let a7;
    	let div7;
    	let div6;
    	let i4;
    	let t14;
    	let t15;
    	let li2;
    	let a8;
    	let div11;
    	let span2;
    	let t17;
    	let div13;
    	let a9;
    	let t19;
    	let div12;
    	let t20;
    	let a10;
    	let i5;
    	let t21;
    	let t22;
    	let modalchangepassword;
    	let current;
    	let mounted;
    	let dispose;
    	modalchangepassword = new ModalChangePassword({ $$inline: true });

    	const block = {
    		c: function create() {
    			header = element("header");
    			a0 = element("a");
    			t0 = space();
    			nav0 = element("nav");
    			ul0 = element("ul");
    			li0 = element("li");
    			a1 = element("a");
    			i0 = element("i");
    			t1 = space();
    			nav1 = element("nav");
    			ul1 = element("ul");
    			li1 = element("li");
    			div10 = element("div");
    			a2 = element("a");
    			i1 = element("i");
    			t2 = space();
    			span0 = element("span");
    			t3 = space();
    			div9 = element("div");
    			div0 = element("div");
    			a3 = element("a");
    			t4 = space();
    			span1 = element("span");
    			span1.textContent = "Notifications";
    			t6 = space();
    			a4 = element("a");
    			t7 = space();
    			div8 = element("div");
    			div1 = element("div");
    			div1.textContent = "today";
    			t9 = space();
    			a5 = element("a");
    			div3 = element("div");
    			div2 = element("div");
    			i2 = element("i");
    			t10 = text("\r\n                      All systems operational.");
    			t11 = space();
    			a6 = element("a");
    			div5 = element("div");
    			div4 = element("div");
    			i3 = element("i");
    			t12 = text("\r\n                      File upload successful.");
    			t13 = space();
    			a7 = element("a");
    			div7 = element("div");
    			div6 = element("div");
    			i4 = element("i");
    			t14 = text("\r\n                      Your holiday has been denied");
    			t15 = space();
    			li2 = element("li");
    			a8 = element("a");
    			div11 = element("div");
    			span2 = element("span");
    			span2.textContent = `${user().name[0]}`;
    			t17 = space();
    			div13 = element("div");
    			a9 = element("a");
    			a9.textContent = "Cambiar contrasea";
    			t19 = space();
    			div12 = element("div");
    			t20 = space();
    			a10 = element("a");
    			i5 = element("i");
    			t21 = text(" Salir");
    			t22 = space();
    			create_component(modalchangepassword.$$.fragment);
    			attr_dev(a0, "href", "#!");
    			attr_dev(a0, "class", "sidebar-toggle");
    			attr_dev(a0, "data-toggleclass", "sidebar-open");
    			attr_dev(a0, "data-target", "body");
    			add_location(a0, file$2, 5, 4, 192);
    			attr_dev(i0, "class", " mdi mdi-magnify mdi-24px align-middle");
    			add_location(i0, file$2, 22, 12, 613);
    			attr_dev(a1, "class", "nav-link ");
    			attr_dev(a1, "data-target", "#!siteSearchModal");
    			attr_dev(a1, "data-toggle", "modal");
    			attr_dev(a1, "href", "#!");
    			add_location(a1, file$2, 17, 10, 464);
    			attr_dev(li0, "class", "nav-item");
    			add_location(li0, file$2, 16, 8, 431);
    			attr_dev(ul0, "class", "nav align-items-center");
    			add_location(ul0, file$2, 14, 6, 382);
    			attr_dev(nav0, "class", " mr-auto my-auto");
    			add_location(nav0, file$2, 13, 4, 344);
    			attr_dev(i1, "class", "mdi mdi-24px mdi-bell-outline");
    			add_location(i1, file$2, 38, 14, 1062);
    			attr_dev(span0, "class", "notification-counter");
    			add_location(span0, file$2, 39, 14, 1121);
    			attr_dev(a2, "href", "#!");
    			attr_dev(a2, "class", "nav-link");
    			attr_dev(a2, "data-toggle", "dropdown");
    			attr_dev(a2, "aria-haspopup", "true");
    			attr_dev(a2, "aria-expanded", "false");
    			add_location(a2, file$2, 32, 12, 875);
    			attr_dev(a3, "href", "#!");
    			attr_dev(a3, "class", "mdi mdi-18px mdi-settings text-muted");
    			add_location(a3, file$2, 46, 16, 1409);
    			attr_dev(span1, "class", "h5 m-0");
    			add_location(span1, file$2, 49, 16, 1535);
    			attr_dev(a4, "href", "#!");
    			attr_dev(a4, "class", "mdi mdi-18px mdi-notification-clear-all text-muted");
    			add_location(a4, file$2, 50, 16, 1594);
    			attr_dev(div0, "class", "d-flex p-all-15 bg-white justify-content-between\r\n                border-bottom ");
    			add_location(div0, file$2, 43, 14, 1280);
    			attr_dev(div1, "class", "text-overline m-b-5");
    			add_location(div1, file$2, 57, 16, 1858);
    			attr_dev(i2, "class", "mdi mdi-circle text-success");
    			add_location(i2, file$2, 61, 22, 2063);
    			attr_dev(div2, "class", "card-body");
    			add_location(div2, file$2, 60, 20, 2016);
    			attr_dev(div3, "class", "card");
    			add_location(div3, file$2, 59, 18, 1976);
    			attr_dev(a5, "href", "#!");
    			attr_dev(a5, "class", "d-block m-b-10");
    			add_location(a5, file$2, 58, 16, 1920);
    			attr_dev(i3, "class", "mdi mdi-upload-multiple ");
    			add_location(i3, file$2, 69, 22, 2389);
    			attr_dev(div4, "class", "card-body");
    			add_location(div4, file$2, 68, 20, 2342);
    			attr_dev(div5, "class", "card");
    			add_location(div5, file$2, 67, 18, 2302);
    			attr_dev(a6, "href", "#!");
    			attr_dev(a6, "class", "d-block m-b-10");
    			add_location(a6, file$2, 66, 16, 2246);
    			attr_dev(i4, "class", "mdi mdi-cancel text-danger");
    			add_location(i4, file$2, 77, 22, 2711);
    			attr_dev(div6, "class", "card-body");
    			add_location(div6, file$2, 76, 20, 2664);
    			attr_dev(div7, "class", "card");
    			add_location(div7, file$2, 75, 18, 2624);
    			attr_dev(a7, "href", "#!");
    			attr_dev(a7, "class", "d-block m-b-10");
    			add_location(a7, file$2, 74, 16, 2568);
    			attr_dev(div8, "class", "notification-events bg-gray-300");
    			add_location(div8, file$2, 56, 14, 1795);
    			attr_dev(div9, "class", "dropdown-menu notification-container dropdown-menu-right");
    			add_location(div9, file$2, 42, 12, 1194);
    			attr_dev(div10, "class", "dropdown");
    			add_location(div10, file$2, 31, 10, 839);
    			attr_dev(li1, "class", "nav-item");
    			add_location(li1, file$2, 30, 8, 806);
    			attr_dev(span2, "class", "avatar-title rounded-circle bg-dark");
    			add_location(span2, file$2, 97, 14, 3293);
    			attr_dev(div11, "class", "avatar avatar-sm avatar-online");
    			add_location(div11, file$2, 96, 12, 3233);
    			attr_dev(a8, "class", "nav-link dropdown-toggle");
    			attr_dev(a8, "href", "#!");
    			attr_dev(a8, "role", "button");
    			attr_dev(a8, "data-toggle", "dropdown");
    			attr_dev(a8, "aria-haspopup", "true");
    			attr_dev(a8, "aria-expanded", "false");
    			add_location(a8, file$2, 89, 10, 3015);
    			attr_dev(a9, "class", "dropdown-item");
    			attr_dev(a9, "href", "#!");
    			attr_dev(a9, "data-toggle", "modal");
    			attr_dev(a9, "data-target", "#modalChangePassword");
    			add_location(a9, file$2, 102, 12, 3479);
    			attr_dev(div12, "class", "dropdown-divider");
    			add_location(div12, file$2, 103, 12, 3605);
    			attr_dev(i5, "class", "mdi mdi-power");
    			add_location(i5, file$2, 104, 92, 3731);
    			attr_dev(a10, "class", "dropdown-item text-danger");
    			attr_dev(a10, "href", "#!");
    			add_location(a10, file$2, 104, 12, 3651);
    			attr_dev(div13, "class", "dropdown-menu dropdown-menu-right");
    			add_location(div13, file$2, 101, 10, 3418);
    			attr_dev(li2, "class", "nav-item dropdown ");
    			add_location(li2, file$2, 88, 8, 2972);
    			attr_dev(ul1, "class", "nav align-items-center");
    			add_location(ul1, file$2, 28, 6, 757);
    			attr_dev(nav1, "class", " ml-auto");
    			add_location(nav1, file$2, 27, 4, 727);
    			attr_dev(header, "class", "admin-header");
    			add_location(header, file$2, 4, 0, 157);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			append_dev(header, a0);
    			append_dev(header, t0);
    			append_dev(header, nav0);
    			append_dev(nav0, ul0);
    			append_dev(ul0, li0);
    			append_dev(li0, a1);
    			append_dev(a1, i0);
    			append_dev(header, t1);
    			append_dev(header, nav1);
    			append_dev(nav1, ul1);
    			append_dev(ul1, li1);
    			append_dev(li1, div10);
    			append_dev(div10, a2);
    			append_dev(a2, i1);
    			append_dev(a2, t2);
    			append_dev(a2, span0);
    			append_dev(div10, t3);
    			append_dev(div10, div9);
    			append_dev(div9, div0);
    			append_dev(div0, a3);
    			append_dev(div0, t4);
    			append_dev(div0, span1);
    			append_dev(div0, t6);
    			append_dev(div0, a4);
    			append_dev(div9, t7);
    			append_dev(div9, div8);
    			append_dev(div8, div1);
    			append_dev(div8, t9);
    			append_dev(div8, a5);
    			append_dev(a5, div3);
    			append_dev(div3, div2);
    			append_dev(div2, i2);
    			append_dev(div2, t10);
    			append_dev(div8, t11);
    			append_dev(div8, a6);
    			append_dev(a6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, i3);
    			append_dev(div4, t12);
    			append_dev(div8, t13);
    			append_dev(div8, a7);
    			append_dev(a7, div7);
    			append_dev(div7, div6);
    			append_dev(div6, i4);
    			append_dev(div6, t14);
    			append_dev(ul1, t15);
    			append_dev(ul1, li2);
    			append_dev(li2, a8);
    			append_dev(a8, div11);
    			append_dev(div11, span2);
    			append_dev(li2, t17);
    			append_dev(li2, div13);
    			append_dev(div13, a9);
    			append_dev(div13, t19);
    			append_dev(div13, div12);
    			append_dev(div13, t20);
    			append_dev(div13, a10);
    			append_dev(a10, i5);
    			append_dev(a10, t21);
    			insert_dev(target, t22, anchor);
    			mount_component(modalchangepassword, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a10, "click", prevent_default(logout), false, true, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalchangepassword.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalchangepassword.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			if (detaching) detach_dev(t22);
    			destroy_component(modalchangepassword, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Header", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ logout, user, ModalChangePassword });
    	return [];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    // List of nodes to update
    const nodes = [];

    // Current location
    let location$2;

    // Function that updates all nodes marking the active ones
    function checkActive(el) {
        // Repeat this for each class
        (el.className || '').split(' ').forEach((cls) => {
            if (!cls) {
                return
            }
            // Remove the active class firsts
            el.node.classList.remove(cls);

            // If the pattern matches, then set the active class
            if (el.pattern.test(location$2)) {
                el.node.classList.add(cls);
            }
        });
    }

    // Listen to changes in the location
    loc.subscribe((value) => {
        // Update the location
        location$2 = value.location + (value.querystring ? '?' + value.querystring : '');

        // Update all nodes
        nodes.map(checkActive);
    });

    /**
     * @typedef {Object} ActiveOptions
     * @property {string|RegExp} [path] - Path expression that makes the link active when matched (must start with '/' or '*'); default is the link's href
     * @property {string} [className] - CSS class to apply to the element when active; default value is "active"
     */

    /**
     * Svelte Action for automatically adding the "active" class to elements (links, or any other DOM element) when the current location matches a certain path.
     * 
     * @param {HTMLElement} node - The target node (automatically set by Svelte)
     * @param {ActiveOptions|string|RegExp} [opts] - Can be an object of type ActiveOptions, or a string (or regular expressions) representing ActiveOptions.path.
     * @returns {{destroy: function(): void}} Destroy function
     */
    function active$1(node, opts) {
        // Check options
        if (opts && (typeof opts == 'string' || (typeof opts == 'object' && opts instanceof RegExp))) {
            // Interpret strings and regular expressions as opts.path
            opts = {
                path: opts
            };
        }
        else {
            // Ensure opts is a dictionary
            opts = opts || {};
        }

        // Path defaults to link target
        if (!opts.path && node.hasAttribute('href')) {
            opts.path = node.getAttribute('href');
            if (opts.path && opts.path.length > 1 && opts.path.charAt(0) == '#') {
                opts.path = opts.path.substring(1);
            }
        }

        // Default class name
        if (!opts.className) {
            opts.className = 'active';
        }

        // If path is a string, it must start with '/' or '*'
        if (!opts.path || 
            typeof opts.path == 'string' && (opts.path.length < 1 || (opts.path.charAt(0) != '/' && opts.path.charAt(0) != '*'))
        ) {
            throw Error('Invalid value for "path" argument')
        }

        // If path is not a regular expression already, make it
        const {pattern} = typeof opts.path == 'string' ?
            regexparam(opts.path) :
            {pattern: opts.path};

        // Add the node to the list
        const el = {
            node,
            className: opts.className,
            pattern
        };
        nodes.push(el);

        // Trigger the action right away
        checkActive(el);

        return {
            // When the element is destroyed, remove it from the list
            destroy() {
                nodes.splice(nodes.indexOf(el), 1);
            }
        }
    }

    /* src\Layout\Aside.svelte generated by Svelte v3.29.0 */
    const file$3 = "src\\Layout\\Aside.svelte";

    // (72:8) {#if user().roles.includes('admin')}
    function create_if_block_2(ctx) {
    	let li;
    	let a;
    	let span1;
    	let span0;
    	let t1;
    	let span2;
    	let i;
    	let link_action;
    	let active_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			span1 = element("span");
    			span0 = element("span");
    			span0.textContent = "Recetas";
    			t1 = space();
    			span2 = element("span");
    			i = element("i");
    			attr_dev(span0, "class", "menu-name");
    			add_location(span0, file$3, 75, 14, 2883);
    			attr_dev(span1, "class", "menu-label");
    			add_location(span1, file$3, 74, 12, 2842);
    			attr_dev(i, "class", "icon-placeholder mdi mdi-playlist-edit");
    			add_location(i, file$3, 79, 14, 3085);
    			attr_dev(span2, "class", "menu-icon");
    			add_location(span2, file$3, 77, 12, 2956);
    			attr_dev(a, "href", "/recetas");
    			attr_dev(a, "class", "menu-link");
    			add_location(a, file$3, 73, 10, 2782);
    			attr_dev(li, "class", "menu-item");
    			add_location(li, file$3, 72, 8, 2695);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, span1);
    			append_dev(span1, span0);
    			append_dev(a, t1);
    			append_dev(a, span2);
    			append_dev(span2, i);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link_action = link.call(null, a)),
    					action_destroyer(active_action = active$1.call(null, li, { path: "/recetas", className: "active" }))
    				];

    				mounted = true;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(72:8) {#if user().roles.includes('admin')}",
    		ctx
    	});

    	return block;
    }

    // (100:8) {#if user().roles.includes('doctor') || user().roles.includes('admin')}
    function create_if_block$2(ctx) {
    	let li1;
    	let a0;
    	let span3;
    	let span1;
    	let t0;
    	let span0;
    	let t1;
    	let span2;
    	let t3;
    	let span4;
    	let i0;
    	let t4;
    	let ul;
    	let show_if = user().roles.includes("admin");
    	let t5;
    	let li0;
    	let a1;
    	let span6;
    	let span5;
    	let t7;
    	let span7;
    	let i1;
    	let link_action;
    	let mounted;
    	let dispose;
    	let if_block = show_if && create_if_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			li1 = element("li");
    			a0 = element("a");
    			span3 = element("span");
    			span1 = element("span");
    			t0 = text("Mantenimiento\r\n                ");
    			span0 = element("span");
    			t1 = space();
    			span2 = element("span");
    			span2.textContent = "Ajustes consultorio";
    			t3 = space();
    			span4 = element("span");
    			i0 = element("i");
    			t4 = space();
    			ul = element("ul");
    			if (if_block) if_block.c();
    			t5 = space();
    			li0 = element("li");
    			a1 = element("a");
    			span6 = element("span");
    			span5 = element("span");
    			span5.textContent = "Empresa";
    			t7 = space();
    			span7 = element("span");
    			i1 = element("i");
    			i1.textContent = "E";
    			attr_dev(span0, "class", "menu-arrow");
    			add_location(span0, file$3, 105, 16, 4139);
    			attr_dev(span1, "class", "menu-name");
    			add_location(span1, file$3, 103, 14, 4066);
    			attr_dev(span2, "class", "menu-info");
    			add_location(span2, file$3, 107, 14, 4205);
    			attr_dev(span3, "class", "menu-label");
    			add_location(span3, file$3, 102, 12, 4025);
    			attr_dev(i0, "class", "icon-placeholder mdi mdi-link-variant ");
    			add_location(i0, file$3, 110, 14, 4330);
    			attr_dev(span4, "class", "menu-icon");
    			add_location(span4, file$3, 109, 12, 4290);
    			attr_dev(a0, "href", "#!");
    			attr_dev(a0, "class", "open-dropdown menu-link");
    			add_location(a0, file$3, 101, 10, 3966);
    			attr_dev(span5, "class", "menu-name");
    			add_location(span5, file$3, 130, 18, 5105);
    			attr_dev(span6, "class", "menu-label");
    			add_location(span6, file$3, 129, 16, 5060);
    			attr_dev(i1, "class", "icon-placeholder ");
    			add_location(i1, file$3, 133, 18, 5230);
    			attr_dev(span7, "class", "menu-icon");
    			add_location(span7, file$3, 132, 16, 5186);
    			attr_dev(a1, "href", "/empresa/detalles");
    			attr_dev(a1, "class", " menu-link");
    			add_location(a1, file$3, 128, 14, 4986);
    			attr_dev(li0, "class", "menu-item");
    			add_location(li0, file$3, 127, 12, 4948);
    			attr_dev(ul, "class", "sub-menu");
    			add_location(ul, file$3, 114, 10, 4457);
    			attr_dev(li1, "class", "menu-item");
    			add_location(li1, file$3, 100, 8, 3932);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li1, anchor);
    			append_dev(li1, a0);
    			append_dev(a0, span3);
    			append_dev(span3, span1);
    			append_dev(span1, t0);
    			append_dev(span1, span0);
    			append_dev(span3, t1);
    			append_dev(span3, span2);
    			append_dev(a0, t3);
    			append_dev(a0, span4);
    			append_dev(span4, i0);
    			append_dev(li1, t4);
    			append_dev(li1, ul);
    			if (if_block) if_block.m(ul, null);
    			append_dev(ul, t5);
    			append_dev(ul, li0);
    			append_dev(li0, a1);
    			append_dev(a1, span6);
    			append_dev(span6, span5);
    			append_dev(a1, t7);
    			append_dev(a1, span7);
    			append_dev(span7, i1);

    			if (!mounted) {
    				dispose = action_destroyer(link_action = link.call(null, a1));
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li1);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(100:8) {#if user().roles.includes('doctor') || user().roles.includes('admin')}",
    		ctx
    	});

    	return block;
    }

    // (116:12) {#if user().roles.includes('admin')}
    function create_if_block_1$1(ctx) {
    	let li;
    	let a;
    	let span1;
    	let span0;
    	let t1;
    	let span2;
    	let i;
    	let link_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			span1 = element("span");
    			span0 = element("span");
    			span0.textContent = "Usuarios";
    			t1 = space();
    			span2 = element("span");
    			i = element("i");
    			i.textContent = "U";
    			attr_dev(span0, "class", "menu-name");
    			add_location(span0, file$3, 119, 18, 4691);
    			attr_dev(span1, "class", "menu-label");
    			add_location(span1, file$3, 118, 16, 4646);
    			attr_dev(i, "class", "icon-placeholder ");
    			add_location(i, file$3, 122, 18, 4817);
    			attr_dev(span2, "class", "menu-icon");
    			add_location(span2, file$3, 121, 16, 4773);
    			attr_dev(a, "href", "/usuarios");
    			attr_dev(a, "class", " menu-link");
    			add_location(a, file$3, 117, 14, 4580);
    			attr_dev(li, "class", "menu-item");
    			add_location(li, file$3, 116, 12, 4542);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, span1);
    			append_dev(span1, span0);
    			append_dev(a, t1);
    			append_dev(a, span2);
    			append_dev(span2, i);

    			if (!mounted) {
    				dispose = action_destroyer(link_action = link.call(null, a));
    				mounted = true;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(116:12) {#if user().roles.includes('admin')}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let aside;
    	let div1;
    	let span0;
    	let a0;
    	let link_action;
    	let t1;
    	let div0;
    	let a1;
    	let t2;
    	let a2;
    	let t3;
    	let div2;
    	let ul;
    	let li0;
    	let a3;
    	let span2;
    	let span1;
    	let t5;
    	let span4;
    	let span3;
    	let t7;
    	let i0;
    	let link_action_1;
    	let active_action;
    	let t8;
    	let li1;
    	let a4;
    	let span6;
    	let span5;
    	let t10;
    	let span7;
    	let i1;
    	let link_action_2;
    	let active_action_1;
    	let t11;
    	let li2;
    	let a5;
    	let span9;
    	let span8;
    	let t13;
    	let span10;
    	let i2;
    	let link_action_3;
    	let active_action_2;
    	let t14;
    	let show_if_1 = user().roles.includes("admin");
    	let t15;
    	let li3;
    	let a6;
    	let span12;
    	let span11;
    	let t17;
    	let span13;
    	let i3;
    	let link_action_4;
    	let active_action_3;
    	let t18;
    	let show_if = user().roles.includes("doctor") || user().roles.includes("admin");
    	let mounted;
    	let dispose;
    	let if_block0 = show_if_1 && create_if_block_2(ctx);
    	let if_block1 = show_if && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			aside = element("aside");
    			div1 = element("div");
    			span0 = element("span");
    			a0 = element("a");
    			a0.textContent = "xmedical pro";
    			t1 = space();
    			div0 = element("div");
    			a1 = element("a");
    			t2 = space();
    			a2 = element("a");
    			t3 = space();
    			div2 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a3 = element("a");
    			span2 = element("span");
    			span1 = element("span");
    			span1.textContent = "Escritorio";
    			t5 = space();
    			span4 = element("span");
    			span3 = element("span");
    			span3.textContent = "1";
    			t7 = space();
    			i0 = element("i");
    			t8 = space();
    			li1 = element("li");
    			a4 = element("a");
    			span6 = element("span");
    			span5 = element("span");
    			span5.textContent = "Pacientes";
    			t10 = space();
    			span7 = element("span");
    			i1 = element("i");
    			t11 = space();
    			li2 = element("li");
    			a5 = element("a");
    			span9 = element("span");
    			span8 = element("span");
    			span8.textContent = "Consultas mdicas";
    			t13 = space();
    			span10 = element("span");
    			i2 = element("i");
    			t14 = space();
    			if (if_block0) if_block0.c();
    			t15 = space();
    			li3 = element("li");
    			a6 = element("a");
    			span12 = element("span");
    			span11 = element("span");
    			span11.textContent = "Citas";
    			t17 = space();
    			span13 = element("span");
    			i3 = element("i");
    			t18 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(a0, "href", "/");
    			add_location(a0, file$3, 12, 8, 333);
    			attr_dev(span0, "class", "admin-brand-content");
    			add_location(span0, file$3, 11, 6, 289);
    			attr_dev(a1, "href", "#!");
    			attr_dev(a1, "class", "admin-pin-sidebar btn-ghost btn btn-rounded-circle pinned");
    			add_location(a1, file$3, 17, 8, 489);
    			attr_dev(a2, "href", "#!");
    			attr_dev(a2, "class", "admin-close-sidebar");
    			add_location(a2, file$3, 21, 8, 662);
    			attr_dev(div0, "class", "ml-auto");
    			add_location(div0, file$3, 15, 6, 429);
    			attr_dev(div1, "class", "admin-sidebar-brand");
    			add_location(div1, file$3, 9, 4, 210);
    			attr_dev(span1, "class", "menu-name");
    			add_location(span1, file$3, 33, 14, 1092);
    			attr_dev(span2, "class", "menu-label");
    			add_location(span2, file$3, 32, 12, 1051);
    			attr_dev(span3, "class", "icon-badge badge-success badge badge-pill");
    			add_location(span3, file$3, 36, 14, 1208);
    			attr_dev(i0, "class", "icon-placeholder mdi mdi-link-variant ");
    			add_location(i0, file$3, 38, 14, 1292);
    			attr_dev(span4, "class", "menu-icon");
    			add_location(span4, file$3, 35, 12, 1168);
    			attr_dev(a3, "href", "/");
    			attr_dev(a3, "class", "menu-link");
    			add_location(a3, file$3, 31, 10, 998);
    			attr_dev(li0, "class", "menu-item");
    			add_location(li0, file$3, 30, 8, 918);
    			attr_dev(span5, "class", "menu-name");
    			add_location(span5, file$3, 48, 14, 1666);
    			attr_dev(span6, "class", "menu-label");
    			add_location(span6, file$3, 47, 12, 1625);
    			attr_dev(i1, "class", "icon-placeholder mdi mdi-account-circle-outline");
    			add_location(i1, file$3, 52, 14, 1870);
    			attr_dev(span7, "class", "menu-icon");
    			add_location(span7, file$3, 50, 12, 1741);
    			attr_dev(a4, "href", "/pacientes");
    			attr_dev(a4, "class", "menu-link");
    			add_location(a4, file$3, 46, 10, 1563);
    			attr_dev(li1, "class", "menu-item");
    			add_location(li1, file$3, 45, 8, 1474);
    			attr_dev(span8, "class", "menu-name");
    			add_location(span8, file$3, 61, 14, 2251);
    			attr_dev(span9, "class", "menu-label");
    			add_location(span9, file$3, 60, 12, 2210);
    			attr_dev(i2, "class", "icon-placeholder mdi mdi-square-edit-outline");
    			add_location(i2, file$3, 65, 14, 2463);
    			attr_dev(span10, "class", "menu-icon");
    			add_location(span10, file$3, 63, 12, 2334);
    			attr_dev(a5, "href", "/historias");
    			attr_dev(a5, "class", "menu-link");
    			add_location(a5, file$3, 59, 10, 2148);
    			attr_dev(li2, "class", "menu-item");
    			add_location(li2, file$3, 58, 8, 2059);
    			attr_dev(span11, "class", "menu-name");
    			add_location(span11, file$3, 89, 14, 3464);
    			attr_dev(span12, "class", "menu-label");
    			add_location(span12, file$3, 88, 12, 3423);
    			attr_dev(i3, "class", "icon-placeholder mdi mdi-calendar-multiselect");
    			add_location(i3, file$3, 93, 14, 3664);
    			attr_dev(span13, "class", "menu-icon");
    			add_location(span13, file$3, 91, 12, 3535);
    			attr_dev(a6, "href", "/citas");
    			attr_dev(a6, "class", "menu-link");
    			add_location(a6, file$3, 87, 10, 3365);
    			attr_dev(li3, "class", "menu-item");
    			add_location(li3, file$3, 86, 8, 3280);
    			attr_dev(ul, "class", "menu");
    			add_location(ul, file$3, 28, 6, 858);
    			attr_dev(div2, "class", "admin-sidebar-wrapper js-scrollbar");
    			add_location(div2, file$3, 26, 4, 770);
    			attr_dev(aside, "class", "admin-sidebar");
    			add_location(aside, file$3, 8, 2, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, aside, anchor);
    			append_dev(aside, div1);
    			append_dev(div1, span0);
    			append_dev(span0, a0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, a1);
    			append_dev(div0, t2);
    			append_dev(div0, a2);
    			append_dev(aside, t3);
    			append_dev(aside, div2);
    			append_dev(div2, ul);
    			append_dev(ul, li0);
    			append_dev(li0, a3);
    			append_dev(a3, span2);
    			append_dev(span2, span1);
    			append_dev(a3, t5);
    			append_dev(a3, span4);
    			append_dev(span4, span3);
    			append_dev(span4, t7);
    			append_dev(span4, i0);
    			append_dev(ul, t8);
    			append_dev(ul, li1);
    			append_dev(li1, a4);
    			append_dev(a4, span6);
    			append_dev(span6, span5);
    			append_dev(a4, t10);
    			append_dev(a4, span7);
    			append_dev(span7, i1);
    			append_dev(ul, t11);
    			append_dev(ul, li2);
    			append_dev(li2, a5);
    			append_dev(a5, span9);
    			append_dev(span9, span8);
    			append_dev(a5, t13);
    			append_dev(a5, span10);
    			append_dev(span10, i2);
    			append_dev(ul, t14);
    			if (if_block0) if_block0.m(ul, null);
    			append_dev(ul, t15);
    			append_dev(ul, li3);
    			append_dev(li3, a6);
    			append_dev(a6, span12);
    			append_dev(span12, span11);
    			append_dev(a6, t17);
    			append_dev(a6, span13);
    			append_dev(span13, i3);
    			append_dev(ul, t18);
    			if (if_block1) if_block1.m(ul, null);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link_action = link.call(null, a0)),
    					action_destroyer(link_action_1 = link.call(null, a3)),
    					action_destroyer(active_action = active$1.call(null, li0, { path: "/", className: "active" })),
    					action_destroyer(link_action_2 = link.call(null, a4)),
    					action_destroyer(active_action_1 = active$1.call(null, li1, { path: "/pacientes", className: "active" })),
    					action_destroyer(link_action_3 = link.call(null, a5)),
    					action_destroyer(active_action_2 = active$1.call(null, li2, { path: "/historias", className: "active" })),
    					action_destroyer(link_action_4 = link.call(null, a6)),
    					action_destroyer(active_action_3 = active$1.call(null, li3, { path: "/citas", className: "active" }))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (show_if) if_block1.p(ctx, dirty);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(aside);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Aside", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Aside> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, active: active$1, user });
    	return [];
    }

    class Aside extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Aside",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src\componentes\ErrorConexion.svelte generated by Svelte v3.29.0 */

    const file$4 = "src\\componentes\\ErrorConexion.svelte";

    function create_fragment$5(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let button;
    	let span;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*msgError*/ ctx[0]);
    			t1 = space();
    			button = element("button");
    			span = element("span");
    			span.textContent = "";
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$4, 11, 12, 333);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "close");
    			attr_dev(button, "data-dismiss", "alert");
    			attr_dev(button, "aria-label", "Close");
    			add_location(button, file$4, 5, 19, 181);
    			attr_dev(div0, "class", "alert alert-danger alert-dismissible fade show");
    			attr_dev(div0, "role", "alert");
    			add_location(div0, file$4, 4, 4, 87);
    			attr_dev(div1, "class", "alert-container");
    			add_location(div1, file$4, 3, 0, 52);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, button);
    			append_dev(button, span);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*msgError*/ 1) set_data_dev(t0, /*msgError*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ErrorConexion", slots, []);
    	let { msgError = "" } = $$props;
    	const writable_props = ["msgError"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ErrorConexion> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("msgError" in $$props) $$invalidate(0, msgError = $$props.msgError);
    	};

    	$$self.$capture_state = () => ({ msgError });

    	$$self.$inject_state = $$props => {
    		if ("msgError" in $$props) $$invalidate(0, msgError = $$props.msgError);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [msgError];
    }

    class ErrorConexion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { msgError: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ErrorConexion",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get msgError() {
    		throw new Error("<ErrorConexion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set msgError(value) {
    		throw new Error("<ErrorConexion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Home\Index.svelte generated by Svelte v3.29.0 */

    const { console: console_1$2 } = globals;
    const file$5 = "src\\Pages\\Home\\Index.svelte";

    // (69:2) {#if errorServer}
    function create_if_block_2$1(ctx) {
    	let errorconexion;
    	let updating_msgError;
    	let current;

    	function errorconexion_msgError_binding(value) {
    		/*errorconexion_msgError_binding*/ ctx[5].call(null, value);
    	}

    	let errorconexion_props = {};

    	if (/*msgError*/ ctx[4] !== void 0) {
    		errorconexion_props.msgError = /*msgError*/ ctx[4];
    	}

    	errorconexion = new ErrorConexion({
    			props: errorconexion_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(errorconexion, "msgError", errorconexion_msgError_binding));

    	const block = {
    		c: function create() {
    			create_component(errorconexion.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorconexion, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const errorconexion_changes = {};

    			if (!updating_msgError && dirty & /*msgError*/ 16) {
    				updating_msgError = true;
    				errorconexion_changes.msgError = /*msgError*/ ctx[4];
    				add_flush_callback(() => updating_msgError = false);
    			}

    			errorconexion.$set(errorconexion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorconexion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorconexion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorconexion, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(69:2) {#if errorServer}",
    		ctx
    	});

    	return block;
    }

    // (80:10) {#if !cargandoResumen}
    function create_if_block_1$2(ctx) {
    	let div6;
    	let div5;
    	let div4;
    	let div2;
    	let div1;
    	let div0;
    	let i0;
    	let t0;
    	let div3;
    	let p0;
    	let t2;
    	let h10;
    	let t3;
    	let t4;
    	let div13;
    	let div12;
    	let div11;
    	let div9;
    	let div8;
    	let div7;
    	let i1;
    	let t5;
    	let div10;
    	let p1;
    	let t7;
    	let h11;
    	let t8;

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			i0 = element("i");
    			t0 = space();
    			div3 = element("div");
    			p0 = element("p");
    			p0.textContent = "pacientes";
    			t2 = space();
    			h10 = element("h1");
    			t3 = text(/*numeroPacientes*/ ctx[0]);
    			t4 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div11 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			i1 = element("i");
    			t5 = space();
    			div10 = element("div");
    			p1 = element("p");
    			p1.textContent = "historias";
    			t7 = space();
    			h11 = element("h1");
    			t8 = text(/*numeroHistorias*/ ctx[1]);
    			attr_dev(i0, "class", "mdi mdi-account");
    			add_location(i0, file$5, 86, 25, 2473);
    			attr_dev(div0, "class", "avatar-title bg-soft-primary rounded-circle");
    			add_location(div0, file$5, 85, 23, 2389);
    			attr_dev(div1, "class", "avatar avatar-lg");
    			add_location(div1, file$5, 84, 21, 2334);
    			attr_dev(div2, "class", "pb-2");
    			add_location(div2, file$5, 83, 19, 2293);
    			attr_dev(p0, "class", "text-muted text-overline m-0");
    			add_location(p0, file$5, 91, 21, 2638);
    			attr_dev(h10, "class", "fw-400");
    			add_location(h10, file$5, 92, 21, 2714);
    			add_location(div3, file$5, 90, 19, 2610);
    			attr_dev(div4, "class", "card-body");
    			add_location(div4, file$5, 82, 17, 2249);
    			attr_dev(div5, "class", "card m-b-30");
    			add_location(div5, file$5, 81, 15, 2205);
    			attr_dev(div6, "class", "col-lg-3 col-md-6");
    			add_location(div6, file$5, 80, 13, 2157);
    			attr_dev(i1, "class", "mdi mdi-format-list-checks");
    			add_location(i1, file$5, 103, 25, 3182);
    			attr_dev(div7, "class", "avatar-title bg-soft-primary rounded-circle");
    			add_location(div7, file$5, 102, 23, 3098);
    			attr_dev(div8, "class", "avatar avatar-lg");
    			add_location(div8, file$5, 101, 21, 3043);
    			attr_dev(div9, "class", "pb-2");
    			add_location(div9, file$5, 100, 19, 3002);
    			attr_dev(p1, "class", "text-muted text-overline m-0");
    			add_location(p1, file$5, 108, 21, 3360);
    			attr_dev(h11, "class", "fw-400");
    			add_location(h11, file$5, 109, 21, 3436);
    			add_location(div10, file$5, 107, 19, 3332);
    			attr_dev(div11, "class", "card-body");
    			add_location(div11, file$5, 99, 17, 2958);
    			attr_dev(div12, "class", "card m-b-30");
    			add_location(div12, file$5, 98, 15, 2914);
    			attr_dev(div13, "class", "col-lg-3 col-md-6");
    			add_location(div13, file$5, 97, 13, 2866);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, i0);
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, p0);
    			append_dev(div3, t2);
    			append_dev(div3, h10);
    			append_dev(h10, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div13, anchor);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, i1);
    			append_dev(div11, t5);
    			append_dev(div11, div10);
    			append_dev(div10, p1);
    			append_dev(div10, t7);
    			append_dev(div10, h11);
    			append_dev(h11, t8);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*numeroPacientes*/ 1) set_data_dev(t3, /*numeroPacientes*/ ctx[0]);
    			if (dirty & /*numeroHistorias*/ 2) set_data_dev(t8, /*numeroHistorias*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div13);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(80:10) {#if !cargandoResumen}",
    		ctx
    	});

    	return block;
    }

    // (118:10) {#if cargandoResumen}
    function create_if_block$3(ctx) {
    	let div6;
    	let div5;
    	let div4;
    	let div2;
    	let div1;
    	let div0;
    	let i0;
    	let t0;
    	let div3;
    	let p0;
    	let t2;
    	let h10;
    	let t3;
    	let t4;
    	let div13;
    	let div12;
    	let div11;
    	let div9;
    	let div8;
    	let div7;
    	let i1;
    	let t5;
    	let div10;
    	let p1;
    	let t7;
    	let h11;
    	let t8;

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			i0 = element("i");
    			t0 = space();
    			div3 = element("div");
    			p0 = element("p");
    			p0.textContent = "pacientes";
    			t2 = space();
    			h10 = element("h1");
    			t3 = text(/*numeroPacientes*/ ctx[0]);
    			t4 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div11 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			i1 = element("i");
    			t5 = space();
    			div10 = element("div");
    			p1 = element("p");
    			p1.textContent = "pacientes";
    			t7 = space();
    			h11 = element("h1");
    			t8 = text(/*numeroPacientes*/ ctx[0]);
    			attr_dev(i0, "class", "mdi mdi-account");
    			add_location(i0, file$5, 124, 25, 3958);
    			attr_dev(div0, "class", "avatar-title bg-soft-primary rounded-circle");
    			add_location(div0, file$5, 123, 23, 3874);
    			attr_dev(div1, "class", "avatar avatar-lg");
    			add_location(div1, file$5, 122, 21, 3819);
    			attr_dev(div2, "class", "pb-2");
    			add_location(div2, file$5, 121, 19, 3778);
    			attr_dev(p0, "class", "text-muted text-overline m-0 font-flow");
    			add_location(p0, file$5, 129, 21, 4123);
    			attr_dev(h10, "class", "fw-400 font-flow");
    			add_location(h10, file$5, 130, 21, 4209);
    			add_location(div3, file$5, 128, 19, 4095);
    			attr_dev(div4, "class", "card-body");
    			add_location(div4, file$5, 120, 17, 3734);
    			attr_dev(div5, "class", "card m-b-30");
    			add_location(div5, file$5, 119, 15, 3690);
    			attr_dev(div6, "class", "col-lg-3 col-md-6");
    			add_location(div6, file$5, 118, 13, 3642);
    			attr_dev(i1, "class", "mdi mdi-format-list-checks");
    			add_location(i1, file$5, 141, 24, 4686);
    			attr_dev(div7, "class", "avatar-title bg-soft-primary rounded-circle");
    			add_location(div7, file$5, 140, 23, 4603);
    			attr_dev(div8, "class", "avatar avatar-lg");
    			add_location(div8, file$5, 139, 21, 4548);
    			attr_dev(div9, "class", "pb-2");
    			add_location(div9, file$5, 138, 19, 4507);
    			attr_dev(p1, "class", "text-muted text-overline m-0 font-flow");
    			add_location(p1, file$5, 146, 21, 4864);
    			attr_dev(h11, "class", "fw-400 font-flow");
    			add_location(h11, file$5, 147, 21, 4950);
    			add_location(div10, file$5, 145, 19, 4836);
    			attr_dev(div11, "class", "card-body");
    			add_location(div11, file$5, 137, 17, 4463);
    			attr_dev(div12, "class", "card m-b-30");
    			add_location(div12, file$5, 136, 15, 4419);
    			attr_dev(div13, "class", "col-lg-3 col-md-6");
    			add_location(div13, file$5, 135, 13, 4371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, i0);
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, p0);
    			append_dev(div3, t2);
    			append_dev(div3, h10);
    			append_dev(h10, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div13, anchor);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, i1);
    			append_dev(div11, t5);
    			append_dev(div11, div10);
    			append_dev(div10, p1);
    			append_dev(div10, t7);
    			append_dev(div10, h11);
    			append_dev(h11, t8);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*numeroPacientes*/ 1) set_data_dev(t3, /*numeroPacientes*/ ctx[0]);
    			if (dirty & /*numeroPacientes*/ 1) set_data_dev(t8, /*numeroPacientes*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div13);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(118:10) {#if cargandoResumen}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let t2;
    	let section;
    	let div3;
    	let div2;
    	let h3;
    	let t8;
    	let div1;
    	let div0;
    	let h5;
    	let i;
    	let t9;
    	let t10;
    	let t11;
    	let current;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });
    	let if_block0 = /*errorServer*/ ctx[2] && create_if_block_2$1(ctx);
    	let if_block1 = !/*cargandoResumen*/ ctx[3] && create_if_block_1$2(ctx);
    	let if_block2 = /*cargandoResumen*/ ctx[3] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			section = element("section");
    			div3 = element("div");
    			div2 = element("div");
    			h3 = element("h3");
    			h3.textContent = `Hola, ${user().title}. ${user().name}!`;
    			t8 = space();
    			div1 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			i = element("i");
    			t9 = text(" Resumen");
    			t10 = space();
    			if (if_block1) if_block1.c();
    			t11 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(h3, "class", "mt-2 text-secondary");
    			add_location(h3, file$5, 74, 8, 1886);
    			attr_dev(i, "class", "mdi mdi-table");
    			add_location(i, file$5, 77, 16, 2050);
    			add_location(h5, file$5, 77, 12, 2046);
    			attr_dev(div0, "class", "col-12 m-b-20 m-t-20");
    			add_location(div0, file$5, 76, 10, 1998);
    			attr_dev(div1, "class", "row");
    			add_location(div1, file$5, 75, 8, 1969);
    			attr_dev(div2, "class", "col-12");
    			add_location(div2, file$5, 73, 6, 1856);
    			attr_dev(div3, "class", "p-2");
    			add_location(div3, file$5, 72, 4, 1831);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$5, 71, 2, 1794);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$5, 66, 0, 1674);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t2);
    			append_dev(main, section);
    			append_dev(section, div3);
    			append_dev(div3, div2);
    			append_dev(div2, h3);
    			append_dev(div2, t8);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h5);
    			append_dev(h5, i);
    			append_dev(h5, t9);
    			append_dev(div1, t10);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t11);
    			if (if_block2) if_block2.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*errorServer*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*errorServer*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(main, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*cargandoResumen*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$2(ctx);
    					if_block1.c();
    					if_block1.m(div1, t11);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*cargandoResumen*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$3(ctx);
    					if_block2.c();
    					if_block2.m(div1, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Index", slots, []);
    	let numeroPacientes = 0;
    	let numeroHistorias = 0;
    	let errorServer = false;
    	let cargandoResumen = false;
    	let msgError = "";

    	const contarPacientes = () => {
    		$$invalidate(3, cargandoResumen = true);

    		const confing = {
    			method: "get",
    			url: `${url}/pacientes`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(confing).then(res => {
    			$$invalidate(3, cargandoResumen = false);
    			$$invalidate(0, numeroPacientes = res.data.length);
    		}).catch(error => {
    			$$invalidate(3, cargandoResumen = false);
    			$$invalidate(2, errorServer = true);
    			$$invalidate(4, msgError = "Ocurri un error al conectarse con el servidor. Intente de nuevo o contacte al administrador!");
    			console.error(error);
    		});
    	};

    	const contarHistorias = () => {
    		$$invalidate(3, cargandoResumen = true);

    		const confing = {
    			method: "get",
    			url: `${url}/historias`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(confing).then(res => {
    			$$invalidate(3, cargandoResumen = false);
    			$$invalidate(1, numeroHistorias = res.data.length);
    		}).catch(error => {
    			$$invalidate(3, cargandoResumen = false);
    			$$invalidate(2, errorServer = true);
    			console.error(error);
    		});
    	};

    	onMount(() => {
    		contarPacientes();
    		contarHistorias();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	function errorconexion_msgError_binding(value) {
    		msgError = value;
    		$$invalidate(4, msgError);
    	}

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		onMount,
    		url,
    		user,
    		Header,
    		Aside,
    		ErrorConexion,
    		numeroPacientes,
    		numeroHistorias,
    		errorServer,
    		cargandoResumen,
    		msgError,
    		contarPacientes,
    		contarHistorias
    	});

    	$$self.$inject_state = $$props => {
    		if ("numeroPacientes" in $$props) $$invalidate(0, numeroPacientes = $$props.numeroPacientes);
    		if ("numeroHistorias" in $$props) $$invalidate(1, numeroHistorias = $$props.numeroHistorias);
    		if ("errorServer" in $$props) $$invalidate(2, errorServer = $$props.errorServer);
    		if ("cargandoResumen" in $$props) $$invalidate(3, cargandoResumen = $$props.cargandoResumen);
    		if ("msgError" in $$props) $$invalidate(4, msgError = $$props.msgError);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		numeroPacientes,
    		numeroHistorias,
    		errorServer,
    		cargandoResumen,
    		msgError,
    		errorconexion_msgError_binding
    	];
    }

    class Index extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src\Pages\Prueba.svelte generated by Svelte v3.29.0 */

    const { console: console_1$3 } = globals;
    const file$6 = "src\\Pages\\Prueba.svelte";

    function create_fragment$7(ctx) {
    	let container;
    	let t0_value = JSON.stringify(/*logs*/ ctx[0]) + "";
    	let t0;
    	let t1;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			container = element("container");
    			t0 = text(t0_value);
    			t1 = space();
    			input = element("input");
    			attr_dev(input, "type", "button");
    			input.value = "saludar";
    			add_location(input, file$6, 74, 0, 1294);
    			add_location(container, file$6, 71, 0, 1255);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, container, anchor);
    			append_dev(container, t0);
    			append_dev(container, t1);
    			append_dev(container, input);

    			if (!mounted) {
    				dispose = listen_dev(input, "click", saludar, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(container);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function saludar() {
    	console.log("..");
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Prueba", slots, []);

    	const getSocketData = event => {
    		let emptyEvent = { data: null };

    		if (!event || !event.data) {
    			return emptyEvent;
    		}

    		const match = event.data.match(/\[.*]/);

    		if (!match) {
    			return emptyEvent;
    		}

    		const data = JSON.parse(match);

    		if (!Array.isArray(data) || !data[1]) {
    			return emptyEvent;
    		}

    		return { type: data[0], payload: data[1] };
    	};

    	onMount(() => {
    		const socket = new WebSocket("ws://localhost:1338/engine.io/?EIO=4&transport=websocket");

    		// Connection opened
    		socket.addEventListener("open", function (event) {
    			console.log("It's open");
    		});

    		// Listen for messages
    		socket.addEventListener("message", function (event) {
    			console.log(getSocketData(event));
    		});
    	}); // console.log(Object.getOwnPropertyNames(io.socket))

    	//  console.log(io.socket.isConnected())
    	//  io.socket.on('connect', function(){
    	//     console.log("connected!")
    	//  })
    	//     io.socket.on("message", function (msg) {
    	//   // ...
    	//   console.log("msg",msg)
    	// });
    	//     console.log("mount..")
    	// })
    	let logs = [];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Prueba> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ onMount, saludar, getSocketData, logs });

    	$$self.$inject_state = $$props => {
    		if ("logs" in $$props) $$invalidate(0, logs = $$props.logs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [logs];
    }

    class Prueba extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Prueba",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src\componentes\Modals\ModalNuevaCita.svelte generated by Svelte v3.29.0 */

    const { console: console_1$4 } = globals;
    const file$7 = "src\\componentes\\Modals\\ModalNuevaCita.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	return child_ctx;
    }

    // (177:20) {#if cargando}
    function create_if_block_4(ctx) {
    	let div;
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loading.$$.fragment);
    			attr_dev(div, "class", "cargando");
    			add_location(div, file$7, 177, 24, 5643);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loading, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(177:20) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    // (221:32) {#each tandas as tanda}
    function create_each_block_1(ctx) {
    	let option;
    	let t_value = /*tanda*/ ctx[22].descripcion + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*tanda*/ ctx[22].id;
    			option.value = option.__value;
    			add_location(option, file$7, 221, 36, 7880);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tandas*/ 2 && t_value !== (t_value = /*tanda*/ ctx[22].descripcion + "")) set_data_dev(t, t_value);

    			if (dirty & /*tandas*/ 2 && option_value_value !== (option_value_value = /*tanda*/ ctx[22].id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(221:32) {#each tandas as tanda}",
    		ctx
    	});

    	return block;
    }

    // (240:20) {#if msgError}
    function create_if_block_3(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*msgError*/ ctx[5]);
    			attr_dev(div, "class", "alert alert-danger");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$7, 240, 24, 8686);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*msgError*/ 32) set_data_dev(t, /*msgError*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(240:20) {#if msgError}",
    		ctx
    	});

    	return block;
    }

    // (257:36) {#if cita.estado === "R"}
    function create_if_block_2$2(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "icon mdi mdi-check-circle-outline");
    			add_location(i, file$7, 257, 40, 9510);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(257:36) {#if cita.estado === \\\"R\\\"}",
    		ctx
    	});

    	return block;
    }

    // (262:36) {#if cita.estado === "X"}
    function create_if_block_1$3(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "icon mdi mdi-alert-octagram");
    			add_location(i, file$7, 262, 40, 9791);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(262:36) {#if cita.estado === \\\"X\\\"}",
    		ctx
    	});

    	return block;
    }

    // (267:36) {#if cita.estado === "N"}
    function create_if_block$4(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "icon mdi mdi-alert-circle-outline");
    			add_location(i, file$7, 267, 40, 10066);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(267:36) {#if cita.estado === \\\"N\\\"}",
    		ctx
    	});

    	return block;
    }

    // (247:20) {#each citas as cita}
    function create_each_block(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let t0;
    	let t1;
    	let t2;
    	let div4;
    	let div3;
    	let div1;
    	let span0;
    	let t3_value = new Date(/*cita*/ ctx[19].fechaCita).getDate() + 1 + "";
    	let t3;
    	let t4;
    	let span1;
    	let t5_value = /*meses*/ ctx[10][new Date(/*cita*/ ctx[19].fechaCita).getMonth()] + "";
    	let t5;
    	let t6;
    	let span2;
    	let t7_value = new Date(/*cita*/ ctx[19].fechaCita).getFullYear() + "";
    	let t7;
    	let t8;
    	let div2;
    	let t9_value = /*cita*/ ctx[19].observaciones + "";
    	let t9;
    	let t10;
    	let if_block0 = /*cita*/ ctx[19].estado === "R" && create_if_block_2$2(ctx);
    	let if_block1 = /*cita*/ ctx[19].estado === "X" && create_if_block_1$3(ctx);
    	let if_block2 = /*cita*/ ctx[19].estado === "N" && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			span0 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			span1 = element("span");
    			t5 = text(t5_value);
    			t6 = space();
    			span2 = element("span");
    			t7 = text(t7_value);
    			t8 = space();
    			div2 = element("div");
    			t9 = text(t9_value);
    			t10 = space();
    			attr_dev(div0, "class", "icon");
    			add_location(div0, file$7, 255, 32, 9387);
    			attr_dev(span0, "class", "svelte-qxlgux");
    			add_location(span0, file$7, 275, 44, 10504);
    			attr_dev(span1, "class", "svelte-qxlgux");
    			add_location(span1, file$7, 280, 44, 10803);
    			attr_dev(span2, "class", "svelte-qxlgux");
    			add_location(span2, file$7, 287, 44, 11218);
    			attr_dev(div1, "class", "fecha svelte-qxlgux");
    			add_location(div1, file$7, 274, 40, 10439);
    			attr_dev(div2, "class", "observaciones svelte-qxlgux");
    			add_location(div2, file$7, 293, 40, 11561);
    			attr_dev(div3, "class", "calendar svelte-qxlgux");
    			add_location(div3, file$7, 273, 36, 10375);
    			attr_dev(div4, "class", "content");
    			add_location(div4, file$7, 272, 32, 10316);
    			attr_dev(div5, "class", "d-flex");
    			add_location(div5, file$7, 254, 28, 9333);
    			attr_dev(div6, "class", "alert alert-dismissible fade show");
    			attr_dev(div6, "role", "alert");
    			toggle_class(div6, "alert-border-success", /*cita*/ ctx[19].estado === "R");
    			toggle_class(div6, "alert-border-danger", /*cita*/ ctx[19].estado === "X");
    			toggle_class(div6, "alert-border-info", /*cita*/ ctx[19].estado === "N");
    			add_location(div6, file$7, 247, 24, 8929);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div0, t1);
    			if (if_block2) if_block2.m(div0, null);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, span0);
    			append_dev(span0, t3);
    			append_dev(div1, t4);
    			append_dev(div1, span1);
    			append_dev(span1, t5);
    			append_dev(div1, t6);
    			append_dev(div1, span2);
    			append_dev(span2, t7);
    			append_dev(div3, t8);
    			append_dev(div3, div2);
    			append_dev(div2, t9);
    			append_dev(div6, t10);
    		},
    		p: function update(ctx, dirty) {
    			if (/*cita*/ ctx[19].estado === "R") {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_2$2(ctx);
    					if_block0.c();
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*cita*/ ctx[19].estado === "X") {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$3(ctx);
    					if_block1.c();
    					if_block1.m(div0, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*cita*/ ctx[19].estado === "N") {
    				if (if_block2) ; else {
    					if_block2 = create_if_block$4(ctx);
    					if_block2.c();
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*citas*/ 4 && t3_value !== (t3_value = new Date(/*cita*/ ctx[19].fechaCita).getDate() + 1 + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*citas*/ 4 && t5_value !== (t5_value = /*meses*/ ctx[10][new Date(/*cita*/ ctx[19].fechaCita).getMonth()] + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*citas*/ 4 && t7_value !== (t7_value = new Date(/*cita*/ ctx[19].fechaCita).getFullYear() + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*citas*/ 4 && t9_value !== (t9_value = /*cita*/ ctx[19].observaciones + "")) set_data_dev(t9, t9_value);

    			if (dirty & /*citas*/ 4) {
    				toggle_class(div6, "alert-border-success", /*cita*/ ctx[19].estado === "R");
    			}

    			if (dirty & /*citas*/ 4) {
    				toggle_class(div6, "alert-border-danger", /*cita*/ ctx[19].estado === "X");
    			}

    			if (dirty & /*citas*/ 4) {
    				toggle_class(div6, "alert-border-info", /*cita*/ ctx[19].estado === "N");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(247:20) {#each citas as cita}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let form;
    	let div15;
    	let div14;
    	let div13;
    	let div0;
    	let h5;
    	let t0_value = /*pacienteSeleccionado*/ ctx[0].nombres + "";
    	let t0;
    	let t1;
    	let t2_value = /*pacienteSeleccionado*/ ctx[0].apellidos + "";
    	let t2;
    	let t3;
    	let span0;
    	let t5;
    	let button0;
    	let span1;
    	let t7;
    	let div6;
    	let t8;
    	let div5;
    	let div1;
    	let label0;
    	let t10;
    	let select0;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let t17;
    	let div2;
    	let label1;
    	let t19;
    	let input;
    	let t20;
    	let div3;
    	let label2;
    	let t22;
    	let select1;
    	let option6;
    	let t24;
    	let div4;
    	let label3;
    	let t26;
    	let textarea;
    	let t27;
    	let t28;
    	let br;
    	let t29;
    	let t30;
    	let div12;
    	let div11;
    	let div8;
    	let a;
    	let h30;
    	let t31;
    	let div7;
    	let t33;
    	let div10;
    	let button1;
    	let h31;
    	let t34;
    	let div9;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*cargando*/ ctx[7] && create_if_block_4(ctx);
    	let each_value_1 = /*tandas*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let if_block1 = /*msgError*/ ctx[5] && create_if_block_3(ctx);
    	let each_value = /*citas*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			form = element("form");
    			div15 = element("div");
    			div14 = element("div");
    			div13 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			span0 = element("span");
    			span0.textContent = "Citas";
    			t5 = space();
    			button0 = element("button");
    			span1 = element("span");
    			span1.textContent = "";
    			t7 = space();
    			div6 = element("div");
    			if (if_block0) if_block0.c();
    			t8 = space();
    			div5 = element("div");
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Proxima cita";
    			t10 = space();
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "- seleccionar tiempo -\r\n                                ";
    			option1 = element("option");
    			option1.textContent = "En una semana";
    			option2 = element("option");
    			option2.textContent = "En 15 dias";
    			option3 = element("option");
    			option3.textContent = "En un mes";
    			option4 = element("option");
    			option4.textContent = "En 6 meses";
    			option5 = element("option");
    			option5.textContent = "En un ao";
    			t17 = space();
    			div2 = element("div");
    			label1 = element("label");
    			label1.textContent = "Fecha de la cita";
    			t19 = space();
    			input = element("input");
    			t20 = space();
    			div3 = element("div");
    			label2 = element("label");
    			label2.textContent = "Tanda";
    			t22 = space();
    			select1 = element("select");
    			option6 = element("option");
    			option6.textContent = "- seleccionar tanda -\r\n                                ";

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t24 = space();
    			div4 = element("div");
    			label3 = element("label");
    			label3.textContent = "Observaciones";
    			t26 = space();
    			textarea = element("textarea");
    			t27 = space();
    			if (if_block1) if_block1.c();
    			t28 = space();
    			br = element("br");
    			t29 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t30 = space();
    			div12 = element("div");
    			div11 = element("div");
    			div8 = element("div");
    			a = element("a");
    			h30 = element("h3");
    			t31 = space();
    			div7 = element("div");
    			div7.textContent = "Cerrar";
    			t33 = space();
    			div10 = element("div");
    			button1 = element("button");
    			h31 = element("h3");
    			t34 = space();
    			div9 = element("div");
    			div9.textContent = "Crear";
    			attr_dev(span0, "class", "badge bg-primary text-white");
    			add_location(span0, file$7, 164, 24, 5124);
    			attr_dev(h5, "class", "modal-title");
    			attr_dev(h5, "id", "modalInterconsulta");
    			add_location(h5, file$7, 162, 20, 4960);
    			attr_dev(span1, "aria-hidden", "true");
    			add_location(span1, file$7, 172, 24, 5451);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$7, 166, 20, 5227);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$7, 161, 16, 4912);
    			attr_dev(label0, "for", "");
    			attr_dev(label0, "class", "text-primary");
    			add_location(label0, file$7, 183, 28, 5898);
    			option0.__value = "";
    			option0.value = option0.__value;
    			add_location(option0, file$7, 188, 32, 6166);
    			option1.__value = "S";
    			option1.value = option1.__value;
    			add_location(option1, file$7, 191, 32, 6320);
    			option2.__value = "D";
    			option2.value = option2.__value;
    			add_location(option2, file$7, 192, 32, 6394);
    			option3.__value = "M";
    			option3.value = option3.__value;
    			add_location(option3, file$7, 193, 32, 6465);
    			option4.__value = "T";
    			option4.value = option4.__value;
    			add_location(option4, file$7, 194, 32, 6535);
    			option5.__value = "A";
    			option5.value = option5.__value;
    			add_location(option5, file$7, 195, 32, 6606);
    			attr_dev(select0, "class", "form-control");
    			if (/*tiempoCita*/ ctx[8] === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[12].call(select0));
    			add_location(select0, file$7, 184, 28, 5983);
    			attr_dev(div1, "class", "form-group col-md-12");
    			add_location(div1, file$7, 182, 24, 5834);
    			attr_dev(label1, "for", "");
    			attr_dev(label1, "class", "text-primary");
    			add_location(label1, file$7, 199, 28, 6803);
    			attr_dev(input, "type", "date");
    			attr_dev(input, "class", "form-control");
    			attr_dev(input, "min", /*fechaMinima*/ ctx[9]);
    			input.required = true;
    			add_location(input, file$7, 202, 28, 6956);
    			attr_dev(div2, "class", "form-group col-md-12");
    			add_location(div2, file$7, 198, 24, 6739);
    			attr_dev(label2, "for", "");
    			attr_dev(label2, "class", "text-primary");
    			add_location(label2, file$7, 211, 28, 7364);
    			option6.__value = "";
    			option6.value = option6.__value;
    			add_location(option6, file$7, 217, 32, 7666);
    			attr_dev(select1, "class", "form-control");
    			select1.required = true;
    			if (/*tandaCita*/ ctx[4] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[14].call(select1));
    			add_location(select1, file$7, 212, 28, 7442);
    			attr_dev(div3, "class", "form-group col-md-12");
    			add_location(div3, file$7, 210, 24, 7300);
    			attr_dev(label3, "for", "");
    			attr_dev(label3, "class", "text-primary");
    			add_location(label3, file$7, 228, 28, 8215);
    			attr_dev(textarea, "class", "form-control");
    			attr_dev(textarea, "rows", "3");
    			add_location(textarea, file$7, 231, 28, 8365);
    			attr_dev(div4, "class", "form-group col-md-12");
    			add_location(div4, file$7, 227, 24, 8151);
    			attr_dev(div5, "class", "form-row");
    			add_location(div5, file$7, 181, 20, 5786);
    			add_location(br, file$7, 244, 20, 8852);
    			attr_dev(div6, "class", "modal-body");
    			add_location(div6, file$7, 175, 16, 5557);
    			attr_dev(h30, "class", "mdi mdi-close-outline");
    			add_location(h30, file$7, 311, 32, 12375);
    			attr_dev(div7, "class", "text-overline");
    			add_location(div7, file$7, 312, 32, 12445);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "text-danger");
    			attr_dev(a, "data-dismiss", "modal");
    			add_location(a, file$7, 305, 28, 12082);
    			attr_dev(div8, "class", "col");
    			add_location(div8, file$7, 304, 24, 12035);
    			attr_dev(h31, "class", "mdi mdi-send");
    			add_location(h31, file$7, 321, 32, 12912);
    			attr_dev(div9, "class", "text-overline");
    			add_location(div9, file$7, 322, 32, 12973);
    			attr_dev(button1, "class", "text-success");
    			set_style(button1, "border", "none");
    			set_style(button1, "background-color", "transparent");
    			add_location(button1, file$7, 316, 28, 12623);
    			attr_dev(div10, "class", "col");
    			add_location(div10, file$7, 315, 24, 12576);
    			attr_dev(div11, "class", "row text-center p-b-10");
    			add_location(div11, file$7, 303, 20, 11973);
    			attr_dev(div12, "class", "modal-footer");
    			add_location(div12, file$7, 302, 16, 11925);
    			attr_dev(div13, "class", "modal-content");
    			add_location(div13, file$7, 160, 12, 4867);
    			attr_dev(div14, "class", "modal-dialog");
    			attr_dev(div14, "role", "document");
    			add_location(div14, file$7, 159, 8, 4811);
    			attr_dev(div15, "class", "modal fade modal-slide-right");
    			attr_dev(div15, "id", "modalNuevaCita");
    			attr_dev(div15, "tabindex", "-1");
    			attr_dev(div15, "role", "dialog");
    			attr_dev(div15, "aria-labelledby", "modalInterconsulta");
    			set_style(div15, "display", "none");
    			set_style(div15, "padding-right", "16px");
    			attr_dev(div15, "aria-modal", "true");
    			add_location(div15, file$7, 150, 4, 4543);
    			attr_dev(form, "class", "col-md-12");
    			add_location(form, file$7, 149, 0, 4468);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div15);
    			append_dev(div15, div14);
    			append_dev(div14, div13);
    			append_dev(div13, div0);
    			append_dev(div0, h5);
    			append_dev(h5, t0);
    			append_dev(h5, t1);
    			append_dev(h5, t2);
    			append_dev(h5, t3);
    			append_dev(h5, span0);
    			append_dev(div0, t5);
    			append_dev(div0, button0);
    			append_dev(button0, span1);
    			append_dev(div13, t7);
    			append_dev(div13, div6);
    			if (if_block0) if_block0.m(div6, null);
    			append_dev(div6, t8);
    			append_dev(div6, div5);
    			append_dev(div5, div1);
    			append_dev(div1, label0);
    			append_dev(div1, t10);
    			append_dev(div1, select0);
    			append_dev(select0, option0);
    			append_dev(select0, option1);
    			append_dev(select0, option2);
    			append_dev(select0, option3);
    			append_dev(select0, option4);
    			append_dev(select0, option5);
    			select_option(select0, /*tiempoCita*/ ctx[8]);
    			append_dev(div5, t17);
    			append_dev(div5, div2);
    			append_dev(div2, label1);
    			append_dev(div2, t19);
    			append_dev(div2, input);
    			set_input_value(input, /*fechaCita*/ ctx[3]);
    			append_dev(div5, t20);
    			append_dev(div5, div3);
    			append_dev(div3, label2);
    			append_dev(div3, t22);
    			append_dev(div3, select1);
    			append_dev(select1, option6);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select1, null);
    			}

    			select_option(select1, /*tandaCita*/ ctx[4]);
    			append_dev(div5, t24);
    			append_dev(div5, div4);
    			append_dev(div4, label3);
    			append_dev(div4, t26);
    			append_dev(div4, textarea);
    			set_input_value(textarea, /*observaciones*/ ctx[6]);
    			append_dev(div6, t27);
    			if (if_block1) if_block1.m(div6, null);
    			append_dev(div6, t28);
    			append_dev(div6, br);
    			append_dev(div6, t29);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div6, null);
    			}

    			append_dev(div13, t30);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div8);
    			append_dev(div8, a);
    			append_dev(a, h30);
    			append_dev(a, t31);
    			append_dev(a, div7);
    			append_dev(div11, t33);
    			append_dev(div11, div10);
    			append_dev(div10, button1);
    			append_dev(button1, h31);
    			append_dev(button1, t34);
    			append_dev(button1, div9);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[12]),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[13]),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[14]),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[15]),
    					listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[16]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*pacienteSeleccionado*/ 1) && t0_value !== (t0_value = /*pacienteSeleccionado*/ ctx[0].nombres + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*pacienteSeleccionado*/ 1) && t2_value !== (t2_value = /*pacienteSeleccionado*/ ctx[0].apellidos + "")) set_data_dev(t2, t2_value);

    			if (/*cargando*/ ctx[7]) {
    				if (if_block0) {
    					if (dirty & /*cargando*/ 128) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div6, t8);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*tiempoCita*/ 256) {
    				select_option(select0, /*tiempoCita*/ ctx[8]);
    			}

    			if (dirty & /*fechaCita*/ 8) {
    				set_input_value(input, /*fechaCita*/ ctx[3]);
    			}

    			if (dirty & /*tandas*/ 2) {
    				each_value_1 = /*tandas*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*tandaCita, tandas*/ 18) {
    				select_option(select1, /*tandaCita*/ ctx[4]);
    			}

    			if (dirty & /*observaciones*/ 64) {
    				set_input_value(textarea, /*observaciones*/ ctx[6]);
    			}

    			if (/*msgError*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3(ctx);
    					if_block1.c();
    					if_block1.m(div6, t28);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*citas, Date, meses*/ 1028) {
    				each_value = /*citas*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div6, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks_1, detaching);
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ModalNuevaCita", slots, []);
    	let fechaMinima = new Date().toISOString().split("T")[0];
    	let { pacienteSeleccionado } = $$props;
    	let tandas = [];
    	let citas = [];
    	let fechaCita = "";
    	let tandaCita = "";
    	let msgError = "";
    	let observaciones = "";

    	let meses = {
    		0: "Enero",
    		1: "Febrero",
    		2: "Marzo",
    		3: "Abril",
    		4: "Mayo",
    		5: "Junio",
    		6: "Julio",
    		7: "Agosto",
    		8: "Septiembre",
    		9: "Octubre",
    		10: "Noviembre",
    		11: "Diciembre"
    	};

    	let cargando = false;
    	let tiempoCita = "";

    	const cargarCitasPorPaciente = () => {
    		const config = {
    			method: "get",
    			url: `${url}/citas/paciente/${pacienteSeleccionado.id}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(2, citas = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarTandas = () => {
    		const config = {
    			method: "get",
    			url: `${url}/tandas`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(1, tandas = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const crearCita = () => {
    		$$invalidate(7, cargando = true);
    		$$invalidate(5, msgError = "");

    		const data = {
    			fechaCita,
    			tanda: tandaCita,
    			observaciones,
    			paciente: pacienteSeleccionado
    		};

    		const config = {
    			method: "post",
    			url: `${url}/citas`,
    			data,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		if (!fechaCita || !tandaCita || !observaciones) {
    			return $$invalidate(5, msgError = "Algunos campos estan vacios");
    		}

    		axios$1(config).then(res => {
    			$$invalidate(7, cargando = false);

    			if (res.status === 200) {
    				$$invalidate(3, fechaCita = "");
    				$$invalidate(4, tandaCita = "");
    				$$invalidate(6, observaciones = "");
    				cargarCitasPorPaciente();
    			}
    		}).catch(err => {
    			$$invalidate(3, fechaCita = "");
    			$$invalidate(4, tandaCita = "");
    			$$invalidate(6, observaciones = "");
    			$$invalidate(8, tiempoCita = "");
    			$$invalidate(7, cargando = false);

    			if (err) {
    				$$invalidate(5, msgError = "Ocurrio un error al registrar la cita, intentalo de nuevo mas tarde o comunicate con el administrador");
    			}

    			if (err.response.data !== undefined) {
    				if (err.response.data.err === 900) {
    					$$invalidate(5, msgError = "No hay horarios disponibles para este consultorio");
    				}

    				if (err.response.data.err === 800) {
    					$$invalidate(5, msgError = "No hay cupos disponibles");
    				}
    			}
    		});
    	};

    	onMount(() => {
    		cargarTandas();
    	});

    	const writable_props = ["pacienteSeleccionado"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<ModalNuevaCita> was created with unknown prop '${key}'`);
    	});

    	function select0_change_handler() {
    		tiempoCita = select_value(this);
    		$$invalidate(8, tiempoCita);
    	}

    	function input_input_handler() {
    		fechaCita = this.value;
    		($$invalidate(3, fechaCita), $$invalidate(8, tiempoCita));
    	}

    	function select1_change_handler() {
    		tandaCita = select_value(this);
    		$$invalidate(4, tandaCita);
    		$$invalidate(1, tandas);
    	}

    	function textarea_input_handler() {
    		observaciones = this.value;
    		$$invalidate(6, observaciones);
    	}

    	const submit_handler = () => crearCita();

    	$$self.$$set = $$props => {
    		if ("pacienteSeleccionado" in $$props) $$invalidate(0, pacienteSeleccionado = $$props.pacienteSeleccionado);
    	};

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		onMount,
    		url,
    		Loading,
    		fechaMinima,
    		pacienteSeleccionado,
    		tandas,
    		citas,
    		fechaCita,
    		tandaCita,
    		msgError,
    		observaciones,
    		meses,
    		cargando,
    		tiempoCita,
    		cargarCitasPorPaciente,
    		cargarTandas,
    		crearCita
    	});

    	$$self.$inject_state = $$props => {
    		if ("fechaMinima" in $$props) $$invalidate(9, fechaMinima = $$props.fechaMinima);
    		if ("pacienteSeleccionado" in $$props) $$invalidate(0, pacienteSeleccionado = $$props.pacienteSeleccionado);
    		if ("tandas" in $$props) $$invalidate(1, tandas = $$props.tandas);
    		if ("citas" in $$props) $$invalidate(2, citas = $$props.citas);
    		if ("fechaCita" in $$props) $$invalidate(3, fechaCita = $$props.fechaCita);
    		if ("tandaCita" in $$props) $$invalidate(4, tandaCita = $$props.tandaCita);
    		if ("msgError" in $$props) $$invalidate(5, msgError = $$props.msgError);
    		if ("observaciones" in $$props) $$invalidate(6, observaciones = $$props.observaciones);
    		if ("meses" in $$props) $$invalidate(10, meses = $$props.meses);
    		if ("cargando" in $$props) $$invalidate(7, cargando = $$props.cargando);
    		if ("tiempoCita" in $$props) $$invalidate(8, tiempoCita = $$props.tiempoCita);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*pacienteSeleccionado*/ 1) {
    			 if (pacienteSeleccionado) {
    				cargarCitasPorPaciente();
    			}
    		}

    		if ($$self.$$.dirty & /*tiempoCita*/ 256) {
    			 if (tiempoCita === "S") {
    				let fecha = new Date();
    				fecha.setDate(fecha.getDate() + 7);
    				$$invalidate(3, fechaCita = fecha.toISOString().split("T")[0]);
    			} else if (tiempoCita === "D") {
    				let fecha = new Date();
    				fecha.setDate(fecha.getDate() + 15);
    				$$invalidate(3, fechaCita = fecha.toISOString().split("T")[0]);
    			} else if (tiempoCita === "M") {
    				let fecha = new Date();
    				fecha.setMonth(fecha.getMonth() + 1);
    				$$invalidate(3, fechaCita = fecha.toISOString().split("T")[0]);
    			} else if (tiempoCita === "T") {
    				let fecha = new Date();
    				fecha.setMonth(fecha.getMonth() + 6);
    				$$invalidate(3, fechaCita = fecha.toISOString().split("T")[0]);
    			} else if (tiempoCita === "A") {
    				let fecha = new Date();
    				fecha.setFullYear(fecha.getFullYear() + 1);
    				$$invalidate(3, fechaCita = fecha.toISOString().split("T")[0]);
    			}
    		}
    	};

    	return [
    		pacienteSeleccionado,
    		tandas,
    		citas,
    		fechaCita,
    		tandaCita,
    		msgError,
    		observaciones,
    		cargando,
    		tiempoCita,
    		fechaMinima,
    		meses,
    		crearCita,
    		select0_change_handler,
    		input_input_handler,
    		select1_change_handler,
    		textarea_input_handler,
    		submit_handler
    	];
    }

    class ModalNuevaCita extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { pacienteSeleccionado: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalNuevaCita",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*pacienteSeleccionado*/ ctx[0] === undefined && !("pacienteSeleccionado" in props)) {
    			console_1$4.warn("<ModalNuevaCita> was created without expected prop 'pacienteSeleccionado'");
    		}
    	}

    	get pacienteSeleccionado() {
    		throw new Error("<ModalNuevaCita>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pacienteSeleccionado(value) {
    		throw new Error("<ModalNuevaCita>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Pacientes\Index.svelte generated by Svelte v3.29.0 */

    const { console: console_1$5 } = globals;
    const file$8 = "src\\Pages\\Pacientes\\Index.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (107:2) {#if errorServer}
    function create_if_block_2$3(ctx) {
    	let errorserver;
    	let current;

    	errorserver = new ErrorConexion({
    			props: {
    				msgError: "Ocurrio un error al contactar al servidor, vuelva a intentar o contacte al administrador"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(errorserver.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorserver, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorserver.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorserver.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorserver, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(107:2) {#if errorServer}",
    		ctx
    	});

    	return block;
    }

    // (146:20) {#if paciente.activo}
    function create_if_block_1$4(ctx) {
    	let tr;
    	let td0;
    	let div;
    	let span;
    	let t0_value = /*paciente*/ ctx[12].nombres[0] + "";
    	let t0;
    	let t1_value = /*paciente*/ ctx[12].apellidos[0] + "";
    	let t1;
    	let t2;
    	let td1;
    	let t3_value = /*paciente*/ ctx[12].nombres + "";
    	let t3;
    	let t4;
    	let t5_value = /*paciente*/ ctx[12].apellidos + "";
    	let t5;
    	let t6;
    	let td2;
    	let t7_value = calcularEdad(/*paciente*/ ctx[12].fechaNacimiento) + "";
    	let t7;
    	let t8;
    	let t9;
    	let td3;
    	let t10_value = /*paciente*/ ctx[12].sexo + "";
    	let t10;
    	let t11;
    	let td4;
    	let t12_value = /*paciente*/ ctx[12].celular + "";
    	let t12;
    	let t13;
    	let td5;
    	let t14_value = /*paciente*/ ctx[12].cedula + "";
    	let t14;
    	let t15;
    	let td6;
    	let button;
    	let i0;
    	let t16;
    	let a0;
    	let i1;
    	let t17;
    	let a1;
    	let i2;
    	let a1_href_value;
    	let link_action;
    	let t18;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[8](/*paciente*/ ctx[12], ...args);
    	}

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[9](/*paciente*/ ctx[12], ...args);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			div = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			td1 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			t5 = text(t5_value);
    			t6 = space();
    			td2 = element("td");
    			t7 = text(t7_value);
    			t8 = text(" aos");
    			t9 = space();
    			td3 = element("td");
    			t10 = text(t10_value);
    			t11 = space();
    			td4 = element("td");
    			t12 = text(t12_value);
    			t13 = space();
    			td5 = element("td");
    			t14 = text(t14_value);
    			t15 = space();
    			td6 = element("td");
    			button = element("button");
    			i0 = element("i");
    			t16 = space();
    			a0 = element("a");
    			i1 = element("i");
    			t17 = space();
    			a1 = element("a");
    			i2 = element("i");
    			t18 = space();
    			attr_dev(span, "class", "avatar-title rounded-circle ");
    			add_location(span, file$8, 149, 32, 5004);
    			attr_dev(div, "class", "avatar avatar-sm");
    			add_location(div, file$8, 148, 28, 4940);
    			add_location(td0, file$8, 147, 24, 4906);
    			add_location(td1, file$8, 152, 24, 5191);
    			add_location(td2, file$8, 153, 24, 5265);
    			add_location(td3, file$8, 154, 24, 5345);
    			add_location(td4, file$8, 155, 24, 5395);
    			add_location(td5, file$8, 156, 24, 5448);
    			attr_dev(i0, "class", "mdi mdi-calendar-multiselect");
    			add_location(i0, file$8, 177, 32, 6698);
    			attr_dev(button, "href", "#!");
    			attr_dev(button, "class", "btn btn-outline-success");
    			attr_dev(button, "data-tooltip", "Nueva cita");
    			attr_dev(button, "data-toggle", "modal");
    			attr_dev(button, "data-target", "#modalNuevaCita");
    			add_location(button, file$8, 159, 28, 5628);
    			attr_dev(i1, "class", "mdi mdi-close");
    			add_location(i1, file$8, 185, 32, 7137);
    			attr_dev(a0, "href", "#!");
    			attr_dev(a0, "class", "btn btn-outline-danger");
    			attr_dev(a0, "data-tooltip", "Eliminar");
    			add_location(a0, file$8, 179, 28, 6811);
    			attr_dev(i2, "class", "mdi mdi-send");
    			add_location(i2, file$8, 193, 32, 7534);
    			attr_dev(a1, "href", a1_href_value = `/pacientes/perfil/${/*paciente*/ ctx[12].id}`);
    			attr_dev(a1, "class", "btn btn-outline-primary");
    			attr_dev(a1, "data-tooltip", "Perfil");
    			add_location(a1, file$8, 187, 28, 7230);
    			attr_dev(td6, "class", "text-right");
    			add_location(td6, file$8, 157, 24, 5500);
    			add_location(tr, file$8, 146, 20, 4876);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, div);
    			append_dev(div, span);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td1);
    			append_dev(td1, t3);
    			append_dev(td1, t4);
    			append_dev(td1, t5);
    			append_dev(tr, t6);
    			append_dev(tr, td2);
    			append_dev(td2, t7);
    			append_dev(td2, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td3);
    			append_dev(td3, t10);
    			append_dev(tr, t11);
    			append_dev(tr, td4);
    			append_dev(td4, t12);
    			append_dev(tr, t13);
    			append_dev(tr, td5);
    			append_dev(td5, t14);
    			append_dev(tr, t15);
    			append_dev(tr, td6);
    			append_dev(td6, button);
    			append_dev(button, i0);
    			append_dev(td6, t16);
    			append_dev(td6, a0);
    			append_dev(a0, i1);
    			append_dev(td6, t17);
    			append_dev(td6, a1);
    			append_dev(a1, i2);
    			append_dev(tr, t18);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", prevent_default(click_handler), false, true, false),
    					listen_dev(a0, "click", prevent_default(click_handler_1), false, true, false),
    					action_destroyer(link_action = link.call(null, a1))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*pacientes*/ 1 && t0_value !== (t0_value = /*paciente*/ ctx[12].nombres[0] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*pacientes*/ 1 && t1_value !== (t1_value = /*paciente*/ ctx[12].apellidos[0] + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*pacientes*/ 1 && t3_value !== (t3_value = /*paciente*/ ctx[12].nombres + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*pacientes*/ 1 && t5_value !== (t5_value = /*paciente*/ ctx[12].apellidos + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*pacientes*/ 1 && t7_value !== (t7_value = calcularEdad(/*paciente*/ ctx[12].fechaNacimiento) + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*pacientes*/ 1 && t10_value !== (t10_value = /*paciente*/ ctx[12].sexo + "")) set_data_dev(t10, t10_value);
    			if (dirty & /*pacientes*/ 1 && t12_value !== (t12_value = /*paciente*/ ctx[12].celular + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*pacientes*/ 1 && t14_value !== (t14_value = /*paciente*/ ctx[12].cedula + "")) set_data_dev(t14, t14_value);

    			if (dirty & /*pacientes*/ 1 && a1_href_value !== (a1_href_value = `/pacientes/perfil/${/*paciente*/ ctx[12].id}`)) {
    				attr_dev(a1, "href", a1_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(146:20) {#if paciente.activo}",
    		ctx
    	});

    	return block;
    }

    // (145:16) {#each pacientes as paciente}
    function create_each_block$1(ctx) {
    	let if_block_anchor;
    	let if_block = /*paciente*/ ctx[12].activo && create_if_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*paciente*/ ctx[12].activo) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(145:16) {#each pacientes as paciente}",
    		ctx
    	});

    	return block;
    }

    // (204:8) {#if cargando}
    function create_if_block$5(ctx) {
    	let div1;
    	let div0;
    	let span;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span = element("span");
    			span.textContent = "Loading...";
    			attr_dev(span, "class", "sr-only");
    			add_location(span, file$8, 206, 24, 7944);
    			attr_dev(div0, "class", "spinner-border text-secondary");
    			attr_dev(div0, "role", "status");
    			add_location(div0, file$8, 205, 20, 7861);
    			attr_dev(div1, "class", "text-center");
    			add_location(div1, file$8, 204, 16, 7814);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(204:8) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let t2;
    	let section;
    	let div9;
    	let div0;
    	let t3;
    	let div8;
    	let h5;
    	let t4;
    	let a;
    	let i;
    	let t5;
    	let link_action;
    	let t6;
    	let div6;
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let div1;
    	let label;
    	let t8;
    	let input;
    	let t9;
    	let div7;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t10;
    	let th1;
    	let t12;
    	let th2;
    	let t14;
    	let th3;
    	let t16;
    	let th4;
    	let t18;
    	let th5;
    	let t20;
    	let th6;
    	let t21;
    	let tbody;
    	let t22;
    	let t23;
    	let modalnuevacita;
    	let current;
    	let mounted;
    	let dispose;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });
    	let if_block0 = /*errorServer*/ ctx[1] && create_if_block_2$3(ctx);
    	let each_value = /*pacientes*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	let if_block1 = /*cargando*/ ctx[3] && create_if_block$5(ctx);

    	modalnuevacita = new ModalNuevaCita({
    			props: {
    				pacienteSeleccionado: /*pacienteSeleccionado*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			section = element("section");
    			div9 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div8 = element("div");
    			h5 = element("h5");
    			t4 = text("Pacientes ");
    			a = element("a");
    			i = element("i");
    			t5 = text(" CREAR");
    			t6 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			label = element("label");
    			label.textContent = "Buscar pacientes";
    			t8 = space();
    			input = element("input");
    			t9 = space();
    			div7 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t10 = space();
    			th1 = element("th");
    			th1.textContent = "Nombre";
    			t12 = space();
    			th2 = element("th");
    			th2.textContent = "Edad";
    			t14 = space();
    			th3 = element("th");
    			th3.textContent = "Sexo";
    			t16 = space();
    			th4 = element("th");
    			th4.textContent = "Celular";
    			t18 = space();
    			th5 = element("th");
    			th5.textContent = "Cedula";
    			t20 = space();
    			th6 = element("th");
    			t21 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t22 = space();
    			if (if_block1) if_block1.c();
    			t23 = space();
    			create_component(modalnuevacita.$$.fragment);
    			attr_dev(div0, "class", "row");
    			add_location(div0, file$8, 113, 6, 3373);
    			attr_dev(i, "class", "mdi mdi-plus");
    			add_location(i, file$8, 115, 89, 3526);
    			attr_dev(a, "href", "/pacientes/crear");
    			attr_dev(a, "class", "btn btn-primary btn-sm");
    			add_location(a, file$8, 115, 22, 3459);
    			add_location(h5, file$8, 115, 8, 3445);
    			attr_dev(label, "for", "Buscar");
    			add_location(label, file$8, 122, 36, 3892);
    			attr_dev(input, "type", "search");
    			attr_dev(input, "class", "form-control");
    			attr_dev(input, "placeholder", "Nombres, Apellidos o Cedula");
    			add_location(input, file$8, 123, 36, 3974);
    			attr_dev(div1, "class", "form-group");
    			add_location(div1, file$8, 121, 32, 3830);
    			attr_dev(div2, "class", "col-lg-4");
    			add_location(div2, file$8, 120, 28, 3774);
    			attr_dev(div3, "class", "row");
    			add_location(div3, file$8, 119, 24, 3727);
    			attr_dev(div4, "class", "col-12");
    			add_location(div4, file$8, 118, 20, 3681);
    			attr_dev(div5, "class", "row");
    			add_location(div5, file$8, 117, 12, 3642);
    			attr_dev(div6, "class", "alert alert-secondary");
    			attr_dev(div6, "role", "alert");
    			add_location(div6, file$8, 116, 8, 3580);
    			add_location(th0, file$8, 134, 20, 4468);
    			add_location(th1, file$8, 135, 20, 4499);
    			add_location(th2, file$8, 136, 20, 4536);
    			add_location(th3, file$8, 137, 20, 4571);
    			add_location(th4, file$8, 138, 20, 4606);
    			add_location(th5, file$8, 139, 20, 4644);
    			add_location(th6, file$8, 140, 20, 4681);
    			add_location(tr, file$8, 133, 16, 4442);
    			add_location(thead, file$8, 132, 16, 4417);
    			add_location(tbody, file$8, 143, 16, 4757);
    			attr_dev(table, "class", "table align-td-middle table-card");
    			add_location(table, file$8, 131, 12, 4351);
    			attr_dev(div7, "class", "table-responsive");
    			add_location(div7, file$8, 130, 8, 4307);
    			attr_dev(div8, "class", "col-md-12 mt-3 m-b-30");
    			add_location(div8, file$8, 114, 6, 3400);
    			attr_dev(div9, "class", "p-2");
    			add_location(div9, file$8, 112, 4, 3348);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$8, 111, 2, 3311);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$8, 104, 0, 3103);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t2);
    			append_dev(main, section);
    			append_dev(section, div9);
    			append_dev(div9, div0);
    			append_dev(div9, t3);
    			append_dev(div9, div8);
    			append_dev(div8, h5);
    			append_dev(h5, t4);
    			append_dev(h5, a);
    			append_dev(a, i);
    			append_dev(a, t5);
    			append_dev(div8, t6);
    			append_dev(div8, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, label);
    			append_dev(div1, t8);
    			append_dev(div1, input);
    			set_input_value(input, /*sltBuscarPacientes*/ ctx[2]);
    			append_dev(div8, t9);
    			append_dev(div8, div7);
    			append_dev(div7, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t10);
    			append_dev(tr, th1);
    			append_dev(tr, t12);
    			append_dev(tr, th2);
    			append_dev(tr, t14);
    			append_dev(tr, th3);
    			append_dev(tr, t16);
    			append_dev(tr, th4);
    			append_dev(tr, t18);
    			append_dev(tr, th5);
    			append_dev(tr, t20);
    			append_dev(tr, th6);
    			append_dev(table, t21);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(div8, t22);
    			if (if_block1) if_block1.m(div8, null);
    			insert_dev(target, t23, anchor);
    			mount_component(modalnuevacita, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link_action = link.call(null, a)),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(input, "input", /*searchPacientes*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*errorServer*/ ctx[1]) {
    				if (if_block0) {
    					if (dirty & /*errorServer*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(main, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*sltBuscarPacientes*/ 4) {
    				set_input_value(input, /*sltBuscarPacientes*/ ctx[2]);
    			}

    			if (dirty & /*pacientes, eliminarPaciente, pacienteSeleccionado, calcularEdad*/ 81) {
    				each_value = /*pacientes*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*cargando*/ ctx[3]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					if_block1.m(div8, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			const modalnuevacita_changes = {};
    			if (dirty & /*pacienteSeleccionado*/ 16) modalnuevacita_changes.pacienteSeleccionado = /*pacienteSeleccionado*/ ctx[4];
    			modalnuevacita.$set(modalnuevacita_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(modalnuevacita.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(modalnuevacita.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks, detaching);
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t23);
    			destroy_component(modalnuevacita, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Index", slots, []);
    	let pacientes = [];
    	let errorServer = false;
    	let sltBuscarPacientes = "";
    	let timeout = null;
    	let cargando = false;
    	let pacienteSeleccionado = {};

    	const searchPacientes = () => {
    		if (timeout) {
    			window.clearTimeout(timeout);
    		}

    		timeout = setTimeout(
    			function () {
    				cargarPacientes();
    			},
    			300
    		);
    	};

    	const eliminarPaciente = id => {
    		Swal.fire({
    			title: "Esta seguro?",
    			text: "Eliminar al paciente es quitarlo de su lista, sin embargo la informacin no se perder!",
    			icon: "warning",
    			showCancelButton: true,
    			confirmButtonColor: "#3085d6",
    			cancelButtonColor: "#d33",
    			confirmButtonText: "Si, Eliminar!",
    			cancelButtonText: "Cancelar"
    		}).then(result => {
    			if (result.isConfirmed) {
    				const config = {
    					method: "put",
    					url: `${url}/pacientes/eliminar/${id}`,
    					headers: {
    						"Authorization": `${localStorage.getItem("auth")}`
    					}
    				};

    				axios$1(config).then(res => {
    					console.log(res.data);
    					cargarPacientes();
    					Swal.fire("Eliminado!", "El paciente se ha eliminado correctamente.", "success");
    				}).catch(error => {
    					console.error(error);
    				});
    			}
    		});
    	};

    	function cargarPacientes() {
    		$$invalidate(3, cargando = true);

    		const config = {
    			method: "get",
    			url: `${url}/pacientes?b=${sltBuscarPacientes}`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		try {
    			axios$1(config).then(res => {
    				$$invalidate(3, cargando = false);

    				if (res.status === 200) {
    					let { data } = res;
    					$$invalidate(0, pacientes = data);
    				}

    				if (res.status === 500) {
    					$$invalidate(1, errorServer = true);
    				}
    			}).catch(err => {
    				$$invalidate(3, cargando = false);
    				console.error(err);

    				if (err) {
    					$$invalidate(1, errorServer = true);
    				}
    			});
    		} catch(error) {
    			if (error) {
    				$$invalidate(1, errorServer = true);
    			}
    		}
    	}

    	onMount(() => {
    		cargarPacientes();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		sltBuscarPacientes = this.value;
    		$$invalidate(2, sltBuscarPacientes);
    	}

    	const click_handler = paciente => $$invalidate(4, pacienteSeleccionado = {
    		id: paciente.id,
    		nombres: paciente.nombres,
    		apellidos: paciente.apellidos,
    		sexo: paciente.sexo,
    		fechaNacimiento: paciente.fechaNacimiento,
    		nacionalidad: paciente.nacionalidad,
    		telefono: paciente.telefono,
    		celular: paciente.celular,
    		cedula: paciente.cedula
    	});

    	const click_handler_1 = paciente => eliminarPaciente(paciente.id);

    	$$self.$capture_state = () => ({
    		link,
    		onMount,
    		url,
    		calcularEdad,
    		axios: axios$1,
    		Header,
    		Aside,
    		ErrorServer: ErrorConexion,
    		ModalNuevaCita,
    		pacientes,
    		errorServer,
    		sltBuscarPacientes,
    		timeout,
    		cargando,
    		pacienteSeleccionado,
    		searchPacientes,
    		eliminarPaciente,
    		cargarPacientes
    	});

    	$$self.$inject_state = $$props => {
    		if ("pacientes" in $$props) $$invalidate(0, pacientes = $$props.pacientes);
    		if ("errorServer" in $$props) $$invalidate(1, errorServer = $$props.errorServer);
    		if ("sltBuscarPacientes" in $$props) $$invalidate(2, sltBuscarPacientes = $$props.sltBuscarPacientes);
    		if ("timeout" in $$props) timeout = $$props.timeout;
    		if ("cargando" in $$props) $$invalidate(3, cargando = $$props.cargando);
    		if ("pacienteSeleccionado" in $$props) $$invalidate(4, pacienteSeleccionado = $$props.pacienteSeleccionado);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		pacientes,
    		errorServer,
    		sltBuscarPacientes,
    		cargando,
    		pacienteSeleccionado,
    		searchPacientes,
    		eliminarPaciente,
    		input_input_handler,
    		click_handler,
    		click_handler_1
    	];
    }

    class Index$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    function fade(node, { delay = 0, duration = 400, easing = identity }) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    	  path: basedir,
    	  exports: {},
    	  require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var moment = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
         module.exports = factory() ;
    }(commonjsGlobal, (function () {
        var hookCallback;

        function hooks() {
            return hookCallback.apply(null, arguments);
        }

        // This is done to register the method called with moment()
        // without creating circular dependencies.
        function setHookCallback(callback) {
            hookCallback = callback;
        }

        function isArray(input) {
            return (
                input instanceof Array ||
                Object.prototype.toString.call(input) === '[object Array]'
            );
        }

        function isObject(input) {
            // IE8 will treat undefined and null as object if it wasn't for
            // input != null
            return (
                input != null &&
                Object.prototype.toString.call(input) === '[object Object]'
            );
        }

        function hasOwnProp(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b);
        }

        function isObjectEmpty(obj) {
            if (Object.getOwnPropertyNames) {
                return Object.getOwnPropertyNames(obj).length === 0;
            } else {
                var k;
                for (k in obj) {
                    if (hasOwnProp(obj, k)) {
                        return false;
                    }
                }
                return true;
            }
        }

        function isUndefined(input) {
            return input === void 0;
        }

        function isNumber(input) {
            return (
                typeof input === 'number' ||
                Object.prototype.toString.call(input) === '[object Number]'
            );
        }

        function isDate(input) {
            return (
                input instanceof Date ||
                Object.prototype.toString.call(input) === '[object Date]'
            );
        }

        function map(arr, fn) {
            var res = [],
                i;
            for (i = 0; i < arr.length; ++i) {
                res.push(fn(arr[i], i));
            }
            return res;
        }

        function extend(a, b) {
            for (var i in b) {
                if (hasOwnProp(b, i)) {
                    a[i] = b[i];
                }
            }

            if (hasOwnProp(b, 'toString')) {
                a.toString = b.toString;
            }

            if (hasOwnProp(b, 'valueOf')) {
                a.valueOf = b.valueOf;
            }

            return a;
        }

        function createUTC(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, true).utc();
        }

        function defaultParsingFlags() {
            // We need to deep clone this object.
            return {
                empty: false,
                unusedTokens: [],
                unusedInput: [],
                overflow: -2,
                charsLeftOver: 0,
                nullInput: false,
                invalidEra: null,
                invalidMonth: null,
                invalidFormat: false,
                userInvalidated: false,
                iso: false,
                parsedDateParts: [],
                era: null,
                meridiem: null,
                rfc2822: false,
                weekdayMismatch: false,
            };
        }

        function getParsingFlags(m) {
            if (m._pf == null) {
                m._pf = defaultParsingFlags();
            }
            return m._pf;
        }

        var some;
        if (Array.prototype.some) {
            some = Array.prototype.some;
        } else {
            some = function (fun) {
                var t = Object(this),
                    len = t.length >>> 0,
                    i;

                for (i = 0; i < len; i++) {
                    if (i in t && fun.call(this, t[i], i, t)) {
                        return true;
                    }
                }

                return false;
            };
        }

        function isValid(m) {
            if (m._isValid == null) {
                var flags = getParsingFlags(m),
                    parsedParts = some.call(flags.parsedDateParts, function (i) {
                        return i != null;
                    }),
                    isNowValid =
                        !isNaN(m._d.getTime()) &&
                        flags.overflow < 0 &&
                        !flags.empty &&
                        !flags.invalidEra &&
                        !flags.invalidMonth &&
                        !flags.invalidWeekday &&
                        !flags.weekdayMismatch &&
                        !flags.nullInput &&
                        !flags.invalidFormat &&
                        !flags.userInvalidated &&
                        (!flags.meridiem || (flags.meridiem && parsedParts));

                if (m._strict) {
                    isNowValid =
                        isNowValid &&
                        flags.charsLeftOver === 0 &&
                        flags.unusedTokens.length === 0 &&
                        flags.bigHour === undefined;
                }

                if (Object.isFrozen == null || !Object.isFrozen(m)) {
                    m._isValid = isNowValid;
                } else {
                    return isNowValid;
                }
            }
            return m._isValid;
        }

        function createInvalid(flags) {
            var m = createUTC(NaN);
            if (flags != null) {
                extend(getParsingFlags(m), flags);
            } else {
                getParsingFlags(m).userInvalidated = true;
            }

            return m;
        }

        // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.
        var momentProperties = (hooks.momentProperties = []),
            updateInProgress = false;

        function copyConfig(to, from) {
            var i, prop, val;

            if (!isUndefined(from._isAMomentObject)) {
                to._isAMomentObject = from._isAMomentObject;
            }
            if (!isUndefined(from._i)) {
                to._i = from._i;
            }
            if (!isUndefined(from._f)) {
                to._f = from._f;
            }
            if (!isUndefined(from._l)) {
                to._l = from._l;
            }
            if (!isUndefined(from._strict)) {
                to._strict = from._strict;
            }
            if (!isUndefined(from._tzm)) {
                to._tzm = from._tzm;
            }
            if (!isUndefined(from._isUTC)) {
                to._isUTC = from._isUTC;
            }
            if (!isUndefined(from._offset)) {
                to._offset = from._offset;
            }
            if (!isUndefined(from._pf)) {
                to._pf = getParsingFlags(from);
            }
            if (!isUndefined(from._locale)) {
                to._locale = from._locale;
            }

            if (momentProperties.length > 0) {
                for (i = 0; i < momentProperties.length; i++) {
                    prop = momentProperties[i];
                    val = from[prop];
                    if (!isUndefined(val)) {
                        to[prop] = val;
                    }
                }
            }

            return to;
        }

        // Moment prototype object
        function Moment(config) {
            copyConfig(this, config);
            this._d = new Date(config._d != null ? config._d.getTime() : NaN);
            if (!this.isValid()) {
                this._d = new Date(NaN);
            }
            // Prevent infinite loop in case updateOffset creates new moment
            // objects.
            if (updateInProgress === false) {
                updateInProgress = true;
                hooks.updateOffset(this);
                updateInProgress = false;
            }
        }

        function isMoment(obj) {
            return (
                obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
            );
        }

        function warn(msg) {
            if (
                hooks.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' &&
                console.warn
            ) {
                console.warn('Deprecation warning: ' + msg);
            }
        }

        function deprecate(msg, fn) {
            var firstTime = true;

            return extend(function () {
                if (hooks.deprecationHandler != null) {
                    hooks.deprecationHandler(null, msg);
                }
                if (firstTime) {
                    var args = [],
                        arg,
                        i,
                        key;
                    for (i = 0; i < arguments.length; i++) {
                        arg = '';
                        if (typeof arguments[i] === 'object') {
                            arg += '\n[' + i + '] ';
                            for (key in arguments[0]) {
                                if (hasOwnProp(arguments[0], key)) {
                                    arg += key + ': ' + arguments[0][key] + ', ';
                                }
                            }
                            arg = arg.slice(0, -2); // Remove trailing comma and space
                        } else {
                            arg = arguments[i];
                        }
                        args.push(arg);
                    }
                    warn(
                        msg +
                            '\nArguments: ' +
                            Array.prototype.slice.call(args).join('') +
                            '\n' +
                            new Error().stack
                    );
                    firstTime = false;
                }
                return fn.apply(this, arguments);
            }, fn);
        }

        var deprecations = {};

        function deprecateSimple(name, msg) {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(name, msg);
            }
            if (!deprecations[name]) {
                warn(msg);
                deprecations[name] = true;
            }
        }

        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;

        function isFunction(input) {
            return (
                (typeof Function !== 'undefined' && input instanceof Function) ||
                Object.prototype.toString.call(input) === '[object Function]'
            );
        }

        function set(config) {
            var prop, i;
            for (i in config) {
                if (hasOwnProp(config, i)) {
                    prop = config[i];
                    if (isFunction(prop)) {
                        this[i] = prop;
                    } else {
                        this['_' + i] = prop;
                    }
                }
            }
            this._config = config;
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
            // TODO: Remove "ordinalParse" fallback in next major release.
            this._dayOfMonthOrdinalParseLenient = new RegExp(
                (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                    '|' +
                    /\d{1,2}/.source
            );
        }

        function mergeConfigs(parentConfig, childConfig) {
            var res = extend({}, parentConfig),
                prop;
            for (prop in childConfig) {
                if (hasOwnProp(childConfig, prop)) {
                    if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                        res[prop] = {};
                        extend(res[prop], parentConfig[prop]);
                        extend(res[prop], childConfig[prop]);
                    } else if (childConfig[prop] != null) {
                        res[prop] = childConfig[prop];
                    } else {
                        delete res[prop];
                    }
                }
            }
            for (prop in parentConfig) {
                if (
                    hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])
                ) {
                    // make sure changes to properties don't modify parent config
                    res[prop] = extend({}, res[prop]);
                }
            }
            return res;
        }

        function Locale(config) {
            if (config != null) {
                this.set(config);
            }
        }

        var keys;

        if (Object.keys) {
            keys = Object.keys;
        } else {
            keys = function (obj) {
                var i,
                    res = [];
                for (i in obj) {
                    if (hasOwnProp(obj, i)) {
                        res.push(i);
                    }
                }
                return res;
            };
        }

        var defaultCalendar = {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        };

        function calendar(key, mom, now) {
            var output = this._calendar[key] || this._calendar['sameElse'];
            return isFunction(output) ? output.call(mom, now) : output;
        }

        function zeroFill(number, targetLength, forceSign) {
            var absNumber = '' + Math.abs(number),
                zerosToFill = targetLength - absNumber.length,
                sign = number >= 0;
            return (
                (sign ? (forceSign ? '+' : '') : '-') +
                Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
                absNumber
            );
        }

        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
            localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
            formatFunctions = {},
            formatTokenFunctions = {};

        // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }
        function addFormatToken(token, padded, ordinal, callback) {
            var func = callback;
            if (typeof callback === 'string') {
                func = function () {
                    return this[callback]();
                };
            }
            if (token) {
                formatTokenFunctions[token] = func;
            }
            if (padded) {
                formatTokenFunctions[padded[0]] = function () {
                    return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                };
            }
            if (ordinal) {
                formatTokenFunctions[ordinal] = function () {
                    return this.localeData().ordinal(
                        func.apply(this, arguments),
                        token
                    );
                };
            }
        }

        function removeFormattingTokens(input) {
            if (input.match(/\[[\s\S]/)) {
                return input.replace(/^\[|\]$/g, '');
            }
            return input.replace(/\\/g, '');
        }

        function makeFormatFunction(format) {
            var array = format.match(formattingTokens),
                i,
                length;

            for (i = 0, length = array.length; i < length; i++) {
                if (formatTokenFunctions[array[i]]) {
                    array[i] = formatTokenFunctions[array[i]];
                } else {
                    array[i] = removeFormattingTokens(array[i]);
                }
            }

            return function (mom) {
                var output = '',
                    i;
                for (i = 0; i < length; i++) {
                    output += isFunction(array[i])
                        ? array[i].call(mom, format)
                        : array[i];
                }
                return output;
            };
        }

        // format date using native date object
        function formatMoment(m, format) {
            if (!m.isValid()) {
                return m.localeData().invalidDate();
            }

            format = expandFormat(format, m.localeData());
            formatFunctions[format] =
                formatFunctions[format] || makeFormatFunction(format);

            return formatFunctions[format](m);
        }

        function expandFormat(format, locale) {
            var i = 5;

            function replaceLongDateFormatTokens(input) {
                return locale.longDateFormat(input) || input;
            }

            localFormattingTokens.lastIndex = 0;
            while (i >= 0 && localFormattingTokens.test(format)) {
                format = format.replace(
                    localFormattingTokens,
                    replaceLongDateFormatTokens
                );
                localFormattingTokens.lastIndex = 0;
                i -= 1;
            }

            return format;
        }

        var defaultLongDateFormat = {
            LTS: 'h:mm:ss A',
            LT: 'h:mm A',
            L: 'MM/DD/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY h:mm A',
            LLLL: 'dddd, MMMM D, YYYY h:mm A',
        };

        function longDateFormat(key) {
            var format = this._longDateFormat[key],
                formatUpper = this._longDateFormat[key.toUpperCase()];

            if (format || !formatUpper) {
                return format;
            }

            this._longDateFormat[key] = formatUpper
                .match(formattingTokens)
                .map(function (tok) {
                    if (
                        tok === 'MMMM' ||
                        tok === 'MM' ||
                        tok === 'DD' ||
                        tok === 'dddd'
                    ) {
                        return tok.slice(1);
                    }
                    return tok;
                })
                .join('');

            return this._longDateFormat[key];
        }

        var defaultInvalidDate = 'Invalid date';

        function invalidDate() {
            return this._invalidDate;
        }

        var defaultOrdinal = '%d',
            defaultDayOfMonthOrdinalParse = /\d{1,2}/;

        function ordinal(number) {
            return this._ordinal.replace('%d', number);
        }

        var defaultRelativeTime = {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            w: 'a week',
            ww: '%d weeks',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        };

        function relativeTime(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return isFunction(output)
                ? output(number, withoutSuffix, string, isFuture)
                : output.replace(/%d/i, number);
        }

        function pastFuture(diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return isFunction(format) ? format(output) : format.replace(/%s/i, output);
        }

        var aliases = {};

        function addUnitAlias(unit, shorthand) {
            var lowerCase = unit.toLowerCase();
            aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }

        function normalizeUnits(units) {
            return typeof units === 'string'
                ? aliases[units] || aliases[units.toLowerCase()]
                : undefined;
        }

        function normalizeObjectUnits(inputObject) {
            var normalizedInput = {},
                normalizedProp,
                prop;

            for (prop in inputObject) {
                if (hasOwnProp(inputObject, prop)) {
                    normalizedProp = normalizeUnits(prop);
                    if (normalizedProp) {
                        normalizedInput[normalizedProp] = inputObject[prop];
                    }
                }
            }

            return normalizedInput;
        }

        var priorities = {};

        function addUnitPriority(unit, priority) {
            priorities[unit] = priority;
        }

        function getPrioritizedUnits(unitsObj) {
            var units = [],
                u;
            for (u in unitsObj) {
                if (hasOwnProp(unitsObj, u)) {
                    units.push({ unit: u, priority: priorities[u] });
                }
            }
            units.sort(function (a, b) {
                return a.priority - b.priority;
            });
            return units;
        }

        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        }

        function absFloor(number) {
            if (number < 0) {
                // -0 -> 0
                return Math.ceil(number) || 0;
            } else {
                return Math.floor(number);
            }
        }

        function toInt(argumentForCoercion) {
            var coercedNumber = +argumentForCoercion,
                value = 0;

            if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                value = absFloor(coercedNumber);
            }

            return value;
        }

        function makeGetSet(unit, keepTime) {
            return function (value) {
                if (value != null) {
                    set$1(this, unit, value);
                    hooks.updateOffset(this, keepTime);
                    return this;
                } else {
                    return get(this, unit);
                }
            };
        }

        function get(mom, unit) {
            return mom.isValid()
                ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
                : NaN;
        }

        function set$1(mom, unit, value) {
            if (mom.isValid() && !isNaN(value)) {
                if (
                    unit === 'FullYear' &&
                    isLeapYear(mom.year()) &&
                    mom.month() === 1 &&
                    mom.date() === 29
                ) {
                    value = toInt(value);
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                        value,
                        mom.month(),
                        daysInMonth(value, mom.month())
                    );
                } else {
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                }
            }
        }

        // MOMENTS

        function stringGet(units) {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units]();
            }
            return this;
        }

        function stringSet(units, value) {
            if (typeof units === 'object') {
                units = normalizeObjectUnits(units);
                var prioritized = getPrioritizedUnits(units),
                    i;
                for (i = 0; i < prioritized.length; i++) {
                    this[prioritized[i].unit](units[prioritized[i].unit]);
                }
            } else {
                units = normalizeUnits(units);
                if (isFunction(this[units])) {
                    return this[units](value);
                }
            }
            return this;
        }

        var match1 = /\d/, //       0 - 9
            match2 = /\d\d/, //      00 - 99
            match3 = /\d{3}/, //     000 - 999
            match4 = /\d{4}/, //    0000 - 9999
            match6 = /[+-]?\d{6}/, // -999999 - 999999
            match1to2 = /\d\d?/, //       0 - 99
            match3to4 = /\d\d\d\d?/, //     999 - 9999
            match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
            match1to3 = /\d{1,3}/, //       0 - 999
            match1to4 = /\d{1,4}/, //       0 - 9999
            match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
            matchUnsigned = /\d+/, //       0 - inf
            matchSigned = /[+-]?\d+/, //    -inf - inf
            matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
            matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
            matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
            // any word (or two) characters or numbers including two/three word month in arabic.
            // includes scottish gaelic two word and hyphenated months
            matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
            regexes;

        regexes = {};

        function addRegexToken(token, regex, strictRegex) {
            regexes[token] = isFunction(regex)
                ? regex
                : function (isStrict, localeData) {
                      return isStrict && strictRegex ? strictRegex : regex;
                  };
        }

        function getParseRegexForToken(token, config) {
            if (!hasOwnProp(regexes, token)) {
                return new RegExp(unescapeFormat(token));
            }

            return regexes[token](config._strict, config._locale);
        }

        // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        function unescapeFormat(s) {
            return regexEscape(
                s
                    .replace('\\', '')
                    .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                        matched,
                        p1,
                        p2,
                        p3,
                        p4
                    ) {
                        return p1 || p2 || p3 || p4;
                    })
            );
        }

        function regexEscape(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }

        var tokens = {};

        function addParseToken(token, callback) {
            var i,
                func = callback;
            if (typeof token === 'string') {
                token = [token];
            }
            if (isNumber(callback)) {
                func = function (input, array) {
                    array[callback] = toInt(input);
                };
            }
            for (i = 0; i < token.length; i++) {
                tokens[token[i]] = func;
            }
        }

        function addWeekParseToken(token, callback) {
            addParseToken(token, function (input, array, config, token) {
                config._w = config._w || {};
                callback(input, config._w, config, token);
            });
        }

        function addTimeToArrayFromToken(token, input, config) {
            if (input != null && hasOwnProp(tokens, token)) {
                tokens[token](input, config._a, config, token);
            }
        }

        var YEAR = 0,
            MONTH = 1,
            DATE = 2,
            HOUR = 3,
            MINUTE = 4,
            SECOND = 5,
            MILLISECOND = 6,
            WEEK = 7,
            WEEKDAY = 8;

        function mod(n, x) {
            return ((n % x) + x) % x;
        }

        var indexOf;

        if (Array.prototype.indexOf) {
            indexOf = Array.prototype.indexOf;
        } else {
            indexOf = function (o) {
                // I know
                var i;
                for (i = 0; i < this.length; ++i) {
                    if (this[i] === o) {
                        return i;
                    }
                }
                return -1;
            };
        }

        function daysInMonth(year, month) {
            if (isNaN(year) || isNaN(month)) {
                return NaN;
            }
            var modMonth = mod(month, 12);
            year += (month - modMonth) / 12;
            return modMonth === 1
                ? isLeapYear(year)
                    ? 29
                    : 28
                : 31 - ((modMonth % 7) % 2);
        }

        // FORMATTING

        addFormatToken('M', ['MM', 2], 'Mo', function () {
            return this.month() + 1;
        });

        addFormatToken('MMM', 0, 0, function (format) {
            return this.localeData().monthsShort(this, format);
        });

        addFormatToken('MMMM', 0, 0, function (format) {
            return this.localeData().months(this, format);
        });

        // ALIASES

        addUnitAlias('month', 'M');

        // PRIORITY

        addUnitPriority('month', 8);

        // PARSING

        addRegexToken('M', match1to2);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
            return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
            return locale.monthsRegex(isStrict);
        });

        addParseToken(['M', 'MM'], function (input, array) {
            array[MONTH] = toInt(input) - 1;
        });

        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
            var month = config._locale.monthsParse(input, token, config._strict);
            // if we didn't find a month name, mark the date as invalid.
            if (month != null) {
                array[MONTH] = month;
            } else {
                getParsingFlags(config).invalidMonth = input;
            }
        });

        // LOCALES

        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
                '_'
            ),
            MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
            defaultMonthsShortRegex = matchWord,
            defaultMonthsRegex = matchWord;

        function localeMonths(m, format) {
            if (!m) {
                return isArray(this._months)
                    ? this._months
                    : this._months['standalone'];
            }
            return isArray(this._months)
                ? this._months[m.month()]
                : this._months[
                      (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                          ? 'format'
                          : 'standalone'
                  ][m.month()];
        }

        function localeMonthsShort(m, format) {
            if (!m) {
                return isArray(this._monthsShort)
                    ? this._monthsShort
                    : this._monthsShort['standalone'];
            }
            return isArray(this._monthsShort)
                ? this._monthsShort[m.month()]
                : this._monthsShort[
                      MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
                  ][m.month()];
        }

        function handleStrictParse(monthName, format, strict) {
            var i,
                ii,
                mom,
                llc = monthName.toLocaleLowerCase();
            if (!this._monthsParse) {
                // this is not used
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
                for (i = 0; i < 12; ++i) {
                    mom = createUTC([2000, i]);
                    this._shortMonthsParse[i] = this.monthsShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeMonthsParse(monthName, format, strict) {
            var i, mom, regex;

            if (this._monthsParseExact) {
                return handleStrictParse.call(this, monthName, format, strict);
            }

            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }

            // TODO: add sorting
            // Sorting makes sure if one month (or abbr) is a prefix of another
            // see sorting in computeMonthsParse
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp(
                        '^' + this.months(mom, '').replace('.', '') + '$',
                        'i'
                    );
                    this._shortMonthsParse[i] = new RegExp(
                        '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                        'i'
                    );
                }
                if (!strict && !this._monthsParse[i]) {
                    regex =
                        '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'MMMM' &&
                    this._longMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'MMM' &&
                    this._shortMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function setMonth(mom, value) {
            var dayOfMonth;

            if (!mom.isValid()) {
                // No op
                return mom;
            }

            if (typeof value === 'string') {
                if (/^\d+$/.test(value)) {
                    value = toInt(value);
                } else {
                    value = mom.localeData().monthsParse(value);
                    // TODO: Another silent failure?
                    if (!isNumber(value)) {
                        return mom;
                    }
                }
            }

            dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
            return mom;
        }

        function getSetMonth(value) {
            if (value != null) {
                setMonth(this, value);
                hooks.updateOffset(this, true);
                return this;
            } else {
                return get(this, 'Month');
            }
        }

        function getDaysInMonth() {
            return daysInMonth(this.year(), this.month());
        }

        function monthsShortRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsShortStrictRegex;
                } else {
                    return this._monthsShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsShortRegex')) {
                    this._monthsShortRegex = defaultMonthsShortRegex;
                }
                return this._monthsShortStrictRegex && isStrict
                    ? this._monthsShortStrictRegex
                    : this._monthsShortRegex;
            }
        }

        function monthsRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsStrictRegex;
                } else {
                    return this._monthsRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    this._monthsRegex = defaultMonthsRegex;
                }
                return this._monthsStrictRegex && isStrict
                    ? this._monthsStrictRegex
                    : this._monthsRegex;
            }
        }

        function computeMonthsParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom;
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                shortPieces.push(this.monthsShort(mom, ''));
                longPieces.push(this.months(mom, ''));
                mixedPieces.push(this.months(mom, ''));
                mixedPieces.push(this.monthsShort(mom, ''));
            }
            // Sorting makes sure if one month (or abbr) is a prefix of another it
            // will match the longer piece.
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);
            for (i = 0; i < 12; i++) {
                shortPieces[i] = regexEscape(shortPieces[i]);
                longPieces[i] = regexEscape(longPieces[i]);
            }
            for (i = 0; i < 24; i++) {
                mixedPieces[i] = regexEscape(mixedPieces[i]);
            }

            this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._monthsShortRegex = this._monthsRegex;
            this._monthsStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._monthsShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken('Y', 0, 0, function () {
            var y = this.year();
            return y <= 9999 ? zeroFill(y, 4) : '+' + y;
        });

        addFormatToken(0, ['YY', 2], 0, function () {
            return this.year() % 100;
        });

        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

        // ALIASES

        addUnitAlias('year', 'y');

        // PRIORITIES

        addUnitPriority('year', 1);

        // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);

        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
            array[YEAR] =
                input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
            array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
            array[YEAR] = parseInt(input, 10);
        });

        // HELPERS

        function daysInYear(year) {
            return isLeapYear(year) ? 366 : 365;
        }

        // HOOKS

        hooks.parseTwoDigitYear = function (input) {
            return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        };

        // MOMENTS

        var getSetYear = makeGetSet('FullYear', true);

        function getIsLeapYear() {
            return isLeapYear(this.year());
        }

        function createDate(y, m, d, h, M, s, ms) {
            // can't just apply() to create a date:
            // https://stackoverflow.com/q/181348
            var date;
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                date = new Date(y + 400, m, d, h, M, s, ms);
                if (isFinite(date.getFullYear())) {
                    date.setFullYear(y);
                }
            } else {
                date = new Date(y, m, d, h, M, s, ms);
            }

            return date;
        }

        function createUTCDate(y) {
            var date, args;
            // the Date.UTC function remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                args = Array.prototype.slice.call(arguments);
                // preserve leap years using a full 400 year cycle, then reset
                args[0] = y + 400;
                date = new Date(Date.UTC.apply(null, args));
                if (isFinite(date.getUTCFullYear())) {
                    date.setUTCFullYear(y);
                }
            } else {
                date = new Date(Date.UTC.apply(null, arguments));
            }

            return date;
        }

        // start-of-first-week - start-of-year
        function firstWeekOffset(year, dow, doy) {
            var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                fwd = 7 + dow - doy,
                // first-week day local weekday -- which local weekday is fwd
                fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

            return -fwdlw + fwd - 1;
        }

        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
            var localWeekday = (7 + weekday - dow) % 7,
                weekOffset = firstWeekOffset(year, dow, doy),
                dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                resYear,
                resDayOfYear;

            if (dayOfYear <= 0) {
                resYear = year - 1;
                resDayOfYear = daysInYear(resYear) + dayOfYear;
            } else if (dayOfYear > daysInYear(year)) {
                resYear = year + 1;
                resDayOfYear = dayOfYear - daysInYear(year);
            } else {
                resYear = year;
                resDayOfYear = dayOfYear;
            }

            return {
                year: resYear,
                dayOfYear: resDayOfYear,
            };
        }

        function weekOfYear(mom, dow, doy) {
            var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                resWeek,
                resYear;

            if (week < 1) {
                resYear = mom.year() - 1;
                resWeek = week + weeksInYear(resYear, dow, doy);
            } else if (week > weeksInYear(mom.year(), dow, doy)) {
                resWeek = week - weeksInYear(mom.year(), dow, doy);
                resYear = mom.year() + 1;
            } else {
                resYear = mom.year();
                resWeek = week;
            }

            return {
                week: resWeek,
                year: resYear,
            };
        }

        function weeksInYear(year, dow, doy) {
            var weekOffset = firstWeekOffset(year, dow, doy),
                weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
            return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }

        // FORMATTING

        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

        // ALIASES

        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W');

        // PRIORITIES

        addUnitPriority('week', 5);
        addUnitPriority('isoWeek', 5);

        // PARSING

        addRegexToken('w', match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2);
        addRegexToken('WW', match1to2, match2);

        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
            input,
            week,
            config,
            token
        ) {
            week[token.substr(0, 1)] = toInt(input);
        });

        // HELPERS

        // LOCALES

        function localeWeek(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }

        var defaultLocaleWeek = {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        };

        function localeFirstDayOfWeek() {
            return this._week.dow;
        }

        function localeFirstDayOfYear() {
            return this._week.doy;
        }

        // MOMENTS

        function getSetWeek(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        function getSetISOWeek(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        // FORMATTING

        addFormatToken('d', 0, 'do', 'day');

        addFormatToken('dd', 0, 0, function (format) {
            return this.localeData().weekdaysMin(this, format);
        });

        addFormatToken('ddd', 0, 0, function (format) {
            return this.localeData().weekdaysShort(this, format);
        });

        addFormatToken('dddd', 0, 0, function (format) {
            return this.localeData().weekdays(this, format);
        });

        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday');

        // ALIASES

        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E');

        // PRIORITY
        addUnitPriority('day', 11);
        addUnitPriority('weekday', 11);
        addUnitPriority('isoWeekday', 11);

        // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
            return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
            return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
            return locale.weekdaysRegex(isStrict);
        });

        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
            var weekday = config._locale.weekdaysParse(input, token, config._strict);
            // if we didn't get a weekday name, mark the date as invalid
            if (weekday != null) {
                week.d = weekday;
            } else {
                getParsingFlags(config).invalidWeekday = input;
            }
        });

        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
            week[token] = toInt(input);
        });

        // HELPERS

        function parseWeekday(input, locale) {
            if (typeof input !== 'string') {
                return input;
            }

            if (!isNaN(input)) {
                return parseInt(input, 10);
            }

            input = locale.weekdaysParse(input);
            if (typeof input === 'number') {
                return input;
            }

            return null;
        }

        function parseIsoWeekday(input, locale) {
            if (typeof input === 'string') {
                return locale.weekdaysParse(input) % 7 || 7;
            }
            return isNaN(input) ? null : input;
        }

        // LOCALES
        function shiftWeekdays(ws, n) {
            return ws.slice(n, 7).concat(ws.slice(0, n));
        }

        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            defaultWeekdaysRegex = matchWord,
            defaultWeekdaysShortRegex = matchWord,
            defaultWeekdaysMinRegex = matchWord;

        function localeWeekdays(m, format) {
            var weekdays = isArray(this._weekdays)
                ? this._weekdays
                : this._weekdays[
                      m && m !== true && this._weekdays.isFormat.test(format)
                          ? 'format'
                          : 'standalone'
                  ];
            return m === true
                ? shiftWeekdays(weekdays, this._week.dow)
                : m
                ? weekdays[m.day()]
                : weekdays;
        }

        function localeWeekdaysShort(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysShort, this._week.dow)
                : m
                ? this._weekdaysShort[m.day()]
                : this._weekdaysShort;
        }

        function localeWeekdaysMin(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysMin, this._week.dow)
                : m
                ? this._weekdaysMin[m.day()]
                : this._weekdaysMin;
        }

        function handleStrictParse$1(weekdayName, format, strict) {
            var i,
                ii,
                mom,
                llc = weekdayName.toLocaleLowerCase();
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._minWeekdaysParse = [];

                for (i = 0; i < 7; ++i) {
                    mom = createUTC([2000, 1]).day(i);
                    this._minWeekdaysParse[i] = this.weekdaysMin(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._shortWeekdaysParse[i] = this.weekdaysShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeWeekdaysParse(weekdayName, format, strict) {
            var i, mom, regex;

            if (this._weekdaysParseExact) {
                return handleStrictParse$1.call(this, weekdayName, format, strict);
            }

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._minWeekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._fullWeekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already

                mom = createUTC([2000, 1]).day(i);
                if (strict && !this._fullWeekdaysParse[i]) {
                    this._fullWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._shortWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._minWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                }
                if (!this._weekdaysParse[i]) {
                    regex =
                        '^' +
                        this.weekdays(mom, '') +
                        '|^' +
                        this.weekdaysShort(mom, '') +
                        '|^' +
                        this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'dddd' &&
                    this._fullWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'ddd' &&
                    this._shortWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'dd' &&
                    this._minWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function getSetDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        }

        function getSetLocaleDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        }

        function getSetISODayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }

            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.

            if (input != null) {
                var weekday = parseIsoWeekday(input, this.localeData());
                return this.day(this.day() % 7 ? weekday : weekday - 7);
            } else {
                return this.day() || 7;
            }
        }

        function weekdaysRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysStrictRegex;
                } else {
                    return this._weekdaysRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    this._weekdaysRegex = defaultWeekdaysRegex;
                }
                return this._weekdaysStrictRegex && isStrict
                    ? this._weekdaysStrictRegex
                    : this._weekdaysRegex;
            }
        }

        function weekdaysShortRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysShortStrictRegex;
                } else {
                    return this._weekdaysShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                    this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                }
                return this._weekdaysShortStrictRegex && isStrict
                    ? this._weekdaysShortStrictRegex
                    : this._weekdaysShortRegex;
            }
        }

        function weekdaysMinRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysMinStrictRegex;
                } else {
                    return this._weekdaysMinRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                    this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                }
                return this._weekdaysMinStrictRegex && isStrict
                    ? this._weekdaysMinStrictRegex
                    : this._weekdaysMinRegex;
            }
        }

        function computeWeekdaysParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var minPieces = [],
                shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom,
                minp,
                shortp,
                longp;
            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, 1]).day(i);
                minp = regexEscape(this.weekdaysMin(mom, ''));
                shortp = regexEscape(this.weekdaysShort(mom, ''));
                longp = regexEscape(this.weekdays(mom, ''));
                minPieces.push(minp);
                shortPieces.push(shortp);
                longPieces.push(longp);
                mixedPieces.push(minp);
                mixedPieces.push(shortp);
                mixedPieces.push(longp);
            }
            // Sorting makes sure if one weekday (or abbr) is a prefix of another it
            // will match the longer piece.
            minPieces.sort(cmpLenRev);
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);

            this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._weekdaysShortRegex = this._weekdaysRegex;
            this._weekdaysMinRegex = this._weekdaysRegex;

            this._weekdaysStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._weekdaysShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
            this._weekdaysMinStrictRegex = new RegExp(
                '^(' + minPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        function hFormat() {
            return this.hours() % 12 || 12;
        }

        function kFormat() {
            return this.hours() || 24;
        }

        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);

        addFormatToken('hmm', 0, 0, function () {
            return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });

        addFormatToken('hmmss', 0, 0, function () {
            return (
                '' +
                hFormat.apply(this) +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        addFormatToken('Hmm', 0, 0, function () {
            return '' + this.hours() + zeroFill(this.minutes(), 2);
        });

        addFormatToken('Hmmss', 0, 0, function () {
            return (
                '' +
                this.hours() +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        function meridiem(token, lowercase) {
            addFormatToken(token, 0, 0, function () {
                return this.localeData().meridiem(
                    this.hours(),
                    this.minutes(),
                    lowercase
                );
            });
        }

        meridiem('a', true);
        meridiem('A', false);

        // ALIASES

        addUnitAlias('hour', 'h');

        // PRIORITY
        addUnitPriority('hour', 13);

        // PARSING

        function matchMeridiem(isStrict, locale) {
            return locale._meridiemParse;
        }

        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2);
        addRegexToken('h', match1to2);
        addRegexToken('k', match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);

        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);

        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
            var kInput = toInt(input);
            array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
            config._isPm = config._locale.isPM(input);
            config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
            array[HOUR] = toInt(input);
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
        });

        // LOCALES

        function localeIsPM(input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return (input + '').toLowerCase().charAt(0) === 'p';
        }

        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
            // Setting the hour should keep the time, because the user explicitly
            // specified which hour they want. So trying to maintain the same hour (in
            // a new timezone) makes sense. Adding/subtracting hours does not follow
            // this rule.
            getSetHour = makeGetSet('Hours', true);

        function localeMeridiem(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        }

        var baseConfig = {
            calendar: defaultCalendar,
            longDateFormat: defaultLongDateFormat,
            invalidDate: defaultInvalidDate,
            ordinal: defaultOrdinal,
            dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
            relativeTime: defaultRelativeTime,

            months: defaultLocaleMonths,
            monthsShort: defaultLocaleMonthsShort,

            week: defaultLocaleWeek,

            weekdays: defaultLocaleWeekdays,
            weekdaysMin: defaultLocaleWeekdaysMin,
            weekdaysShort: defaultLocaleWeekdaysShort,

            meridiemParse: defaultLocaleMeridiemParse,
        };

        // internal storage for locale config files
        var locales = {},
            localeFamilies = {},
            globalLocale;

        function commonPrefix(arr1, arr2) {
            var i,
                minl = Math.min(arr1.length, arr2.length);
            for (i = 0; i < minl; i += 1) {
                if (arr1[i] !== arr2[i]) {
                    return i;
                }
            }
            return minl;
        }

        function normalizeLocale(key) {
            return key ? key.toLowerCase().replace('_', '-') : key;
        }

        // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        function chooseLocale(names) {
            var i = 0,
                j,
                next,
                locale,
                split;

            while (i < names.length) {
                split = normalizeLocale(names[i]).split('-');
                j = split.length;
                next = normalizeLocale(names[i + 1]);
                next = next ? next.split('-') : null;
                while (j > 0) {
                    locale = loadLocale(split.slice(0, j).join('-'));
                    if (locale) {
                        return locale;
                    }
                    if (
                        next &&
                        next.length >= j &&
                        commonPrefix(split, next) >= j - 1
                    ) {
                        //the next array item is better than a shallower substring of this one
                        break;
                    }
                    j--;
                }
                i++;
            }
            return globalLocale;
        }

        function loadLocale(name) {
            var oldLocale = null,
                aliasedRequire;
            // TODO: Find a better way to register and load all the locales in Node
            if (
                locales[name] === undefined &&
                'object' !== 'undefined' &&
                module &&
                module.exports
            ) {
                try {
                    oldLocale = globalLocale._abbr;
                    aliasedRequire = commonjsRequire;
                    aliasedRequire('./locale/' + name);
                    getSetGlobalLocale(oldLocale);
                } catch (e) {
                    // mark as not found to avoid repeating expensive file require call causing high CPU
                    // when trying to find en-US, en_US, en-us for every format call
                    locales[name] = null; // null means not found
                }
            }
            return locales[name];
        }

        // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.
        function getSetGlobalLocale(key, values) {
            var data;
            if (key) {
                if (isUndefined(values)) {
                    data = getLocale(key);
                } else {
                    data = defineLocale(key, values);
                }

                if (data) {
                    // moment.duration._locale = moment._locale = data;
                    globalLocale = data;
                } else {
                    if (typeof console !== 'undefined' && console.warn) {
                        //warn user if arguments are passed but the locale could not be set
                        console.warn(
                            'Locale ' + key + ' not found. Did you forget to load it?'
                        );
                    }
                }
            }

            return globalLocale._abbr;
        }

        function defineLocale(name, config) {
            if (config !== null) {
                var locale,
                    parentConfig = baseConfig;
                config.abbr = name;
                if (locales[name] != null) {
                    deprecateSimple(
                        'defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                            'an existing locale. moment.defineLocale(localeName, ' +
                            'config) should only be used for creating a new locale ' +
                            'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                    );
                    parentConfig = locales[name]._config;
                } else if (config.parentLocale != null) {
                    if (locales[config.parentLocale] != null) {
                        parentConfig = locales[config.parentLocale]._config;
                    } else {
                        locale = loadLocale(config.parentLocale);
                        if (locale != null) {
                            parentConfig = locale._config;
                        } else {
                            if (!localeFamilies[config.parentLocale]) {
                                localeFamilies[config.parentLocale] = [];
                            }
                            localeFamilies[config.parentLocale].push({
                                name: name,
                                config: config,
                            });
                            return null;
                        }
                    }
                }
                locales[name] = new Locale(mergeConfigs(parentConfig, config));

                if (localeFamilies[name]) {
                    localeFamilies[name].forEach(function (x) {
                        defineLocale(x.name, x.config);
                    });
                }

                // backwards compat for now: also set the locale
                // make sure we set the locale AFTER all child locales have been
                // created, so we won't end up with the child locale set.
                getSetGlobalLocale(name);

                return locales[name];
            } else {
                // useful for testing
                delete locales[name];
                return null;
            }
        }

        function updateLocale(name, config) {
            if (config != null) {
                var locale,
                    tmpLocale,
                    parentConfig = baseConfig;

                if (locales[name] != null && locales[name].parentLocale != null) {
                    // Update existing child locale in-place to avoid memory-leaks
                    locales[name].set(mergeConfigs(locales[name]._config, config));
                } else {
                    // MERGE
                    tmpLocale = loadLocale(name);
                    if (tmpLocale != null) {
                        parentConfig = tmpLocale._config;
                    }
                    config = mergeConfigs(parentConfig, config);
                    if (tmpLocale == null) {
                        // updateLocale is called for creating a new locale
                        // Set abbr so it will have a name (getters return
                        // undefined otherwise).
                        config.abbr = name;
                    }
                    locale = new Locale(config);
                    locale.parentLocale = locales[name];
                    locales[name] = locale;
                }

                // backwards compat for now: also set the locale
                getSetGlobalLocale(name);
            } else {
                // pass null for config to unupdate, useful for tests
                if (locales[name] != null) {
                    if (locales[name].parentLocale != null) {
                        locales[name] = locales[name].parentLocale;
                        if (name === getSetGlobalLocale()) {
                            getSetGlobalLocale(name);
                        }
                    } else if (locales[name] != null) {
                        delete locales[name];
                    }
                }
            }
            return locales[name];
        }

        // returns locale data
        function getLocale(key) {
            var locale;

            if (key && key._locale && key._locale._abbr) {
                key = key._locale._abbr;
            }

            if (!key) {
                return globalLocale;
            }

            if (!isArray(key)) {
                //short-circuit everything else
                locale = loadLocale(key);
                if (locale) {
                    return locale;
                }
                key = [key];
            }

            return chooseLocale(key);
        }

        function listLocales() {
            return keys(locales);
        }

        function checkOverflow(m) {
            var overflow,
                a = m._a;

            if (a && getParsingFlags(m).overflow === -2) {
                overflow =
                    a[MONTH] < 0 || a[MONTH] > 11
                        ? MONTH
                        : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                        ? DATE
                        : a[HOUR] < 0 ||
                          a[HOUR] > 24 ||
                          (a[HOUR] === 24 &&
                              (a[MINUTE] !== 0 ||
                                  a[SECOND] !== 0 ||
                                  a[MILLISECOND] !== 0))
                        ? HOUR
                        : a[MINUTE] < 0 || a[MINUTE] > 59
                        ? MINUTE
                        : a[SECOND] < 0 || a[SECOND] > 59
                        ? SECOND
                        : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                        ? MILLISECOND
                        : -1;

                if (
                    getParsingFlags(m)._overflowDayOfYear &&
                    (overflow < YEAR || overflow > DATE)
                ) {
                    overflow = DATE;
                }
                if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                    overflow = WEEK;
                }
                if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                    overflow = WEEKDAY;
                }

                getParsingFlags(m).overflow = overflow;
            }

            return m;
        }

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
            isoDates = [
                ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
                ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
                ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
                ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
                ['YYYY-DDD', /\d{4}-\d{3}/],
                ['YYYY-MM', /\d{4}-\d\d/, false],
                ['YYYYYYMMDD', /[+-]\d{10}/],
                ['YYYYMMDD', /\d{8}/],
                ['GGGG[W]WWE', /\d{4}W\d{3}/],
                ['GGGG[W]WW', /\d{4}W\d{2}/, false],
                ['YYYYDDD', /\d{7}/],
                ['YYYYMM', /\d{6}/, false],
                ['YYYY', /\d{4}/, false],
            ],
            // iso time formats and regexes
            isoTimes = [
                ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
                ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
                ['HH:mm:ss', /\d\d:\d\d:\d\d/],
                ['HH:mm', /\d\d:\d\d/],
                ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
                ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
                ['HHmmss', /\d\d\d\d\d\d/],
                ['HHmm', /\d\d\d\d/],
                ['HH', /\d\d/],
            ],
            aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
            // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
            rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
            obsOffsets = {
                UT: 0,
                GMT: 0,
                EDT: -4 * 60,
                EST: -5 * 60,
                CDT: -5 * 60,
                CST: -6 * 60,
                MDT: -6 * 60,
                MST: -7 * 60,
                PDT: -7 * 60,
                PST: -8 * 60,
            };

        // date from iso format
        function configFromISO(config) {
            var i,
                l,
                string = config._i,
                match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                allowTime,
                dateFormat,
                timeFormat,
                tzFormat;

            if (match) {
                getParsingFlags(config).iso = true;

                for (i = 0, l = isoDates.length; i < l; i++) {
                    if (isoDates[i][1].exec(match[1])) {
                        dateFormat = isoDates[i][0];
                        allowTime = isoDates[i][2] !== false;
                        break;
                    }
                }
                if (dateFormat == null) {
                    config._isValid = false;
                    return;
                }
                if (match[3]) {
                    for (i = 0, l = isoTimes.length; i < l; i++) {
                        if (isoTimes[i][1].exec(match[3])) {
                            // match[2] should be 'T' or space
                            timeFormat = (match[2] || ' ') + isoTimes[i][0];
                            break;
                        }
                    }
                    if (timeFormat == null) {
                        config._isValid = false;
                        return;
                    }
                }
                if (!allowTime && timeFormat != null) {
                    config._isValid = false;
                    return;
                }
                if (match[4]) {
                    if (tzRegex.exec(match[4])) {
                        tzFormat = 'Z';
                    } else {
                        config._isValid = false;
                        return;
                    }
                }
                config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                configFromStringAndFormat(config);
            } else {
                config._isValid = false;
            }
        }

        function extractFromRFC2822Strings(
            yearStr,
            monthStr,
            dayStr,
            hourStr,
            minuteStr,
            secondStr
        ) {
            var result = [
                untruncateYear(yearStr),
                defaultLocaleMonthsShort.indexOf(monthStr),
                parseInt(dayStr, 10),
                parseInt(hourStr, 10),
                parseInt(minuteStr, 10),
            ];

            if (secondStr) {
                result.push(parseInt(secondStr, 10));
            }

            return result;
        }

        function untruncateYear(yearStr) {
            var year = parseInt(yearStr, 10);
            if (year <= 49) {
                return 2000 + year;
            } else if (year <= 999) {
                return 1900 + year;
            }
            return year;
        }

        function preprocessRFC2822(s) {
            // Remove comments and folding whitespace and replace multiple-spaces with a single space
            return s
                .replace(/\([^)]*\)|[\n\t]/g, ' ')
                .replace(/(\s\s+)/g, ' ')
                .replace(/^\s\s*/, '')
                .replace(/\s\s*$/, '');
        }

        function checkWeekday(weekdayStr, parsedInput, config) {
            if (weekdayStr) {
                // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
                var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                    weekdayActual = new Date(
                        parsedInput[0],
                        parsedInput[1],
                        parsedInput[2]
                    ).getDay();
                if (weekdayProvided !== weekdayActual) {
                    getParsingFlags(config).weekdayMismatch = true;
                    config._isValid = false;
                    return false;
                }
            }
            return true;
        }

        function calculateOffset(obsOffset, militaryOffset, numOffset) {
            if (obsOffset) {
                return obsOffsets[obsOffset];
            } else if (militaryOffset) {
                // the only allowed military tz is Z
                return 0;
            } else {
                var hm = parseInt(numOffset, 10),
                    m = hm % 100,
                    h = (hm - m) / 100;
                return h * 60 + m;
            }
        }

        // date and time from ref 2822 format
        function configFromRFC2822(config) {
            var match = rfc2822.exec(preprocessRFC2822(config._i)),
                parsedArray;
            if (match) {
                parsedArray = extractFromRFC2822Strings(
                    match[4],
                    match[3],
                    match[2],
                    match[5],
                    match[6],
                    match[7]
                );
                if (!checkWeekday(match[1], parsedArray, config)) {
                    return;
                }

                config._a = parsedArray;
                config._tzm = calculateOffset(match[8], match[9], match[10]);

                config._d = createUTCDate.apply(null, config._a);
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

                getParsingFlags(config).rfc2822 = true;
            } else {
                config._isValid = false;
            }
        }

        // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
        function configFromString(config) {
            var matched = aspNetJsonRegex.exec(config._i);
            if (matched !== null) {
                config._d = new Date(+matched[1]);
                return;
            }

            configFromISO(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            configFromRFC2822(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            if (config._strict) {
                config._isValid = false;
            } else {
                // Final attempt, use Input Fallback
                hooks.createFromInputFallback(config);
            }
        }

        hooks.createFromInputFallback = deprecate(
            'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
                'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
                'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
            function (config) {
                config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
            }
        );

        // Pick the first defined of two or three arguments.
        function defaults(a, b, c) {
            if (a != null) {
                return a;
            }
            if (b != null) {
                return b;
            }
            return c;
        }

        function currentDateArray(config) {
            // hooks is actually the exported moment object
            var nowValue = new Date(hooks.now());
            if (config._useUTC) {
                return [
                    nowValue.getUTCFullYear(),
                    nowValue.getUTCMonth(),
                    nowValue.getUTCDate(),
                ];
            }
            return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }

        // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]
        function configFromArray(config) {
            var i,
                date,
                input = [],
                currentDate,
                expectedWeekday,
                yearToUse;

            if (config._d) {
                return;
            }

            currentDate = currentDateArray(config);

            //compute day of the year from weeks and weekdays
            if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                dayOfYearFromWeekInfo(config);
            }

            //if the day of the year is set, figure out what it is
            if (config._dayOfYear != null) {
                yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

                if (
                    config._dayOfYear > daysInYear(yearToUse) ||
                    config._dayOfYear === 0
                ) {
                    getParsingFlags(config)._overflowDayOfYear = true;
                }

                date = createUTCDate(yearToUse, 0, config._dayOfYear);
                config._a[MONTH] = date.getUTCMonth();
                config._a[DATE] = date.getUTCDate();
            }

            // Default to current date.
            // * if no year, month, day of month are given, default to today
            // * if day of month is given, default month and year
            // * if month is given, default only year
            // * if year is given, don't default anything
            for (i = 0; i < 3 && config._a[i] == null; ++i) {
                config._a[i] = input[i] = currentDate[i];
            }

            // Zero out whatever was not defaulted, including time
            for (; i < 7; i++) {
                config._a[i] = input[i] =
                    config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
            }

            // Check for 24:00:00.000
            if (
                config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0
            ) {
                config._nextDay = true;
                config._a[HOUR] = 0;
            }

            config._d = (config._useUTC ? createUTCDate : createDate).apply(
                null,
                input
            );
            expectedWeekday = config._useUTC
                ? config._d.getUTCDay()
                : config._d.getDay();

            // Apply timezone offset from input. The actual utcOffset can be changed
            // with parseZone.
            if (config._tzm != null) {
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            }

            if (config._nextDay) {
                config._a[HOUR] = 24;
            }

            // check for mismatching day of week
            if (
                config._w &&
                typeof config._w.d !== 'undefined' &&
                config._w.d !== expectedWeekday
            ) {
                getParsingFlags(config).weekdayMismatch = true;
            }
        }

        function dayOfYearFromWeekInfo(config) {
            var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                dow = 1;
                doy = 4;

                // TODO: We need to take the current isoWeekYear, but that depends on
                // how we interpret now (local, utc, fixed offset). So create
                // a now version of current config (take local/utc/offset flags, and
                // create now).
                weekYear = defaults(
                    w.GG,
                    config._a[YEAR],
                    weekOfYear(createLocal(), 1, 4).year
                );
                week = defaults(w.W, 1);
                weekday = defaults(w.E, 1);
                if (weekday < 1 || weekday > 7) {
                    weekdayOverflow = true;
                }
            } else {
                dow = config._locale._week.dow;
                doy = config._locale._week.doy;

                curWeek = weekOfYear(createLocal(), dow, doy);

                weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

                // Default to current week.
                week = defaults(w.w, curWeek.week);

                if (w.d != null) {
                    // weekday -- low day numbers are considered next week
                    weekday = w.d;
                    if (weekday < 0 || weekday > 6) {
                        weekdayOverflow = true;
                    }
                } else if (w.e != null) {
                    // local weekday -- counting starts from beginning of week
                    weekday = w.e + dow;
                    if (w.e < 0 || w.e > 6) {
                        weekdayOverflow = true;
                    }
                } else {
                    // default to beginning of week
                    weekday = dow;
                }
            }
            if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                getParsingFlags(config)._overflowWeeks = true;
            } else if (weekdayOverflow != null) {
                getParsingFlags(config)._overflowWeekday = true;
            } else {
                temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                config._a[YEAR] = temp.year;
                config._dayOfYear = temp.dayOfYear;
            }
        }

        // constant that refers to the ISO standard
        hooks.ISO_8601 = function () {};

        // constant that refers to the RFC 2822 form
        hooks.RFC_2822 = function () {};

        // date from string and format string
        function configFromStringAndFormat(config) {
            // TODO: Move this to another part of the creation flow to prevent circular deps
            if (config._f === hooks.ISO_8601) {
                configFromISO(config);
                return;
            }
            if (config._f === hooks.RFC_2822) {
                configFromRFC2822(config);
                return;
            }
            config._a = [];
            getParsingFlags(config).empty = true;

            // This array is used to make a Date, either with `new Date` or `Date.UTC`
            var string = '' + config._i,
                i,
                parsedInput,
                tokens,
                token,
                skipped,
                stringLength = string.length,
                totalParsedInputLength = 0,
                era;

            tokens =
                expandFormat(config._f, config._locale).match(formattingTokens) || [];

            for (i = 0; i < tokens.length; i++) {
                token = tokens[i];
                parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                    [])[0];
                if (parsedInput) {
                    skipped = string.substr(0, string.indexOf(parsedInput));
                    if (skipped.length > 0) {
                        getParsingFlags(config).unusedInput.push(skipped);
                    }
                    string = string.slice(
                        string.indexOf(parsedInput) + parsedInput.length
                    );
                    totalParsedInputLength += parsedInput.length;
                }
                // don't parse if it's not a known token
                if (formatTokenFunctions[token]) {
                    if (parsedInput) {
                        getParsingFlags(config).empty = false;
                    } else {
                        getParsingFlags(config).unusedTokens.push(token);
                    }
                    addTimeToArrayFromToken(token, parsedInput, config);
                } else if (config._strict && !parsedInput) {
                    getParsingFlags(config).unusedTokens.push(token);
                }
            }

            // add remaining unparsed input length to the string
            getParsingFlags(config).charsLeftOver =
                stringLength - totalParsedInputLength;
            if (string.length > 0) {
                getParsingFlags(config).unusedInput.push(string);
            }

            // clear _12h flag if hour is <= 12
            if (
                config._a[HOUR] <= 12 &&
                getParsingFlags(config).bigHour === true &&
                config._a[HOUR] > 0
            ) {
                getParsingFlags(config).bigHour = undefined;
            }

            getParsingFlags(config).parsedDateParts = config._a.slice(0);
            getParsingFlags(config).meridiem = config._meridiem;
            // handle meridiem
            config._a[HOUR] = meridiemFixWrap(
                config._locale,
                config._a[HOUR],
                config._meridiem
            );

            // handle era
            era = getParsingFlags(config).era;
            if (era !== null) {
                config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
            }

            configFromArray(config);
            checkOverflow(config);
        }

        function meridiemFixWrap(locale, hour, meridiem) {
            var isPm;

            if (meridiem == null) {
                // nothing to do
                return hour;
            }
            if (locale.meridiemHour != null) {
                return locale.meridiemHour(hour, meridiem);
            } else if (locale.isPM != null) {
                // Fallback
                isPm = locale.isPM(meridiem);
                if (isPm && hour < 12) {
                    hour += 12;
                }
                if (!isPm && hour === 12) {
                    hour = 0;
                }
                return hour;
            } else {
                // this is not supposed to happen
                return hour;
            }
        }

        // date from string and array of format strings
        function configFromStringAndArray(config) {
            var tempConfig,
                bestMoment,
                scoreToBeat,
                i,
                currentScore,
                validFormatFound,
                bestFormatIsValid = false;

            if (config._f.length === 0) {
                getParsingFlags(config).invalidFormat = true;
                config._d = new Date(NaN);
                return;
            }

            for (i = 0; i < config._f.length; i++) {
                currentScore = 0;
                validFormatFound = false;
                tempConfig = copyConfig({}, config);
                if (config._useUTC != null) {
                    tempConfig._useUTC = config._useUTC;
                }
                tempConfig._f = config._f[i];
                configFromStringAndFormat(tempConfig);

                if (isValid(tempConfig)) {
                    validFormatFound = true;
                }

                // if there is any input that was not parsed add a penalty for that format
                currentScore += getParsingFlags(tempConfig).charsLeftOver;

                //or tokens
                currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

                getParsingFlags(tempConfig).score = currentScore;

                if (!bestFormatIsValid) {
                    if (
                        scoreToBeat == null ||
                        currentScore < scoreToBeat ||
                        validFormatFound
                    ) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                        if (validFormatFound) {
                            bestFormatIsValid = true;
                        }
                    }
                } else {
                    if (currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                    }
                }
            }

            extend(config, bestMoment || tempConfig);
        }

        function configFromObject(config) {
            if (config._d) {
                return;
            }

            var i = normalizeObjectUnits(config._i),
                dayOrDate = i.day === undefined ? i.date : i.day;
            config._a = map(
                [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
                function (obj) {
                    return obj && parseInt(obj, 10);
                }
            );

            configFromArray(config);
        }

        function createFromConfig(config) {
            var res = new Moment(checkOverflow(prepareConfig(config)));
            if (res._nextDay) {
                // Adding is smart enough around DST
                res.add(1, 'd');
                res._nextDay = undefined;
            }

            return res;
        }

        function prepareConfig(config) {
            var input = config._i,
                format = config._f;

            config._locale = config._locale || getLocale(config._l);

            if (input === null || (format === undefined && input === '')) {
                return createInvalid({ nullInput: true });
            }

            if (typeof input === 'string') {
                config._i = input = config._locale.preparse(input);
            }

            if (isMoment(input)) {
                return new Moment(checkOverflow(input));
            } else if (isDate(input)) {
                config._d = input;
            } else if (isArray(format)) {
                configFromStringAndArray(config);
            } else if (format) {
                configFromStringAndFormat(config);
            } else {
                configFromInput(config);
            }

            if (!isValid(config)) {
                config._d = null;
            }

            return config;
        }

        function configFromInput(config) {
            var input = config._i;
            if (isUndefined(input)) {
                config._d = new Date(hooks.now());
            } else if (isDate(input)) {
                config._d = new Date(input.valueOf());
            } else if (typeof input === 'string') {
                configFromString(config);
            } else if (isArray(input)) {
                config._a = map(input.slice(0), function (obj) {
                    return parseInt(obj, 10);
                });
                configFromArray(config);
            } else if (isObject(input)) {
                configFromObject(config);
            } else if (isNumber(input)) {
                // from milliseconds
                config._d = new Date(input);
            } else {
                hooks.createFromInputFallback(config);
            }
        }

        function createLocalOrUTC(input, format, locale, strict, isUTC) {
            var c = {};

            if (format === true || format === false) {
                strict = format;
                format = undefined;
            }

            if (locale === true || locale === false) {
                strict = locale;
                locale = undefined;
            }

            if (
                (isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)
            ) {
                input = undefined;
            }
            // object construction must be done this way.
            // https://github.com/moment/moment/issues/1423
            c._isAMomentObject = true;
            c._useUTC = c._isUTC = isUTC;
            c._l = locale;
            c._i = input;
            c._f = format;
            c._strict = strict;

            return createFromConfig(c);
        }

        function createLocal(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, false);
        }

        var prototypeMin = deprecate(
                'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other < this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            ),
            prototypeMax = deprecate(
                'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other > this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            );

        // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.
        function pickBy(fn, moments) {
            var res, i;
            if (moments.length === 1 && isArray(moments[0])) {
                moments = moments[0];
            }
            if (!moments.length) {
                return createLocal();
            }
            res = moments[0];
            for (i = 1; i < moments.length; ++i) {
                if (!moments[i].isValid() || moments[i][fn](res)) {
                    res = moments[i];
                }
            }
            return res;
        }

        // TODO: Use [].sort instead?
        function min() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isBefore', args);
        }

        function max() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isAfter', args);
        }

        var now = function () {
            return Date.now ? Date.now() : +new Date();
        };

        var ordering = [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
        ];

        function isDurationValid(m) {
            var key,
                unitHasDecimal = false,
                i;
            for (key in m) {
                if (
                    hasOwnProp(m, key) &&
                    !(
                        indexOf.call(ordering, key) !== -1 &&
                        (m[key] == null || !isNaN(m[key]))
                    )
                ) {
                    return false;
                }
            }

            for (i = 0; i < ordering.length; ++i) {
                if (m[ordering[i]]) {
                    if (unitHasDecimal) {
                        return false; // only allow non-integers for smallest unit
                    }
                    if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                        unitHasDecimal = true;
                    }
                }
            }

            return true;
        }

        function isValid$1() {
            return this._isValid;
        }

        function createInvalid$1() {
            return createDuration(NaN);
        }

        function Duration(duration) {
            var normalizedInput = normalizeObjectUnits(duration),
                years = normalizedInput.year || 0,
                quarters = normalizedInput.quarter || 0,
                months = normalizedInput.month || 0,
                weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
                days = normalizedInput.day || 0,
                hours = normalizedInput.hour || 0,
                minutes = normalizedInput.minute || 0,
                seconds = normalizedInput.second || 0,
                milliseconds = normalizedInput.millisecond || 0;

            this._isValid = isDurationValid(normalizedInput);

            // representation for dateAddRemove
            this._milliseconds =
                +milliseconds +
                seconds * 1e3 + // 1000
                minutes * 6e4 + // 1000 * 60
                hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
            // Because of dateAddRemove treats 24 hours as different from a
            // day when working around DST, we need to store them separately
            this._days = +days + weeks * 7;
            // It is impossible to translate months into days without knowing
            // which months you are are talking about, so we have to store
            // it separately.
            this._months = +months + quarters * 3 + years * 12;

            this._data = {};

            this._locale = getLocale();

            this._bubble();
        }

        function isDuration(obj) {
            return obj instanceof Duration;
        }

        function absRound(number) {
            if (number < 0) {
                return Math.round(-1 * number) * -1;
            } else {
                return Math.round(number);
            }
        }

        // compare two arrays, return the number of differences
        function compareArrays(array1, array2, dontConvert) {
            var len = Math.min(array1.length, array2.length),
                lengthDiff = Math.abs(array1.length - array2.length),
                diffs = 0,
                i;
            for (i = 0; i < len; i++) {
                if (
                    (dontConvert && array1[i] !== array2[i]) ||
                    (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
                ) {
                    diffs++;
                }
            }
            return diffs + lengthDiff;
        }

        // FORMATTING

        function offset(token, separator) {
            addFormatToken(token, 0, 0, function () {
                var offset = this.utcOffset(),
                    sign = '+';
                if (offset < 0) {
                    offset = -offset;
                    sign = '-';
                }
                return (
                    sign +
                    zeroFill(~~(offset / 60), 2) +
                    separator +
                    zeroFill(~~offset % 60, 2)
                );
            });
        }

        offset('Z', ':');
        offset('ZZ', '');

        // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
            config._useUTC = true;
            config._tzm = offsetFromString(matchShortOffset, input);
        });

        // HELPERS

        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']
        var chunkOffset = /([\+\-]|\d\d)/gi;

        function offsetFromString(matcher, string) {
            var matches = (string || '').match(matcher),
                chunk,
                parts,
                minutes;

            if (matches === null) {
                return null;
            }

            chunk = matches[matches.length - 1] || [];
            parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
            minutes = +(parts[1] * 60) + toInt(parts[2]);

            return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        }

        // Return a moment from input, that is local/utc/zone equivalent to model.
        function cloneWithOffset(input, model) {
            var res, diff;
            if (model._isUTC) {
                res = model.clone();
                diff =
                    (isMoment(input) || isDate(input)
                        ? input.valueOf()
                        : createLocal(input).valueOf()) - res.valueOf();
                // Use low-level api, because this fn is low-level api.
                res._d.setTime(res._d.valueOf() + diff);
                hooks.updateOffset(res, false);
                return res;
            } else {
                return createLocal(input).local();
            }
        }

        function getDateOffset(m) {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return -Math.round(m._d.getTimezoneOffset());
        }

        // HOOKS

        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.
        hooks.updateOffset = function () {};

        // MOMENTS

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        function getSetOffset(input, keepLocalTime, keepMinutes) {
            var offset = this._offset || 0,
                localAdjust;
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            if (input != null) {
                if (typeof input === 'string') {
                    input = offsetFromString(matchShortOffset, input);
                    if (input === null) {
                        return this;
                    }
                } else if (Math.abs(input) < 16 && !keepMinutes) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = getDateOffset(this);
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.add(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addSubtract(
                            this,
                            createDuration(input - offset, 'm'),
                            1,
                            false
                        );
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        hooks.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
                return this;
            } else {
                return this._isUTC ? offset : getDateOffset(this);
            }
        }

        function getSetZone(input, keepLocalTime) {
            if (input != null) {
                if (typeof input !== 'string') {
                    input = -input;
                }

                this.utcOffset(input, keepLocalTime);

                return this;
            } else {
                return -this.utcOffset();
            }
        }

        function setOffsetToUTC(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        }

        function setOffsetToLocal(keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.subtract(getDateOffset(this), 'm');
                }
            }
            return this;
        }

        function setOffsetToParsedOffset() {
            if (this._tzm != null) {
                this.utcOffset(this._tzm, false, true);
            } else if (typeof this._i === 'string') {
                var tZone = offsetFromString(matchOffset, this._i);
                if (tZone != null) {
                    this.utcOffset(tZone);
                } else {
                    this.utcOffset(0, true);
                }
            }
            return this;
        }

        function hasAlignedHourOffset(input) {
            if (!this.isValid()) {
                return false;
            }
            input = input ? createLocal(input).utcOffset() : 0;

            return (this.utcOffset() - input) % 60 === 0;
        }

        function isDaylightSavingTime() {
            return (
                this.utcOffset() > this.clone().month(0).utcOffset() ||
                this.utcOffset() > this.clone().month(5).utcOffset()
            );
        }

        function isDaylightSavingTimeShifted() {
            if (!isUndefined(this._isDSTShifted)) {
                return this._isDSTShifted;
            }

            var c = {},
                other;

            copyConfig(c, this);
            c = prepareConfig(c);

            if (c._a) {
                other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                this._isDSTShifted =
                    this.isValid() && compareArrays(c._a, other.toArray()) > 0;
            } else {
                this._isDSTShifted = false;
            }

            return this._isDSTShifted;
        }

        function isLocal() {
            return this.isValid() ? !this._isUTC : false;
        }

        function isUtcOffset() {
            return this.isValid() ? this._isUTC : false;
        }

        function isUtc() {
            return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }

        // ASP.NET json date format regex
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
            // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
            // and further modified to allow for strings containing both week and day
            isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

        function createDuration(input, key) {
            var duration = input,
                // matching against regexp is expensive, do it on demand
                match = null,
                sign,
                ret,
                diffRes;

            if (isDuration(input)) {
                duration = {
                    ms: input._milliseconds,
                    d: input._days,
                    M: input._months,
                };
            } else if (isNumber(input) || !isNaN(+input)) {
                duration = {};
                if (key) {
                    duration[key] = +input;
                } else {
                    duration.milliseconds = +input;
                }
            } else if ((match = aspNetRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: 0,
                    d: toInt(match[DATE]) * sign,
                    h: toInt(match[HOUR]) * sign,
                    m: toInt(match[MINUTE]) * sign,
                    s: toInt(match[SECOND]) * sign,
                    ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
                };
            } else if ((match = isoRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: parseIso(match[2], sign),
                    M: parseIso(match[3], sign),
                    w: parseIso(match[4], sign),
                    d: parseIso(match[5], sign),
                    h: parseIso(match[6], sign),
                    m: parseIso(match[7], sign),
                    s: parseIso(match[8], sign),
                };
            } else if (duration == null) {
                // checks for null or undefined
                duration = {};
            } else if (
                typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)
            ) {
                diffRes = momentsDifference(
                    createLocal(duration.from),
                    createLocal(duration.to)
                );

                duration = {};
                duration.ms = diffRes.milliseconds;
                duration.M = diffRes.months;
            }

            ret = new Duration(duration);

            if (isDuration(input) && hasOwnProp(input, '_locale')) {
                ret._locale = input._locale;
            }

            if (isDuration(input) && hasOwnProp(input, '_isValid')) {
                ret._isValid = input._isValid;
            }

            return ret;
        }

        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;

        function parseIso(inp, sign) {
            // We'd normally use ~~inp for this, but unfortunately it also
            // converts floats to ints.
            // inp may be undefined, so careful calling replace on it.
            var res = inp && parseFloat(inp.replace(',', '.'));
            // apply sign while we're at it
            return (isNaN(res) ? 0 : res) * sign;
        }

        function positiveMomentsDifference(base, other) {
            var res = {};

            res.months =
                other.month() - base.month() + (other.year() - base.year()) * 12;
            if (base.clone().add(res.months, 'M').isAfter(other)) {
                --res.months;
            }

            res.milliseconds = +other - +base.clone().add(res.months, 'M');

            return res;
        }

        function momentsDifference(base, other) {
            var res;
            if (!(base.isValid() && other.isValid())) {
                return { milliseconds: 0, months: 0 };
            }

            other = cloneWithOffset(other, base);
            if (base.isBefore(other)) {
                res = positiveMomentsDifference(base, other);
            } else {
                res = positiveMomentsDifference(other, base);
                res.milliseconds = -res.milliseconds;
                res.months = -res.months;
            }

            return res;
        }

        // TODO: remove 'name' arg after deprecation is removed
        function createAdder(direction, name) {
            return function (val, period) {
                var dur, tmp;
                //invert the arguments, but complain about it
                if (period !== null && !isNaN(+period)) {
                    deprecateSimple(
                        name,
                        'moment().' +
                            name +
                            '(period, number) is deprecated. Please use moment().' +
                            name +
                            '(number, period). ' +
                            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                    );
                    tmp = val;
                    val = period;
                    period = tmp;
                }

                dur = createDuration(val, period);
                addSubtract(this, dur, direction);
                return this;
            };
        }

        function addSubtract(mom, duration, isAdding, updateOffset) {
            var milliseconds = duration._milliseconds,
                days = absRound(duration._days),
                months = absRound(duration._months);

            if (!mom.isValid()) {
                // No op
                return;
            }

            updateOffset = updateOffset == null ? true : updateOffset;

            if (months) {
                setMonth(mom, get(mom, 'Month') + months * isAdding);
            }
            if (days) {
                set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
            }
            if (milliseconds) {
                mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
            }
            if (updateOffset) {
                hooks.updateOffset(mom, days || months);
            }
        }

        var add = createAdder(1, 'add'),
            subtract = createAdder(-1, 'subtract');

        function isString(input) {
            return typeof input === 'string' || input instanceof String;
        }

        // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
        function isMomentInput(input) {
            return (
                isMoment(input) ||
                isDate(input) ||
                isString(input) ||
                isNumber(input) ||
                isNumberOrStringArray(input) ||
                isMomentInputObject(input) ||
                input === null ||
                input === undefined
            );
        }

        function isMomentInputObject(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'years',
                    'year',
                    'y',
                    'months',
                    'month',
                    'M',
                    'days',
                    'day',
                    'd',
                    'dates',
                    'date',
                    'D',
                    'hours',
                    'hour',
                    'h',
                    'minutes',
                    'minute',
                    'm',
                    'seconds',
                    'second',
                    's',
                    'milliseconds',
                    'millisecond',
                    'ms',
                ],
                i,
                property;

            for (i = 0; i < properties.length; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function isNumberOrStringArray(input) {
            var arrayTest = isArray(input),
                dataTypeTest = false;
            if (arrayTest) {
                dataTypeTest =
                    input.filter(function (item) {
                        return !isNumber(item) && isString(input);
                    }).length === 0;
            }
            return arrayTest && dataTypeTest;
        }

        function isCalendarSpec(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'sameDay',
                    'nextDay',
                    'lastDay',
                    'nextWeek',
                    'lastWeek',
                    'sameElse',
                ],
                i,
                property;

            for (i = 0; i < properties.length; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function getCalendarFormat(myMoment, now) {
            var diff = myMoment.diff(now, 'days', true);
            return diff < -6
                ? 'sameElse'
                : diff < -1
                ? 'lastWeek'
                : diff < 0
                ? 'lastDay'
                : diff < 1
                ? 'sameDay'
                : diff < 2
                ? 'nextDay'
                : diff < 7
                ? 'nextWeek'
                : 'sameElse';
        }

        function calendar$1(time, formats) {
            // Support for single parameter, formats only overload to the calendar function
            if (arguments.length === 1) {
                if (!arguments[0]) {
                    time = undefined;
                    formats = undefined;
                } else if (isMomentInput(arguments[0])) {
                    time = arguments[0];
                    formats = undefined;
                } else if (isCalendarSpec(arguments[0])) {
                    formats = arguments[0];
                    time = undefined;
                }
            }
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're local/utc/offset or not.
            var now = time || createLocal(),
                sod = cloneWithOffset(now, this).startOf('day'),
                format = hooks.calendarFormat(this, sod) || 'sameElse',
                output =
                    formats &&
                    (isFunction(formats[format])
                        ? formats[format].call(this, now)
                        : formats[format]);

            return this.format(
                output || this.localeData().calendar(format, this, createLocal(now))
            );
        }

        function clone() {
            return new Moment(this);
        }

        function isAfter(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() > localInput.valueOf();
            } else {
                return localInput.valueOf() < this.clone().startOf(units).valueOf();
            }
        }

        function isBefore(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() < localInput.valueOf();
            } else {
                return this.clone().endOf(units).valueOf() < localInput.valueOf();
            }
        }

        function isBetween(from, to, units, inclusivity) {
            var localFrom = isMoment(from) ? from : createLocal(from),
                localTo = isMoment(to) ? to : createLocal(to);
            if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
                return false;
            }
            inclusivity = inclusivity || '()';
            return (
                (inclusivity[0] === '('
                    ? this.isAfter(localFrom, units)
                    : !this.isBefore(localFrom, units)) &&
                (inclusivity[1] === ')'
                    ? this.isBefore(localTo, units)
                    : !this.isAfter(localTo, units))
            );
        }

        function isSame(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input),
                inputMs;
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() === localInput.valueOf();
            } else {
                inputMs = localInput.valueOf();
                return (
                    this.clone().startOf(units).valueOf() <= inputMs &&
                    inputMs <= this.clone().endOf(units).valueOf()
                );
            }
        }

        function isSameOrAfter(input, units) {
            return this.isSame(input, units) || this.isAfter(input, units);
        }

        function isSameOrBefore(input, units) {
            return this.isSame(input, units) || this.isBefore(input, units);
        }

        function diff(input, units, asFloat) {
            var that, zoneDelta, output;

            if (!this.isValid()) {
                return NaN;
            }

            that = cloneWithOffset(input, this);

            if (!that.isValid()) {
                return NaN;
            }

            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

            units = normalizeUnits(units);

            switch (units) {
                case 'year':
                    output = monthDiff(this, that) / 12;
                    break;
                case 'month':
                    output = monthDiff(this, that);
                    break;
                case 'quarter':
                    output = monthDiff(this, that) / 3;
                    break;
                case 'second':
                    output = (this - that) / 1e3;
                    break; // 1000
                case 'minute':
                    output = (this - that) / 6e4;
                    break; // 1000 * 60
                case 'hour':
                    output = (this - that) / 36e5;
                    break; // 1000 * 60 * 60
                case 'day':
                    output = (this - that - zoneDelta) / 864e5;
                    break; // 1000 * 60 * 60 * 24, negate dst
                case 'week':
                    output = (this - that - zoneDelta) / 6048e5;
                    break; // 1000 * 60 * 60 * 24 * 7, negate dst
                default:
                    output = this - that;
            }

            return asFloat ? output : absFloor(output);
        }

        function monthDiff(a, b) {
            if (a.date() < b.date()) {
                // end-of-month calculations work correct when the start month has more
                // days than the end month.
                return -monthDiff(b, a);
            }
            // difference in months
            var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
                // b is in (anchor - 1 month, anchor + 1 month)
                anchor = a.clone().add(wholeMonthDiff, 'months'),
                anchor2,
                adjust;

            if (b - anchor < 0) {
                anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor - anchor2);
            } else {
                anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor2 - anchor);
            }

            //check for negative zero, return zero if negative zero
            return -(wholeMonthDiff + adjust) || 0;
        }

        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

        function toString() {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }

        function toISOString(keepOffset) {
            if (!this.isValid()) {
                return null;
            }
            var utc = keepOffset !== true,
                m = utc ? this.clone().utc() : this;
            if (m.year() < 0 || m.year() > 9999) {
                return formatMoment(
                    m,
                    utc
                        ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                        : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
                );
            }
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                if (utc) {
                    return this.toDate().toISOString();
                } else {
                    return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                        .toISOString()
                        .replace('Z', formatMoment(m, 'Z'));
                }
            }
            return formatMoment(
                m,
                utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }

        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */
        function inspect() {
            if (!this.isValid()) {
                return 'moment.invalid(/* ' + this._i + ' */)';
            }
            var func = 'moment',
                zone = '',
                prefix,
                year,
                datetime,
                suffix;
            if (!this.isLocal()) {
                func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
                zone = 'Z';
            }
            prefix = '[' + func + '("]';
            year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
            datetime = '-MM-DD[T]HH:mm:ss.SSS';
            suffix = zone + '[")]';

            return this.format(prefix + year + datetime + suffix);
        }

        function format(inputString) {
            if (!inputString) {
                inputString = this.isUtc()
                    ? hooks.defaultFormatUtc
                    : hooks.defaultFormat;
            }
            var output = formatMoment(this, inputString);
            return this.localeData().postformat(output);
        }

        function from(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ to: this, from: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function fromNow(withoutSuffix) {
            return this.from(createLocal(), withoutSuffix);
        }

        function to(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ from: this, to: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function toNow(withoutSuffix) {
            return this.to(createLocal(), withoutSuffix);
        }

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        function locale(key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = getLocale(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        }

        var lang = deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        );

        function localeData() {
            return this._locale;
        }

        var MS_PER_SECOND = 1000,
            MS_PER_MINUTE = 60 * MS_PER_SECOND,
            MS_PER_HOUR = 60 * MS_PER_MINUTE,
            MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

        // actual modulo - handles negative numbers (for dates before 1970):
        function mod$1(dividend, divisor) {
            return ((dividend % divisor) + divisor) % divisor;
        }

        function localStartOfDate(y, m, d) {
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return new Date(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return new Date(y, m, d).valueOf();
            }
        }

        function utcStartOfDate(y, m, d) {
            // Date.UTC remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return Date.UTC(y, m, d);
            }
        }

        function startOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year(), 0, 1);
                    break;
                case 'quarter':
                    time = startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3),
                        1
                    );
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month(), 1);
                    break;
                case 'week':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday()
                    );
                    break;
                case 'isoWeek':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1)
                    );
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date());
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time -= mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    );
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_MINUTE);
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_SECOND);
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function endOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year() + 1, 0, 1) - 1;
                    break;
                case 'quarter':
                    time =
                        startOfDate(
                            this.year(),
                            this.month() - (this.month() % 3) + 3,
                            1
                        ) - 1;
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                    break;
                case 'week':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - this.weekday() + 7
                        ) - 1;
                    break;
                case 'isoWeek':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - (this.isoWeekday() - 1) + 7
                        ) - 1;
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time +=
                        MS_PER_HOUR -
                        mod$1(
                            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                            MS_PER_HOUR
                        ) -
                        1;
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function valueOf() {
            return this._d.valueOf() - (this._offset || 0) * 60000;
        }

        function unix() {
            return Math.floor(this.valueOf() / 1000);
        }

        function toDate() {
            return new Date(this.valueOf());
        }

        function toArray() {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hour(),
                m.minute(),
                m.second(),
                m.millisecond(),
            ];
        }

        function toObject() {
            var m = this;
            return {
                years: m.year(),
                months: m.month(),
                date: m.date(),
                hours: m.hours(),
                minutes: m.minutes(),
                seconds: m.seconds(),
                milliseconds: m.milliseconds(),
            };
        }

        function toJSON() {
            // new Date(NaN).toJSON() === null
            return this.isValid() ? this.toISOString() : null;
        }

        function isValid$2() {
            return isValid(this);
        }

        function parsingFlags() {
            return extend({}, getParsingFlags(this));
        }

        function invalidAt() {
            return getParsingFlags(this).overflow;
        }

        function creationData() {
            return {
                input: this._i,
                format: this._f,
                locale: this._locale,
                isUTC: this._isUTC,
                strict: this._strict,
            };
        }

        addFormatToken('N', 0, 0, 'eraAbbr');
        addFormatToken('NN', 0, 0, 'eraAbbr');
        addFormatToken('NNN', 0, 0, 'eraAbbr');
        addFormatToken('NNNN', 0, 0, 'eraName');
        addFormatToken('NNNNN', 0, 0, 'eraNarrow');

        addFormatToken('y', ['y', 1], 'yo', 'eraYear');
        addFormatToken('y', ['yy', 2], 0, 'eraYear');
        addFormatToken('y', ['yyy', 3], 0, 'eraYear');
        addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

        addRegexToken('N', matchEraAbbr);
        addRegexToken('NN', matchEraAbbr);
        addRegexToken('NNN', matchEraAbbr);
        addRegexToken('NNNN', matchEraName);
        addRegexToken('NNNNN', matchEraNarrow);

        addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
            input,
            array,
            config,
            token
        ) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        });

        addRegexToken('y', matchUnsigned);
        addRegexToken('yy', matchUnsigned);
        addRegexToken('yyy', matchUnsigned);
        addRegexToken('yyyy', matchUnsigned);
        addRegexToken('yo', matchEraYearOrdinal);

        addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
        addParseToken(['yo'], function (input, array, config, token) {
            var match;
            if (config._locale._eraYearOrdinalRegex) {
                match = input.match(config._locale._eraYearOrdinalRegex);
            }

            if (config._locale.eraYearOrdinalParse) {
                array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
            } else {
                array[YEAR] = parseInt(input, 10);
            }
        });

        function localeEras(m, format) {
            var i,
                l,
                date,
                eras = this._eras || getLocale('en')._eras;
            for (i = 0, l = eras.length; i < l; ++i) {
                switch (typeof eras[i].since) {
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].since).startOf('day');
                        eras[i].since = date.valueOf();
                        break;
                }

                switch (typeof eras[i].until) {
                    case 'undefined':
                        eras[i].until = +Infinity;
                        break;
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].until).startOf('day').valueOf();
                        eras[i].until = date.valueOf();
                        break;
                }
            }
            return eras;
        }

        function localeErasParse(eraName, format, strict) {
            var i,
                l,
                eras = this.eras(),
                name,
                abbr,
                narrow;
            eraName = eraName.toUpperCase();

            for (i = 0, l = eras.length; i < l; ++i) {
                name = eras[i].name.toUpperCase();
                abbr = eras[i].abbr.toUpperCase();
                narrow = eras[i].narrow.toUpperCase();

                if (strict) {
                    switch (format) {
                        case 'N':
                        case 'NN':
                        case 'NNN':
                            if (abbr === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNN':
                            if (name === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNNN':
                            if (narrow === eraName) {
                                return eras[i];
                            }
                            break;
                    }
                } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                    return eras[i];
                }
            }
        }

        function localeErasConvertYear(era, year) {
            var dir = era.since <= era.until ? +1 : -1;
            if (year === undefined) {
                return hooks(era.since).year();
            } else {
                return hooks(era.since).year() + (year - era.offset) * dir;
            }
        }

        function getEraName() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].name;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].name;
                }
            }

            return '';
        }

        function getEraNarrow() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].narrow;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].narrow;
                }
            }

            return '';
        }

        function getEraAbbr() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].abbr;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].abbr;
                }
            }

            return '';
        }

        function getEraYear() {
            var i,
                l,
                dir,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                dir = eras[i].since <= eras[i].until ? +1 : -1;

                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (
                    (eras[i].since <= val && val <= eras[i].until) ||
                    (eras[i].until <= val && val <= eras[i].since)
                ) {
                    return (
                        (this.year() - hooks(eras[i].since).year()) * dir +
                        eras[i].offset
                    );
                }
            }

            return this.year();
        }

        function erasNameRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNameRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNameRegex : this._erasRegex;
        }

        function erasAbbrRegex(isStrict) {
            if (!hasOwnProp(this, '_erasAbbrRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }

        function erasNarrowRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNarrowRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }

        function matchEraAbbr(isStrict, locale) {
            return locale.erasAbbrRegex(isStrict);
        }

        function matchEraName(isStrict, locale) {
            return locale.erasNameRegex(isStrict);
        }

        function matchEraNarrow(isStrict, locale) {
            return locale.erasNarrowRegex(isStrict);
        }

        function matchEraYearOrdinal(isStrict, locale) {
            return locale._eraYearOrdinalRegex || matchUnsigned;
        }

        function computeErasParse() {
            var abbrPieces = [],
                namePieces = [],
                narrowPieces = [],
                mixedPieces = [],
                i,
                l,
                eras = this.eras();

            for (i = 0, l = eras.length; i < l; ++i) {
                namePieces.push(regexEscape(eras[i].name));
                abbrPieces.push(regexEscape(eras[i].abbr));
                narrowPieces.push(regexEscape(eras[i].narrow));

                mixedPieces.push(regexEscape(eras[i].name));
                mixedPieces.push(regexEscape(eras[i].abbr));
                mixedPieces.push(regexEscape(eras[i].narrow));
            }

            this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
            this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
            this._erasNarrowRegex = new RegExp(
                '^(' + narrowPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken(0, ['gg', 2], 0, function () {
            return this.weekYear() % 100;
        });

        addFormatToken(0, ['GG', 2], 0, function () {
            return this.isoWeekYear() % 100;
        });

        function addWeekYearFormatToken(token, getter) {
            addFormatToken(0, [token, token.length], 0, getter);
        }

        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear');

        // ALIASES

        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG');

        // PRIORITY

        addUnitPriority('weekYear', 1);
        addUnitPriority('isoWeekYear', 1);

        // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);

        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
            input,
            week,
            config,
            token
        ) {
            week[token.substr(0, 2)] = toInt(input);
        });

        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
            week[token] = hooks.parseTwoDigitYear(input);
        });

        // MOMENTS

        function getSetWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy
            );
        }

        function getSetISOWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.isoWeek(),
                this.isoWeekday(),
                1,
                4
            );
        }

        function getISOWeeksInYear() {
            return weeksInYear(this.year(), 1, 4);
        }

        function getISOWeeksInISOWeekYear() {
            return weeksInYear(this.isoWeekYear(), 1, 4);
        }

        function getWeeksInYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }

        function getWeeksInWeekYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }

        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
            var weeksTarget;
            if (input == null) {
                return weekOfYear(this, dow, doy).year;
            } else {
                weeksTarget = weeksInYear(input, dow, doy);
                if (week > weeksTarget) {
                    week = weeksTarget;
                }
                return setWeekAll.call(this, input, week, weekday, dow, doy);
            }
        }

        function setWeekAll(weekYear, week, weekday, dow, doy) {
            var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

            this.year(date.getUTCFullYear());
            this.month(date.getUTCMonth());
            this.date(date.getUTCDate());
            return this;
        }

        // FORMATTING

        addFormatToken('Q', 0, 'Qo', 'quarter');

        // ALIASES

        addUnitAlias('quarter', 'Q');

        // PRIORITY

        addUnitPriority('quarter', 7);

        // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
            array[MONTH] = (toInt(input) - 1) * 3;
        });

        // MOMENTS

        function getSetQuarter(input) {
            return input == null
                ? Math.ceil((this.month() + 1) / 3)
                : this.month((input - 1) * 3 + (this.month() % 3));
        }

        // FORMATTING

        addFormatToken('D', ['DD', 2], 'Do', 'date');

        // ALIASES

        addUnitAlias('date', 'D');

        // PRIORITY
        addUnitPriority('date', 9);

        // PARSING

        addRegexToken('D', match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
            // TODO: Remove "ordinalParse" fallback in next major release.
            return isStrict
                ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
                : locale._dayOfMonthOrdinalParseLenient;
        });

        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
            array[DATE] = toInt(input.match(match1to2)[0]);
        });

        // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true);

        // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

        // ALIASES

        addUnitAlias('dayOfYear', 'DDD');

        // PRIORITY
        addUnitPriority('dayOfYear', 4);

        // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
            config._dayOfYear = toInt(input);
        });

        // HELPERS

        // MOMENTS

        function getSetDayOfYear(input) {
            var dayOfYear =
                Math.round(
                    (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
                ) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        }

        // FORMATTING

        addFormatToken('m', ['mm', 2], 0, 'minute');

        // ALIASES

        addUnitAlias('minute', 'm');

        // PRIORITY

        addUnitPriority('minute', 14);

        // PARSING

        addRegexToken('m', match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE);

        // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false);

        // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second');

        // ALIASES

        addUnitAlias('second', 's');

        // PRIORITY

        addUnitPriority('second', 15);

        // PARSING

        addRegexToken('s', match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND);

        // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false);

        // FORMATTING

        addFormatToken('S', 0, 0, function () {
            return ~~(this.millisecond() / 100);
        });

        addFormatToken(0, ['SS', 2], 0, function () {
            return ~~(this.millisecond() / 10);
        });

        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
            return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
            return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
            return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
            return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
            return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
            return this.millisecond() * 1000000;
        });

        // ALIASES

        addUnitAlias('millisecond', 'ms');

        // PRIORITY

        addUnitPriority('millisecond', 16);

        // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);

        var token, getSetMillisecond;
        for (token = 'SSSS'; token.length <= 9; token += 'S') {
            addRegexToken(token, matchUnsigned);
        }

        function parseMs(input, array) {
            array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }

        for (token = 'S'; token.length <= 9; token += 'S') {
            addParseToken(token, parseMs);
        }

        getSetMillisecond = makeGetSet('Milliseconds', false);

        // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName');

        // MOMENTS

        function getZoneAbbr() {
            return this._isUTC ? 'UTC' : '';
        }

        function getZoneName() {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        }

        var proto = Moment.prototype;

        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== 'undefined' && Symbol.for != null) {
            proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
                return 'Moment<' + this.format() + '>';
            };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
            'dates accessor is deprecated. Use date instead.',
            getSetDayOfMonth
        );
        proto.months = deprecate(
            'months accessor is deprecated. Use month instead',
            getSetMonth
        );
        proto.years = deprecate(
            'years accessor is deprecated. Use year instead',
            getSetYear
        );
        proto.zone = deprecate(
            'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
            getSetZone
        );
        proto.isDSTShifted = deprecate(
            'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
            isDaylightSavingTimeShifted
        );

        function createUnix(input) {
            return createLocal(input * 1000);
        }

        function createInZone() {
            return createLocal.apply(null, arguments).parseZone();
        }

        function preParsePostFormat(string) {
            return string;
        }

        var proto$1 = Locale.prototype;

        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;

        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;

        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;

        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;

        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;

        function get$1(format, index, field, setter) {
            var locale = getLocale(),
                utc = createUTC().set(setter, index);
            return locale[field](utc, format);
        }

        function listMonthsImpl(format, index, field) {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';

            if (index != null) {
                return get$1(format, index, field, 'month');
            }

            var i,
                out = [];
            for (i = 0; i < 12; i++) {
                out[i] = get$1(format, i, field, 'month');
            }
            return out;
        }

        // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)
        function listWeekdaysImpl(localeSorted, format, index, field) {
            if (typeof localeSorted === 'boolean') {
                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            } else {
                format = localeSorted;
                index = format;
                localeSorted = false;

                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            }

            var locale = getLocale(),
                shift = localeSorted ? locale._week.dow : 0,
                i,
                out = [];

            if (index != null) {
                return get$1(format, (index + shift) % 7, field, 'day');
            }

            for (i = 0; i < 7; i++) {
                out[i] = get$1(format, (i + shift) % 7, field, 'day');
            }
            return out;
        }

        function listMonths(format, index) {
            return listMonthsImpl(format, index, 'months');
        }

        function listMonthsShort(format, index) {
            return listMonthsImpl(format, index, 'monthsShort');
        }

        function listWeekdays(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }

        function listWeekdaysShort(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }

        function listWeekdaysMin(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }

        getSetGlobalLocale('en', {
            eras: [
                {
                    since: '0001-01-01',
                    until: +Infinity,
                    offset: 1,
                    name: 'Anno Domini',
                    narrow: 'AD',
                    abbr: 'AD',
                },
                {
                    since: '0000-12-31',
                    until: -Infinity,
                    offset: 1,
                    name: 'Before Christ',
                    narrow: 'BC',
                    abbr: 'BC',
                },
            ],
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        toInt((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
        });

        // Side effect imports

        hooks.lang = deprecate(
            'moment.lang is deprecated. Use moment.locale instead.',
            getSetGlobalLocale
        );
        hooks.langData = deprecate(
            'moment.langData is deprecated. Use moment.localeData instead.',
            getLocale
        );

        var mathAbs = Math.abs;

        function abs() {
            var data = this._data;

            this._milliseconds = mathAbs(this._milliseconds);
            this._days = mathAbs(this._days);
            this._months = mathAbs(this._months);

            data.milliseconds = mathAbs(data.milliseconds);
            data.seconds = mathAbs(data.seconds);
            data.minutes = mathAbs(data.minutes);
            data.hours = mathAbs(data.hours);
            data.months = mathAbs(data.months);
            data.years = mathAbs(data.years);

            return this;
        }

        function addSubtract$1(duration, input, value, direction) {
            var other = createDuration(input, value);

            duration._milliseconds += direction * other._milliseconds;
            duration._days += direction * other._days;
            duration._months += direction * other._months;

            return duration._bubble();
        }

        // supports only 2.0-style add(1, 's') or add(duration)
        function add$1(input, value) {
            return addSubtract$1(this, input, value, 1);
        }

        // supports only 2.0-style subtract(1, 's') or subtract(duration)
        function subtract$1(input, value) {
            return addSubtract$1(this, input, value, -1);
        }

        function absCeil(number) {
            if (number < 0) {
                return Math.floor(number);
            } else {
                return Math.ceil(number);
            }
        }

        function bubble() {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds,
                minutes,
                hours,
                years,
                monthsFromDays;

            // if we have a mix of positive and negative values, bubble down first
            // check: https://github.com/moment/moment/issues/2166
            if (
                !(
                    (milliseconds >= 0 && days >= 0 && months >= 0) ||
                    (milliseconds <= 0 && days <= 0 && months <= 0)
                )
            ) {
                milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                days = 0;
                months = 0;
            }

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absFloor(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absFloor(seconds / 60);
            data.minutes = minutes % 60;

            hours = absFloor(minutes / 60);
            data.hours = hours % 24;

            days += absFloor(hours / 24);

            // convert days to months
            monthsFromDays = absFloor(daysToMonths(days));
            months += monthsFromDays;
            days -= absCeil(monthsToDays(monthsFromDays));

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;

            return this;
        }

        function daysToMonths(days) {
            // 400 years have 146097 days (taking into account leap year rules)
            // 400 years have 12 months === 4800
            return (days * 4800) / 146097;
        }

        function monthsToDays(months) {
            // the reverse of daysToMonths
            return (months * 146097) / 4800;
        }

        function as(units) {
            if (!this.isValid()) {
                return NaN;
            }
            var days,
                months,
                milliseconds = this._milliseconds;

            units = normalizeUnits(units);

            if (units === 'month' || units === 'quarter' || units === 'year') {
                days = this._days + milliseconds / 864e5;
                months = this._months + daysToMonths(days);
                switch (units) {
                    case 'month':
                        return months;
                    case 'quarter':
                        return months / 3;
                    case 'year':
                        return months / 12;
                }
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(monthsToDays(this._months));
                switch (units) {
                    case 'week':
                        return days / 7 + milliseconds / 6048e5;
                    case 'day':
                        return days + milliseconds / 864e5;
                    case 'hour':
                        return days * 24 + milliseconds / 36e5;
                    case 'minute':
                        return days * 1440 + milliseconds / 6e4;
                    case 'second':
                        return days * 86400 + milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond':
                        return Math.floor(days * 864e5) + milliseconds;
                    default:
                        throw new Error('Unknown unit ' + units);
                }
            }
        }

        // TODO: Use this.as('ms')?
        function valueOf$1() {
            if (!this.isValid()) {
                return NaN;
            }
            return (
                this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6
            );
        }

        function makeAs(alias) {
            return function () {
                return this.as(alias);
            };
        }

        var asMilliseconds = makeAs('ms'),
            asSeconds = makeAs('s'),
            asMinutes = makeAs('m'),
            asHours = makeAs('h'),
            asDays = makeAs('d'),
            asWeeks = makeAs('w'),
            asMonths = makeAs('M'),
            asQuarters = makeAs('Q'),
            asYears = makeAs('y');

        function clone$1() {
            return createDuration(this);
        }

        function get$2(units) {
            units = normalizeUnits(units);
            return this.isValid() ? this[units + 's']() : NaN;
        }

        function makeGetter(name) {
            return function () {
                return this.isValid() ? this._data[name] : NaN;
            };
        }

        var milliseconds = makeGetter('milliseconds'),
            seconds = makeGetter('seconds'),
            minutes = makeGetter('minutes'),
            hours = makeGetter('hours'),
            days = makeGetter('days'),
            months = makeGetter('months'),
            years = makeGetter('years');

        function weeks() {
            return absFloor(this.days() / 7);
        }

        var round = Math.round,
            thresholds = {
                ss: 44, // a few seconds to seconds
                s: 45, // seconds to minute
                m: 45, // minutes to hour
                h: 22, // hours to day
                d: 26, // days to month/week
                w: null, // weeks to month
                M: 11, // months to year
            };

        // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
            return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }

        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
            var duration = createDuration(posNegDuration).abs(),
                seconds = round(duration.as('s')),
                minutes = round(duration.as('m')),
                hours = round(duration.as('h')),
                days = round(duration.as('d')),
                months = round(duration.as('M')),
                weeks = round(duration.as('w')),
                years = round(duration.as('y')),
                a =
                    (seconds <= thresholds.ss && ['s', seconds]) ||
                    (seconds < thresholds.s && ['ss', seconds]) ||
                    (minutes <= 1 && ['m']) ||
                    (minutes < thresholds.m && ['mm', minutes]) ||
                    (hours <= 1 && ['h']) ||
                    (hours < thresholds.h && ['hh', hours]) ||
                    (days <= 1 && ['d']) ||
                    (days < thresholds.d && ['dd', days]);

            if (thresholds.w != null) {
                a =
                    a ||
                    (weeks <= 1 && ['w']) ||
                    (weeks < thresholds.w && ['ww', weeks]);
            }
            a = a ||
                (months <= 1 && ['M']) ||
                (months < thresholds.M && ['MM', months]) ||
                (years <= 1 && ['y']) || ['yy', years];

            a[2] = withoutSuffix;
            a[3] = +posNegDuration > 0;
            a[4] = locale;
            return substituteTimeAgo.apply(null, a);
        }

        // This function allows you to set the rounding function for relative time strings
        function getSetRelativeTimeRounding(roundingFunction) {
            if (roundingFunction === undefined) {
                return round;
            }
            if (typeof roundingFunction === 'function') {
                round = roundingFunction;
                return true;
            }
            return false;
        }

        // This function allows you to set a threshold for relative time strings
        function getSetRelativeTimeThreshold(threshold, limit) {
            if (thresholds[threshold] === undefined) {
                return false;
            }
            if (limit === undefined) {
                return thresholds[threshold];
            }
            thresholds[threshold] = limit;
            if (threshold === 's') {
                thresholds.ss = limit - 1;
            }
            return true;
        }

        function humanize(argWithSuffix, argThresholds) {
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var withSuffix = false,
                th = thresholds,
                locale,
                output;

            if (typeof argWithSuffix === 'object') {
                argThresholds = argWithSuffix;
                argWithSuffix = false;
            }
            if (typeof argWithSuffix === 'boolean') {
                withSuffix = argWithSuffix;
            }
            if (typeof argThresholds === 'object') {
                th = Object.assign({}, thresholds, argThresholds);
                if (argThresholds.s != null && argThresholds.ss == null) {
                    th.ss = argThresholds.s - 1;
                }
            }

            locale = this.localeData();
            output = relativeTime$1(this, !withSuffix, th, locale);

            if (withSuffix) {
                output = locale.pastFuture(+this, output);
            }

            return locale.postformat(output);
        }

        var abs$1 = Math.abs;

        function sign(x) {
            return (x > 0) - (x < 0) || +x;
        }

        function toISOString$1() {
            // for ISO strings we do not use the normal bubbling rules:
            //  * milliseconds bubble up until they become hours
            //  * days do not bubble at all
            //  * months bubble up until they become years
            // This is because there is no context-free conversion between hours and days
            // (think of clock changes)
            // and also not between days and months (28-31 days per month)
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var seconds = abs$1(this._milliseconds) / 1000,
                days = abs$1(this._days),
                months = abs$1(this._months),
                minutes,
                hours,
                years,
                s,
                total = this.asSeconds(),
                totalSign,
                ymSign,
                daysSign,
                hmsSign;

            if (!total) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            // 3600 seconds -> 60 minutes -> 1 hour
            minutes = absFloor(seconds / 60);
            hours = absFloor(minutes / 60);
            seconds %= 60;
            minutes %= 60;

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

            totalSign = total < 0 ? '-' : '';
            ymSign = sign(this._months) !== sign(total) ? '-' : '';
            daysSign = sign(this._days) !== sign(total) ? '-' : '';
            hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

            return (
                totalSign +
                'P' +
                (years ? ymSign + years + 'Y' : '') +
                (months ? ymSign + months + 'M' : '') +
                (days ? daysSign + days + 'D' : '') +
                (hours || minutes || seconds ? 'T' : '') +
                (hours ? hmsSign + hours + 'H' : '') +
                (minutes ? hmsSign + minutes + 'M' : '') +
                (seconds ? hmsSign + s + 'S' : '')
            );
        }

        var proto$2 = Duration.prototype;

        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;

        proto$2.toIsoString = deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
            toISOString$1
        );
        proto$2.lang = lang;

        // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf');

        // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
            config._d = new Date(parseFloat(input) * 1000);
        });
        addParseToken('x', function (input, array, config) {
            config._d = new Date(toInt(input));
        });

        //! moment.js

        hooks.version = '2.29.1';

        setHookCallback(createLocal);

        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;

        // currently HTML5 input type only supports 24-hour formats
        hooks.HTML5_FMT = {
            DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
            DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
            DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
            DATE: 'YYYY-MM-DD', // <input type="date" />
            TIME: 'HH:mm', // <input type="time" />
            TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
            TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
            WEEK: 'GGGG-[W]WW', // <input type="week" />
            MONTH: 'YYYY-MM', // <input type="month" />
        };

        return hooks;

    })));
    });

    var es = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        typeof commonjsRequire === 'function' ? factory(moment) :
       
       factory(global.moment);
    }(commonjsGlobal, (function (moment) {
        //! moment.js locale configuration

        var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
                '_'
            ),
            monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
            monthsParse = [
                /^ene/i,
                /^feb/i,
                /^mar/i,
                /^abr/i,
                /^may/i,
                /^jun/i,
                /^jul/i,
                /^ago/i,
                /^sep/i,
                /^oct/i,
                /^nov/i,
                /^dic/i,
            ],
            monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

        var es = moment.defineLocale('es', {
            months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
                '_'
            ),
            monthsShort: function (m, format) {
                if (!m) {
                    return monthsShortDot;
                } else if (/-MMM-/.test(format)) {
                    return monthsShort[m.month()];
                } else {
                    return monthsShortDot[m.month()];
                }
            },
            monthsRegex: monthsRegex,
            monthsShortRegex: monthsRegex,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
            weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
            weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D [de] MMMM [de] YYYY',
                LLL: 'D [de] MMMM [de] YYYY H:mm',
                LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
            },
            calendar: {
                sameDay: function () {
                    return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                nextDay: function () {
                    return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                nextWeek: function () {
                    return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                lastDay: function () {
                    return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                lastWeek: function () {
                    return (
                        '[el] dddd [pasado a la' +
                        (this.hours() !== 1 ? 's' : '') +
                        '] LT'
                    );
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'en %s',
                past: 'hace %s',
                s: 'unos segundos',
                ss: '%d segundos',
                m: 'un minuto',
                mm: '%d minutos',
                h: 'una hora',
                hh: '%d horas',
                d: 'un da',
                dd: '%d das',
                w: 'una semana',
                ww: '%d semanas',
                M: 'un mes',
                MM: '%d meses',
                y: 'un ao',
                yy: '%d aos',
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: '%d',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
            invalidDate: 'Fecha invlida',
        });

        return es;

    })));
    });

    /* src\componentes\Evoluciones.svelte generated by Svelte v3.29.0 */
    const file$9 = "src\\componentes\\Evoluciones.svelte";

    // (31:16) {#if user().roles.includes('doctor') || user().roles.includes('admin')}
    function create_if_block$6(ctx) {
    	let span;
    	let t0_value = moment(/*fecha*/ ctx[2]).fromNow() + "";
    	let t0;
    	let t1;
    	let a;
    	let i;
    	let t2;
    	let a_href_value;
    	let link_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			a = element("a");
    			i = element("i");
    			t2 = text(" editar");
    			attr_dev(i, "class", "fab fa-share-square");
    			add_location(i, file$9, 33, 169, 1254);
    			attr_dev(a, "href", a_href_value = `/pacientes/${/*idPaciente*/ ctx[4]}/historias/${/*id*/ ctx[3]}`);
    			attr_dev(a, "class", "btn btn-primary btn-sm text-white");
    			set_style(a, "position", "absolute");
    			set_style(a, "right", "20px");
    			add_location(a, file$9, 33, 25, 1110);
    			attr_dev(span, "class", "text-muted ml-3 small");
    			add_location(span, file$9, 32, 21, 1021);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, a);
    			append_dev(a, i);
    			append_dev(a, t2);

    			if (!mounted) {
    				dispose = action_destroyer(link_action = link.call(null, a));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fecha*/ 4 && t0_value !== (t0_value = moment(/*fecha*/ ctx[2]).fromNow() + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*idPaciente, id*/ 24 && a_href_value !== (a_href_value = `/pacientes/${/*idPaciente*/ ctx[4]}/historias/${/*id*/ ctx[3]}`)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(31:16) {#if user().roles.includes('doctor') || user().roles.includes('admin')}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let span0;
    	let t0_value = /*nombre*/ ctx[5][0] + "";
    	let t0;
    	let t1_value = /*apellido*/ ctx[6][0] + "";
    	let t1;
    	let t2;
    	let div1;
    	let h6;
    	let span1;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let show_if = user().roles.includes("doctor") || user().roles.includes("admin");
    	let t7;
    	let small0;
    	let t9;
    	let p0;
    	let t10;
    	let t11;
    	let small1;
    	let t13;
    	let p1;
    	let t14;
    	let if_block = show_if && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			div1 = element("div");
    			h6 = element("h6");
    			span1 = element("span");
    			t3 = text(/*nombre*/ ctx[5]);
    			t4 = space();
    			t5 = text(/*apellido*/ ctx[6]);
    			t6 = space();
    			if (if_block) if_block.c();
    			t7 = space();
    			small0 = element("small");
    			small0.textContent = "Motivo de Consulta";
    			t9 = space();
    			p0 = element("p");
    			t10 = text(/*motivo*/ ctx[0]);
    			t11 = space();
    			small1 = element("small");
    			small1.textContent = "Historia de la Enfermedad";
    			t13 = space();
    			p1 = element("p");
    			t14 = text(/*historia*/ ctx[1]);
    			attr_dev(span0, "class", "avatar-title rounded-circle");
    			add_location(span0, file$9, 26, 12, 671);
    			attr_dev(div0, "class", "avatar mr-3  avatar-sm");
    			add_location(div0, file$9, 25, 8, 621);
    			add_location(span1, file$9, 29, 35, 833);
    			attr_dev(h6, "class", "mt-0 mb-1");
    			add_location(h6, file$9, 29, 12, 810);
    			attr_dev(small0, "class", "mt-4 mb-4 text-primary");
    			add_location(small0, file$9, 37, 12, 1386);
    			attr_dev(p0, "data-bind", "text: atencionMedica.motivoConsulta");
    			add_location(p0, file$9, 38, 12, 1464);
    			attr_dev(small1, "class", "mt-4 mb-4 text-primary");
    			add_location(small1, file$9, 39, 12, 1541);
    			attr_dev(p1, "data-bind", "text: atencionMedica.historiaEnfermedad");
    			add_location(p1, file$9, 40, 12, 1626);
    			attr_dev(div1, "class", "media-body");
    			add_location(div1, file$9, 28, 8, 772);
    			attr_dev(div2, "class", "media");
    			add_location(div2, file$9, 24, 4, 592);
    			attr_dev(div3, "class", "list-unstyled");
    			add_location(div3, file$9, 23, 0, 559);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			append_dev(span0, t1);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, h6);
    			append_dev(h6, span1);
    			append_dev(span1, t3);
    			append_dev(span1, t4);
    			append_dev(span1, t5);
    			append_dev(h6, t6);
    			if (if_block) if_block.m(h6, null);
    			append_dev(div1, t7);
    			append_dev(div1, small0);
    			append_dev(div1, t9);
    			append_dev(div1, p0);
    			append_dev(p0, t10);
    			append_dev(div1, t11);
    			append_dev(div1, small1);
    			append_dev(div1, t13);
    			append_dev(div1, p1);
    			append_dev(p1, t14);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*nombre*/ 32 && t0_value !== (t0_value = /*nombre*/ ctx[5][0] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*apellido*/ 64 && t1_value !== (t1_value = /*apellido*/ ctx[6][0] + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*nombre*/ 32) set_data_dev(t3, /*nombre*/ ctx[5]);
    			if (dirty & /*apellido*/ 64) set_data_dev(t5, /*apellido*/ ctx[6]);
    			if (show_if) if_block.p(ctx, dirty);
    			if (dirty & /*motivo*/ 1) set_data_dev(t10, /*motivo*/ ctx[0]);
    			if (dirty & /*historia*/ 2) set_data_dev(t14, /*historia*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Evoluciones", slots, []);
    	let { motivo = "" } = $$props;
    	let { historia = "" } = $$props;
    	let { fecha = "" } = $$props;
    	let { id = "" } = $$props;
    	let { idPaciente = "" } = $$props;
    	let { usuario } = $$props;

    	onMount(() => {
    		moment.locale("es");
    	});

    	const writable_props = ["motivo", "historia", "fecha", "id", "idPaciente", "usuario"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Evoluciones> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("motivo" in $$props) $$invalidate(0, motivo = $$props.motivo);
    		if ("historia" in $$props) $$invalidate(1, historia = $$props.historia);
    		if ("fecha" in $$props) $$invalidate(2, fecha = $$props.fecha);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("idPaciente" in $$props) $$invalidate(4, idPaciente = $$props.idPaciente);
    		if ("usuario" in $$props) $$invalidate(7, usuario = $$props.usuario);
    	};

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		onMount,
    		link,
    		user,
    		url,
    		moment,
    		motivo,
    		historia,
    		fecha,
    		id,
    		idPaciente,
    		usuario,
    		nombre,
    		apellido
    	});

    	$$self.$inject_state = $$props => {
    		if ("motivo" in $$props) $$invalidate(0, motivo = $$props.motivo);
    		if ("historia" in $$props) $$invalidate(1, historia = $$props.historia);
    		if ("fecha" in $$props) $$invalidate(2, fecha = $$props.fecha);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("idPaciente" in $$props) $$invalidate(4, idPaciente = $$props.idPaciente);
    		if ("usuario" in $$props) $$invalidate(7, usuario = $$props.usuario);
    		if ("nombre" in $$props) $$invalidate(5, nombre = $$props.nombre);
    		if ("apellido" in $$props) $$invalidate(6, apellido = $$props.apellido);
    	};

    	let nombre;
    	let apellido;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*usuario*/ 128) {
    			 $$invalidate(5, nombre = usuario.nombre);
    		}

    		if ($$self.$$.dirty & /*usuario*/ 128) {
    			 $$invalidate(6, apellido = usuario.apellido);
    		}
    	};

    	return [motivo, historia, fecha, id, idPaciente, nombre, apellido, usuario];
    }

    class Evoluciones extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			motivo: 0,
    			historia: 1,
    			fecha: 2,
    			id: 3,
    			idPaciente: 4,
    			usuario: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Evoluciones",
    			options,
    			id: create_fragment$a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*usuario*/ ctx[7] === undefined && !("usuario" in props)) {
    			console.warn("<Evoluciones> was created without expected prop 'usuario'");
    		}
    	}

    	get motivo() {
    		throw new Error("<Evoluciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set motivo(value) {
    		throw new Error("<Evoluciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get historia() {
    		throw new Error("<Evoluciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set historia(value) {
    		throw new Error("<Evoluciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fecha() {
    		throw new Error("<Evoluciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fecha(value) {
    		throw new Error("<Evoluciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Evoluciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Evoluciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get idPaciente() {
    		throw new Error("<Evoluciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set idPaciente(value) {
    		throw new Error("<Evoluciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get usuario() {
    		throw new Error("<Evoluciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set usuario(value) {
    		throw new Error("<Evoluciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\componentes\UltimosVitales.svelte generated by Svelte v3.29.0 */

    const file$a = "src\\componentes\\UltimosVitales.svelte";

    function create_fragment$b(ctx) {
    	let div23;
    	let div2;
    	let div1;
    	let div0;
    	let i0;
    	let t0;
    	let t1;
    	let div5;
    	let div4;
    	let a;
    	let i1;
    	let t2;
    	let div3;
    	let button0;
    	let t4;
    	let button1;
    	let t6;
    	let button2;
    	let t8;
    	let div22;
    	let div21;
    	let div8;
    	let div6;
    	let i2;
    	let t9;
    	let t10;
    	let div7;
    	let p0;
    	let t11;
    	let t12;
    	let t13;
    	let t14;
    	let div11;
    	let div9;
    	let i3;
    	let t15;
    	let t16;
    	let div10;
    	let p1;
    	let t17;
    	let t18;
    	let t19;
    	let t20;
    	let div14;
    	let div12;
    	let i4;
    	let t21;
    	let t22;
    	let div13;
    	let p2;
    	let t23;
    	let t24;
    	let div17;
    	let div15;
    	let i5;
    	let t25;
    	let t26;
    	let div16;
    	let p3;
    	let t27;
    	let t28;
    	let div20;
    	let div18;
    	let i6;
    	let t29;
    	let t30;
    	let div19;
    	let p4;
    	let t31;

    	const block = {
    		c: function create() {
    			div23 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			i0 = element("i");
    			t0 = text("\r\n      Ultimos Signo Vitales");
    			t1 = space();
    			div5 = element("div");
    			div4 = element("div");
    			a = element("a");
    			i1 = element("i");
    			t2 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Action";
    			t4 = space();
    			button1 = element("button");
    			button1.textContent = "Another action";
    			t6 = space();
    			button2 = element("button");
    			button2.textContent = "Something else here";
    			t8 = space();
    			div22 = element("div");
    			div21 = element("div");
    			div8 = element("div");
    			div6 = element("div");
    			i2 = element("i");
    			t9 = text(" Peso");
    			t10 = space();
    			div7 = element("div");
    			p0 = element("p");
    			t11 = text(/*peso*/ ctx[0]);
    			t12 = space();
    			t13 = text(/*tipoPeso*/ ctx[5]);
    			t14 = space();
    			div11 = element("div");
    			div9 = element("div");
    			i3 = element("i");
    			t15 = text(" Temperatura");
    			t16 = space();
    			div10 = element("div");
    			p1 = element("p");
    			t17 = text(/*temperatura*/ ctx[1]);
    			t18 = text(" ");
    			t19 = text(/*tipoTemperatura*/ ctx[6]);
    			t20 = space();
    			div14 = element("div");
    			div12 = element("div");
    			i4 = element("i");
    			t21 = text(" Frecuencia Respiratoria");
    			t22 = space();
    			div13 = element("div");
    			p2 = element("p");
    			t23 = text(/*frecuenciaRespiratoria*/ ctx[2]);
    			t24 = space();
    			div17 = element("div");
    			div15 = element("div");
    			i5 = element("i");
    			t25 = text(" Frecuencia Cardiaca");
    			t26 = space();
    			div16 = element("div");
    			p3 = element("p");
    			t27 = text(/*frecuenciaCardiaca*/ ctx[3]);
    			t28 = space();
    			div20 = element("div");
    			div18 = element("div");
    			i6 = element("i");
    			t29 = text(" Presion Alterial (mmHg)");
    			t30 = space();
    			div19 = element("div");
    			p4 = element("p");
    			t31 = text(/*presionAlterial*/ ctx[4]);
    			attr_dev(i0, "class", "mdi mdi-account-heart mdi-18px");
    			add_location(i0, file$a, 13, 10, 445);
    			attr_dev(div0, "class", "avatar-title bg-dark rounded-circle");
    			add_location(div0, file$a, 12, 8, 384);
    			attr_dev(div1, "class", "avatar mr-2 avatar-xs");
    			add_location(div1, file$a, 11, 6, 339);
    			attr_dev(div2, "class", "card-header");
    			add_location(div2, file$a, 10, 4, 306);
    			attr_dev(i1, "class", "icon mdi  mdi-dots-vertical");
    			add_location(i1, file$a, 20, 87, 714);
    			attr_dev(a, "href", "#");
    			attr_dev(a, "data-toggle", "dropdown");
    			attr_dev(a, "aria-haspopup", "true");
    			attr_dev(a, "aria-expanded", "false");
    			add_location(a, file$a, 20, 8, 635);
    			attr_dev(button0, "class", "dropdown-item");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$a, 24, 10, 846);
    			attr_dev(button1, "class", "dropdown-item");
    			attr_dev(button1, "type", "button");
    			add_location(button1, file$a, 25, 10, 917);
    			attr_dev(button2, "class", "dropdown-item");
    			attr_dev(button2, "type", "button");
    			add_location(button2, file$a, 26, 10, 996);
    			attr_dev(div3, "class", "dropdown-menu dropdown-menu-right");
    			add_location(div3, file$a, 23, 8, 787);
    			attr_dev(div4, "class", "dropdown");
    			add_location(div4, file$a, 19, 6, 603);
    			attr_dev(div5, "class", "card-controls");
    			add_location(div5, file$a, 18, 4, 568);
    			attr_dev(i2, "class", "mdi mdi-speedometer mdi-18px");
    			add_location(i2, file$a, 36, 12, 1330);
    			attr_dev(div6, "class", "col-lg-9 col-sm-10");
    			add_location(div6, file$a, 35, 10, 1284);
    			add_location(p0, file$a, 39, 12, 1454);
    			attr_dev(div7, "class", "col-lg-3 col-sm-2");
    			add_location(div7, file$a, 38, 10, 1409);
    			attr_dev(div8, "class", "row");
    			add_location(div8, file$a, 34, 8, 1255);
    			attr_dev(i3, "class", "mdi mdi-thermometer mdi-18px");
    			add_location(i3, file$a, 45, 12, 1599);
    			attr_dev(div9, "class", "col-lg-9 col-sm-10");
    			add_location(div9, file$a, 44, 10, 1553);
    			add_location(p1, file$a, 48, 12, 1730);
    			attr_dev(div10, "class", "col-lg-3 col-sm-2");
    			add_location(div10, file$a, 47, 10, 1685);
    			attr_dev(div11, "class", "row");
    			add_location(div11, file$a, 43, 8, 1524);
    			attr_dev(i4, "class", "mdi mdi-chart-line mdi-18px");
    			add_location(i4, file$a, 53, 12, 1888);
    			attr_dev(div12, "class", "col-lg-9 col-sm-10");
    			add_location(div12, file$a, 52, 10, 1842);
    			attr_dev(p2, "data-bind", "text: frecuenciaRespiratoria");
    			add_location(p2, file$a, 56, 12, 2030);
    			attr_dev(div13, "class", "col-lg-3 col-sm-2");
    			add_location(div13, file$a, 55, 10, 1985);
    			attr_dev(div14, "class", "row");
    			add_location(div14, file$a, 51, 8, 1813);
    			attr_dev(i5, "class", "mdi mdi-heart-pulse mdi-18px");
    			add_location(i5, file$a, 61, 12, 2221);
    			attr_dev(div15, "class", "col-lg-9 col-sm-10");
    			add_location(div15, file$a, 60, 10, 2175);
    			attr_dev(p3, "data-bind", "text: frecuenciaCardiaca");
    			add_location(p3, file$a, 64, 12, 2360);
    			attr_dev(div16, "class", "col-lg-3 col-sm-2");
    			add_location(div16, file$a, 63, 10, 2315);
    			attr_dev(div17, "class", "row");
    			add_location(div17, file$a, 59, 8, 2146);
    			attr_dev(i6, "class", "mdi mdi-heart-pulse mdi-18px");
    			add_location(i6, file$a, 69, 12, 2543);
    			attr_dev(div18, "class", "col-lg-9 col-sm-10");
    			add_location(div18, file$a, 68, 10, 2497);
    			attr_dev(p4, "data-bind", "text: tensionArterialSistolica +'/' + tensionArterialDiastolica");
    			add_location(p4, file$a, 72, 12, 2686);
    			attr_dev(div19, "class", "col-lg-3 col-sm-2");
    			add_location(div19, file$a, 71, 10, 2641);
    			attr_dev(div20, "class", "row");
    			add_location(div20, file$a, 67, 8, 2468);
    			attr_dev(div21, "class", "list-group-item ");
    			add_location(div21, file$a, 32, 6, 1213);
    			attr_dev(div22, "class", "list-group list  list-group-flush");
    			attr_dev(div22, "data-bind", "using: ultimosSignosVitales");
    			add_location(div22, file$a, 30, 4, 1116);
    			attr_dev(div23, "class", "card m-b-30");
    			add_location(div23, file$a, 9, 0, 275);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div23, anchor);
    			append_dev(div23, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, i0);
    			append_dev(div2, t0);
    			append_dev(div23, t1);
    			append_dev(div23, div5);
    			append_dev(div5, div4);
    			append_dev(div4, a);
    			append_dev(a, i1);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t4);
    			append_dev(div3, button1);
    			append_dev(div3, t6);
    			append_dev(div3, button2);
    			append_dev(div23, t8);
    			append_dev(div23, div22);
    			append_dev(div22, div21);
    			append_dev(div21, div8);
    			append_dev(div8, div6);
    			append_dev(div6, i2);
    			append_dev(div6, t9);
    			append_dev(div8, t10);
    			append_dev(div8, div7);
    			append_dev(div7, p0);
    			append_dev(p0, t11);
    			append_dev(p0, t12);
    			append_dev(p0, t13);
    			append_dev(div21, t14);
    			append_dev(div21, div11);
    			append_dev(div11, div9);
    			append_dev(div9, i3);
    			append_dev(div9, t15);
    			append_dev(div11, t16);
    			append_dev(div11, div10);
    			append_dev(div10, p1);
    			append_dev(p1, t17);
    			append_dev(p1, t18);
    			append_dev(p1, t19);
    			append_dev(div21, t20);
    			append_dev(div21, div14);
    			append_dev(div14, div12);
    			append_dev(div12, i4);
    			append_dev(div12, t21);
    			append_dev(div14, t22);
    			append_dev(div14, div13);
    			append_dev(div13, p2);
    			append_dev(p2, t23);
    			append_dev(div21, t24);
    			append_dev(div21, div17);
    			append_dev(div17, div15);
    			append_dev(div15, i5);
    			append_dev(div15, t25);
    			append_dev(div17, t26);
    			append_dev(div17, div16);
    			append_dev(div16, p3);
    			append_dev(p3, t27);
    			append_dev(div21, t28);
    			append_dev(div21, div20);
    			append_dev(div20, div18);
    			append_dev(div18, i6);
    			append_dev(div18, t29);
    			append_dev(div20, t30);
    			append_dev(div20, div19);
    			append_dev(div19, p4);
    			append_dev(p4, t31);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*peso*/ 1) set_data_dev(t11, /*peso*/ ctx[0]);
    			if (dirty & /*tipoPeso*/ 32) set_data_dev(t13, /*tipoPeso*/ ctx[5]);
    			if (dirty & /*temperatura*/ 2) set_data_dev(t17, /*temperatura*/ ctx[1]);
    			if (dirty & /*tipoTemperatura*/ 64) set_data_dev(t19, /*tipoTemperatura*/ ctx[6]);
    			if (dirty & /*frecuenciaRespiratoria*/ 4) set_data_dev(t23, /*frecuenciaRespiratoria*/ ctx[2]);
    			if (dirty & /*frecuenciaCardiaca*/ 8) set_data_dev(t27, /*frecuenciaCardiaca*/ ctx[3]);
    			if (dirty & /*presionAlterial*/ 16) set_data_dev(t31, /*presionAlterial*/ ctx[4]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div23);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UltimosVitales", slots, []);
    	let { peso = "" } = $$props;
    	let { temperatura = "" } = $$props;
    	let { frecuenciaRespiratoria = "" } = $$props;
    	let { frecuenciaCardiaca = "" } = $$props;
    	let { presionAlterial = "" } = $$props;
    	let { tipoPeso = "" } = $$props;
    	let { tipoTemperatura = "" } = $$props;

    	const writable_props = [
    		"peso",
    		"temperatura",
    		"frecuenciaRespiratoria",
    		"frecuenciaCardiaca",
    		"presionAlterial",
    		"tipoPeso",
    		"tipoTemperatura"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UltimosVitales> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("peso" in $$props) $$invalidate(0, peso = $$props.peso);
    		if ("temperatura" in $$props) $$invalidate(1, temperatura = $$props.temperatura);
    		if ("frecuenciaRespiratoria" in $$props) $$invalidate(2, frecuenciaRespiratoria = $$props.frecuenciaRespiratoria);
    		if ("frecuenciaCardiaca" in $$props) $$invalidate(3, frecuenciaCardiaca = $$props.frecuenciaCardiaca);
    		if ("presionAlterial" in $$props) $$invalidate(4, presionAlterial = $$props.presionAlterial);
    		if ("tipoPeso" in $$props) $$invalidate(5, tipoPeso = $$props.tipoPeso);
    		if ("tipoTemperatura" in $$props) $$invalidate(6, tipoTemperatura = $$props.tipoTemperatura);
    	};

    	$$self.$capture_state = () => ({
    		peso,
    		temperatura,
    		frecuenciaRespiratoria,
    		frecuenciaCardiaca,
    		presionAlterial,
    		tipoPeso,
    		tipoTemperatura
    	});

    	$$self.$inject_state = $$props => {
    		if ("peso" in $$props) $$invalidate(0, peso = $$props.peso);
    		if ("temperatura" in $$props) $$invalidate(1, temperatura = $$props.temperatura);
    		if ("frecuenciaRespiratoria" in $$props) $$invalidate(2, frecuenciaRespiratoria = $$props.frecuenciaRespiratoria);
    		if ("frecuenciaCardiaca" in $$props) $$invalidate(3, frecuenciaCardiaca = $$props.frecuenciaCardiaca);
    		if ("presionAlterial" in $$props) $$invalidate(4, presionAlterial = $$props.presionAlterial);
    		if ("tipoPeso" in $$props) $$invalidate(5, tipoPeso = $$props.tipoPeso);
    		if ("tipoTemperatura" in $$props) $$invalidate(6, tipoTemperatura = $$props.tipoTemperatura);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		peso,
    		temperatura,
    		frecuenciaRespiratoria,
    		frecuenciaCardiaca,
    		presionAlterial,
    		tipoPeso,
    		tipoTemperatura
    	];
    }

    class UltimosVitales extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
    			peso: 0,
    			temperatura: 1,
    			frecuenciaRespiratoria: 2,
    			frecuenciaCardiaca: 3,
    			presionAlterial: 4,
    			tipoPeso: 5,
    			tipoTemperatura: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UltimosVitales",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get peso() {
    		throw new Error("<UltimosVitales>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set peso(value) {
    		throw new Error("<UltimosVitales>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get temperatura() {
    		throw new Error("<UltimosVitales>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set temperatura(value) {
    		throw new Error("<UltimosVitales>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get frecuenciaRespiratoria() {
    		throw new Error("<UltimosVitales>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set frecuenciaRespiratoria(value) {
    		throw new Error("<UltimosVitales>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get frecuenciaCardiaca() {
    		throw new Error("<UltimosVitales>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set frecuenciaCardiaca(value) {
    		throw new Error("<UltimosVitales>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get presionAlterial() {
    		throw new Error("<UltimosVitales>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set presionAlterial(value) {
    		throw new Error("<UltimosVitales>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tipoPeso() {
    		throw new Error("<UltimosVitales>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tipoPeso(value) {
    		throw new Error("<UltimosVitales>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tipoTemperatura() {
    		throw new Error("<UltimosVitales>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tipoTemperatura(value) {
    		throw new Error("<UltimosVitales>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\componentes\CabeceraPerfil.svelte generated by Svelte v3.29.0 */

    const { console: console_1$6 } = globals;
    const file$b = "src\\componentes\\CabeceraPerfil.svelte";

    // (75:14) {#if user().roles.includes('doctor') || user().roles.includes('admin')}
    function create_if_block$7(ctx) {
    	let button;
    	let i;
    	let t;
    	let br;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t = text("\r\n                Iniciar nueva atencin\r\n              ");
    			br = element("br");
    			attr_dev(i, "class", "mdi mdi-progress-check");
    			add_location(i, file$b, 79, 15, 2791);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn text-white mb-2 ml-2 mr-2 ml-3 btn-primary");
    			add_location(button, file$b, 75, 14, 2616);
    			add_location(br, file$b, 81, 23, 2894);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);
    			append_dev(button, t);
    			insert_dev(target, br, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*crearNuevaHistoria*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(br);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(75:14) {#if user().roles.includes('doctor') || user().roles.includes('admin')}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div10;
    	let div9;
    	let div8;
    	let div7;
    	let div4;
    	let div3;
    	let div0;
    	let span0;
    	let t0_value = `${/*nombres*/ ctx[0][0]}${/*apellidos*/ ctx[1][0]}` + "";
    	let t0;
    	let t1;
    	let div2;
    	let h5;
    	let span1;
    	let t2_value = `${/*nombres*/ ctx[0]} ${/*apellidos*/ ctx[1]}` + "";
    	let t2;
    	let t3;
    	let a;
    	let i0;
    	let t4;
    	let t5;
    	let div1;
    	let span2;
    	let t6;
    	let t7;
    	let t8;
    	let span3;
    	let t9;
    	let t10;
    	let t11;
    	let div6;
    	let div5;
    	let show_if = user().roles.includes("doctor") || user().roles.includes("admin");
    	let t12;
    	let button;
    	let i1;
    	let t13;
    	let t14;
    	let modalnuevacita;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = show_if && create_if_block$7(ctx);

    	modalnuevacita = new ModalNuevaCita({
    			props: {
    				pacienteSeleccionado: /*pacienteSeleccionado*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			a = element("a");
    			i0 = element("i");
    			t4 = text(" Ver datos personales");
    			t5 = space();
    			div1 = element("div");
    			span2 = element("span");
    			t6 = text(/*edad*/ ctx[3]);
    			t7 = text(" aos");
    			t8 = text(" | ");
    			span3 = element("span");
    			t9 = text("No. Cedula: ");
    			t10 = text(/*cedula*/ ctx[2]);
    			t11 = space();
    			div6 = element("div");
    			div5 = element("div");
    			if (if_block) if_block.c();
    			t12 = space();
    			button = element("button");
    			i1 = element("i");
    			t13 = text("\r\n                Citas");
    			t14 = space();
    			create_component(modalnuevacita.$$.fragment);
    			attr_dev(span0, "class", "avatar-title rounded-circle");
    			add_location(span0, file$b, 55, 16, 1589);
    			attr_dev(div0, "class", "avatar mr-3  avatar-xl");
    			add_location(div0, file$b, 54, 14, 1535);
    			attr_dev(span1, "data-bind", "text: paciente().nombreParaMostrar");
    			add_location(span1, file$b, 59, 18, 1795);
    			attr_dev(i0, "class", "mdi mdi-comment-eye");
    			add_location(i0, file$b, 62, 20, 2050);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "btn ml-2 btn-primary btn-sm");
    			attr_dev(a, "data-toggle", "modal");
    			attr_dev(a, "data-target", "#modalDatosPersonales");
    			add_location(a, file$b, 60, 18, 1903);
    			attr_dev(h5, "class", "mt-0");
    			add_location(h5, file$b, 58, 16, 1757);
    			attr_dev(span2, "data-bind", "text: paciente().edad");
    			add_location(span2, file$b, 65, 40, 2195);
    			attr_dev(span3, "data-bind", "text: paciente().cedula");
    			add_location(span3, file$b, 65, 101, 2256);
    			attr_dev(div1, "class", "opacity-75");
    			add_location(div1, file$b, 65, 16, 2171);
    			attr_dev(div2, "class", "media-body m-auto");
    			add_location(div2, file$b, 57, 14, 1708);
    			attr_dev(div3, "class", "media");
    			add_location(div3, file$b, 53, 12, 1500);
    			attr_dev(div4, "class", "col-md-6 text-white p-b-30");
    			add_location(div4, file$b, 52, 10, 1446);
    			attr_dev(i1, "class", "mdi mdi-calendar-multiselect");
    			add_location(i1, file$b, 99, 15, 3655);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn text-white m-b-30 ml-2 mr-2 ml-3 btn-primary");
    			attr_dev(button, "data-toggle", "modal");
    			attr_dev(button, "data-target", "#modalNuevaCita");
    			add_location(button, file$b, 83, 14, 2935);
    			attr_dev(div5, "class", "dropdown");
    			add_location(div5, file$b, 73, 12, 2491);
    			attr_dev(div6, "class", "col-md-6");
    			set_style(div6, "text-align", "right");
    			add_location(div6, file$b, 72, 10, 2429);
    			attr_dev(div7, "class", "row p-b-60 p-t-60");
    			add_location(div7, file$b, 51, 8, 1403);
    			attr_dev(div8, "class", "col-md-12");
    			add_location(div8, file$b, 50, 6, 1370);
    			attr_dev(div9, "class", "");
    			add_location(div9, file$b, 49, 4, 1348);
    			attr_dev(div10, "class", "bg-dark m-b-30");
    			add_location(div10, file$b, 48, 0, 1314);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, h5);
    			append_dev(h5, span1);
    			append_dev(span1, t2);
    			append_dev(h5, t3);
    			append_dev(h5, a);
    			append_dev(a, i0);
    			append_dev(a, t4);
    			append_dev(div2, t5);
    			append_dev(div2, div1);
    			append_dev(div1, span2);
    			append_dev(span2, t6);
    			append_dev(span2, t7);
    			append_dev(div1, t8);
    			append_dev(div1, span3);
    			append_dev(span3, t9);
    			append_dev(span3, t10);
    			append_dev(div7, t11);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			if (if_block) if_block.m(div5, null);
    			append_dev(div5, t12);
    			append_dev(div5, button);
    			append_dev(button, i1);
    			append_dev(button, t13);
    			insert_dev(target, t14, anchor);
    			mount_component(modalnuevacita, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*nombres, apellidos*/ 3) && t0_value !== (t0_value = `${/*nombres*/ ctx[0][0]}${/*apellidos*/ ctx[1][0]}` + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*nombres, apellidos*/ 3) && t2_value !== (t2_value = `${/*nombres*/ ctx[0]} ${/*apellidos*/ ctx[1]}` + "")) set_data_dev(t2, t2_value);
    			if (!current || dirty & /*edad*/ 8) set_data_dev(t6, /*edad*/ ctx[3]);
    			if (!current || dirty & /*cedula*/ 4) set_data_dev(t10, /*cedula*/ ctx[2]);
    			if (show_if) if_block.p(ctx, dirty);
    			const modalnuevacita_changes = {};
    			if (dirty & /*pacienteSeleccionado*/ 32) modalnuevacita_changes.pacienteSeleccionado = /*pacienteSeleccionado*/ ctx[5];
    			modalnuevacita.$set(modalnuevacita_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalnuevacita.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalnuevacita.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div10);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t14);
    			destroy_component(modalnuevacita, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CabeceraPerfil", slots, []);
    	let { nombres = "" } = $$props;
    	let { apellidos = "" } = $$props;
    	let { cedula = "" } = $$props;
    	let { edad } = $$props;
    	let { id = "" } = $$props;
    	let { paciente } = $$props;
    	let { cargando } = $$props;
    	let pacienteSeleccionado = {};

    	function crearNuevaHistoria() {
    		const config = {
    			method: "post",
    			url: `${url}/historias`,
    			data: paciente,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		Swal.fire({
    			text: "Quieres crear una nueva consulta para este paciente?",
    			icon: "warning",
    			showCancelButton: true,
    			confirmButtonColor: "#3085d6",
    			cancelButtonColor: "#d33",
    			confirmButtonText: "Si, crear!",
    			cancelButtonText: "Cancelar"
    		}).then(result => {
    			if (result.isConfirmed) {
    				$$invalidate(7, cargando = true);

    				axios$1(config).then(res => {
    					console.log(res.data);
    					push(`/pacientes/${id}/historias/${res.data.id}`);
    					$$invalidate(7, cargando = false);
    				}).catch(error => {
    					$$invalidate(7, cargando = false);
    					console.error(error);
    				});
    			}
    		});
    	}

    	const writable_props = ["nombres", "apellidos", "cedula", "edad", "id", "paciente", "cargando"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<CabeceraPerfil> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(5, pacienteSeleccionado = {
    		id: paciente.id,
    		nombres: paciente.nombres,
    		apellidos: paciente.apellidos,
    		sexo: paciente.sexo,
    		fechaNacimiento: paciente.fechaNacimiento,
    		nacionalidad: paciente.nacionalidad,
    		telefono: paciente.telefono,
    		celular: paciente.celular,
    		cedula: paciente.cedula
    	});

    	$$self.$$set = $$props => {
    		if ("nombres" in $$props) $$invalidate(0, nombres = $$props.nombres);
    		if ("apellidos" in $$props) $$invalidate(1, apellidos = $$props.apellidos);
    		if ("cedula" in $$props) $$invalidate(2, cedula = $$props.cedula);
    		if ("edad" in $$props) $$invalidate(3, edad = $$props.edad);
    		if ("id" in $$props) $$invalidate(8, id = $$props.id);
    		if ("paciente" in $$props) $$invalidate(4, paciente = $$props.paciente);
    		if ("cargando" in $$props) $$invalidate(7, cargando = $$props.cargando);
    	};

    	$$self.$capture_state = () => ({
    		url,
    		user,
    		axios: axios$1,
    		push,
    		ModalNuevaCita,
    		nombres,
    		apellidos,
    		cedula,
    		edad,
    		id,
    		paciente,
    		cargando,
    		pacienteSeleccionado,
    		crearNuevaHistoria
    	});

    	$$self.$inject_state = $$props => {
    		if ("nombres" in $$props) $$invalidate(0, nombres = $$props.nombres);
    		if ("apellidos" in $$props) $$invalidate(1, apellidos = $$props.apellidos);
    		if ("cedula" in $$props) $$invalidate(2, cedula = $$props.cedula);
    		if ("edad" in $$props) $$invalidate(3, edad = $$props.edad);
    		if ("id" in $$props) $$invalidate(8, id = $$props.id);
    		if ("paciente" in $$props) $$invalidate(4, paciente = $$props.paciente);
    		if ("cargando" in $$props) $$invalidate(7, cargando = $$props.cargando);
    		if ("pacienteSeleccionado" in $$props) $$invalidate(5, pacienteSeleccionado = $$props.pacienteSeleccionado);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		nombres,
    		apellidos,
    		cedula,
    		edad,
    		paciente,
    		pacienteSeleccionado,
    		crearNuevaHistoria,
    		cargando,
    		id,
    		click_handler
    	];
    }

    class CabeceraPerfil extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
    			nombres: 0,
    			apellidos: 1,
    			cedula: 2,
    			edad: 3,
    			id: 8,
    			paciente: 4,
    			cargando: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CabeceraPerfil",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*edad*/ ctx[3] === undefined && !("edad" in props)) {
    			console_1$6.warn("<CabeceraPerfil> was created without expected prop 'edad'");
    		}

    		if (/*paciente*/ ctx[4] === undefined && !("paciente" in props)) {
    			console_1$6.warn("<CabeceraPerfil> was created without expected prop 'paciente'");
    		}

    		if (/*cargando*/ ctx[7] === undefined && !("cargando" in props)) {
    			console_1$6.warn("<CabeceraPerfil> was created without expected prop 'cargando'");
    		}
    	}

    	get nombres() {
    		throw new Error("<CabeceraPerfil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nombres(value) {
    		throw new Error("<CabeceraPerfil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get apellidos() {
    		throw new Error("<CabeceraPerfil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set apellidos(value) {
    		throw new Error("<CabeceraPerfil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cedula() {
    		throw new Error("<CabeceraPerfil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cedula(value) {
    		throw new Error("<CabeceraPerfil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get edad() {
    		throw new Error("<CabeceraPerfil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set edad(value) {
    		throw new Error("<CabeceraPerfil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<CabeceraPerfil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<CabeceraPerfil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get paciente() {
    		throw new Error("<CabeceraPerfil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set paciente(value) {
    		throw new Error("<CabeceraPerfil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cargando() {
    		throw new Error("<CabeceraPerfil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cargando(value) {
    		throw new Error("<CabeceraPerfil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function requiredArgs(required, args) {
      if (args.length < required) {
        throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
      }
    }

    /**
     * @name toDate
     * @category Common Helpers
     * @summary Convert the given argument to an instance of Date.
     *
     * @description
     * Convert the given argument to an instance of Date.
     *
     * If the argument is an instance of Date, the function returns its clone.
     *
     * If the argument is a number, it is treated as a timestamp.
     *
     * If the argument is none of the above, the function returns Invalid Date.
     *
     * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
     *
     * @param {Date|Number} argument - the value to convert
     * @returns {Date} the parsed date in the local time zone
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Clone the date:
     * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
     * //=> Tue Feb 11 2014 11:30:30
     *
     * @example
     * // Convert the timestamp to date:
     * const result = toDate(1392098430000)
     * //=> Tue Feb 11 2014 11:30:30
     */

    function toDate(argument) {
      requiredArgs(1, arguments);
      var argStr = Object.prototype.toString.call(argument); // Clone the date

      if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new Date(argument.getTime());
      } else if (typeof argument === 'number' || argStr === '[object Number]') {
        return new Date(argument);
      } else {
        if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
          // eslint-disable-next-line no-console
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

          console.warn(new Error().stack);
        }

        return new Date(NaN);
      }
    }

    /**
     * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
     * They usually appear for dates that denote time before the timezones were introduced
     * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
     * and GMT+01:00:00 after that date)
     *
     * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
     * which would lead to incorrect calculations.
     *
     * This function returns the timezone offset in milliseconds that takes seconds in account.
     */
    function getTimezoneOffsetInMilliseconds(date) {
      var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      utcDate.setUTCFullYear(date.getFullYear());
      return date.getTime() - utcDate.getTime();
    }

    /**
     * @name startOfDay
     * @category Day Helpers
     * @summary Return the start of a day for the given date.
     *
     * @description
     * Return the start of a day for the given date.
     * The result will be in the local timezone.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a day
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a day for 2 September 2014 11:55:00:
     * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 02 2014 00:00:00
     */

    function startOfDay(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    var MILLISECONDS_IN_DAY = 86400000;
    /**
     * @name differenceInCalendarDays
     * @category Day Helpers
     * @summary Get the number of calendar days between the given dates.
     *
     * @description
     * Get the number of calendar days between the given dates. This means that the times are removed
     * from the dates and then the difference in days is calculated.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of calendar days
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many calendar days are between
     * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
     * const result = differenceInCalendarDays(
     *   new Date(2012, 6, 2, 0, 0),
     *   new Date(2011, 6, 2, 23, 0)
     * )
     * //=> 366
     * // How many calendar days are between
     * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
     * const result = differenceInCalendarDays(
     *   new Date(2011, 6, 3, 0, 1),
     *   new Date(2011, 6, 2, 23, 59)
     * )
     * //=> 1
     */

    function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var startOfDayLeft = startOfDay(dirtyDateLeft);
      var startOfDayRight = startOfDay(dirtyDateRight);
      var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
      var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight); // Round the number of days to the nearest integer
      // because the number of milliseconds in a day is not constant
      // (e.g. it's different in the day of the daylight saving time clock shift)

      return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
    }

    // for accurate equality comparisons of UTC timestamps that end up
    // having the same representation in local time, e.g. one hour before
    // DST ends vs. the instant that DST ends.

    function compareLocalAsc(dateLeft, dateRight) {
      var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();

      if (diff < 0) {
        return -1;
      } else if (diff > 0) {
        return 1; // Return 0 if diff is 0; return NaN if diff is NaN
      } else {
        return diff;
      }
    }
    /**
     * @name differenceInDays
     * @category Day Helpers
     * @summary Get the number of full days between the given dates.
     *
     * @description
     * Get the number of full day periods between two dates. Fractional days are
     * truncated towards zero.
     *
     * One "full day" is the distance between a local time in one day to the same
     * local time on the next or previous day. A full day can sometimes be less than
     * or more than 24 hours if a daylight savings change happens between two dates.
     *
     * To ignore DST and only measure exact 24-hour periods, use this instead:
     * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
     *
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of full days according to the local timezone
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many full days are between
     * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
     * const result = differenceInDays(
     *   new Date(2012, 6, 2, 0, 0),
     *   new Date(2011, 6, 2, 23, 0)
     * )
     * //=> 365
     * // How many full days are between
     * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
     * const result = differenceInDays(
     *   new Date(2011, 6, 3, 0, 1),
     *   new Date(2011, 6, 2, 23, 59)
     * )
     * //=> 0
     * // How many full days are between
     * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
     * // Note: because local time is used, the
     * // result will always be 92 days, even in
     * // time zones where DST starts and the
     * // period has only 92*24-1 hours.
     * const result = differenceInDays(
     *   new Date(2020, 5, 1),
     *   new Date(2020, 2, 1)
     * )
    //=> 92
     */


    function differenceInDays(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var sign = compareLocalAsc(dateLeft, dateRight);
      var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
      dateLeft.setDate(dateLeft.getDate() - sign * difference); // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
      // If so, result must be decreased by 1 in absolute value

      var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);
      var result = sign * (difference - isLastDayNotFull); // Prevent negative zero

      return result === 0 ? 0 : result;
    }

    /* src\componentes\Modals\ModalDatosPaciente.svelte generated by Svelte v3.29.0 */
    const file$c = "src\\componentes\\Modals\\ModalDatosPaciente.svelte";

    // (47:24) {:else}
    function create_else_block$1(ctx) {
    	let div;
    	let span1;
    	let i;
    	let t0;
    	let span0;
    	let t1_value = moment(/*paciente*/ ctx[0].updatedAt).fromNow() + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span1 = element("span");
    			i = element("i");
    			t0 = text(" Ultima vez modificado\r\n                                ");
    			span0 = element("span");
    			t1 = text(t1_value);
    			attr_dev(i, "class", "mdi mdi-calendar-alert");
    			add_location(i, file$c, 48, 61, 2278);
    			add_location(span0, file$c, 49, 32, 2372);
    			attr_dev(span1, "class", "badge badge-danger");
    			add_location(span1, file$c, 48, 28, 2245);
    			attr_dev(div, "class", "m-auto");
    			add_location(div, file$c, 47, 24, 2195);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span1);
    			append_dev(span1, i);
    			append_dev(span1, t0);
    			append_dev(span1, span0);
    			append_dev(span0, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*paciente*/ 1 && t1_value !== (t1_value = moment(/*paciente*/ ctx[0].updatedAt).fromNow() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(47:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (42:24) {#if differenceInDays(Date.now(), paciente.updatedAt)  < 90 }
    function create_if_block$8(ctx) {
    	let div;
    	let span1;
    	let t0;
    	let span0;
    	let t1_value = moment(/*paciente*/ ctx[0].updatedAt).fromNow() + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span1 = element("span");
    			t0 = text("Ultima vez modificado\r\n                                ");
    			span0 = element("span");
    			t1 = text(t1_value);
    			add_location(span0, file$c, 44, 32, 2046);
    			attr_dev(span1, "class", "badge badge-primary");
    			add_location(span1, file$c, 43, 28, 1957);
    			attr_dev(div, "class", "m-auto");
    			add_location(div, file$c, 42, 24, 1907);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span1);
    			append_dev(span1, t0);
    			append_dev(span1, span0);
    			append_dev(span0, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*paciente*/ 1 && t1_value !== (t1_value = moment(/*paciente*/ ctx[0].updatedAt).fromNow() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(42:24) {#if differenceInDays(Date.now(), paciente.updatedAt)  < 90 }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div46;
    	let div45;
    	let div44;
    	let div0;
    	let h5;
    	let t1;
    	let button;
    	let span0;
    	let t3;
    	let div35;
    	let div4;
    	let div2;
    	let div1;
    	let img;
    	let img_src_value;
    	let t4;
    	let h30;
    	let a0;
    	let t5_value = /*paciente*/ ctx[0].nombres + "";
    	let t5;
    	let t6;
    	let t7_value = /*paciente*/ ctx[0].apellidos + "";
    	let t7;
    	let t8;
    	let div3;
    	let t9_value = (/*paciente*/ ctx[0].email || "N/A") + "";
    	let t9;
    	let t10;
    	let show_if;
    	let t11;
    	let hr0;
    	let t12;
    	let form;
    	let div25;
    	let div6;
    	let div5;
    	let sapn;
    	let t14;
    	let strong0;
    	let t15_value = (/*paciente*/ ctx[0].cedula || "N/A") + "";
    	let t15;
    	let t16;
    	let div8;
    	let div7;
    	let span1;
    	let t18;
    	let strong1;
    	let t19_value = (/*paciente*/ ctx[0].nombres || "N/A") + "";
    	let t19;
    	let t20;
    	let div10;
    	let div9;
    	let span2;
    	let t22;
    	let strong2;
    	let t23_value = (/*paciente*/ ctx[0].apellidos || "N/A") + "";
    	let t23;
    	let t24;
    	let div12;
    	let div11;
    	let span3;
    	let t26;
    	let strong3;
    	let t27_value = (/*paciente*/ ctx[0].sexo || "N/A") + "";
    	let t27;
    	let t28;
    	let div14;
    	let div13;
    	let span4;
    	let t30;
    	let strong4;
    	let t31_value = (/*edad*/ ctx[1] || "N/A") + "";
    	let t31;
    	let t32;
    	let t33;
    	let div16;
    	let div15;
    	let span5;
    	let t35;
    	let strong5;
    	let t36_value = (new Date(/*paciente*/ ctx[0].fechaNacimiento).toLocaleDateString("es-DO") || "N/A") + "";
    	let t36;
    	let t37;
    	let div18;
    	let div17;
    	let span6;
    	let t39;
    	let strong6;
    	let t40_value = (/*paciente*/ ctx[0].telefono || "N/A") + "";
    	let t40;
    	let t41;
    	let div20;
    	let div19;
    	let span7;
    	let t43;
    	let strong7;
    	let t44_value = (/*paciente*/ ctx[0].celular || "N/A") + "";
    	let t44;
    	let t45;
    	let div22;
    	let div21;
    	let span8;
    	let t47;
    	let strong8;
    	let t48_value = (/*seguro*/ ctx[2] || "N/A") + "";
    	let t48;
    	let t49;
    	let div24;
    	let div23;
    	let span9;
    	let t51;
    	let strong9;
    	let t52_value = (/*paciente*/ ctx[0].numeroSeguro || "N/A") + "";
    	let t52;
    	let t53;
    	let p;
    	let span10;
    	let t55;
    	let hr1;
    	let t56;
    	let div34;
    	let div27;
    	let div26;
    	let span11;
    	let t58;
    	let strong10;
    	let t59_value = (/*paciente*/ ctx[0].direccion || "N/A") + "";
    	let t59;
    	let t60;
    	let div29;
    	let div28;
    	let span12;
    	let t62;
    	let strong11;
    	let t63_value = (/*paciente*/ ctx[0].provincia || "N/A") + "";
    	let t63;
    	let t64;
    	let div31;
    	let div30;
    	let span13;
    	let t66;
    	let strong12;
    	let t67_value = (/*paciente*/ ctx[0].ciudad || "N/A") + "";
    	let t67;
    	let t68;
    	let div33;
    	let div32;
    	let span14;
    	let t70;
    	let strong13;
    	let t71_value = (/*paciente*/ ctx[0].nacionalidad || "N/A") + "";
    	let t71;
    	let t72;
    	let div43;
    	let div42;
    	let div37;
    	let a1;
    	let h31;
    	let t73;
    	let div36;
    	let t75;
    	let div39;
    	let a2;
    	let h32;
    	let t76;
    	let div38;
    	let a2_href_value;
    	let link_action;
    	let t78;
    	let div41;
    	let a3;
    	let h33;
    	let t79;
    	let div40;
    	let a3_href_value;
    	let link_action_1;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (show_if == null || dirty & /*paciente*/ 1) show_if = !!(differenceInDays(Date.now(), /*paciente*/ ctx[0].updatedAt) < 90);
    		if (show_if) return create_if_block$8;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div46 = element("div");
    			div45 = element("div");
    			div44 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Datos del paciente";
    			t1 = space();
    			button = element("button");
    			span0 = element("span");
    			span0.textContent = "";
    			t3 = space();
    			div35 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			img = element("img");
    			t4 = space();
    			h30 = element("h3");
    			a0 = element("a");
    			t5 = text(t5_value);
    			t6 = space();
    			t7 = text(t7_value);
    			t8 = space();
    			div3 = element("div");
    			t9 = text(t9_value);
    			t10 = space();
    			if_block.c();
    			t11 = space();
    			hr0 = element("hr");
    			t12 = space();
    			form = element("form");
    			div25 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			sapn = element("sapn");
    			sapn.textContent = "Cedula / pasaporte";
    			t14 = space();
    			strong0 = element("strong");
    			t15 = text(t15_value);
    			t16 = space();
    			div8 = element("div");
    			div7 = element("div");
    			span1 = element("span");
    			span1.textContent = "Nombres";
    			t18 = space();
    			strong1 = element("strong");
    			t19 = text(t19_value);
    			t20 = space();
    			div10 = element("div");
    			div9 = element("div");
    			span2 = element("span");
    			span2.textContent = "Apellidos";
    			t22 = space();
    			strong2 = element("strong");
    			t23 = text(t23_value);
    			t24 = space();
    			div12 = element("div");
    			div11 = element("div");
    			span3 = element("span");
    			span3.textContent = "Sexo";
    			t26 = space();
    			strong3 = element("strong");
    			t27 = text(t27_value);
    			t28 = space();
    			div14 = element("div");
    			div13 = element("div");
    			span4 = element("span");
    			span4.textContent = "Edad";
    			t30 = space();
    			strong4 = element("strong");
    			t31 = text(t31_value);
    			t32 = text(" aos");
    			t33 = space();
    			div16 = element("div");
    			div15 = element("div");
    			span5 = element("span");
    			span5.textContent = "Fecha Nacimiento";
    			t35 = space();
    			strong5 = element("strong");
    			t36 = text(t36_value);
    			t37 = space();
    			div18 = element("div");
    			div17 = element("div");
    			span6 = element("span");
    			span6.textContent = "Telefono";
    			t39 = space();
    			strong6 = element("strong");
    			t40 = text(t40_value);
    			t41 = space();
    			div20 = element("div");
    			div19 = element("div");
    			span7 = element("span");
    			span7.textContent = "Celular";
    			t43 = space();
    			strong7 = element("strong");
    			t44 = text(t44_value);
    			t45 = space();
    			div22 = element("div");
    			div21 = element("div");
    			span8 = element("span");
    			span8.textContent = "Seguro Medico";
    			t47 = space();
    			strong8 = element("strong");
    			t48 = text(t48_value);
    			t49 = space();
    			div24 = element("div");
    			div23 = element("div");
    			span9 = element("span");
    			span9.textContent = "No. Seguro";
    			t51 = space();
    			strong9 = element("strong");
    			t52 = text(t52_value);
    			t53 = space();
    			p = element("p");
    			span10 = element("span");
    			span10.textContent = "Datos demogrficos";
    			t55 = space();
    			hr1 = element("hr");
    			t56 = space();
    			div34 = element("div");
    			div27 = element("div");
    			div26 = element("div");
    			span11 = element("span");
    			span11.textContent = "Direccin";
    			t58 = space();
    			strong10 = element("strong");
    			t59 = text(t59_value);
    			t60 = space();
    			div29 = element("div");
    			div28 = element("div");
    			span12 = element("span");
    			span12.textContent = "Provincia";
    			t62 = space();
    			strong11 = element("strong");
    			t63 = text(t63_value);
    			t64 = space();
    			div31 = element("div");
    			div30 = element("div");
    			span13 = element("span");
    			span13.textContent = "Ciudad";
    			t66 = space();
    			strong12 = element("strong");
    			t67 = text(t67_value);
    			t68 = space();
    			div33 = element("div");
    			div32 = element("div");
    			span14 = element("span");
    			span14.textContent = "Nacionalidad";
    			t70 = space();
    			strong13 = element("strong");
    			t71 = text(t71_value);
    			t72 = space();
    			div43 = element("div");
    			div42 = element("div");
    			div37 = element("div");
    			a1 = element("a");
    			h31 = element("h3");
    			t73 = space();
    			div36 = element("div");
    			div36.textContent = "Cerrar";
    			t75 = space();
    			div39 = element("div");
    			a2 = element("a");
    			h32 = element("h3");
    			t76 = space();
    			div38 = element("div");
    			div38.textContent = "Editar";
    			t78 = space();
    			div41 = element("div");
    			a3 = element("a");
    			h33 = element("h3");
    			t79 = space();
    			div40 = element("div");
    			div40.textContent = "Perfil";
    			attr_dev(h5, "class", "modal-title");
    			attr_dev(h5, "id", "modalDatosPersonales");
    			add_location(h5, file$c, 20, 20, 737);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$c, 22, 24, 934);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "close");
    			attr_dev(button, "data-dismiss", "modal");
    			attr_dev(button, "aria-label", "Close");
    			add_location(button, file$c, 21, 20, 832);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$c, 19, 16, 689);
    			attr_dev(img, "class", "avatar-img rounded-circle");
    			if (img.src !== (img_src_value = "https://picsum.photos/200/300")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "imagen paciente");
    			add_location(img, file$c, 30, 32, 1238);
    			attr_dev(div1, "class", "avatar avatar-xl");
    			add_location(div1, file$c, 29, 28, 1174);
    			add_location(div2, file$c, 28, 24, 1139);
    			attr_dev(a0, "href", "/");
    			add_location(a0, file$c, 34, 28, 1492);
    			attr_dev(h30, "class", "p-t-10 searchBy-name");
    			add_location(h30, file$c, 33, 24, 1429);
    			attr_dev(div3, "class", "text-muted text-center m-b-10");
    			add_location(div3, file$c, 38, 24, 1664);
    			attr_dev(div4, "class", "text-center");
    			add_location(div4, file$c, 27, 20, 1088);
    			add_location(hr0, file$c, 53, 20, 2543);
    			attr_dev(sapn, "class", "text-primary");
    			add_location(sapn, file$c, 58, 36, 2832);
    			attr_dev(strong0, "class", "d-block");
    			add_location(strong0, file$c, 59, 36, 2922);
    			attr_dev(div5, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div5, file$c, 57, 32, 2754);
    			attr_dev(div6, "class", "form-group col-md-6");
    			add_location(div6, file$c, 56, 28, 2687);
    			attr_dev(span1, "class", "text-primary");
    			add_location(span1, file$c, 64, 36, 3234);
    			attr_dev(strong1, "class", "d-block");
    			add_location(strong1, file$c, 65, 36, 3313);
    			attr_dev(div7, "class", " bg-gray-100 p-2 rounded-sm");
    			add_location(div7, file$c, 63, 32, 3155);
    			attr_dev(div8, "class", "form-group col-md-6");
    			add_location(div8, file$c, 62, 28, 3088);
    			attr_dev(span2, "class", "text-primary");
    			add_location(span2, file$c, 70, 36, 3626);
    			attr_dev(strong2, "class", "d-block");
    			add_location(strong2, file$c, 71, 36, 3707);
    			attr_dev(div9, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div9, file$c, 69, 32, 3548);
    			attr_dev(div10, "class", "form-group col-md-6");
    			add_location(div10, file$c, 68, 28, 3481);
    			attr_dev(span3, "class", "text-primary");
    			add_location(span3, file$c, 76, 36, 4022);
    			attr_dev(strong3, "class", "d-block");
    			add_location(strong3, file$c, 77, 36, 4098);
    			attr_dev(div11, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div11, file$c, 75, 32, 3944);
    			attr_dev(div12, "class", "form-group col-md-6");
    			add_location(div12, file$c, 74, 28, 3877);
    			attr_dev(span4, "class", "text-primary");
    			add_location(span4, file$c, 82, 36, 4408);
    			attr_dev(strong4, "class", "d-block");
    			add_location(strong4, file$c, 83, 36, 4484);
    			attr_dev(div13, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div13, file$c, 81, 32, 4330);
    			attr_dev(div14, "class", "form-group col-md-6");
    			add_location(div14, file$c, 80, 28, 4263);
    			attr_dev(span5, "class", "text-primary");
    			add_location(span5, file$c, 88, 36, 4790);
    			attr_dev(strong5, "class", "d-block");
    			add_location(strong5, file$c, 89, 36, 4878);
    			attr_dev(div15, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div15, file$c, 87, 32, 4712);
    			attr_dev(div16, "class", "form-group col-md-6");
    			add_location(div16, file$c, 86, 28, 4645);
    			attr_dev(span6, "class", "text-primary");
    			add_location(span6, file$c, 94, 36, 5238);
    			attr_dev(strong6, "class", "d-block");
    			add_location(strong6, file$c, 95, 36, 5318);
    			attr_dev(div17, "class", " bg-gray-100 p-2 rounded-sm");
    			add_location(div17, file$c, 93, 32, 5159);
    			attr_dev(div18, "class", "form-group col-md-6");
    			add_location(div18, file$c, 92, 28, 5092);
    			attr_dev(span7, "class", "text-primary");
    			add_location(span7, file$c, 100, 36, 5632);
    			attr_dev(strong7, "class", "d-block");
    			add_location(strong7, file$c, 101, 36, 5711);
    			attr_dev(div19, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div19, file$c, 99, 32, 5554);
    			attr_dev(div20, "class", "form-group col-md-6");
    			add_location(div20, file$c, 98, 28, 5487);
    			attr_dev(span8, "class", "text-primary");
    			add_location(span8, file$c, 106, 36, 6025);
    			attr_dev(strong8, "class", "d-block");
    			add_location(strong8, file$c, 107, 36, 6110);
    			attr_dev(div21, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div21, file$c, 105, 32, 5947);
    			attr_dev(div22, "class", "form-group col-md-6 ");
    			add_location(div22, file$c, 104, 28, 5879);
    			attr_dev(span9, "class", "text-primary");
    			add_location(span9, file$c, 112, 36, 6414);
    			attr_dev(strong9, "class", "d-block");
    			add_location(strong9, file$c, 113, 36, 6496);
    			attr_dev(div23, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div23, file$c, 111, 32, 6336);
    			attr_dev(div24, "class", "form-group col-md-6 ");
    			add_location(div24, file$c, 110, 28, 6268);
    			attr_dev(div25, "class", "form-row");
    			add_location(div25, file$c, 55, 24, 2635);
    			attr_dev(span10, "class", "badge badge-primary");
    			add_location(span10, file$c, 117, 64, 6737);
    			attr_dev(p, "class", "mt-3");
    			set_style(p, "font-size", "18px");
    			add_location(p, file$c, 117, 24, 6697);
    			add_location(hr1, file$c, 118, 24, 6826);
    			attr_dev(span11, "for", "inpDireccion");
    			attr_dev(span11, "class", "text-primary");
    			add_location(span11, file$c, 122, 36, 7055);
    			attr_dev(strong10, "class", "d-block");
    			add_location(strong10, file$c, 123, 36, 7162);
    			attr_dev(div26, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div26, file$c, 121, 32, 6977);
    			attr_dev(div27, "class", "form-group col-md-12 ");
    			add_location(div27, file$c, 120, 28, 6908);
    			attr_dev(span12, "class", "text-primary");
    			add_location(span12, file$c, 128, 36, 7478);
    			attr_dev(strong11, "class", "d-block");
    			add_location(strong11, file$c, 129, 36, 7559);
    			attr_dev(div28, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div28, file$c, 127, 32, 7400);
    			attr_dev(div29, "class", "form-group col-md-6 ");
    			add_location(div29, file$c, 126, 28, 7332);
    			attr_dev(span13, "class", "text-primary");
    			add_location(span13, file$c, 134, 36, 7875);
    			attr_dev(strong12, "class", "d-block");
    			add_location(strong12, file$c, 135, 36, 7953);
    			attr_dev(div30, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div30, file$c, 133, 32, 7797);
    			attr_dev(div31, "class", "form-group col-md-6 ");
    			add_location(div31, file$c, 132, 28, 7729);
    			attr_dev(span14, "for", "inpPais");
    			attr_dev(span14, "class", "text-primary");
    			add_location(span14, file$c, 140, 36, 8266);
    			attr_dev(strong13, "class", "d-block");
    			add_location(strong13, file$c, 141, 36, 8364);
    			attr_dev(div32, "class", "bg-gray-100 p-2 rounded-sm");
    			add_location(div32, file$c, 139, 32, 8188);
    			attr_dev(div33, "class", "form-group col-md-6 ");
    			add_location(div33, file$c, 138, 28, 8120);
    			attr_dev(div34, "class", "form-row");
    			add_location(div34, file$c, 119, 24, 6856);
    			attr_dev(form, "class", "form-group floating-label");
    			add_location(form, file$c, 54, 20, 2569);
    			attr_dev(div35, "class", "modal-body");
    			add_location(div35, file$c, 25, 16, 1040);
    			attr_dev(h31, "class", "mdi mdi-close-outline");
    			add_location(h31, file$c, 155, 32, 8966);
    			attr_dev(div36, "class", "text-overline");
    			add_location(div36, file$c, 156, 32, 9039);
    			attr_dev(a1, "href", "#!");
    			attr_dev(a1, "class", "text-danger");
    			attr_dev(a1, "data-dismiss", "modal");
    			add_location(a1, file$c, 153, 28, 8801);
    			attr_dev(div37, "class", "col");
    			add_location(div37, file$c, 152, 24, 8754);
    			attr_dev(h32, "class", "mdi mdi-account-edit");
    			add_location(h32, file$c, 162, 32, 9466);
    			attr_dev(div38, "class", "text-overline");
    			add_location(div38, file$c, 163, 32, 9538);
    			attr_dev(a2, "href", a2_href_value = `/pacientes/${/*paciente*/ ctx[0].id}/editar`);
    			attr_dev(a2, "class", "text-success");
    			add_location(a2, file$c, 160, 28, 9217);
    			attr_dev(div39, "class", "col");
    			add_location(div39, file$c, 159, 24, 9170);
    			attr_dev(h33, "class", "mdi mdi-folder-account-outline");
    			add_location(h33, file$c, 170, 32, 10034);
    			attr_dev(div40, "class", "text-overline");
    			add_location(div40, file$c, 171, 32, 10116);
    			attr_dev(a3, "href", a3_href_value = `/pacientes/perfil/${/*paciente*/ ctx[0].id}`);
    			attr_dev(a3, "class", "text-info");
    			add_location(a3, file$c, 168, 28, 9788);
    			attr_dev(div41, "class", "col");
    			add_location(div41, file$c, 166, 24, 9669);
    			attr_dev(div42, "class", "row text-center p-b-10");
    			add_location(div42, file$c, 151, 20, 8692);
    			attr_dev(div43, "class", "modal-footer");
    			add_location(div43, file$c, 150, 16, 8644);
    			attr_dev(div44, "class", "modal-content");
    			add_location(div44, file$c, 18, 12, 644);
    			attr_dev(div45, "class", "modal-dialog");
    			attr_dev(div45, "role", "document");
    			add_location(div45, file$c, 17, 8, 588);
    			attr_dev(div46, "class", "modal fade modal-slide-right");
    			attr_dev(div46, "id", "modalDatosPersonales");
    			attr_dev(div46, "tabindex", "-1");
    			attr_dev(div46, "role", "dialog");
    			attr_dev(div46, "aria-labelledby", "modalDatosPersonales");
    			set_style(div46, "display", "none");
    			set_style(div46, "padding-right", "16px");
    			attr_dev(div46, "aria-modal", "true");
    			add_location(div46, file$c, 15, 0, 372);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div46, anchor);
    			append_dev(div46, div45);
    			append_dev(div45, div44);
    			append_dev(div44, div0);
    			append_dev(div0, h5);
    			append_dev(div0, t1);
    			append_dev(div0, button);
    			append_dev(button, span0);
    			append_dev(div44, t3);
    			append_dev(div44, div35);
    			append_dev(div35, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, img);
    			append_dev(div4, t4);
    			append_dev(div4, h30);
    			append_dev(h30, a0);
    			append_dev(a0, t5);
    			append_dev(a0, t6);
    			append_dev(a0, t7);
    			append_dev(div4, t8);
    			append_dev(div4, div3);
    			append_dev(div3, t9);
    			append_dev(div4, t10);
    			if_block.m(div4, null);
    			append_dev(div35, t11);
    			append_dev(div35, hr0);
    			append_dev(div35, t12);
    			append_dev(div35, form);
    			append_dev(form, div25);
    			append_dev(div25, div6);
    			append_dev(div6, div5);
    			append_dev(div5, sapn);
    			append_dev(div5, t14);
    			append_dev(div5, strong0);
    			append_dev(strong0, t15);
    			append_dev(div25, t16);
    			append_dev(div25, div8);
    			append_dev(div8, div7);
    			append_dev(div7, span1);
    			append_dev(div7, t18);
    			append_dev(div7, strong1);
    			append_dev(strong1, t19);
    			append_dev(div25, t20);
    			append_dev(div25, div10);
    			append_dev(div10, div9);
    			append_dev(div9, span2);
    			append_dev(div9, t22);
    			append_dev(div9, strong2);
    			append_dev(strong2, t23);
    			append_dev(div25, t24);
    			append_dev(div25, div12);
    			append_dev(div12, div11);
    			append_dev(div11, span3);
    			append_dev(div11, t26);
    			append_dev(div11, strong3);
    			append_dev(strong3, t27);
    			append_dev(div25, t28);
    			append_dev(div25, div14);
    			append_dev(div14, div13);
    			append_dev(div13, span4);
    			append_dev(div13, t30);
    			append_dev(div13, strong4);
    			append_dev(strong4, t31);
    			append_dev(strong4, t32);
    			append_dev(div25, t33);
    			append_dev(div25, div16);
    			append_dev(div16, div15);
    			append_dev(div15, span5);
    			append_dev(div15, t35);
    			append_dev(div15, strong5);
    			append_dev(strong5, t36);
    			append_dev(div25, t37);
    			append_dev(div25, div18);
    			append_dev(div18, div17);
    			append_dev(div17, span6);
    			append_dev(div17, t39);
    			append_dev(div17, strong6);
    			append_dev(strong6, t40);
    			append_dev(div25, t41);
    			append_dev(div25, div20);
    			append_dev(div20, div19);
    			append_dev(div19, span7);
    			append_dev(div19, t43);
    			append_dev(div19, strong7);
    			append_dev(strong7, t44);
    			append_dev(div25, t45);
    			append_dev(div25, div22);
    			append_dev(div22, div21);
    			append_dev(div21, span8);
    			append_dev(div21, t47);
    			append_dev(div21, strong8);
    			append_dev(strong8, t48);
    			append_dev(div25, t49);
    			append_dev(div25, div24);
    			append_dev(div24, div23);
    			append_dev(div23, span9);
    			append_dev(div23, t51);
    			append_dev(div23, strong9);
    			append_dev(strong9, t52);
    			append_dev(form, t53);
    			append_dev(form, p);
    			append_dev(p, span10);
    			append_dev(form, t55);
    			append_dev(form, hr1);
    			append_dev(form, t56);
    			append_dev(form, div34);
    			append_dev(div34, div27);
    			append_dev(div27, div26);
    			append_dev(div26, span11);
    			append_dev(div26, t58);
    			append_dev(div26, strong10);
    			append_dev(strong10, t59);
    			append_dev(div34, t60);
    			append_dev(div34, div29);
    			append_dev(div29, div28);
    			append_dev(div28, span12);
    			append_dev(div28, t62);
    			append_dev(div28, strong11);
    			append_dev(strong11, t63);
    			append_dev(div34, t64);
    			append_dev(div34, div31);
    			append_dev(div31, div30);
    			append_dev(div30, span13);
    			append_dev(div30, t66);
    			append_dev(div30, strong12);
    			append_dev(strong12, t67);
    			append_dev(div34, t68);
    			append_dev(div34, div33);
    			append_dev(div33, div32);
    			append_dev(div32, span14);
    			append_dev(div32, t70);
    			append_dev(div32, strong13);
    			append_dev(strong13, t71);
    			append_dev(div44, t72);
    			append_dev(div44, div43);
    			append_dev(div43, div42);
    			append_dev(div42, div37);
    			append_dev(div37, a1);
    			append_dev(a1, h31);
    			append_dev(a1, t73);
    			append_dev(a1, div36);
    			append_dev(div42, t75);
    			append_dev(div42, div39);
    			append_dev(div39, a2);
    			append_dev(a2, h32);
    			append_dev(a2, t76);
    			append_dev(a2, div38);
    			append_dev(div42, t78);
    			append_dev(div42, div41);
    			append_dev(div41, a3);
    			append_dev(a3, h33);
    			append_dev(a3, t79);
    			append_dev(a3, div40);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link_action = link.call(null, a2)),
    					listen_dev(a2, "click", /*click_handler*/ ctx[3], false, false, false),
    					action_destroyer(link_action_1 = link.call(null, a3)),
    					listen_dev(a3, "click", /*click_handler_1*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*paciente*/ 1 && t5_value !== (t5_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*paciente*/ 1 && t7_value !== (t7_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*paciente*/ 1 && t9_value !== (t9_value = (/*paciente*/ ctx[0].email || "N/A") + "")) set_data_dev(t9, t9_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div4, null);
    				}
    			}

    			if (dirty & /*paciente*/ 1 && t15_value !== (t15_value = (/*paciente*/ ctx[0].cedula || "N/A") + "")) set_data_dev(t15, t15_value);
    			if (dirty & /*paciente*/ 1 && t19_value !== (t19_value = (/*paciente*/ ctx[0].nombres || "N/A") + "")) set_data_dev(t19, t19_value);
    			if (dirty & /*paciente*/ 1 && t23_value !== (t23_value = (/*paciente*/ ctx[0].apellidos || "N/A") + "")) set_data_dev(t23, t23_value);
    			if (dirty & /*paciente*/ 1 && t27_value !== (t27_value = (/*paciente*/ ctx[0].sexo || "N/A") + "")) set_data_dev(t27, t27_value);
    			if (dirty & /*edad*/ 2 && t31_value !== (t31_value = (/*edad*/ ctx[1] || "N/A") + "")) set_data_dev(t31, t31_value);
    			if (dirty & /*paciente*/ 1 && t36_value !== (t36_value = (new Date(/*paciente*/ ctx[0].fechaNacimiento).toLocaleDateString("es-DO") || "N/A") + "")) set_data_dev(t36, t36_value);
    			if (dirty & /*paciente*/ 1 && t40_value !== (t40_value = (/*paciente*/ ctx[0].telefono || "N/A") + "")) set_data_dev(t40, t40_value);
    			if (dirty & /*paciente*/ 1 && t44_value !== (t44_value = (/*paciente*/ ctx[0].celular || "N/A") + "")) set_data_dev(t44, t44_value);
    			if (dirty & /*seguro*/ 4 && t48_value !== (t48_value = (/*seguro*/ ctx[2] || "N/A") + "")) set_data_dev(t48, t48_value);
    			if (dirty & /*paciente*/ 1 && t52_value !== (t52_value = (/*paciente*/ ctx[0].numeroSeguro || "N/A") + "")) set_data_dev(t52, t52_value);
    			if (dirty & /*paciente*/ 1 && t59_value !== (t59_value = (/*paciente*/ ctx[0].direccion || "N/A") + "")) set_data_dev(t59, t59_value);
    			if (dirty & /*paciente*/ 1 && t63_value !== (t63_value = (/*paciente*/ ctx[0].provincia || "N/A") + "")) set_data_dev(t63, t63_value);
    			if (dirty & /*paciente*/ 1 && t67_value !== (t67_value = (/*paciente*/ ctx[0].ciudad || "N/A") + "")) set_data_dev(t67, t67_value);
    			if (dirty & /*paciente*/ 1 && t71_value !== (t71_value = (/*paciente*/ ctx[0].nacionalidad || "N/A") + "")) set_data_dev(t71, t71_value);

    			if (dirty & /*paciente*/ 1 && a2_href_value !== (a2_href_value = `/pacientes/${/*paciente*/ ctx[0].id}/editar`)) {
    				attr_dev(a2, "href", a2_href_value);
    			}

    			if (dirty & /*paciente*/ 1 && a3_href_value !== (a3_href_value = `/pacientes/perfil/${/*paciente*/ ctx[0].id}`)) {
    				attr_dev(a3, "href", a3_href_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div46);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ModalDatosPaciente", slots, []);
    	let { paciente = {} } = $$props;
    	let { edad = "" } = $$props;
    	let { seguro = "" } = $$props;

    	onMount(() => {
    		moment.locale("es");
    	});

    	const writable_props = ["paciente", "edad", "seguro"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ModalDatosPaciente> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => jQuery("#modalDatosPersonales").modal("hide");
    	const click_handler_1 = () => jQuery("#modalDatosPersonales").modal("hide");

    	$$self.$$set = $$props => {
    		if ("paciente" in $$props) $$invalidate(0, paciente = $$props.paciente);
    		if ("edad" in $$props) $$invalidate(1, edad = $$props.edad);
    		if ("seguro" in $$props) $$invalidate(2, seguro = $$props.seguro);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		link,
    		differenceInDays,
    		moment,
    		paciente,
    		edad,
    		seguro
    	});

    	$$self.$inject_state = $$props => {
    		if ("paciente" in $$props) $$invalidate(0, paciente = $$props.paciente);
    		if ("edad" in $$props) $$invalidate(1, edad = $$props.edad);
    		if ("seguro" in $$props) $$invalidate(2, seguro = $$props.seguro);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [paciente, edad, seguro, click_handler, click_handler_1];
    }

    class ModalDatosPaciente extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { paciente: 0, edad: 1, seguro: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalDatosPaciente",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get paciente() {
    		throw new Error("<ModalDatosPaciente>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set paciente(value) {
    		throw new Error("<ModalDatosPaciente>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get edad() {
    		throw new Error("<ModalDatosPaciente>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set edad(value) {
    		throw new Error("<ModalDatosPaciente>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seguro() {
    		throw new Error("<ModalDatosPaciente>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set seguro(value) {
    		throw new Error("<ModalDatosPaciente>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\componentes\TarjetaAntecedentes.svelte generated by Svelte v3.29.0 */
    const file$d = "src\\componentes\\TarjetaAntecedentes.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (15:8) {#if antecedente.categoria.id === id}
    function create_if_block$9(ctx) {
    	let if_block_anchor;
    	let if_block = /*antecedente*/ ctx[3].activo && create_if_block_1$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*antecedente*/ ctx[3].activo) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$5(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(15:8) {#if antecedente.categoria.id === id}",
    		ctx
    	});

    	return block;
    }

    // (16:12) {#if antecedente.activo}
    function create_if_block_1$5(ctx) {
    	let div;
    	let h5;
    	let t0_value = /*antecedente*/ ctx[3].nombre + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*antecedente*/ ctx[3].descripcion + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h5 = element("h5");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			attr_dev(h5, "class", "alert-heading");
    			set_style(h5, "margin-bottom", "0px");
    			set_style(h5, "font-size", "12px");
    			set_style(h5, "text-transform", "uppercase");
    			set_style(h5, "font-weight", "bold");
    			add_location(h5, file$d, 17, 20, 456);
    			set_style(p, "padding", "0");
    			set_style(p, "margin", "0");
    			add_location(p, file$d, 18, 20, 616);
    			attr_dev(div, "class", "alert alert-secondary");
    			set_style(div, "padding", "10px");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$d, 16, 16, 363);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h5);
    			append_dev(h5, t0);
    			append_dev(div, t1);
    			append_dev(div, p);
    			append_dev(p, t2);
    			append_dev(div, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*antecedentes*/ 4 && t0_value !== (t0_value = /*antecedente*/ ctx[3].nombre + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*antecedentes*/ 4 && t2_value !== (t2_value = /*antecedente*/ ctx[3].descripcion + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(16:12) {#if antecedente.activo}",
    		ctx
    	});

    	return block;
    }

    // (14:4) {#each antecedentes as antecedente}
    function create_each_block$2(ctx) {
    	let if_block_anchor;
    	let if_block = /*antecedente*/ ctx[3].categoria.id === /*id*/ ctx[0] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*antecedente*/ ctx[3].categoria.id === /*id*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(14:4) {#each antecedentes as antecedente}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div;
    	let h6;
    	let t0;
    	let t1;
    	let hr;
    	let t2;
    	let each_value = /*antecedentes*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			h6 = element("h6");
    			t0 = text(/*nombre*/ ctx[1]);
    			t1 = space();
    			hr = element("hr");
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h6, file$d, 11, 4, 192);
    			add_location(hr, file$d, 12, 4, 215);
    			add_location(div, file$d, 10, 0, 181);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h6);
    			append_dev(h6, t0);
    			append_dev(div, t1);
    			append_dev(div, hr);
    			append_dev(div, t2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*nombre*/ 2) set_data_dev(t0, /*nombre*/ ctx[1]);

    			if (dirty & /*antecedentes, id*/ 5) {
    				each_value = /*antecedentes*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TarjetaAntecedentes", slots, []);
    	let { id = "" } = $$props;
    	let { nombre = "" } = $$props;
    	let { antecedentes = [] } = $$props;

    	onMount(() => {
    		
    	});

    	const writable_props = ["id", "nombre", "antecedentes"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TarjetaAntecedentes> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("nombre" in $$props) $$invalidate(1, nombre = $$props.nombre);
    		if ("antecedentes" in $$props) $$invalidate(2, antecedentes = $$props.antecedentes);
    	};

    	$$self.$capture_state = () => ({ onMount, id, nombre, antecedentes });

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("nombre" in $$props) $$invalidate(1, nombre = $$props.nombre);
    		if ("antecedentes" in $$props) $$invalidate(2, antecedentes = $$props.antecedentes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [id, nombre, antecedentes];
    }

    class TarjetaAntecedentes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { id: 0, nombre: 1, antecedentes: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TarjetaAntecedentes",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get id() {
    		throw new Error("<TarjetaAntecedentes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<TarjetaAntecedentes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nombre() {
    		throw new Error("<TarjetaAntecedentes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nombre(value) {
    		throw new Error("<TarjetaAntecedentes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get antecedentes() {
    		throw new Error("<TarjetaAntecedentes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set antecedentes(value) {
    		throw new Error("<TarjetaAntecedentes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Pacientes\PacientePerfil.svelte generated by Svelte v3.29.0 */

    const { console: console_1$7 } = globals;
    const file$e = "src\\Pages\\Pacientes\\PacientePerfil.svelte";

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[38] = list[i];
    	child_ctx[39] = list;
    	child_ctx[40] = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[38] = list[i];
    	return child_ctx;
    }

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	child_ctx[43] = list;
    	child_ctx[44] = i;
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[45] = list[i];
    	return child_ctx;
    }

    // (185:2) {#if cargando}
    function create_if_block_5(ctx) {
    	let div;
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loading.$$.fragment);
    			attr_dev(div, "class", "cargando svelte-3oo6xw");
    			add_location(div, file$e, 185, 4, 5496);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loading, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(185:2) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    // (333:20) {#if historia.activo}
    function create_if_block_4$1(ctx) {
    	let evoluciones;
    	let current;

    	evoluciones = new Evoluciones({
    			props: {
    				usuario: /*historia*/ ctx[45].usuario,
    				idPaciente: /*paciente*/ ctx[1].id,
    				id: /*historia*/ ctx[45].id,
    				fecha: /*historia*/ ctx[45].fechaHora,
    				motivo: /*historia*/ ctx[45].motivoConsulta,
    				historia: /*historia*/ ctx[45].historiaEnfermedad
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(evoluciones.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(evoluciones, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const evoluciones_changes = {};
    			if (dirty[0] & /*historiasPaciente*/ 64) evoluciones_changes.usuario = /*historia*/ ctx[45].usuario;
    			if (dirty[0] & /*paciente*/ 2) evoluciones_changes.idPaciente = /*paciente*/ ctx[1].id;
    			if (dirty[0] & /*historiasPaciente*/ 64) evoluciones_changes.id = /*historia*/ ctx[45].id;
    			if (dirty[0] & /*historiasPaciente*/ 64) evoluciones_changes.fecha = /*historia*/ ctx[45].fechaHora;
    			if (dirty[0] & /*historiasPaciente*/ 64) evoluciones_changes.motivo = /*historia*/ ctx[45].motivoConsulta;
    			if (dirty[0] & /*historiasPaciente*/ 64) evoluciones_changes.historia = /*historia*/ ctx[45].historiaEnfermedad;
    			evoluciones.$set(evoluciones_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(evoluciones.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(evoluciones.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(evoluciones, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(333:20) {#if historia.activo}",
    		ctx
    	});

    	return block;
    }

    // (332:18) {#each historiasPaciente as historia}
    function create_each_block_4(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*historia*/ ctx[45].activo && create_if_block_4$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*historia*/ ctx[45].activo) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*historiasPaciente*/ 64) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_4$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(332:18) {#each historiasPaciente as historia}",
    		ctx
    	});

    	return block;
    }

    // (370:20) {#each categoriasAntecedentes as categoria}
    function create_each_block_3(ctx) {
    	let tarjetaantecedentes;
    	let updating_id;
    	let updating_nombre;
    	let updating_antecedentes;
    	let current;

    	function tarjetaantecedentes_id_binding(value) {
    		/*tarjetaantecedentes_id_binding*/ ctx[25].call(null, value, /*categoria*/ ctx[35]);
    	}

    	function tarjetaantecedentes_nombre_binding(value) {
    		/*tarjetaantecedentes_nombre_binding*/ ctx[26].call(null, value, /*categoria*/ ctx[35]);
    	}

    	function tarjetaantecedentes_antecedentes_binding(value) {
    		/*tarjetaantecedentes_antecedentes_binding*/ ctx[27].call(null, value);
    	}

    	let tarjetaantecedentes_props = {};

    	if (/*categoria*/ ctx[35].id !== void 0) {
    		tarjetaantecedentes_props.id = /*categoria*/ ctx[35].id;
    	}

    	if (/*categoria*/ ctx[35].nombre !== void 0) {
    		tarjetaantecedentes_props.nombre = /*categoria*/ ctx[35].nombre;
    	}

    	if (/*paciente*/ ctx[1].antecedentes !== void 0) {
    		tarjetaantecedentes_props.antecedentes = /*paciente*/ ctx[1].antecedentes;
    	}

    	tarjetaantecedentes = new TarjetaAntecedentes({
    			props: tarjetaantecedentes_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(tarjetaantecedentes, "id", tarjetaantecedentes_id_binding));
    	binding_callbacks.push(() => bind(tarjetaantecedentes, "nombre", tarjetaantecedentes_nombre_binding));
    	binding_callbacks.push(() => bind(tarjetaantecedentes, "antecedentes", tarjetaantecedentes_antecedentes_binding));

    	const block = {
    		c: function create() {
    			create_component(tarjetaantecedentes.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tarjetaantecedentes, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const tarjetaantecedentes_changes = {};

    			if (!updating_id && dirty[0] & /*categoriasAntecedentes*/ 16) {
    				updating_id = true;
    				tarjetaantecedentes_changes.id = /*categoria*/ ctx[35].id;
    				add_flush_callback(() => updating_id = false);
    			}

    			if (!updating_nombre && dirty[0] & /*categoriasAntecedentes*/ 16) {
    				updating_nombre = true;
    				tarjetaantecedentes_changes.nombre = /*categoria*/ ctx[35].nombre;
    				add_flush_callback(() => updating_nombre = false);
    			}

    			if (!updating_antecedentes && dirty[0] & /*paciente*/ 2) {
    				updating_antecedentes = true;
    				tarjetaantecedentes_changes.antecedentes = /*paciente*/ ctx[1].antecedentes;
    				add_flush_callback(() => updating_antecedentes = false);
    			}

    			tarjetaantecedentes.$set(tarjetaantecedentes_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tarjetaantecedentes.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tarjetaantecedentes.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tarjetaantecedentes, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(370:20) {#each categoriasAntecedentes as categoria}",
    		ctx
    	});

    	return block;
    }

    // (497:26) {#if antecedente.categoria.id === categoria.id}
    function create_if_block_2$4(ctx) {
    	let if_block_anchor;
    	let if_block = /*antecedente*/ ctx[38].activo === false && create_if_block_3$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*antecedente*/ ctx[38].activo === false) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(497:26) {#if antecedente.categoria.id === categoria.id}",
    		ctx
    	});

    	return block;
    }

    // (498:28) {#if antecedente.activo === false}
    function create_if_block_3$1(ctx) {
    	let button;
    	let i;
    	let t0;
    	let span;
    	let t1_value = /*antecedente*/ ctx[38].nombre + "";
    	let t1;
    	let t2;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[28](/*antecedente*/ ctx[38], ...args);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = space();
    			span = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(i, "class", "mdi mdi-plus");
    			add_location(i, file$e, 505, 33, 18449);
    			attr_dev(span, "data-bind", "text: nombre");
    			add_location(span, file$e, 506, 32, 18509);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn btn-outline-primary btn-sm mb-1 mr-2");
    			set_style(button, "box-shadow", "none");
    			add_location(button, file$e, 499, 30, 18093);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);
    			append_dev(button, t0);
    			append_dev(button, span);
    			append_dev(span, t1);
    			append_dev(button, t2);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*antecedentes*/ 32 && t1_value !== (t1_value = /*antecedente*/ ctx[38].nombre + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(498:28) {#if antecedente.activo === false}",
    		ctx
    	});

    	return block;
    }

    // (496:24) {#each antecedentes as antecedente}
    function create_each_block_2(ctx) {
    	let if_block_anchor;
    	let if_block = /*antecedente*/ ctx[38].categoria.id === /*categoria*/ ctx[35].id && create_if_block_2$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*antecedente*/ ctx[38].categoria.id === /*categoria*/ ctx[35].id) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(496:24) {#each antecedentes as antecedente}",
    		ctx
    	});

    	return block;
    }

    // (523:32) {#if antecedente.categoria.id === categoria.id}
    function create_if_block$a(ctx) {
    	let if_block_anchor;
    	let if_block = /*antecedente*/ ctx[38].activo === true && create_if_block_1$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*antecedente*/ ctx[38].activo === true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(523:32) {#if antecedente.categoria.id === categoria.id}",
    		ctx
    	});

    	return block;
    }

    // (524:34) {#if antecedente.activo === true}
    function create_if_block_1$6(ctx) {
    	let div6;
    	let div1;
    	let div0;
    	let i0;
    	let t0;
    	let span;
    	let t1_value = /*antecedente*/ ctx[38].nombre + "";
    	let t1;
    	let t2;
    	let div4;
    	let div3;
    	let a;
    	let i1;
    	let t3;
    	let div2;
    	let button;
    	let i2;
    	let t4;
    	let t5;
    	let div5;
    	let textarea;
    	let t6;
    	let mounted;
    	let dispose;

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[29](/*antecedente*/ ctx[38], ...args);
    	}

    	function textarea_input_handler() {
    		/*textarea_input_handler*/ ctx[30].call(textarea, /*each_value_1*/ ctx[39], /*antecedente_index*/ ctx[40]);
    	}

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			i0 = element("i");
    			t0 = space();
    			span = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			a = element("a");
    			i1 = element("i");
    			t3 = space();
    			div2 = element("div");
    			button = element("button");
    			i2 = element("i");
    			t4 = text("\r\n                                              Eliminar");
    			t5 = space();
    			div5 = element("div");
    			textarea = element("textarea");
    			t6 = space();
    			attr_dev(i0, "class", "mdi mdi-history mdi-18px");
    			add_location(i0, file$e, 531, 42, 19814);
    			attr_dev(span, "data-bind", "text: nombre");
    			add_location(span, file$e, 532, 42, 19896);
    			attr_dev(div0, "class", "card-title");
    			add_location(div0, file$e, 530, 40, 19746);
    			attr_dev(div1, "class", "card-header");
    			add_location(div1, file$e, 529, 38, 19679);
    			attr_dev(i1, "class", "icon mdi  mdi-dots-vertical");
    			add_location(i1, file$e, 545, 44, 20661);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "data-toggle", "dropdown");
    			attr_dev(a, "aria-haspopup", "true");
    			attr_dev(a, "aria-expanded", "false");
    			add_location(a, file$e, 539, 42, 20313);
    			attr_dev(i2, "class", "mdi mdi-trash-can-outline");
    			add_location(i2, file$e, 559, 47, 21517);
    			attr_dev(button, "class", "dropdown-item text-danger");
    			attr_dev(button, "type", "button");
    			add_location(button, file$e, 552, 44, 21068);
    			attr_dev(div2, "class", "dropdown-menu dropdown-menu-right");
    			add_location(div2, file$e, 549, 42, 20886);
    			attr_dev(div3, "class", "dropdown");
    			add_location(div3, file$e, 538, 40, 20247);
    			attr_dev(div4, "class", "card-controls");
    			add_location(div4, file$e, 537, 38, 20178);
    			attr_dev(textarea, "class", "form-control");
    			set_style(textarea, "width", "100%");
    			set_style(textarea, "display", "block");
    			set_style(textarea, "height", "100px");
    			attr_dev(textarea, "id", "exampleFormControlTextarea1");
    			attr_dev(textarea, "rows", "5");
    			attr_dev(textarea, "name", "Comentario");
    			add_location(textarea, file$e, 568, 40, 22012);
    			attr_dev(div5, "class", "card-body");
    			add_location(div5, file$e, 567, 38, 21947);
    			attr_dev(div6, "class", "card m-b-20 mt-3");
    			set_style(div6, "box-shadow", "none");
    			set_style(div6, "border", "1px grey solid");
    			add_location(div6, file$e, 525, 36, 19443);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div1);
    			append_dev(div1, div0);
    			append_dev(div0, i0);
    			append_dev(div0, t0);
    			append_dev(div0, span);
    			append_dev(span, t1);
    			append_dev(div6, t2);
    			append_dev(div6, div4);
    			append_dev(div4, div3);
    			append_dev(div3, a);
    			append_dev(a, i1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			append_dev(button, i2);
    			append_dev(button, t4);
    			append_dev(div6, t5);
    			append_dev(div6, div5);
    			append_dev(div5, textarea);
    			set_input_value(textarea, /*antecedente*/ ctx[38].descripcion);
    			append_dev(div6, t6);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", click_handler_1, false, false, false),
    					listen_dev(textarea, "input", textarea_input_handler),
    					listen_dev(textarea, "blur", /*actualizarAntecedentesPaciente*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*antecedentes*/ 32 && t1_value !== (t1_value = /*antecedente*/ ctx[38].nombre + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*antecedentes*/ 32) {
    				set_input_value(textarea, /*antecedente*/ ctx[38].descripcion);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(524:34) {#if antecedente.activo === true}",
    		ctx
    	});

    	return block;
    }

    // (522:30) {#each antecedentes as antecedente}
    function create_each_block_1$1(ctx) {
    	let if_block_anchor;
    	let if_block = /*antecedente*/ ctx[38].categoria.id === /*categoria*/ ctx[35].id && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*antecedente*/ ctx[38].categoria.id === /*categoria*/ ctx[35].id) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(522:30) {#each antecedentes as antecedente}",
    		ctx
    	});

    	return block;
    }

    // (481:16) {#each categoriasAntecedentes as categoria}
    function create_each_block$3(ctx) {
    	let div8;
    	let div1;
    	let div0;
    	let t0_value = /*categoria*/ ctx[35].nombre + "";
    	let t0;
    	let t1;
    	let div7;
    	let div2;
    	let t2;
    	let div6;
    	let div5;
    	let div4;
    	let div3;
    	let t3;
    	let each_value_2 = /*antecedentes*/ ctx[5];
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	let each_value_1 = /*antecedentes*/ ctx[5];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div7 = element("div");
    			div2 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t2 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			attr_dev(div0, "class", "card-title");
    			attr_dev(div0, "data-bind", "text: nombre");
    			add_location(div0, file$e, 486, 22, 17432);
    			attr_dev(div1, "class", "card-header");
    			add_location(div1, file$e, 485, 20, 17383);
    			attr_dev(div2, "class", "botones-antecedentes");
    			attr_dev(div2, "data-bind", "foreach: tiposAntecedentesFiltrados");
    			add_location(div2, file$e, 491, 22, 17652);
    			attr_dev(div3, "class", "col-lg-12");
    			attr_dev(div3, "data-bind", "foreach: antecedentesFiltrados");
    			add_location(div3, file$e, 517, 28, 18971);
    			attr_dev(div4, "class", "row");
    			add_location(div4, file$e, 516, 26, 18924);
    			attr_dev(div5, "class", "col-12");
    			add_location(div5, file$e, 515, 24, 18876);
    			attr_dev(div6, "class", "row");
    			add_location(div6, file$e, 514, 22, 18833);
    			attr_dev(div7, "class", "card-body");
    			add_location(div7, file$e, 490, 20, 17605);
    			attr_dev(div8, "class", "card  m-b-30");
    			set_style(div8, "box-shadow", "none");
    			set_style(div8, "border", "#32325d solid 1px");
    			add_location(div8, file$e, 481, 18, 17220);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div8, t1);
    			append_dev(div8, div7);
    			append_dev(div7, div2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div2, null);
    			}

    			append_dev(div7, t2);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div3, null);
    			}

    			append_dev(div8, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*categoriasAntecedentes*/ 16 && t0_value !== (t0_value = /*categoria*/ ctx[35].nombre + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*cambiarEstadoAntecedente, antecedentes, categoriasAntecedentes*/ 131120) {
    				each_value_2 = /*antecedentes*/ ctx[5];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			if (dirty[0] & /*antecedentes, actualizarAntecedentesPaciente, eliminarAntecedente, categoriasAntecedentes*/ 81968) {
    				each_value_1 = /*antecedentes*/ ctx[5];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div3, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(481:16) {#each categoriasAntecedentes as categoria}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let t1;
    	let header;
    	let t2;
    	let section1;
    	let section0;
    	let cabeceraperfil;
    	let updating_cargando;
    	let updating_edad;
    	let updating_nombres;
    	let updating_apellidos;
    	let updating_cedula;
    	let updating_id;
    	let t3;
    	let div16;
    	let div15;
    	let div14;
    	let div0;
    	let ultimosvitales;
    	let t4;
    	let div6;
    	let div5;
    	let div3;
    	let div2;
    	let div1;
    	let i0;
    	let t5;
    	let t6;
    	let div4;
    	let t7;
    	let div13;
    	let div12;
    	let div9;
    	let div8;
    	let div7;
    	let i1;
    	let t8;
    	let span0;
    	let button0;
    	let i2;
    	let t10;
    	let t11;
    	let div11;
    	let div10;
    	let t12;
    	let modaldatospaciente;
    	let t13;
    	let div26;
    	let div25;
    	let div24;
    	let div20;
    	let h5;
    	let t15;
    	let button1;
    	let span1;
    	let t17;
    	let div19;
    	let div18;
    	let div17;
    	let i3;
    	let t18;
    	let i4;
    	let t20;
    	let div23;
    	let div22;
    	let div21;
    	let main_intro;
    	let current;
    	let mounted;
    	let dispose;
    	aside = new Aside({ $$inline: true });
    	let if_block = /*cargando*/ ctx[0] && create_if_block_5(ctx);
    	header = new Header({ $$inline: true });

    	function cabeceraperfil_cargando_binding(value) {
    		/*cabeceraperfil_cargando_binding*/ ctx[19].call(null, value);
    	}

    	function cabeceraperfil_edad_binding(value) {
    		/*cabeceraperfil_edad_binding*/ ctx[20].call(null, value);
    	}

    	function cabeceraperfil_nombres_binding(value) {
    		/*cabeceraperfil_nombres_binding*/ ctx[21].call(null, value);
    	}

    	function cabeceraperfil_apellidos_binding(value) {
    		/*cabeceraperfil_apellidos_binding*/ ctx[22].call(null, value);
    	}

    	function cabeceraperfil_cedula_binding(value) {
    		/*cabeceraperfil_cedula_binding*/ ctx[23].call(null, value);
    	}

    	function cabeceraperfil_id_binding(value) {
    		/*cabeceraperfil_id_binding*/ ctx[24].call(null, value);
    	}

    	let cabeceraperfil_props = { paciente: /*paciente*/ ctx[1] };

    	if (/*cargando*/ ctx[0] !== void 0) {
    		cabeceraperfil_props.cargando = /*cargando*/ ctx[0];
    	}

    	if (/*edad*/ ctx[2] !== void 0) {
    		cabeceraperfil_props.edad = /*edad*/ ctx[2];
    	}

    	if (/*paciente*/ ctx[1].nombres !== void 0) {
    		cabeceraperfil_props.nombres = /*paciente*/ ctx[1].nombres;
    	}

    	if (/*paciente*/ ctx[1].apellidos !== void 0) {
    		cabeceraperfil_props.apellidos = /*paciente*/ ctx[1].apellidos;
    	}

    	if (/*paciente*/ ctx[1].cedula !== void 0) {
    		cabeceraperfil_props.cedula = /*paciente*/ ctx[1].cedula;
    	}

    	if (/*paciente*/ ctx[1].id !== void 0) {
    		cabeceraperfil_props.id = /*paciente*/ ctx[1].id;
    	}

    	cabeceraperfil = new CabeceraPerfil({
    			props: cabeceraperfil_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(cabeceraperfil, "cargando", cabeceraperfil_cargando_binding));
    	binding_callbacks.push(() => bind(cabeceraperfil, "edad", cabeceraperfil_edad_binding));
    	binding_callbacks.push(() => bind(cabeceraperfil, "nombres", cabeceraperfil_nombres_binding));
    	binding_callbacks.push(() => bind(cabeceraperfil, "apellidos", cabeceraperfil_apellidos_binding));
    	binding_callbacks.push(() => bind(cabeceraperfil, "cedula", cabeceraperfil_cedula_binding));
    	binding_callbacks.push(() => bind(cabeceraperfil, "id", cabeceraperfil_id_binding));

    	ultimosvitales = new UltimosVitales({
    			props: {
    				peso: /*peso*/ ctx[7] ?? 0,
    				tipoPeso: /*tipoPeso*/ ctx[8],
    				temperatura: /*temperatura*/ ctx[9],
    				tipoTemperatura: /*tipoTemperatura*/ ctx[10],
    				frecuenciaRespiratoria: /*frecuenciaRespiratoria*/ ctx[11],
    				frecuenciaCardiaca: /*frecuenciaCardiaca*/ ctx[12],
    				presionAlterial: /*presionAlterial*/ ctx[13]
    			},
    			$$inline: true
    		});

    	let each_value_4 = /*historiasPaciente*/ ctx[6];
    	validate_each_argument(each_value_4);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks_2[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const out = i => transition_out(each_blocks_2[i], 1, 1, () => {
    		each_blocks_2[i] = null;
    	});

    	let each_value_3 = /*categoriasAntecedentes*/ ctx[4];
    	validate_each_argument(each_value_3);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out_1 = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	modaldatospaciente = new ModalDatosPaciente({
    			props: {
    				paciente: /*paciente*/ ctx[1],
    				edad: /*edad*/ ctx[2],
    				seguro: /*seguro*/ ctx[3]
    			},
    			$$inline: true
    		});

    	let each_value = /*categoriasAntecedentes*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(header.$$.fragment);
    			t2 = space();
    			section1 = element("section");
    			section0 = element("section");
    			create_component(cabeceraperfil.$$.fragment);
    			t3 = space();
    			div16 = element("div");
    			div15 = element("div");
    			div14 = element("div");
    			div0 = element("div");
    			create_component(ultimosvitales.$$.fragment);
    			t4 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			i0 = element("i");
    			t5 = text("\r\n                  Historial atenciones");
    			t6 = space();
    			div4 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t7 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			i1 = element("i");
    			t8 = space();
    			span0 = element("span");
    			span0.textContent = "Antecedentes ";
    			button0 = element("button");
    			i2 = element("i");
    			t10 = text(" CAMBIAR ");
    			t11 = space();
    			div11 = element("div");
    			div10 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t12 = space();
    			create_component(modaldatospaciente.$$.fragment);
    			t13 = space();
    			div26 = element("div");
    			div25 = element("div");
    			div24 = element("div");
    			div20 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Antecedentes";
    			t15 = space();
    			button1 = element("button");
    			span1 = element("span");
    			span1.textContent = "";
    			t17 = space();
    			div19 = element("div");
    			div18 = element("div");
    			div17 = element("div");
    			i3 = element("i");
    			t18 = space();
    			i4 = element("i");
    			i4.textContent = "listo y guardado";
    			t20 = space();
    			div23 = element("div");
    			div22 = element("div");
    			div21 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "col-lg-3 order-lg-1 order-sm-3");
    			add_location(div0, file$e, 204, 12, 6010);
    			attr_dev(i0, "class", "mdi mdi-progress-check mdi-18px");
    			add_location(i0, file$e, 325, 22, 11351);
    			attr_dev(div1, "class", "avatar-title bg-dark rounded-circle");
    			add_location(div1, file$e, 324, 20, 11278);
    			attr_dev(div2, "class", "avatar mr-2 avatar-xs");
    			add_location(div2, file$e, 323, 18, 11221);
    			attr_dev(div3, "class", "card-header");
    			add_location(div3, file$e, 322, 16, 11176);
    			attr_dev(div4, "class", "card-body");
    			add_location(div4, file$e, 330, 16, 11532);
    			attr_dev(div5, "class", "card m-b-30");
    			add_location(div5, file$e, 321, 14, 11133);
    			attr_dev(div6, "class", "col-md-5 order-2 order-sm-1");
    			add_location(div6, file$e, 320, 12, 11076);
    			attr_dev(i1, "class", "mdi mdi-history mdi-18px");
    			add_location(i1, file$e, 354, 22, 12537);
    			attr_dev(div7, "class", "avatar-title bg-dark rounded-circle");
    			add_location(div7, file$e, 353, 20, 12464);
    			attr_dev(div8, "class", "avatar mr-2 avatar-xs");
    			add_location(div8, file$e, 352, 18, 12407);
    			add_location(span0, file$e, 360, 18, 12754);
    			attr_dev(i2, "class", "mdi mdi-plus");
    			add_location(i2, file$e, 364, 21, 12971);
    			attr_dev(button0, "class", "btn btn-outline-primary btn-sm");
    			attr_dev(button0, "data-toggle", "modal");
    			attr_dev(button0, "data-target", "#modalAntecedentes");
    			add_location(button0, file$e, 360, 50, 12786);
    			attr_dev(div9, "class", "card-header");
    			add_location(div9, file$e, 351, 16, 12362);
    			attr_dev(div10, "class", "atenciones-vnc mb-3");
    			add_location(div10, file$e, 368, 18, 13126);
    			attr_dev(div11, "class", "card-body");
    			add_location(div11, file$e, 367, 16, 13083);
    			attr_dev(div12, "class", "card m-b-30");
    			add_location(div12, file$e, 350, 14, 12319);
    			attr_dev(div13, "class", "col-md-4 order-lg-12 order-sm-2");
    			add_location(div13, file$e, 349, 12, 12258);
    			attr_dev(div14, "class", "row");
    			add_location(div14, file$e, 203, 10, 5979);
    			attr_dev(div15, "class", "col-md-12");
    			add_location(div15, file$e, 202, 8, 5944);
    			attr_dev(div16, "class", "pull-up");
    			add_location(div16, file$e, 201, 6, 5913);
    			attr_dev(section0, "class", "admin-content");
    			add_location(section0, file$e, 191, 4, 5612);
    			attr_dev(h5, "class", "modal-title");
    			attr_dev(h5, "id", "modalAntecedentes");
    			add_location(h5, file$e, 457, 12, 16278);
    			attr_dev(span1, "aria-hidden", "true");
    			add_location(span1, file$e, 464, 14, 16522);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "close");
    			attr_dev(button1, "data-dismiss", "modal");
    			attr_dev(button1, "aria-label", "Close");
    			add_location(button1, file$e, 458, 12, 16356);
    			attr_dev(i3, "class", "mdi mdi-check-all");
    			add_location(i3, file$e, 472, 18, 16854);
    			add_location(i4, file$e, 472, 50, 16886);
    			attr_dev(div17, "class", "guardando mr-2 text-success");
    			attr_dev(div17, "data-bind", "html: content, class: contentClass");
    			add_location(div17, file$e, 468, 16, 16690);
    			attr_dev(div18, "class", "guardar-documento");
    			add_location(div18, file$e, 467, 14, 16641);
    			set_style(div19, "margin-right", "40px");
    			add_location(div19, file$e, 466, 12, 16592);
    			attr_dev(div20, "class", "modal-header");
    			add_location(div20, file$e, 456, 10, 16238);
    			attr_dev(div21, "class", "col-lg-12");
    			attr_dev(div21, "data-bind", "foreach: gruposAntecedentes");
    			add_location(div21, file$e, 479, 14, 17076);
    			attr_dev(div22, "class", "row");
    			add_location(div22, file$e, 478, 12, 17043);
    			attr_dev(div23, "class", "modal-body");
    			add_location(div23, file$e, 477, 10, 17005);
    			attr_dev(div24, "class", "modal-content");
    			add_location(div24, file$e, 455, 8, 16199);
    			attr_dev(div25, "class", "modal-dialog");
    			attr_dev(div25, "role", "document");
    			add_location(div25, file$e, 454, 6, 16147);
    			attr_dev(div26, "class", "modal fade modal-slide-right");
    			attr_dev(div26, "id", "modalAntecedentes");
    			attr_dev(div26, "tabindex", "-1");
    			attr_dev(div26, "role", "dialog");
    			attr_dev(div26, "aria-labelledby", "modalAntecedentes");
    			set_style(div26, "display", "none");
    			attr_dev(div26, "aria-hidden", "true");
    			add_location(div26, file$e, 445, 4, 15913);
    			attr_dev(section1, "class", "admin-content");
    			add_location(section1, file$e, 190, 2, 5575);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$e, 183, 0, 5419);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			if (if_block) if_block.m(main, null);
    			append_dev(main, t1);
    			mount_component(header, main, null);
    			append_dev(main, t2);
    			append_dev(main, section1);
    			append_dev(section1, section0);
    			mount_component(cabeceraperfil, section0, null);
    			append_dev(section0, t3);
    			append_dev(section0, div16);
    			append_dev(div16, div15);
    			append_dev(div15, div14);
    			append_dev(div14, div0);
    			mount_component(ultimosvitales, div0, null);
    			append_dev(div14, t4);
    			append_dev(div14, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, i0);
    			append_dev(div3, t5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div4, null);
    			}

    			append_dev(div14, t7);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, i1);
    			append_dev(div9, t8);
    			append_dev(div9, span0);
    			append_dev(div9, button0);
    			append_dev(button0, i2);
    			append_dev(button0, t10);
    			append_dev(div12, t11);
    			append_dev(div12, div11);
    			append_dev(div11, div10);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div10, null);
    			}

    			append_dev(section1, t12);
    			mount_component(modaldatospaciente, section1, null);
    			append_dev(section1, t13);
    			append_dev(section1, div26);
    			append_dev(div26, div25);
    			append_dev(div25, div24);
    			append_dev(div24, div20);
    			append_dev(div20, h5);
    			append_dev(div20, t15);
    			append_dev(div20, button1);
    			append_dev(button1, span1);
    			append_dev(div20, t17);
    			append_dev(div20, div19);
    			append_dev(div19, div18);
    			append_dev(div18, div17);
    			append_dev(div17, i3);
    			append_dev(div17, t18);
    			append_dev(div17, i4);
    			append_dev(div24, t20);
    			append_dev(div24, div23);
    			append_dev(div23, div22);
    			append_dev(div22, div21);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div21, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(i1, "click", /*combinarAntecedentes*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*cargando*/ ctx[0]) {
    				if (if_block) {
    					if (dirty[0] & /*cargando*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(main, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const cabeceraperfil_changes = {};
    			if (dirty[0] & /*paciente*/ 2) cabeceraperfil_changes.paciente = /*paciente*/ ctx[1];

    			if (!updating_cargando && dirty[0] & /*cargando*/ 1) {
    				updating_cargando = true;
    				cabeceraperfil_changes.cargando = /*cargando*/ ctx[0];
    				add_flush_callback(() => updating_cargando = false);
    			}

    			if (!updating_edad && dirty[0] & /*edad*/ 4) {
    				updating_edad = true;
    				cabeceraperfil_changes.edad = /*edad*/ ctx[2];
    				add_flush_callback(() => updating_edad = false);
    			}

    			if (!updating_nombres && dirty[0] & /*paciente*/ 2) {
    				updating_nombres = true;
    				cabeceraperfil_changes.nombres = /*paciente*/ ctx[1].nombres;
    				add_flush_callback(() => updating_nombres = false);
    			}

    			if (!updating_apellidos && dirty[0] & /*paciente*/ 2) {
    				updating_apellidos = true;
    				cabeceraperfil_changes.apellidos = /*paciente*/ ctx[1].apellidos;
    				add_flush_callback(() => updating_apellidos = false);
    			}

    			if (!updating_cedula && dirty[0] & /*paciente*/ 2) {
    				updating_cedula = true;
    				cabeceraperfil_changes.cedula = /*paciente*/ ctx[1].cedula;
    				add_flush_callback(() => updating_cedula = false);
    			}

    			if (!updating_id && dirty[0] & /*paciente*/ 2) {
    				updating_id = true;
    				cabeceraperfil_changes.id = /*paciente*/ ctx[1].id;
    				add_flush_callback(() => updating_id = false);
    			}

    			cabeceraperfil.$set(cabeceraperfil_changes);
    			const ultimosvitales_changes = {};
    			if (dirty[0] & /*peso*/ 128) ultimosvitales_changes.peso = /*peso*/ ctx[7] ?? 0;
    			if (dirty[0] & /*tipoPeso*/ 256) ultimosvitales_changes.tipoPeso = /*tipoPeso*/ ctx[8];
    			if (dirty[0] & /*temperatura*/ 512) ultimosvitales_changes.temperatura = /*temperatura*/ ctx[9];
    			if (dirty[0] & /*tipoTemperatura*/ 1024) ultimosvitales_changes.tipoTemperatura = /*tipoTemperatura*/ ctx[10];
    			if (dirty[0] & /*frecuenciaRespiratoria*/ 2048) ultimosvitales_changes.frecuenciaRespiratoria = /*frecuenciaRespiratoria*/ ctx[11];
    			if (dirty[0] & /*frecuenciaCardiaca*/ 4096) ultimosvitales_changes.frecuenciaCardiaca = /*frecuenciaCardiaca*/ ctx[12];
    			if (dirty[0] & /*presionAlterial*/ 8192) ultimosvitales_changes.presionAlterial = /*presionAlterial*/ ctx[13];
    			ultimosvitales.$set(ultimosvitales_changes);

    			if (dirty[0] & /*historiasPaciente, paciente*/ 66) {
    				each_value_4 = /*historiasPaciente*/ ctx[6];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    						transition_in(each_blocks_2[i], 1);
    					} else {
    						each_blocks_2[i] = create_each_block_4(child_ctx);
    						each_blocks_2[i].c();
    						transition_in(each_blocks_2[i], 1);
    						each_blocks_2[i].m(div4, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_4.length; i < each_blocks_2.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty[0] & /*categoriasAntecedentes, paciente*/ 18) {
    				each_value_3 = /*categoriasAntecedentes*/ ctx[4];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_3(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div10, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks_1.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}

    			const modaldatospaciente_changes = {};
    			if (dirty[0] & /*paciente*/ 2) modaldatospaciente_changes.paciente = /*paciente*/ ctx[1];
    			if (dirty[0] & /*edad*/ 4) modaldatospaciente_changes.edad = /*edad*/ ctx[2];
    			if (dirty[0] & /*seguro*/ 8) modaldatospaciente_changes.seguro = /*seguro*/ ctx[3];
    			modaldatospaciente.$set(modaldatospaciente_changes);

    			if (dirty[0] & /*antecedentes, actualizarAntecedentesPaciente, eliminarAntecedente, categoriasAntecedentes, cambiarEstadoAntecedente*/ 213040) {
    				each_value = /*categoriasAntecedentes*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div21, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(header.$$.fragment, local);
    			transition_in(cabeceraperfil.$$.fragment, local);
    			transition_in(ultimosvitales.$$.fragment, local);

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks_2[i]);
    			}

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			transition_in(modaldatospaciente.$$.fragment, local);

    			if (!main_intro) {
    				add_render_callback(() => {
    					main_intro = create_in_transition(main, fade, { duration: 300 });
    					main_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(header.$$.fragment, local);
    			transition_out(cabeceraperfil.$$.fragment, local);
    			transition_out(ultimosvitales.$$.fragment, local);
    			each_blocks_2 = each_blocks_2.filter(Boolean);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				transition_out(each_blocks_2[i]);
    			}

    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			transition_out(modaldatospaciente.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			if (if_block) if_block.d();
    			destroy_component(header);
    			destroy_component(cabeceraperfil);
    			destroy_component(ultimosvitales);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			destroy_component(modaldatospaciente);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function calcularEdad$1(fecha) {
    	var hoy = new Date();
    	var cumpleanos = new Date(fecha);
    	var edad = hoy.getFullYear() - cumpleanos.getFullYear();
    	var m = hoy.getMonth() - cumpleanos.getMonth();

    	if (m < 0 || m === 0 && hoy.getDate() < cumpleanos.getDate()) {
    		edad--;
    	}

    	return edad;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PacientePerfil", slots, []);
    	let { params = "" } = $$props;
    	let cargando = false;
    	let paciente = {};
    	let edad = "";
    	let seguro = "";
    	let categoriasAntecedentes = [];
    	let antecedentes = [];
    	let historiasPaciente = [];
    	let peso = 0;
    	let tipoPeso = "";
    	let temperatura = "";
    	let tipoTemperatura = "";
    	let frecuenciaRespiratoria = "";
    	let frecuenciaCardiaca = "";
    	let presionAlterial = "";

    	const cargarHistoriasPaciente = async () => {
    		try {
    			const config = {
    				method: "get",
    				url: `${url}/historias/paciente/${params.id}`,
    				headers: {
    					"Authorization": `${localStorage.getItem("auth")}`
    				}
    			};

    			let promesa = await axios$1(config);
    			$$invalidate(6, historiasPaciente = promesa.data);

    			if (historiasPaciente.length !== 0) {
    				$$invalidate(7, peso = promesa.data[0].peso.valor);
    				$$invalidate(8, tipoPeso = promesa.data[0].peso.tipo);
    				$$invalidate(9, temperatura = promesa.data[0].temperatura.valor);
    				$$invalidate(10, tipoTemperatura = promesa.data[0].temperatura.tipo);
    				$$invalidate(11, frecuenciaRespiratoria = promesa.data[0].frecuenciaRespiratoria);
    				$$invalidate(12, frecuenciaCardiaca = promesa.data[0].frecuenciaCardiaca);
    				$$invalidate(13, presionAlterial = `${promesa.data[0].presionAlterial.mm}/${promesa.data[0].presionAlterial.Hg}`);
    			} else {
    				return false;
    			}
    		} catch(error) {
    			console.log(error);
    		}
    	};

    	function actualizarAntecedentesPaciente() {
    		$$invalidate(1, paciente.antecedentes = antecedentes, paciente);

    		const config = {
    			method: "put",
    			url: `${url}/pacientes/${paciente.id}`,
    			data: paciente,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			console.log(res.data);
    		}).catch(error => {
    			console.error(error);
    		});
    	}

    	const combinarAntecedentes = () => {
    		for (const ant of paciente.antecedentes) {
    			if (ant.activo == true) {
    				const index = antecedentes.findIndex(x => x.id === ant.id);
    				$$invalidate(5, antecedentes[index].activo = ant.activo, antecedentes);
    				$$invalidate(5, antecedentes[index].descripcion = ant.descripcion, antecedentes);
    			}
    		}
    	};

    	function eliminarAntecedente(idAntecedente) {
    		const index = antecedentes.findIndex(x => x.id === idAntecedente);
    		$$invalidate(5, antecedentes[index].activo = false, antecedentes);
    		actualizarAntecedentesPaciente();
    	}

    	function cambiarEstadoAntecedente(idAntecedente) {
    		const index = antecedentes.findIndex(x => x.id === idAntecedente);
    		$$invalidate(5, antecedentes[index].activo = true, antecedentes);
    		actualizarAntecedentesPaciente();
    	}

    	async function cargarAntecedentes() {
    		const config = {
    			method: "get",
    			url: `${url}/antecedentes`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		let promesa = await axios$1(config);

    		if (promesa.status == 200) {
    			$$invalidate(5, antecedentes = promesa.data);
    		} else {
    			console.error(promesa.statusText);
    		}
    	}

    	function cargarCategoriasAntecedentes() {
    		const config = {
    			method: "get",
    			url: `${url}/categorias/antecedentes`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(4, categoriasAntecedentes = res.data);
    		});
    	}

    	async function cargarPaciente() {
    		$$invalidate(0, cargando = true);

    		const config = {
    			method: "get",
    			url: `${url}/pacientes/${params.id}`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		try {
    			let promesa = await axios$1(config);

    			if (promesa.status == 200) {
    				$$invalidate(0, cargando = false);
    				$$invalidate(1, paciente = promesa.data);
    				$$invalidate(2, edad = calcularEdad$1(paciente.fechaNacimiento));

    				if (paciente.seguroMedico.length !== 0) {
    					$$invalidate(3, seguro = paciente.seguroMedico[0].nombre);
    				} else {
    					$$invalidate(3, seguro = "N/A");
    				}
    			}
    		} catch(error) {
    			$$invalidate(0, cargando = false);
    			console.error(error);
    		}
    	}

    	onMount(async () => {
    		jQuery("html, body").animate({ scrollTop: 0 }, "slow");
    		await cargarPaciente();
    		await cargarAntecedentes();
    		await cargarHistoriasPaciente();
    		cargarCategoriasAntecedentes();
    		combinarAntecedentes();
    	});

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<PacientePerfil> was created with unknown prop '${key}'`);
    	});

    	function cabeceraperfil_cargando_binding(value) {
    		cargando = value;
    		$$invalidate(0, cargando);
    	}

    	function cabeceraperfil_edad_binding(value) {
    		edad = value;
    		$$invalidate(2, edad);
    	}

    	function cabeceraperfil_nombres_binding(value) {
    		paciente.nombres = value;
    		$$invalidate(1, paciente);
    	}

    	function cabeceraperfil_apellidos_binding(value) {
    		paciente.apellidos = value;
    		$$invalidate(1, paciente);
    	}

    	function cabeceraperfil_cedula_binding(value) {
    		paciente.cedula = value;
    		$$invalidate(1, paciente);
    	}

    	function cabeceraperfil_id_binding(value) {
    		paciente.id = value;
    		$$invalidate(1, paciente);
    	}

    	function tarjetaantecedentes_id_binding(value, categoria) {
    		categoria.id = value;
    		$$invalidate(4, categoriasAntecedentes);
    	}

    	function tarjetaantecedentes_nombre_binding(value, categoria) {
    		categoria.nombre = value;
    		$$invalidate(4, categoriasAntecedentes);
    	}

    	function tarjetaantecedentes_antecedentes_binding(value) {
    		paciente.antecedentes = value;
    		$$invalidate(1, paciente);
    	}

    	const click_handler = antecedente => cambiarEstadoAntecedente(antecedente.id);
    	const click_handler_1 = antecedente => eliminarAntecedente(antecedente.id);

    	function textarea_input_handler(each_value_1, antecedente_index) {
    		each_value_1[antecedente_index].descripcion = this.value;
    		$$invalidate(5, antecedentes);
    	}

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(18, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		push,
    		axios: axios$1,
    		onMount,
    		tick,
    		url,
    		Header,
    		Aside,
    		Evoluciones,
    		UltimosVitales,
    		Loading,
    		CabeceraPerfil,
    		ModalDatosPaciente,
    		TarjetaAntecedentes,
    		params,
    		cargando,
    		paciente,
    		edad,
    		seguro,
    		categoriasAntecedentes,
    		antecedentes,
    		historiasPaciente,
    		peso,
    		tipoPeso,
    		temperatura,
    		tipoTemperatura,
    		frecuenciaRespiratoria,
    		frecuenciaCardiaca,
    		presionAlterial,
    		cargarHistoriasPaciente,
    		actualizarAntecedentesPaciente,
    		combinarAntecedentes,
    		eliminarAntecedente,
    		cambiarEstadoAntecedente,
    		cargarAntecedentes,
    		cargarCategoriasAntecedentes,
    		cargarPaciente,
    		calcularEdad: calcularEdad$1
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(18, params = $$props.params);
    		if ("cargando" in $$props) $$invalidate(0, cargando = $$props.cargando);
    		if ("paciente" in $$props) $$invalidate(1, paciente = $$props.paciente);
    		if ("edad" in $$props) $$invalidate(2, edad = $$props.edad);
    		if ("seguro" in $$props) $$invalidate(3, seguro = $$props.seguro);
    		if ("categoriasAntecedentes" in $$props) $$invalidate(4, categoriasAntecedentes = $$props.categoriasAntecedentes);
    		if ("antecedentes" in $$props) $$invalidate(5, antecedentes = $$props.antecedentes);
    		if ("historiasPaciente" in $$props) $$invalidate(6, historiasPaciente = $$props.historiasPaciente);
    		if ("peso" in $$props) $$invalidate(7, peso = $$props.peso);
    		if ("tipoPeso" in $$props) $$invalidate(8, tipoPeso = $$props.tipoPeso);
    		if ("temperatura" in $$props) $$invalidate(9, temperatura = $$props.temperatura);
    		if ("tipoTemperatura" in $$props) $$invalidate(10, tipoTemperatura = $$props.tipoTemperatura);
    		if ("frecuenciaRespiratoria" in $$props) $$invalidate(11, frecuenciaRespiratoria = $$props.frecuenciaRespiratoria);
    		if ("frecuenciaCardiaca" in $$props) $$invalidate(12, frecuenciaCardiaca = $$props.frecuenciaCardiaca);
    		if ("presionAlterial" in $$props) $$invalidate(13, presionAlterial = $$props.presionAlterial);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		cargando,
    		paciente,
    		edad,
    		seguro,
    		categoriasAntecedentes,
    		antecedentes,
    		historiasPaciente,
    		peso,
    		tipoPeso,
    		temperatura,
    		tipoTemperatura,
    		frecuenciaRespiratoria,
    		frecuenciaCardiaca,
    		presionAlterial,
    		actualizarAntecedentesPaciente,
    		combinarAntecedentes,
    		eliminarAntecedente,
    		cambiarEstadoAntecedente,
    		params,
    		cabeceraperfil_cargando_binding,
    		cabeceraperfil_edad_binding,
    		cabeceraperfil_nombres_binding,
    		cabeceraperfil_apellidos_binding,
    		cabeceraperfil_cedula_binding,
    		cabeceraperfil_id_binding,
    		tarjetaantecedentes_id_binding,
    		tarjetaantecedentes_nombre_binding,
    		tarjetaantecedentes_antecedentes_binding,
    		click_handler,
    		click_handler_1,
    		textarea_input_handler
    	];
    }

    class PacientePerfil extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { params: 18 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PacientePerfil",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get params() {
    		throw new Error("<PacientePerfil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<PacientePerfil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\componentes\Select2.svelte generated by Svelte v3.29.0 */
    const file$f = "src\\componentes\\Select2.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (23:4) {#each datos as item}
    function create_each_block$4(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[5].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[5].id;
    			option.value = option.__value;
    			add_location(option, file$f, 23, 8, 533);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*datos*/ 2 && t_value !== (t_value = /*item*/ ctx[5].nombre + "")) set_data_dev(t, t_value);

    			if (dirty & /*datos*/ 2 && option_value_value !== (option_value_value = /*item*/ ctx[5].id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(23:4) {#each datos as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let label_1;
    	let t0;
    	let t1;
    	let select;
    	let option;
    	let t2;
    	let t3;
    	let select_class_value;
    	let each_value = /*datos*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			t0 = text(/*label*/ ctx[3]);
    			t1 = space();
    			select = element("select");
    			option = element("option");
    			t2 = text(/*placeholder*/ ctx[2]);
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(label_1, "for", /*id*/ ctx[0]);
    			add_location(label_1, file$f, 15, 0, 334);
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$f, 21, 4, 455);
    			attr_dev(select, "class", select_class_value = `form-control ${/*id*/ ctx[0]}`);
    			set_style(select, "width", "100%");
    			attr_dev(select, "id", /*id*/ ctx[0]);
    			add_location(select, file$f, 16, 0, 367);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, select, anchor);
    			append_dev(select, option);
    			append_dev(option, t2);
    			append_dev(option, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*label*/ 8) set_data_dev(t0, /*label*/ ctx[3]);

    			if (dirty & /*id*/ 1) {
    				attr_dev(label_1, "for", /*id*/ ctx[0]);
    			}

    			if (dirty & /*placeholder*/ 4) set_data_dev(t2, /*placeholder*/ ctx[2]);

    			if (dirty & /*datos*/ 2) {
    				each_value = /*datos*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*id*/ 1 && select_class_value !== (select_class_value = `form-control ${/*id*/ ctx[0]}`)) {
    				attr_dev(select, "class", select_class_value);
    			}

    			if (dirty & /*id*/ 1) {
    				attr_dev(select, "id", /*id*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(select);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Select2", slots, []);
    	let { id } = $$props;
    	let { datos } = $$props;
    	let { valor } = $$props;
    	let { placeholder } = $$props;
    	let { label } = $$props;

    	onMount(() => {
    		jQuery(`#${id}`).select2({ placeholder: `${placeholder}` });

    		jQuery(`#${id}`).on("select2:select", e => {
    			$$invalidate(4, valor = e.params.data.id);
    		});
    	});

    	const writable_props = ["id", "datos", "valor", "placeholder", "label"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Select2> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("datos" in $$props) $$invalidate(1, datos = $$props.datos);
    		if ("valor" in $$props) $$invalidate(4, valor = $$props.valor);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("label" in $$props) $$invalidate(3, label = $$props.label);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		id,
    		datos,
    		valor,
    		placeholder,
    		label
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("datos" in $$props) $$invalidate(1, datos = $$props.datos);
    		if ("valor" in $$props) $$invalidate(4, valor = $$props.valor);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("label" in $$props) $$invalidate(3, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [id, datos, placeholder, label, valor];
    }

    class Select2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
    			id: 0,
    			datos: 1,
    			valor: 4,
    			placeholder: 2,
    			label: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select2",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[0] === undefined && !("id" in props)) {
    			console.warn("<Select2> was created without expected prop 'id'");
    		}

    		if (/*datos*/ ctx[1] === undefined && !("datos" in props)) {
    			console.warn("<Select2> was created without expected prop 'datos'");
    		}

    		if (/*valor*/ ctx[4] === undefined && !("valor" in props)) {
    			console.warn("<Select2> was created without expected prop 'valor'");
    		}

    		if (/*placeholder*/ ctx[2] === undefined && !("placeholder" in props)) {
    			console.warn("<Select2> was created without expected prop 'placeholder'");
    		}

    		if (/*label*/ ctx[3] === undefined && !("label" in props)) {
    			console.warn("<Select2> was created without expected prop 'label'");
    		}
    	}

    	get id() {
    		throw new Error("<Select2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Select2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get datos() {
    		throw new Error("<Select2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set datos(value) {
    		throw new Error("<Select2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valor() {
    		throw new Error("<Select2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valor(value) {
    		throw new Error("<Select2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Select2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Select2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Select2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Select2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Pacientes\PacienteCrear.svelte generated by Svelte v3.29.0 */

    const { console: console_1$8 } = globals;
    const file$g = "src\\Pages\\Pacientes\\PacienteCrear.svelte";

    function create_fragment$h(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let section1;
    	let div6;
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let t2;
    	let h3;
    	let t4;
    	let form;
    	let section0;
    	let div40;
    	let div39;
    	let div38;
    	let div37;
    	let div36;
    	let h50;
    	let t6;
    	let div9;
    	let div7;
    	let label0;
    	let t8;
    	let input0;
    	let t9;
    	let div8;
    	let label1;
    	let t11;
    	let input1;
    	let t12;
    	let div12;
    	let div10;
    	let label2;
    	let t14;
    	let input2;
    	let t15;
    	let div11;
    	let label3;
    	let t17;
    	let select0;
    	let option0;
    	let option1;
    	let option2;
    	let t21;
    	let div15;
    	let div13;
    	let label4;
    	let t23;
    	let input3;
    	let t24;
    	let div14;
    	let label5;
    	let t26;
    	let select1;
    	let option3;
    	let option4;
    	let option5;
    	let t30;
    	let div18;
    	let div16;
    	let label6;
    	let t32;
    	let input4;
    	let t33;
    	let div17;
    	let label7;
    	let t35;
    	let input5;
    	let t36;
    	let div21;
    	let div19;
    	let label8;
    	let t38;
    	let input6;
    	let t39;
    	let div20;
    	let label9;
    	let t41;
    	let input7;
    	let t42;
    	let div23;
    	let div22;
    	let label10;
    	let input8;
    	let t43;
    	let span0;
    	let t44;
    	let span1;
    	let t46;
    	let div27;
    	let h51;
    	let t48;
    	let hr0;
    	let t49;
    	let div26;
    	let div24;
    	let select20;
    	let updating_valor;
    	let t50;
    	let div25;
    	let label11;
    	let t52;
    	let input9;
    	let div27_class_value;
    	let t53;
    	let h52;
    	let t55;
    	let hr1;
    	let t56;
    	let div30;
    	let div28;
    	let select21;
    	let updating_valor_1;
    	let t57;
    	let div29;
    	let select22;
    	let updating_valor_2;
    	let t58;
    	let div32;
    	let div31;
    	let select23;
    	let updating_valor_3;
    	let t59;
    	let div34;
    	let div33;
    	let label12;
    	let t61;
    	let input10;
    	let t62;
    	let div35;
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });

    	function select20_valor_binding(value) {
    		/*select20_valor_binding*/ ctx[30].call(null, value);
    	}

    	let select20_props = {
    		id: "sltAseguradoras",
    		datos: /*aseguradoras*/ ctx[1],
    		placeholder: " - seleccionar aseguradora - ",
    		label: "Aseguradora"
    	};

    	if (/*aseguradora*/ ctx[2] !== void 0) {
    		select20_props.valor = /*aseguradora*/ ctx[2];
    	}

    	select20 = new Select2({ props: select20_props, $$inline: true });
    	binding_callbacks.push(() => bind(select20, "valor", select20_valor_binding));

    	function select21_valor_binding(value) {
    		/*select21_valor_binding*/ ctx[32].call(null, value);
    	}

    	let select21_props = {
    		id: "sltCiudad",
    		datos: ciudades,
    		placeholder: " - seleccionar ciudad - ",
    		label: "Ciudad"
    	};

    	if (/*ciudad*/ ctx[14] !== void 0) {
    		select21_props.valor = /*ciudad*/ ctx[14];
    	}

    	select21 = new Select2({ props: select21_props, $$inline: true });
    	binding_callbacks.push(() => bind(select21, "valor", select21_valor_binding));

    	function select22_valor_binding(value) {
    		/*select22_valor_binding*/ ctx[33].call(null, value);
    	}

    	let select22_props = {
    		id: "sltProvincia",
    		datos: provincias,
    		placeholder: " - seleccionar provincia - ",
    		label: "Provincia"
    	};

    	if (/*provincia*/ ctx[15] !== void 0) {
    		select22_props.valor = /*provincia*/ ctx[15];
    	}

    	select22 = new Select2({ props: select22_props, $$inline: true });
    	binding_callbacks.push(() => bind(select22, "valor", select22_valor_binding));

    	function select23_valor_binding(value) {
    		/*select23_valor_binding*/ ctx[34].call(null, value);
    	}

    	let select23_props = {
    		id: "sltNacionalidad",
    		datos: nacionalidades,
    		placeholder: " - seleccionar nacionalidad - ",
    		label: "Nacionalidad"
    	};

    	if (/*nacionalidad*/ ctx[8] !== void 0) {
    		select23_props.valor = /*nacionalidad*/ ctx[8];
    	}

    	select23 = new Select2({ props: select23_props, $$inline: true });
    	binding_callbacks.push(() => bind(select23, "valor", select23_valor_binding));

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			section1 = element("section");
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t2 = space();
    			h3 = element("h3");
    			h3.textContent = "Nuevo paciente";
    			t4 = space();
    			form = element("form");
    			section0 = element("section");
    			div40 = element("div");
    			div39 = element("div");
    			div38 = element("div");
    			div37 = element("div");
    			div36 = element("div");
    			h50 = element("h5");
    			h50.textContent = "Datos personales";
    			t6 = space();
    			div9 = element("div");
    			div7 = element("div");
    			label0 = element("label");
    			label0.textContent = "Nombre";
    			t8 = space();
    			input0 = element("input");
    			t9 = space();
    			div8 = element("div");
    			label1 = element("label");
    			label1.textContent = "Apellidos";
    			t11 = space();
    			input1 = element("input");
    			t12 = space();
    			div12 = element("div");
    			div10 = element("div");
    			label2 = element("label");
    			label2.textContent = "Apodo";
    			t14 = space();
    			input2 = element("input");
    			t15 = space();
    			div11 = element("div");
    			label3 = element("label");
    			label3.textContent = "Sexo";
    			t17 = space();
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "- seleccionar sexo - ";
    			option1 = element("option");
    			option1.textContent = "Masculino";
    			option2 = element("option");
    			option2.textContent = "Femenino";
    			t21 = space();
    			div15 = element("div");
    			div13 = element("div");
    			label4 = element("label");
    			label4.textContent = "Fecha de nacimiento";
    			t23 = space();
    			input3 = element("input");
    			t24 = space();
    			div14 = element("div");
    			label5 = element("label");
    			label5.textContent = "Tipo de documento";
    			t26 = space();
    			select1 = element("select");
    			option3 = element("option");
    			option3.textContent = "- seleccionar tipo - ";
    			option4 = element("option");
    			option4.textContent = "Cedula";
    			option5 = element("option");
    			option5.textContent = "Pasaporte";
    			t30 = space();
    			div18 = element("div");
    			div16 = element("div");
    			label6 = element("label");
    			label6.textContent = "No. Cedula / Pasaporte";
    			t32 = space();
    			input4 = element("input");
    			t33 = space();
    			div17 = element("div");
    			label7 = element("label");
    			label7.textContent = "Telefono";
    			t35 = space();
    			input5 = element("input");
    			t36 = space();
    			div21 = element("div");
    			div19 = element("div");
    			label8 = element("label");
    			label8.textContent = "Celular";
    			t38 = space();
    			input6 = element("input");
    			t39 = space();
    			div20 = element("div");
    			label9 = element("label");
    			label9.textContent = "Correo electronico";
    			t41 = space();
    			input7 = element("input");
    			t42 = space();
    			div23 = element("div");
    			div22 = element("div");
    			label10 = element("label");
    			input8 = element("input");
    			t43 = space();
    			span0 = element("span");
    			t44 = space();
    			span1 = element("span");
    			span1.textContent = "El paciente es asegurado";
    			t46 = space();
    			div27 = element("div");
    			h51 = element("h5");
    			h51.textContent = "Informacion de seguro";
    			t48 = space();
    			hr0 = element("hr");
    			t49 = space();
    			div26 = element("div");
    			div24 = element("div");
    			create_component(select20.$$.fragment);
    			t50 = space();
    			div25 = element("div");
    			label11 = element("label");
    			label11.textContent = "No. Afiliado";
    			t52 = space();
    			input9 = element("input");
    			t53 = space();
    			h52 = element("h5");
    			h52.textContent = "Direccion";
    			t55 = space();
    			hr1 = element("hr");
    			t56 = space();
    			div30 = element("div");
    			div28 = element("div");
    			create_component(select21.$$.fragment);
    			t57 = space();
    			div29 = element("div");
    			create_component(select22.$$.fragment);
    			t58 = space();
    			div32 = element("div");
    			div31 = element("div");
    			create_component(select23.$$.fragment);
    			t59 = space();
    			div34 = element("div");
    			div33 = element("div");
    			label12 = element("label");
    			label12.textContent = "Direccion";
    			t61 = space();
    			input10 = element("input");
    			t62 = space();
    			div35 = element("div");
    			button = element("button");
    			button.textContent = "Guardar";
    			attr_dev(div0, "class", "avatar-title bg-info rounded-circle mdi mdi-account-circle-outline");
    			add_location(div0, file$g, 165, 28, 5408);
    			attr_dev(div1, "class", "avatar avatar-lg ");
    			add_location(div1, file$g, 164, 24, 5347);
    			attr_dev(div2, "class", "m-b-10");
    			add_location(div2, file$g, 163, 20, 5301);
    			add_location(h3, file$g, 168, 20, 5576);
    			attr_dev(div3, "class", "col-lg-8 text-center mx-auto text-white p-b-30");
    			add_location(div3, file$g, 162, 16, 5219);
    			attr_dev(div4, "class", "row p-b-60 p-t-60");
    			add_location(div4, file$g, 161, 12, 5170);
    			attr_dev(div5, "class", "container");
    			add_location(div5, file$g, 160, 8, 5133);
    			attr_dev(div6, "class", "bg-dark bg-dots m-b-30");
    			add_location(div6, file$g, 159, 4, 5087);
    			attr_dev(h50, "class", "");
    			add_location(h50, file$g, 180, 32, 6035);
    			attr_dev(label0, "for", "inpNombre");
    			add_location(label0, file$g, 183, 40, 6238);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "id", "inpNombre");
    			attr_dev(input0, "placeholder", "John");
    			input0.required = true;
    			add_location(input0, file$g, 184, 40, 6317);
    			attr_dev(div7, "class", "form-group col-md-6");
    			add_location(div7, file$g, 182, 36, 6163);
    			attr_dev(label1, "for", "inpApellido");
    			add_location(label1, file$g, 194, 40, 6891);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "id", "inpApellido");
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "placeholder", "Doe");
    			input1.required = true;
    			add_location(input1, file$g, 195, 40, 6975);
    			attr_dev(div8, "class", "form-group col-md-6");
    			add_location(div8, file$g, 193, 36, 6816);
    			attr_dev(div9, "class", "form-row");
    			add_location(div9, file$g, 181, 32, 6103);
    			attr_dev(label2, "for", "inpApodo");
    			add_location(label2, file$g, 207, 40, 7648);
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "class", "form-control");
    			attr_dev(input2, "id", "inpApodo");
    			add_location(input2, file$g, 208, 40, 7725);
    			attr_dev(div10, "class", "form-group col-md-6");
    			add_location(div10, file$g, 206, 36, 7573);
    			attr_dev(label3, "for", "sltSexo");
    			add_location(label3, file$g, 216, 40, 8178);
    			option0.__value = "";
    			option0.value = option0.__value;
    			option0.selected = true;
    			option0.disabled = true;
    			add_location(option0, file$g, 223, 44, 8590);
    			option1.__value = "Masculino";
    			option1.value = option1.__value;
    			add_location(option1, file$g, 224, 44, 8702);
    			option2.__value = "Femenino";
    			option2.value = option2.__value;
    			add_location(option2, file$g, 225, 44, 8792);
    			attr_dev(select0, "class", "form-control");
    			attr_dev(select0, "id", "sltSexo");
    			select0.required = true;
    			if (/*sexo*/ ctx[6] === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[22].call(select0));
    			add_location(select0, file$g, 217, 40, 8253);
    			attr_dev(div11, "class", "form-group col-md-6");
    			add_location(div11, file$g, 215, 36, 8103);
    			attr_dev(div12, "class", "form-row");
    			add_location(div12, file$g, 205, 32, 7513);
    			attr_dev(label4, "for", "inpFechaNacimiento");
    			add_location(label4, file$g, 231, 40, 9138);
    			attr_dev(input3, "type", "date");
    			attr_dev(input3, "class", "form-control");
    			attr_dev(input3, "id", "inpFechaNacimiento");
    			input3.required = true;
    			add_location(input3, file$g, 232, 40, 9239);
    			attr_dev(div13, "class", "form-group col-md-6");
    			add_location(div13, file$g, 230, 36, 9063);
    			attr_dev(label5, "for", "sltTipoDocumento");
    			add_location(label5, file$g, 241, 40, 9765);
    			option3.__value = "";
    			option3.value = option3.__value;
    			option3.selected = true;
    			option3.disabled = true;
    			add_location(option3, file$g, 247, 44, 10163);
    			option4.__value = "C";
    			option4.value = option4.__value;
    			add_location(option4, file$g, 248, 44, 10275);
    			option5.__value = "P";
    			option5.value = option5.__value;
    			add_location(option5, file$g, 249, 44, 10354);
    			attr_dev(select1, "class", "form-control");
    			attr_dev(select1, "id", "sltTipoDocumento");
    			if (/*tipoDocumento*/ ctx[12] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[24].call(select1));
    			add_location(select1, file$g, 242, 40, 9862);
    			attr_dev(div14, "class", "form-group col-md-6");
    			add_location(div14, file$g, 240, 36, 9690);
    			attr_dev(div15, "class", "form-row");
    			add_location(div15, file$g, 229, 32, 9003);
    			attr_dev(label6, "for", "inpNumeroDocumento");
    			add_location(label6, file$g, 255, 40, 10694);
    			attr_dev(input4, "type", "number");
    			attr_dev(input4, "class", "form-control");
    			attr_dev(input4, "id", "inpNumeroDocumento");
    			add_location(input4, file$g, 256, 40, 10798);
    			attr_dev(div16, "class", "form-group col-md-6");
    			add_location(div16, file$g, 254, 36, 10619);
    			attr_dev(label7, "for", "inpTelefono");
    			add_location(label7, file$g, 264, 40, 11265);
    			attr_dev(input5, "type", "tel");
    			attr_dev(input5, "class", "form-control");
    			attr_dev(input5, "id", "inpTelefono");
    			add_location(input5, file$g, 265, 40, 11348);
    			attr_dev(div17, "class", "form-group col-md-6");
    			add_location(div17, file$g, 263, 36, 11190);
    			attr_dev(div18, "class", "form-row");
    			add_location(div18, file$g, 253, 32, 10559);
    			attr_dev(label8, "for", "inpCelular");
    			add_location(label8, file$g, 275, 40, 11902);
    			attr_dev(input6, "type", "tel");
    			attr_dev(input6, "class", "form-control");
    			attr_dev(input6, "id", "inpCelular");
    			add_location(input6, file$g, 276, 40, 11983);
    			attr_dev(div19, "class", "form-group col-md-6");
    			add_location(div19, file$g, 274, 36, 11827);
    			attr_dev(label9, "for", "inpCorreo");
    			add_location(label9, file$g, 284, 40, 12439);
    			attr_dev(input7, "type", "email");
    			attr_dev(input7, "class", "form-control");
    			attr_dev(input7, "id", "inpCorreo");
    			add_location(input7, file$g, 285, 40, 12530);
    			attr_dev(div20, "class", "form-group col-md-6");
    			add_location(div20, file$g, 283, 36, 12364);
    			attr_dev(div21, "class", "form-row");
    			add_location(div21, file$g, 273, 32, 11767);
    			attr_dev(input8, "type", "checkbox");
    			attr_dev(input8, "name", "option");
    			input8.__value = "1";
    			input8.value = input8.__value;
    			attr_dev(input8, "class", "cstm-switch-input");
    			add_location(input8, file$g, 296, 44, 13144);
    			attr_dev(span0, "class", "cstm-switch-indicator bg-success ");
    			add_location(span0, file$g, 297, 44, 13288);
    			attr_dev(span1, "class", "cstm-switch-description");
    			add_location(span1, file$g, 298, 44, 13389);
    			attr_dev(label10, "class", "cstm-switch");
    			add_location(label10, file$g, 295, 40, 13071);
    			attr_dev(div22, "class", " m-b-10");
    			add_location(div22, file$g, 294, 36, 13008);
    			attr_dev(div23, "class", "form-group");
    			add_location(div23, file$g, 293, 32, 12946);
    			add_location(h51, file$g, 303, 40, 13802);
    			add_location(hr0, file$g, 304, 40, 13874);
    			attr_dev(div24, "class", "form-group col-md-6");
    			add_location(div24, file$g, 306, 44, 13988);
    			attr_dev(label11, "for", "inpNoAfiliado");
    			add_location(label11, file$g, 316, 48, 14686);
    			attr_dev(input9, "type", "number");
    			attr_dev(input9, "class", "form-control");
    			attr_dev(input9, "id", "inpNoAfiliado");
    			add_location(input9, file$g, 317, 48, 14783);
    			attr_dev(div25, "class", "form-group col-md-6");
    			add_location(div25, file$g, 315, 44, 14603);
    			attr_dev(div26, "class", "form-row");
    			add_location(div26, file$g, 305, 40, 13920);

    			attr_dev(div27, "class", div27_class_value = !/*asegurado*/ ctx[0]
    			? "hidden seguro animate__animated animate__bounceIn"
    			: "show seguro animate__animated animate__bounceIn");

    			add_location(div27, file$g, 302, 36, 13630);
    			attr_dev(h52, "class", "mt-3");
    			add_location(h52, file$g, 326, 32, 15311);
    			add_location(hr1, file$g, 327, 32, 15376);
    			attr_dev(div28, "class", "form-group col-md-6");
    			add_location(div28, file$g, 329, 36, 15474);
    			attr_dev(div29, "class", "form-group col-md-6");
    			add_location(div29, file$g, 338, 36, 16044);
    			attr_dev(div30, "class", "form-row");
    			add_location(div30, file$g, 328, 32, 15414);
    			attr_dev(div31, "class", "form-group col-md-6");
    			add_location(div31, file$g, 358, 36, 17298);
    			attr_dev(div32, "class", "form-row");
    			add_location(div32, file$g, 348, 32, 16640);
    			attr_dev(label12, "for", "inpDireccion");
    			add_location(label12, file$g, 370, 40, 18046);
    			attr_dev(input10, "type", "text");
    			attr_dev(input10, "class", "form-control");
    			attr_dev(input10, "id", "inpDireccion");
    			add_location(input10, file$g, 371, 40, 18131);
    			attr_dev(div33, "class", "form-group col-md-12");
    			add_location(div33, file$g, 369, 36, 17970);
    			attr_dev(div34, "class", "form-row");
    			add_location(div34, file$g, 368, 32, 17910);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "btn btn-success btn-cta");
    			add_location(button, file$g, 380, 36, 18615);
    			attr_dev(div35, "class", "text-right");
    			add_location(div35, file$g, 379, 32, 18553);
    			attr_dev(div36, "class", "card-body");
    			add_location(div36, file$g, 179, 27, 5978);
    			attr_dev(div37, "class", "card py-3 m-b-30");
    			add_location(div37, file$g, 178, 23, 5919);
    			attr_dev(div38, "class", "col-lg-8 mx-auto  mt-2");
    			add_location(div38, file$g, 177, 20, 5858);
    			attr_dev(div39, "class", "row ");
    			add_location(div39, file$g, 176, 16, 5818);
    			attr_dev(div40, "class", "container");
    			add_location(div40, file$g, 175, 12, 5777);
    			attr_dev(section0, "class", "pull-up");
    			add_location(section0, file$g, 174, 8, 5738);
    			add_location(form, file$g, 173, 4, 5677);
    			attr_dev(section1, "class", "admin-content ");
    			add_location(section1, file$g, 158, 2, 5049);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$g, 156, 0, 5006);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			append_dev(main, section1);
    			append_dev(section1, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div3, t2);
    			append_dev(div3, h3);
    			append_dev(section1, t4);
    			append_dev(section1, form);
    			append_dev(form, section0);
    			append_dev(section0, div40);
    			append_dev(div40, div39);
    			append_dev(div39, div38);
    			append_dev(div38, div37);
    			append_dev(div37, div36);
    			append_dev(div36, h50);
    			append_dev(div36, t6);
    			append_dev(div36, div9);
    			append_dev(div9, div7);
    			append_dev(div7, label0);
    			append_dev(div7, t8);
    			append_dev(div7, input0);
    			set_input_value(input0, /*nombres*/ ctx[3]);
    			append_dev(div9, t9);
    			append_dev(div9, div8);
    			append_dev(div8, label1);
    			append_dev(div8, t11);
    			append_dev(div8, input1);
    			set_input_value(input1, /*apellidos*/ ctx[4]);
    			append_dev(div36, t12);
    			append_dev(div36, div12);
    			append_dev(div12, div10);
    			append_dev(div10, label2);
    			append_dev(div10, t14);
    			append_dev(div10, input2);
    			set_input_value(input2, /*apodo*/ ctx[5]);
    			append_dev(div12, t15);
    			append_dev(div12, div11);
    			append_dev(div11, label3);
    			append_dev(div11, t17);
    			append_dev(div11, select0);
    			append_dev(select0, option0);
    			append_dev(select0, option1);
    			append_dev(select0, option2);
    			select_option(select0, /*sexo*/ ctx[6]);
    			append_dev(div36, t21);
    			append_dev(div36, div15);
    			append_dev(div15, div13);
    			append_dev(div13, label4);
    			append_dev(div13, t23);
    			append_dev(div13, input3);
    			set_input_value(input3, /*fechaNacimiento*/ ctx[7]);
    			append_dev(div15, t24);
    			append_dev(div15, div14);
    			append_dev(div14, label5);
    			append_dev(div14, t26);
    			append_dev(div14, select1);
    			append_dev(select1, option3);
    			append_dev(select1, option4);
    			append_dev(select1, option5);
    			select_option(select1, /*tipoDocumento*/ ctx[12]);
    			append_dev(div36, t30);
    			append_dev(div36, div18);
    			append_dev(div18, div16);
    			append_dev(div16, label6);
    			append_dev(div16, t32);
    			append_dev(div16, input4);
    			set_input_value(input4, /*cedula*/ ctx[11]);
    			append_dev(div18, t33);
    			append_dev(div18, div17);
    			append_dev(div17, label7);
    			append_dev(div17, t35);
    			append_dev(div17, input5);
    			set_input_value(input5, /*telefono*/ ctx[9]);
    			append_dev(div36, t36);
    			append_dev(div36, div21);
    			append_dev(div21, div19);
    			append_dev(div19, label8);
    			append_dev(div19, t38);
    			append_dev(div19, input6);
    			set_input_value(input6, /*celular*/ ctx[10]);
    			append_dev(div21, t39);
    			append_dev(div21, div20);
    			append_dev(div20, label9);
    			append_dev(div20, t41);
    			append_dev(div20, input7);
    			set_input_value(input7, /*email*/ ctx[17]);
    			append_dev(div36, t42);
    			append_dev(div36, div23);
    			append_dev(div23, div22);
    			append_dev(div22, label10);
    			append_dev(label10, input8);
    			input8.checked = /*asegurado*/ ctx[0];
    			append_dev(label10, t43);
    			append_dev(label10, span0);
    			append_dev(label10, t44);
    			append_dev(label10, span1);
    			append_dev(div36, t46);
    			append_dev(div36, div27);
    			append_dev(div27, h51);
    			append_dev(div27, t48);
    			append_dev(div27, hr0);
    			append_dev(div27, t49);
    			append_dev(div27, div26);
    			append_dev(div26, div24);
    			mount_component(select20, div24, null);
    			append_dev(div26, t50);
    			append_dev(div26, div25);
    			append_dev(div25, label11);
    			append_dev(div25, t52);
    			append_dev(div25, input9);
    			set_input_value(input9, /*numeroSeguro*/ ctx[13]);
    			append_dev(div36, t53);
    			append_dev(div36, h52);
    			append_dev(div36, t55);
    			append_dev(div36, hr1);
    			append_dev(div36, t56);
    			append_dev(div36, div30);
    			append_dev(div30, div28);
    			mount_component(select21, div28, null);
    			append_dev(div30, t57);
    			append_dev(div30, div29);
    			mount_component(select22, div29, null);
    			append_dev(div36, t58);
    			append_dev(div36, div32);
    			append_dev(div32, div31);
    			mount_component(select23, div31, null);
    			append_dev(div36, t59);
    			append_dev(div36, div34);
    			append_dev(div34, div33);
    			append_dev(div33, label12);
    			append_dev(div33, t61);
    			append_dev(div33, input10);
    			set_input_value(input10, /*direccion*/ ctx[16]);
    			append_dev(div36, t62);
    			append_dev(div36, div35);
    			append_dev(div35, button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[19]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[20]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[21]),
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[22]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[23]),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[24]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[25]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[26]),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[27]),
    					listen_dev(input7, "input", /*input7_input_handler*/ ctx[28]),
    					listen_dev(input8, "change", /*input8_change_handler*/ ctx[29]),
    					listen_dev(input9, "input", /*input9_input_handler*/ ctx[31]),
    					listen_dev(input10, "input", /*input10_input_handler*/ ctx[35]),
    					listen_dev(form, "submit", prevent_default(/*registrarPaciente*/ ctx[18]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*nombres*/ 8 && input0.value !== /*nombres*/ ctx[3]) {
    				set_input_value(input0, /*nombres*/ ctx[3]);
    			}

    			if (dirty[0] & /*apellidos*/ 16 && input1.value !== /*apellidos*/ ctx[4]) {
    				set_input_value(input1, /*apellidos*/ ctx[4]);
    			}

    			if (dirty[0] & /*apodo*/ 32 && input2.value !== /*apodo*/ ctx[5]) {
    				set_input_value(input2, /*apodo*/ ctx[5]);
    			}

    			if (dirty[0] & /*sexo*/ 64) {
    				select_option(select0, /*sexo*/ ctx[6]);
    			}

    			if (dirty[0] & /*fechaNacimiento*/ 128) {
    				set_input_value(input3, /*fechaNacimiento*/ ctx[7]);
    			}

    			if (dirty[0] & /*tipoDocumento*/ 4096) {
    				select_option(select1, /*tipoDocumento*/ ctx[12]);
    			}

    			if (dirty[0] & /*cedula*/ 2048 && to_number(input4.value) !== /*cedula*/ ctx[11]) {
    				set_input_value(input4, /*cedula*/ ctx[11]);
    			}

    			if (dirty[0] & /*telefono*/ 512) {
    				set_input_value(input5, /*telefono*/ ctx[9]);
    			}

    			if (dirty[0] & /*celular*/ 1024) {
    				set_input_value(input6, /*celular*/ ctx[10]);
    			}

    			if (dirty[0] & /*email*/ 131072 && input7.value !== /*email*/ ctx[17]) {
    				set_input_value(input7, /*email*/ ctx[17]);
    			}

    			if (dirty[0] & /*asegurado*/ 1) {
    				input8.checked = /*asegurado*/ ctx[0];
    			}

    			const select20_changes = {};
    			if (dirty[0] & /*aseguradoras*/ 2) select20_changes.datos = /*aseguradoras*/ ctx[1];

    			if (!updating_valor && dirty[0] & /*aseguradora*/ 4) {
    				updating_valor = true;
    				select20_changes.valor = /*aseguradora*/ ctx[2];
    				add_flush_callback(() => updating_valor = false);
    			}

    			select20.$set(select20_changes);

    			if (dirty[0] & /*numeroSeguro*/ 8192 && to_number(input9.value) !== /*numeroSeguro*/ ctx[13]) {
    				set_input_value(input9, /*numeroSeguro*/ ctx[13]);
    			}

    			if (!current || dirty[0] & /*asegurado*/ 1 && div27_class_value !== (div27_class_value = !/*asegurado*/ ctx[0]
    			? "hidden seguro animate__animated animate__bounceIn"
    			: "show seguro animate__animated animate__bounceIn")) {
    				attr_dev(div27, "class", div27_class_value);
    			}

    			const select21_changes = {};

    			if (!updating_valor_1 && dirty[0] & /*ciudad*/ 16384) {
    				updating_valor_1 = true;
    				select21_changes.valor = /*ciudad*/ ctx[14];
    				add_flush_callback(() => updating_valor_1 = false);
    			}

    			select21.$set(select21_changes);
    			const select22_changes = {};

    			if (!updating_valor_2 && dirty[0] & /*provincia*/ 32768) {
    				updating_valor_2 = true;
    				select22_changes.valor = /*provincia*/ ctx[15];
    				add_flush_callback(() => updating_valor_2 = false);
    			}

    			select22.$set(select22_changes);
    			const select23_changes = {};

    			if (!updating_valor_3 && dirty[0] & /*nacionalidad*/ 256) {
    				updating_valor_3 = true;
    				select23_changes.valor = /*nacionalidad*/ ctx[8];
    				add_flush_callback(() => updating_valor_3 = false);
    			}

    			select23.$set(select23_changes);

    			if (dirty[0] & /*direccion*/ 65536 && input10.value !== /*direccion*/ ctx[16]) {
    				set_input_value(input10, /*direccion*/ ctx[16]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(select20.$$.fragment, local);
    			transition_in(select21.$$.fragment, local);
    			transition_in(select22.$$.fragment, local);
    			transition_in(select23.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(select20.$$.fragment, local);
    			transition_out(select21.$$.fragment, local);
    			transition_out(select22.$$.fragment, local);
    			transition_out(select23.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			destroy_component(select20);
    			destroy_component(select21);
    			destroy_component(select22);
    			destroy_component(select23);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PacienteCrear", slots, []);
    	let asegurado = false;
    	let aseguradoras = [];
    	let aseguradora = "";
    	let nombres = "";
    	let apellidos = "";
    	let apodo = "";
    	let sexo = "";
    	let fechaNacimiento = "";
    	let nacionalidad = "";
    	let estadoCivil = "";
    	let telefono = "";
    	let celular = "";
    	let cedula = "";
    	let tipoDocumento = "";
    	let religion = "";
    	let ocupacion = "";
    	let numeroSeguro = "";
    	let ciudad = "";
    	let provincia = "";
    	let direccion = "";
    	let email = "";
    	let empresa = {};
    	let responsables = [];
    	let usuario = {};

    	const registrarPaciente = () => {
    		const paciente = {
    			nombres,
    			apellidos,
    			apodo,
    			sexo,
    			fechaNacimiento: new Date(fechaNacimiento),
    			nacionalidad,
    			estadoCivil,
    			telefono,
    			celular,
    			cedula,
    			tipoDocumento,
    			religion,
    			ocupacion,
    			seguroMedico: aseguradoras.filter(x => x.id === aseguradora),
    			numeroSeguro,
    			ciudad,
    			provincia,
    			direccion,
    			email,
    			empresa: empresa.id,
    			responsables,
    			usuario: usuario.id,
    			antecedentes: []
    		};

    		const config = {
    			method: "post",
    			url: `${url}/pacientes`,
    			data: paciente,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			if (res.status === 200) {
    				push(`/pacientes/perfil/${res.data.id}`);
    			}

    			if (res.status === 201) {
    				Swal.fire({
    					title: "El paciente ya existe",
    					text: "Deseas cargar su perfil?",
    					icon: "warning",
    					showCancelButton: true,
    					confirmButtonColor: "#3085d6",
    					cancelButtonColor: "#d33",
    					confirmButtonText: "Si, cargar perfil!",
    					cancelButtonText: "Cancelar"
    				}).then(result => {
    					if (result.isConfirmed) {
    						push(`/pacientes/perfil/${res.data}`);
    					}
    				});
    			}
    		}).catch(error => {
    			if (error.response.data.error == 5010) {
    				Swal.fire({
    					title: "Suscripcin vencida",
    					text: "Para registrar mas paciente puede renovar su suscripcin, comuniquese con el administrador: vnc3xp@gmail.com",
    					icon: "error",
    					showCancelButton: false,
    					confirmButtonColor: "#3085d6",
    					cancelButtonColor: "#d33",
    					confirmButtonText: "Ok"
    				}).then(result => {
    					if (result.isConfirmed) {
    						return false;
    					}
    				});
    			}
    		});
    	};

    	function cargarAseguradoras() {
    		const config = {
    			method: "get",
    			url: `${url}/Aseguradoras`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(1, aseguradoras = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	}

    	const cargarUsuario = () => {
    		const config = {
    			method: "get",
    			url: `${url}/usuarios/${user().id}`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			usuario = res.data;
    			empresa = res.data.empresa;
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	onMount(() => {
    		jQuery(".select-aseguradoras").select2({
    			placeholder: " - seleccionar aseguradora - "
    		});

    		jQuery(".select-aseguradoras").on("select2:select", e => {
    			console.log(e.params.data.id);
    		});

    		cargarAseguradoras();
    		cargarUsuario();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<PacienteCrear> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		nombres = this.value;
    		$$invalidate(3, nombres);
    	}

    	function input1_input_handler() {
    		apellidos = this.value;
    		$$invalidate(4, apellidos);
    	}

    	function input2_input_handler() {
    		apodo = this.value;
    		$$invalidate(5, apodo);
    	}

    	function select0_change_handler() {
    		sexo = select_value(this);
    		$$invalidate(6, sexo);
    	}

    	function input3_input_handler() {
    		fechaNacimiento = this.value;
    		$$invalidate(7, fechaNacimiento);
    	}

    	function select1_change_handler() {
    		tipoDocumento = select_value(this);
    		$$invalidate(12, tipoDocumento);
    	}

    	function input4_input_handler() {
    		cedula = to_number(this.value);
    		$$invalidate(11, cedula);
    	}

    	function input5_input_handler() {
    		telefono = this.value;
    		$$invalidate(9, telefono);
    	}

    	function input6_input_handler() {
    		celular = this.value;
    		$$invalidate(10, celular);
    	}

    	function input7_input_handler() {
    		email = this.value;
    		$$invalidate(17, email);
    	}

    	function input8_change_handler() {
    		asegurado = this.checked;
    		$$invalidate(0, asegurado);
    	}

    	function select20_valor_binding(value) {
    		aseguradora = value;
    		$$invalidate(2, aseguradora);
    	}

    	function input9_input_handler() {
    		numeroSeguro = to_number(this.value);
    		$$invalidate(13, numeroSeguro);
    	}

    	function select21_valor_binding(value) {
    		ciudad = value;
    		$$invalidate(14, ciudad);
    	}

    	function select22_valor_binding(value) {
    		provincia = value;
    		$$invalidate(15, provincia);
    	}

    	function select23_valor_binding(value) {
    		nacionalidad = value;
    		$$invalidate(8, nacionalidad);
    	}

    	function input10_input_handler() {
    		direccion = this.value;
    		$$invalidate(16, direccion);
    	}

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		Header,
    		Aside,
    		Select2,
    		push,
    		onMount,
    		url,
    		user,
    		ciudades,
    		provincias,
    		nacionalidades,
    		asegurado,
    		aseguradoras,
    		aseguradora,
    		nombres,
    		apellidos,
    		apodo,
    		sexo,
    		fechaNacimiento,
    		nacionalidad,
    		estadoCivil,
    		telefono,
    		celular,
    		cedula,
    		tipoDocumento,
    		religion,
    		ocupacion,
    		numeroSeguro,
    		ciudad,
    		provincia,
    		direccion,
    		email,
    		empresa,
    		responsables,
    		usuario,
    		registrarPaciente,
    		cargarAseguradoras,
    		cargarUsuario
    	});

    	$$self.$inject_state = $$props => {
    		if ("asegurado" in $$props) $$invalidate(0, asegurado = $$props.asegurado);
    		if ("aseguradoras" in $$props) $$invalidate(1, aseguradoras = $$props.aseguradoras);
    		if ("aseguradora" in $$props) $$invalidate(2, aseguradora = $$props.aseguradora);
    		if ("nombres" in $$props) $$invalidate(3, nombres = $$props.nombres);
    		if ("apellidos" in $$props) $$invalidate(4, apellidos = $$props.apellidos);
    		if ("apodo" in $$props) $$invalidate(5, apodo = $$props.apodo);
    		if ("sexo" in $$props) $$invalidate(6, sexo = $$props.sexo);
    		if ("fechaNacimiento" in $$props) $$invalidate(7, fechaNacimiento = $$props.fechaNacimiento);
    		if ("nacionalidad" in $$props) $$invalidate(8, nacionalidad = $$props.nacionalidad);
    		if ("estadoCivil" in $$props) estadoCivil = $$props.estadoCivil;
    		if ("telefono" in $$props) $$invalidate(9, telefono = $$props.telefono);
    		if ("celular" in $$props) $$invalidate(10, celular = $$props.celular);
    		if ("cedula" in $$props) $$invalidate(11, cedula = $$props.cedula);
    		if ("tipoDocumento" in $$props) $$invalidate(12, tipoDocumento = $$props.tipoDocumento);
    		if ("religion" in $$props) religion = $$props.religion;
    		if ("ocupacion" in $$props) ocupacion = $$props.ocupacion;
    		if ("numeroSeguro" in $$props) $$invalidate(13, numeroSeguro = $$props.numeroSeguro);
    		if ("ciudad" in $$props) $$invalidate(14, ciudad = $$props.ciudad);
    		if ("provincia" in $$props) $$invalidate(15, provincia = $$props.provincia);
    		if ("direccion" in $$props) $$invalidate(16, direccion = $$props.direccion);
    		if ("email" in $$props) $$invalidate(17, email = $$props.email);
    		if ("empresa" in $$props) empresa = $$props.empresa;
    		if ("responsables" in $$props) responsables = $$props.responsables;
    		if ("usuario" in $$props) usuario = $$props.usuario;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		asegurado,
    		aseguradoras,
    		aseguradora,
    		nombres,
    		apellidos,
    		apodo,
    		sexo,
    		fechaNacimiento,
    		nacionalidad,
    		telefono,
    		celular,
    		cedula,
    		tipoDocumento,
    		numeroSeguro,
    		ciudad,
    		provincia,
    		direccion,
    		email,
    		registrarPaciente,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		select0_change_handler,
    		input3_input_handler,
    		select1_change_handler,
    		input4_input_handler,
    		input5_input_handler,
    		input6_input_handler,
    		input7_input_handler,
    		input8_change_handler,
    		select20_valor_binding,
    		input9_input_handler,
    		select21_valor_binding,
    		select22_valor_binding,
    		select23_valor_binding,
    		input10_input_handler
    	];
    }

    class PacienteCrear extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PacienteCrear",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src\Pages\Pacientes\PacienteEditar.svelte generated by Svelte v3.29.0 */

    const { console: console_1$9 } = globals;
    const file$h = "src\\Pages\\Pacientes\\PacienteEditar.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[30] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[30] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[30] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[30] = list[i];
    	return child_ctx;
    }

    // (134:2) {#if msgError}
    function create_if_block_1$7(ctx) {
    	let errorconexion;
    	let current;

    	errorconexion = new ErrorConexion({
    			props: { msgError: /*msgError*/ ctx[7] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(errorconexion.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorconexion, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const errorconexion_changes = {};
    			if (dirty[0] & /*msgError*/ 128) errorconexion_changes.msgError = /*msgError*/ ctx[7];
    			errorconexion.$set(errorconexion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorconexion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorconexion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorconexion, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(134:2) {#if msgError}",
    		ctx
    	});

    	return block;
    }

    // (137:2) {#if cargando}
    function create_if_block$b(ctx) {
    	let div;
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loading.$$.fragment);
    			attr_dev(div, "class", "cargando");
    			add_location(div, file$h, 137, 4, 4293);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loading, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(137:2) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    // (294:52) {#each aseguradoras as item}
    function create_each_block_3$1(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[30].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[30].id;
    			option.value = option.__value;
    			add_location(option, file$h, 294, 57, 13821);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*aseguradoras*/ 4 && t_value !== (t_value = /*item*/ ctx[30].nombre + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*aseguradoras*/ 4 && option_value_value !== (option_value_value = /*item*/ ctx[30].id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(294:52) {#each aseguradoras as item}",
    		ctx
    	});

    	return block;
    }

    // (323:44) {#each ciudades as item}
    function create_each_block_2$1(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[30].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[30].id;
    			option.value = option.__value;
    			add_location(option, file$h, 323, 49, 15782);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(323:44) {#each ciudades as item}",
    		ctx
    	});

    	return block;
    }

    // (338:44) {#each provincias as item}
    function create_each_block_1$2(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[30].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[30].id;
    			option.value = option.__value;
    			add_location(option, file$h, 338, 49, 16819);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(338:44) {#each provincias as item}",
    		ctx
    	});

    	return block;
    }

    // (364:44) {#each nacionalidades as item}
    function create_each_block$5(ctx) {
    	let option;
    	let t_value = /*item*/ ctx[30].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*item*/ ctx[30].id;
    			option.value = option.__value;
    			add_location(option, file$h, 364, 49, 18550);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(364:44) {#each nacionalidades as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let t2;
    	let t3;
    	let section1;
    	let div6;
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let t4;
    	let h3;
    	let t5_value = /*paciente*/ ctx[4].nombres + "";
    	let t5;
    	let t6;
    	let t7_value = /*paciente*/ ctx[4].apellidos + "";
    	let t7;
    	let t8;
    	let form;
    	let section0;
    	let div40;
    	let div39;
    	let div38;
    	let div37;
    	let div36;
    	let h50;
    	let t10;
    	let div9;
    	let div7;
    	let label0;
    	let t12;
    	let input0;
    	let t13;
    	let div8;
    	let label1;
    	let t15;
    	let input1;
    	let t16;
    	let div12;
    	let div10;
    	let label2;
    	let t18;
    	let input2;
    	let t19;
    	let div11;
    	let label3;
    	let t21;
    	let select0;
    	let option0;
    	let option1;
    	let option2;
    	let t25;
    	let div15;
    	let div13;
    	let label4;
    	let t27;
    	let input3;
    	let t28;
    	let div14;
    	let label5;
    	let t30;
    	let select1;
    	let option3;
    	let option4;
    	let option5;
    	let t34;
    	let div18;
    	let div16;
    	let label6;
    	let t36;
    	let input4;
    	let t37;
    	let div17;
    	let label7;
    	let t39;
    	let input5;
    	let t40;
    	let div21;
    	let div19;
    	let label8;
    	let t42;
    	let input6;
    	let t43;
    	let div20;
    	let label9;
    	let t45;
    	let input7;
    	let t46;
    	let div23;
    	let div22;
    	let label10;
    	let input8;
    	let t47;
    	let span0;
    	let t48;
    	let span1;
    	let t50;
    	let div27;
    	let h51;
    	let t52;
    	let hr0;
    	let t53;
    	let div26;
    	let div24;
    	let label11;
    	let t55;
    	let select2;
    	let t56;
    	let div25;
    	let label12;
    	let t58;
    	let input9;
    	let div27_class_value;
    	let t59;
    	let h52;
    	let t61;
    	let hr1;
    	let t62;
    	let div30;
    	let div28;
    	let label13;
    	let t64;
    	let select3;
    	let t65;
    	let div29;
    	let label14;
    	let t67;
    	let select4;
    	let t68;
    	let div32;
    	let div31;
    	let label15;
    	let t70;
    	let select5;
    	let t71;
    	let div34;
    	let div33;
    	let label16;
    	let t73;
    	let input10;
    	let t74;
    	let div35;
    	let a;
    	let t75;
    	let a_href_value;
    	let link_action;
    	let t76;
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });
    	let if_block0 = /*msgError*/ ctx[7] && create_if_block_1$7(ctx);
    	let if_block1 = /*cargando*/ ctx[6] && create_if_block$b(ctx);
    	let each_value_3 = /*aseguradoras*/ ctx[2];
    	validate_each_argument(each_value_3);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_3[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	let each_value_2 = ciudades;
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	let each_value_1 = provincias;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	let each_value = nacionalidades;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			section1 = element("section");
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t4 = space();
    			h3 = element("h3");
    			t5 = text(t5_value);
    			t6 = space();
    			t7 = text(t7_value);
    			t8 = space();
    			form = element("form");
    			section0 = element("section");
    			div40 = element("div");
    			div39 = element("div");
    			div38 = element("div");
    			div37 = element("div");
    			div36 = element("div");
    			h50 = element("h5");
    			h50.textContent = "Datos personales";
    			t10 = space();
    			div9 = element("div");
    			div7 = element("div");
    			label0 = element("label");
    			label0.textContent = "Nombre";
    			t12 = space();
    			input0 = element("input");
    			t13 = space();
    			div8 = element("div");
    			label1 = element("label");
    			label1.textContent = "Apellidos";
    			t15 = space();
    			input1 = element("input");
    			t16 = space();
    			div12 = element("div");
    			div10 = element("div");
    			label2 = element("label");
    			label2.textContent = "Apodo";
    			t18 = space();
    			input2 = element("input");
    			t19 = space();
    			div11 = element("div");
    			label3 = element("label");
    			label3.textContent = "Sexo";
    			t21 = space();
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "- seleccionar sexo - ";
    			option1 = element("option");
    			option1.textContent = "Masculino";
    			option2 = element("option");
    			option2.textContent = "Femenino";
    			t25 = space();
    			div15 = element("div");
    			div13 = element("div");
    			label4 = element("label");
    			label4.textContent = "Fecha de nacimiento";
    			t27 = space();
    			input3 = element("input");
    			t28 = space();
    			div14 = element("div");
    			label5 = element("label");
    			label5.textContent = "Tipo de documento";
    			t30 = space();
    			select1 = element("select");
    			option3 = element("option");
    			option3.textContent = "- seleccionar tipo - ";
    			option4 = element("option");
    			option4.textContent = "Cedula";
    			option5 = element("option");
    			option5.textContent = "Pasaporte";
    			t34 = space();
    			div18 = element("div");
    			div16 = element("div");
    			label6 = element("label");
    			label6.textContent = "No. Cedula / Pasaporte";
    			t36 = space();
    			input4 = element("input");
    			t37 = space();
    			div17 = element("div");
    			label7 = element("label");
    			label7.textContent = "Telefono";
    			t39 = space();
    			input5 = element("input");
    			t40 = space();
    			div21 = element("div");
    			div19 = element("div");
    			label8 = element("label");
    			label8.textContent = "Celular";
    			t42 = space();
    			input6 = element("input");
    			t43 = space();
    			div20 = element("div");
    			label9 = element("label");
    			label9.textContent = "Correo electronico";
    			t45 = space();
    			input7 = element("input");
    			t46 = space();
    			div23 = element("div");
    			div22 = element("div");
    			label10 = element("label");
    			input8 = element("input");
    			t47 = space();
    			span0 = element("span");
    			t48 = space();
    			span1 = element("span");
    			span1.textContent = "El paciente es asegurado";
    			t50 = space();
    			div27 = element("div");
    			h51 = element("h5");
    			h51.textContent = "Informacion de seguro";
    			t52 = space();
    			hr0 = element("hr");
    			t53 = space();
    			div26 = element("div");
    			div24 = element("div");
    			label11 = element("label");
    			label11.textContent = "Aseguradora";
    			t55 = space();
    			select2 = element("select");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t56 = space();
    			div25 = element("div");
    			label12 = element("label");
    			label12.textContent = "No. Afiliado";
    			t58 = space();
    			input9 = element("input");
    			t59 = space();
    			h52 = element("h5");
    			h52.textContent = "Direccion";
    			t61 = space();
    			hr1 = element("hr");
    			t62 = space();
    			div30 = element("div");
    			div28 = element("div");
    			label13 = element("label");
    			label13.textContent = "Ciudad";
    			t64 = space();
    			select3 = element("select");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t65 = space();
    			div29 = element("div");
    			label14 = element("label");
    			label14.textContent = "Provincia";
    			t67 = space();
    			select4 = element("select");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t68 = space();
    			div32 = element("div");
    			div31 = element("div");
    			label15 = element("label");
    			label15.textContent = "Nacionalidad";
    			t70 = space();
    			select5 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t71 = space();
    			div34 = element("div");
    			div33 = element("div");
    			label16 = element("label");
    			label16.textContent = "Direccion";
    			t73 = space();
    			input10 = element("input");
    			t74 = space();
    			div35 = element("div");
    			a = element("a");
    			t75 = text("Ir al perfil");
    			t76 = space();
    			button = element("button");
    			button.textContent = "Guardar";
    			attr_dev(div0, "class", "avatar-title bg-info rounded-circle mdi mdi-account-circle-outline");
    			add_location(div0, file$h, 148, 28, 4719);
    			attr_dev(div1, "class", "avatar avatar-lg ");
    			add_location(div1, file$h, 147, 24, 4658);
    			attr_dev(div2, "class", "m-b-10");
    			add_location(div2, file$h, 146, 20, 4612);
    			add_location(h3, file$h, 151, 20, 4887);
    			attr_dev(div3, "class", "col-lg-8 text-center mx-auto text-white p-b-30");
    			add_location(div3, file$h, 145, 16, 4530);
    			attr_dev(div4, "class", "row p-b-60 p-t-60");
    			add_location(div4, file$h, 144, 12, 4481);
    			attr_dev(div5, "class", "container");
    			add_location(div5, file$h, 143, 8, 4444);
    			attr_dev(div6, "class", "bg-dark bg-dots m-b-30");
    			add_location(div6, file$h, 142, 4, 4398);
    			attr_dev(h50, "class", "");
    			add_location(h50, file$h, 163, 32, 5372);
    			attr_dev(label0, "for", "inpNombre");
    			add_location(label0, file$h, 166, 40, 5575);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "id", "inpNombre");
    			attr_dev(input0, "placeholder", "John");
    			input0.required = true;
    			add_location(input0, file$h, 167, 40, 5654);
    			attr_dev(div7, "class", "form-group col-md-6");
    			add_location(div7, file$h, 165, 36, 5500);
    			attr_dev(label1, "for", "inpApellido");
    			add_location(label1, file$h, 177, 40, 6237);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "id", "inpApellido");
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "placeholder", "Doe");
    			input1.required = true;
    			add_location(input1, file$h, 178, 40, 6321);
    			attr_dev(div8, "class", "form-group col-md-6");
    			add_location(div8, file$h, 176, 36, 6162);
    			attr_dev(div9, "class", "form-row");
    			add_location(div9, file$h, 164, 32, 5440);
    			attr_dev(label2, "for", "inpApodo");
    			add_location(label2, file$h, 190, 40, 7003);
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "class", "form-control");
    			attr_dev(input2, "id", "inpApodo");
    			add_location(input2, file$h, 191, 40, 7080);
    			attr_dev(div10, "class", "form-group col-md-6");
    			add_location(div10, file$h, 189, 36, 6928);
    			attr_dev(label3, "for", "sltSexo");
    			add_location(label3, file$h, 199, 40, 7542);
    			option0.__value = "";
    			option0.value = option0.__value;
    			option0.selected = true;
    			option0.disabled = true;
    			add_location(option0, file$h, 206, 44, 7963);
    			option1.__value = "Masculino";
    			option1.value = option1.__value;
    			add_location(option1, file$h, 207, 44, 8075);
    			option2.__value = "Femenino";
    			option2.value = option2.__value;
    			add_location(option2, file$h, 208, 44, 8165);
    			attr_dev(select0, "class", "form-control");
    			attr_dev(select0, "id", "sltSexo");
    			select0.required = true;
    			if (/*paciente*/ ctx[4].sexo === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[12].call(select0));
    			add_location(select0, file$h, 200, 40, 7617);
    			attr_dev(div11, "class", "form-group col-md-6");
    			add_location(div11, file$h, 198, 36, 7467);
    			attr_dev(div12, "class", "form-row");
    			add_location(div12, file$h, 188, 32, 6868);
    			attr_dev(label4, "for", "inpFechaNacimiento");
    			add_location(label4, file$h, 214, 40, 8511);
    			attr_dev(input3, "type", "date");
    			attr_dev(input3, "class", "form-control");
    			attr_dev(input3, "id", "inpFechaNacimiento");
    			input3.required = true;
    			add_location(input3, file$h, 215, 40, 8612);
    			attr_dev(div13, "class", "form-group col-md-6");
    			add_location(div13, file$h, 213, 36, 8436);
    			attr_dev(label5, "for", "sltTipoDocumento");
    			add_location(label5, file$h, 224, 40, 9138);
    			option3.__value = "";
    			option3.value = option3.__value;
    			option3.selected = true;
    			option3.disabled = true;
    			add_location(option3, file$h, 231, 44, 9599);
    			option4.__value = "C";
    			option4.value = option4.__value;
    			add_location(option4, file$h, 232, 44, 9711);
    			option5.__value = "P";
    			option5.value = option5.__value;
    			add_location(option5, file$h, 233, 44, 9790);
    			attr_dev(select1, "class", "form-control");
    			attr_dev(select1, "id", "sltTipoDocumento");
    			select1.required = true;
    			if (/*paciente*/ ctx[4].tipoDocumento === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[14].call(select1));
    			add_location(select1, file$h, 225, 40, 9235);
    			attr_dev(div14, "class", "form-group col-md-6");
    			add_location(div14, file$h, 223, 36, 9063);
    			attr_dev(div15, "class", "form-row");
    			add_location(div15, file$h, 212, 32, 8376);
    			attr_dev(label6, "for", "inpNumeroDocumento");
    			add_location(label6, file$h, 239, 40, 10130);
    			attr_dev(input4, "type", "number");
    			attr_dev(input4, "class", "form-control");
    			attr_dev(input4, "id", "inpNumeroDocumento");
    			add_location(input4, file$h, 240, 40, 10234);
    			attr_dev(div16, "class", "form-group col-md-6");
    			add_location(div16, file$h, 238, 36, 10055);
    			attr_dev(label7, "for", "inpTelefono");
    			add_location(label7, file$h, 248, 40, 10710);
    			attr_dev(input5, "type", "tel");
    			attr_dev(input5, "class", "form-control");
    			attr_dev(input5, "id", "inpTelefono");
    			add_location(input5, file$h, 249, 40, 10793);
    			attr_dev(div17, "class", "form-group col-md-6");
    			add_location(div17, file$h, 247, 36, 10635);
    			attr_dev(div18, "class", "form-row");
    			add_location(div18, file$h, 237, 32, 9995);
    			attr_dev(label8, "for", "inpCelular");
    			add_location(label8, file$h, 259, 40, 11356);
    			attr_dev(input6, "type", "tel");
    			attr_dev(input6, "class", "form-control");
    			attr_dev(input6, "id", "inpCelular");
    			add_location(input6, file$h, 260, 40, 11437);
    			attr_dev(div19, "class", "form-group col-md-6");
    			add_location(div19, file$h, 258, 36, 11281);
    			attr_dev(label9, "for", "inpCorreo");
    			add_location(label9, file$h, 268, 40, 11902);
    			attr_dev(input7, "type", "email");
    			attr_dev(input7, "class", "form-control");
    			attr_dev(input7, "id", "inpCorreo");
    			add_location(input7, file$h, 269, 40, 11993);
    			attr_dev(div20, "class", "form-group col-md-6");
    			add_location(div20, file$h, 267, 36, 11827);
    			attr_dev(div21, "class", "form-row");
    			add_location(div21, file$h, 257, 32, 11221);
    			attr_dev(input8, "type", "checkbox");
    			attr_dev(input8, "name", "option");
    			input8.__value = "1";
    			input8.value = input8.__value;
    			attr_dev(input8, "class", "cstm-switch-input");
    			add_location(input8, file$h, 280, 44, 12616);
    			attr_dev(span0, "class", "cstm-switch-indicator bg-success ");
    			add_location(span0, file$h, 281, 44, 12760);
    			attr_dev(span1, "class", "cstm-switch-description");
    			add_location(span1, file$h, 282, 44, 12861);
    			attr_dev(label10, "class", "cstm-switch");
    			add_location(label10, file$h, 279, 40, 12543);
    			attr_dev(div22, "class", " m-b-10");
    			add_location(div22, file$h, 278, 36, 12480);
    			attr_dev(div23, "class", "form-group");
    			add_location(div23, file$h, 277, 32, 12418);
    			add_location(h51, file$h, 287, 40, 13274);
    			add_location(hr0, file$h, 288, 40, 13346);
    			attr_dev(label11, "for", "");
    			add_location(label11, file$h, 291, 48, 13543);
    			attr_dev(select2, "class", "form-control");
    			if (/*aseguradora*/ ctx[3] === void 0) add_render_callback(() => /*select2_change_handler*/ ctx[20].call(select2));
    			add_location(select2, file$h, 292, 48, 13626);
    			attr_dev(div24, "class", "form-group col-md-6");
    			add_location(div24, file$h, 290, 44, 13460);
    			attr_dev(label12, "for", "inpNoAfiliado");
    			add_location(label12, file$h, 306, 48, 14661);
    			attr_dev(input9, "type", "number");
    			attr_dev(input9, "class", "form-control");
    			attr_dev(input9, "id", "inpNoAfiliado");
    			add_location(input9, file$h, 307, 48, 14758);
    			attr_dev(div25, "class", "form-group col-md-6");
    			add_location(div25, file$h, 305, 44, 14578);
    			attr_dev(div26, "class", "form-row");
    			add_location(div26, file$h, 289, 40, 13392);

    			attr_dev(div27, "class", div27_class_value = !/*asegurado*/ ctx[1]
    			? "hidden seguro animate__animated animate__bounceIn"
    			: "show seguro animate__animated animate__bounceIn");

    			add_location(div27, file$h, 286, 36, 13102);
    			attr_dev(h52, "class", "mt-3");
    			add_location(h52, file$h, 316, 32, 15295);
    			add_location(hr1, file$h, 317, 32, 15360);
    			attr_dev(label13, "for", "");
    			add_location(label13, file$h, 320, 40, 15533);
    			attr_dev(select3, "class", "form-control");
    			if (/*paciente*/ ctx[4].ciudad === void 0) add_render_callback(() => /*select3_change_handler*/ ctx[22].call(select3));
    			add_location(select3, file$h, 321, 40, 15603);
    			attr_dev(div28, "class", "form-group col-md-6");
    			add_location(div28, file$h, 319, 36, 15458);
    			attr_dev(label14, "for", "");
    			add_location(label14, file$h, 335, 40, 16562);
    			attr_dev(select4, "class", "form-control");
    			if (/*paciente*/ ctx[4].provincia === void 0) add_render_callback(() => /*select4_change_handler*/ ctx[23].call(select4));
    			add_location(select4, file$h, 336, 40, 16635);
    			attr_dev(div29, "class", "form-group col-md-6");
    			add_location(div29, file$h, 334, 36, 16487);
    			attr_dev(div30, "class", "form-row");
    			add_location(div30, file$h, 318, 32, 15398);
    			attr_dev(label15, "for", "");
    			add_location(label15, file$h, 361, 40, 18283);
    			attr_dev(select5, "class", "form-control");
    			if (/*paciente*/ ctx[4].nacionalidad === void 0) add_render_callback(() => /*select5_change_handler*/ ctx[24].call(select5));
    			add_location(select5, file$h, 362, 40, 18359);
    			attr_dev(div31, "class", "form-group col-md-6");
    			add_location(div31, file$h, 360, 36, 18208);
    			attr_dev(div32, "class", "form-row");
    			add_location(div32, file$h, 350, 32, 17550);
    			attr_dev(label16, "for", "inpDireccion");
    			add_location(label16, file$h, 378, 40, 19433);
    			attr_dev(input10, "type", "text");
    			attr_dev(input10, "class", "form-control");
    			attr_dev(input10, "id", "inpDireccion");
    			add_location(input10, file$h, 379, 40, 19518);
    			attr_dev(div33, "class", "form-group col-md-12");
    			add_location(div33, file$h, 377, 36, 19357);
    			attr_dev(div34, "class", "form-row");
    			add_location(div34, file$h, 376, 32, 19297);
    			attr_dev(a, "href", a_href_value = `/pacientes/perfil/${/*params*/ ctx[0].idPaciente}`);
    			attr_dev(a, "class", "btn btn-primary btn-cta");
    			add_location(a, file$h, 388, 36, 20011);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "btn btn-success btn-cta");
    			add_location(button, file$h, 391, 36, 20237);
    			attr_dev(div35, "class", "text-right");
    			add_location(div35, file$h, 387, 32, 19949);
    			attr_dev(div36, "class", "card-body");
    			add_location(div36, file$h, 162, 27, 5315);
    			attr_dev(div37, "class", "card py-3 m-b-30");
    			add_location(div37, file$h, 161, 23, 5256);
    			attr_dev(div38, "class", "col-lg-8 mx-auto  mt-2");
    			add_location(div38, file$h, 160, 20, 5195);
    			attr_dev(div39, "class", "row ");
    			add_location(div39, file$h, 159, 16, 5155);
    			attr_dev(div40, "class", "container");
    			add_location(div40, file$h, 158, 12, 5114);
    			attr_dev(section0, "class", "pull-up");
    			add_location(section0, file$h, 157, 8, 5075);
    			add_location(form, file$h, 156, 4, 5013);
    			attr_dev(section1, "class", "admin-content ");
    			add_location(section1, file$h, 141, 2, 4360);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$h, 131, 0, 4167);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t2);
    			if (if_block1) if_block1.m(main, null);
    			append_dev(main, t3);
    			append_dev(main, section1);
    			append_dev(section1, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div3, t4);
    			append_dev(div3, h3);
    			append_dev(h3, t5);
    			append_dev(h3, t6);
    			append_dev(h3, t7);
    			append_dev(section1, t8);
    			append_dev(section1, form);
    			append_dev(form, section0);
    			append_dev(section0, div40);
    			append_dev(div40, div39);
    			append_dev(div39, div38);
    			append_dev(div38, div37);
    			append_dev(div37, div36);
    			append_dev(div36, h50);
    			append_dev(div36, t10);
    			append_dev(div36, div9);
    			append_dev(div9, div7);
    			append_dev(div7, label0);
    			append_dev(div7, t12);
    			append_dev(div7, input0);
    			set_input_value(input0, /*paciente*/ ctx[4].nombres);
    			append_dev(div9, t13);
    			append_dev(div9, div8);
    			append_dev(div8, label1);
    			append_dev(div8, t15);
    			append_dev(div8, input1);
    			set_input_value(input1, /*paciente*/ ctx[4].apellidos);
    			append_dev(div36, t16);
    			append_dev(div36, div12);
    			append_dev(div12, div10);
    			append_dev(div10, label2);
    			append_dev(div10, t18);
    			append_dev(div10, input2);
    			set_input_value(input2, /*paciente*/ ctx[4].apodo);
    			append_dev(div12, t19);
    			append_dev(div12, div11);
    			append_dev(div11, label3);
    			append_dev(div11, t21);
    			append_dev(div11, select0);
    			append_dev(select0, option0);
    			append_dev(select0, option1);
    			append_dev(select0, option2);
    			select_option(select0, /*paciente*/ ctx[4].sexo);
    			append_dev(div36, t25);
    			append_dev(div36, div15);
    			append_dev(div15, div13);
    			append_dev(div13, label4);
    			append_dev(div13, t27);
    			append_dev(div13, input3);
    			set_input_value(input3, /*fechaNacimiento*/ ctx[5]);
    			append_dev(div15, t28);
    			append_dev(div15, div14);
    			append_dev(div14, label5);
    			append_dev(div14, t30);
    			append_dev(div14, select1);
    			append_dev(select1, option3);
    			append_dev(select1, option4);
    			append_dev(select1, option5);
    			select_option(select1, /*paciente*/ ctx[4].tipoDocumento);
    			append_dev(div36, t34);
    			append_dev(div36, div18);
    			append_dev(div18, div16);
    			append_dev(div16, label6);
    			append_dev(div16, t36);
    			append_dev(div16, input4);
    			set_input_value(input4, /*paciente*/ ctx[4].cedula);
    			append_dev(div18, t37);
    			append_dev(div18, div17);
    			append_dev(div17, label7);
    			append_dev(div17, t39);
    			append_dev(div17, input5);
    			set_input_value(input5, /*paciente*/ ctx[4].telefono);
    			append_dev(div36, t40);
    			append_dev(div36, div21);
    			append_dev(div21, div19);
    			append_dev(div19, label8);
    			append_dev(div19, t42);
    			append_dev(div19, input6);
    			set_input_value(input6, /*paciente*/ ctx[4].celular);
    			append_dev(div21, t43);
    			append_dev(div21, div20);
    			append_dev(div20, label9);
    			append_dev(div20, t45);
    			append_dev(div20, input7);
    			set_input_value(input7, /*paciente*/ ctx[4].email);
    			append_dev(div36, t46);
    			append_dev(div36, div23);
    			append_dev(div23, div22);
    			append_dev(div22, label10);
    			append_dev(label10, input8);
    			input8.checked = /*asegurado*/ ctx[1];
    			append_dev(label10, t47);
    			append_dev(label10, span0);
    			append_dev(label10, t48);
    			append_dev(label10, span1);
    			append_dev(div36, t50);
    			append_dev(div36, div27);
    			append_dev(div27, h51);
    			append_dev(div27, t52);
    			append_dev(div27, hr0);
    			append_dev(div27, t53);
    			append_dev(div27, div26);
    			append_dev(div26, div24);
    			append_dev(div24, label11);
    			append_dev(div24, t55);
    			append_dev(div24, select2);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(select2, null);
    			}

    			select_option(select2, /*aseguradora*/ ctx[3]);
    			append_dev(div26, t56);
    			append_dev(div26, div25);
    			append_dev(div25, label12);
    			append_dev(div25, t58);
    			append_dev(div25, input9);
    			set_input_value(input9, /*paciente*/ ctx[4].numeroSeguro);
    			append_dev(div36, t59);
    			append_dev(div36, h52);
    			append_dev(div36, t61);
    			append_dev(div36, hr1);
    			append_dev(div36, t62);
    			append_dev(div36, div30);
    			append_dev(div30, div28);
    			append_dev(div28, label13);
    			append_dev(div28, t64);
    			append_dev(div28, select3);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(select3, null);
    			}

    			select_option(select3, /*paciente*/ ctx[4].ciudad);
    			append_dev(div30, t65);
    			append_dev(div30, div29);
    			append_dev(div29, label14);
    			append_dev(div29, t67);
    			append_dev(div29, select4);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select4, null);
    			}

    			select_option(select4, /*paciente*/ ctx[4].provincia);
    			append_dev(div36, t68);
    			append_dev(div36, div32);
    			append_dev(div32, div31);
    			append_dev(div31, label15);
    			append_dev(div31, t70);
    			append_dev(div31, select5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select5, null);
    			}

    			select_option(select5, /*paciente*/ ctx[4].nacionalidad);
    			append_dev(div36, t71);
    			append_dev(div36, div34);
    			append_dev(div34, div33);
    			append_dev(div33, label16);
    			append_dev(div33, t73);
    			append_dev(div33, input10);
    			set_input_value(input10, /*paciente*/ ctx[4].direccion);
    			append_dev(div36, t74);
    			append_dev(div36, div35);
    			append_dev(div35, a);
    			append_dev(a, t75);
    			append_dev(div35, t76);
    			append_dev(div35, button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[9]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[10]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[11]),
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[12]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[13]),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[14]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[15]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[16]),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[17]),
    					listen_dev(input7, "input", /*input7_input_handler*/ ctx[18]),
    					listen_dev(input8, "change", /*input8_change_handler*/ ctx[19]),
    					listen_dev(select2, "change", /*select2_change_handler*/ ctx[20]),
    					listen_dev(input9, "input", /*input9_input_handler*/ ctx[21]),
    					listen_dev(select3, "change", /*select3_change_handler*/ ctx[22]),
    					listen_dev(select4, "change", /*select4_change_handler*/ ctx[23]),
    					listen_dev(select5, "change", /*select5_change_handler*/ ctx[24]),
    					listen_dev(input10, "input", /*input10_input_handler*/ ctx[25]),
    					action_destroyer(link_action = link.call(null, a)),
    					listen_dev(form, "submit", prevent_default(/*actualizarPaciente*/ ctx[8]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*msgError*/ ctx[7]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*msgError*/ 128) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(main, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*cargando*/ ctx[6]) {
    				if (if_block1) {
    					if (dirty[0] & /*cargando*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$b(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(main, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*paciente*/ 16) && t5_value !== (t5_value = /*paciente*/ ctx[4].nombres + "")) set_data_dev(t5, t5_value);
    			if ((!current || dirty[0] & /*paciente*/ 16) && t7_value !== (t7_value = /*paciente*/ ctx[4].apellidos + "")) set_data_dev(t7, t7_value);

    			if (dirty[0] & /*paciente*/ 16 && input0.value !== /*paciente*/ ctx[4].nombres) {
    				set_input_value(input0, /*paciente*/ ctx[4].nombres);
    			}

    			if (dirty[0] & /*paciente*/ 16 && input1.value !== /*paciente*/ ctx[4].apellidos) {
    				set_input_value(input1, /*paciente*/ ctx[4].apellidos);
    			}

    			if (dirty[0] & /*paciente*/ 16 && input2.value !== /*paciente*/ ctx[4].apodo) {
    				set_input_value(input2, /*paciente*/ ctx[4].apodo);
    			}

    			if (dirty[0] & /*paciente*/ 16) {
    				select_option(select0, /*paciente*/ ctx[4].sexo);
    			}

    			if (dirty[0] & /*fechaNacimiento*/ 32) {
    				set_input_value(input3, /*fechaNacimiento*/ ctx[5]);
    			}

    			if (dirty[0] & /*paciente*/ 16) {
    				select_option(select1, /*paciente*/ ctx[4].tipoDocumento);
    			}

    			if (dirty[0] & /*paciente*/ 16 && to_number(input4.value) !== /*paciente*/ ctx[4].cedula) {
    				set_input_value(input4, /*paciente*/ ctx[4].cedula);
    			}

    			if (dirty[0] & /*paciente*/ 16) {
    				set_input_value(input5, /*paciente*/ ctx[4].telefono);
    			}

    			if (dirty[0] & /*paciente*/ 16) {
    				set_input_value(input6, /*paciente*/ ctx[4].celular);
    			}

    			if (dirty[0] & /*paciente*/ 16 && input7.value !== /*paciente*/ ctx[4].email) {
    				set_input_value(input7, /*paciente*/ ctx[4].email);
    			}

    			if (dirty[0] & /*asegurado*/ 2) {
    				input8.checked = /*asegurado*/ ctx[1];
    			}

    			if (dirty[0] & /*aseguradoras*/ 4) {
    				each_value_3 = /*aseguradoras*/ ctx[2];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_3$1(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(select2, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_3.length;
    			}

    			if (dirty[0] & /*aseguradora, aseguradoras*/ 12) {
    				select_option(select2, /*aseguradora*/ ctx[3]);
    			}

    			if (dirty[0] & /*paciente*/ 16 && to_number(input9.value) !== /*paciente*/ ctx[4].numeroSeguro) {
    				set_input_value(input9, /*paciente*/ ctx[4].numeroSeguro);
    			}

    			if (!current || dirty[0] & /*asegurado*/ 2 && div27_class_value !== (div27_class_value = !/*asegurado*/ ctx[1]
    			? "hidden seguro animate__animated animate__bounceIn"
    			: "show seguro animate__animated animate__bounceIn")) {
    				attr_dev(div27, "class", div27_class_value);
    			}

    			if (dirty & /*ciudades*/ 0) {
    				each_value_2 = ciudades;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2$1(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(select3, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (dirty[0] & /*paciente*/ 16) {
    				select_option(select3, /*paciente*/ ctx[4].ciudad);
    			}

    			if (dirty & /*provincias*/ 0) {
    				each_value_1 = provincias;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select4, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty[0] & /*paciente*/ 16) {
    				select_option(select4, /*paciente*/ ctx[4].provincia);
    			}

    			if (dirty & /*nacionalidades*/ 0) {
    				each_value = nacionalidades;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select5, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*paciente*/ 16) {
    				select_option(select5, /*paciente*/ ctx[4].nacionalidad);
    			}

    			if (dirty[0] & /*paciente*/ 16 && input10.value !== /*paciente*/ ctx[4].direccion) {
    				set_input_value(input10, /*paciente*/ ctx[4].direccion);
    			}

    			if (!current || dirty[0] & /*params*/ 1 && a_href_value !== (a_href_value = `/pacientes/perfil/${/*params*/ ctx[0].idPaciente}`)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PacienteEditar", slots, []);
    	let { params } = $$props;

    	const Toast = Swal.mixin({
    		toast: true,
    		position: "top-end",
    		showConfirmButton: false,
    		timer: 3000,
    		timerProgressBar: true,
    		didOpen: toast => {
    			toast.addEventListener("mouseenter", Swal.stopTimer);
    			toast.addEventListener("mouseleave", Swal.resumeTimer);
    		}
    	});

    	let asegurado = false;
    	let aseguradoras = [];
    	let aseguradora = "";
    	let usuario = {};
    	let paciente = {};
    	let fechaNacimiento = "";
    	let cargando = false;
    	let msgError = "";

    	const cargarPaciente = async () => {
    		const config = {
    			method: "get",
    			url: `${url}/pacientes/${params.idPaciente}`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		try {
    			let promesa = await axios$1(config);
    			$$invalidate(4, paciente = promesa.data);
    			$$invalidate(5, fechaNacimiento = promesa.data.fechaNacimiento.split("T")[0]);

    			if (promesa.data.seguroMedico[0]) {
    				$$invalidate(1, asegurado = true);
    				$$invalidate(3, aseguradora = promesa.data.seguroMedico[0].id);
    			}

    			console.log(promesa.data);
    		} catch(error) {
    			
    		}
    	};

    	const actualizarPaciente = () => {
    		$$invalidate(7, msgError = "");
    		$$invalidate(6, cargando = true);

    		const data = {
    			nombres: paciente.nombres,
    			apellidos: paciente.apellidos,
    			apodo: paciente.apodo,
    			sexo: paciente.sexo,
    			fechaNacimiento: new Date(fechaNacimiento),
    			nacionalidad: paciente.nacionalidad,
    			estadoCivil: paciente.estadoCivil,
    			telefono: paciente.telefono,
    			celular: paciente.celular,
    			cedula: paciente.cedula,
    			tipoDocumento: paciente.tipoDocumento,
    			religion: paciente.religion,
    			ocupacion: paciente.ocupacion,
    			seguroMedico: aseguradoras.filter(x => x.id === aseguradora),
    			numeroSeguro: paciente.numeroSeguro,
    			ciudad: paciente.ciudad,
    			provincia: paciente.provincia,
    			direccion: paciente.direccion,
    			email: paciente.email,
    			responsables: paciente.responsables
    		};

    		const config = {
    			method: "put",
    			url: `${url}/pacientes/${params.idPaciente}`,
    			data,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(6, cargando = false);

    			if (res.status === 200) {
    				Toast.fire({
    					icon: "success",
    					title: "Se actualizo el paciente"
    				});
    			}
    		}).catch(error => {
    			$$invalidate(6, cargando = false);
    			$$invalidate(7, msgError = "Ocurrio un error, intentelo mas tarde.");
    			console.log(error);
    		});
    	};

    	function cargarAseguradoras() {
    		console.log("cargando aseguradoras");

    		const config = {
    			method: "get",
    			url: `${url}/Aseguradoras`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(2, aseguradoras = res.data);
    			console.log(aseguradoras);
    		}).catch(err => {
    			console.error(err);
    		});
    	}

    	onMount(async () => {
    		await cargarPaciente();
    		cargarAseguradoras();
    	});

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$9.warn(`<PacienteEditar> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		paciente.nombres = this.value;
    		$$invalidate(4, paciente);
    	}

    	function input1_input_handler() {
    		paciente.apellidos = this.value;
    		$$invalidate(4, paciente);
    	}

    	function input2_input_handler() {
    		paciente.apodo = this.value;
    		$$invalidate(4, paciente);
    	}

    	function select0_change_handler() {
    		paciente.sexo = select_value(this);
    		$$invalidate(4, paciente);
    	}

    	function input3_input_handler() {
    		fechaNacimiento = this.value;
    		$$invalidate(5, fechaNacimiento);
    	}

    	function select1_change_handler() {
    		paciente.tipoDocumento = select_value(this);
    		$$invalidate(4, paciente);
    	}

    	function input4_input_handler() {
    		paciente.cedula = to_number(this.value);
    		$$invalidate(4, paciente);
    	}

    	function input5_input_handler() {
    		paciente.telefono = this.value;
    		$$invalidate(4, paciente);
    	}

    	function input6_input_handler() {
    		paciente.celular = this.value;
    		$$invalidate(4, paciente);
    	}

    	function input7_input_handler() {
    		paciente.email = this.value;
    		$$invalidate(4, paciente);
    	}

    	function input8_change_handler() {
    		asegurado = this.checked;
    		$$invalidate(1, asegurado);
    	}

    	function select2_change_handler() {
    		aseguradora = select_value(this);
    		$$invalidate(3, aseguradora);
    		$$invalidate(2, aseguradoras);
    	}

    	function input9_input_handler() {
    		paciente.numeroSeguro = to_number(this.value);
    		$$invalidate(4, paciente);
    	}

    	function select3_change_handler() {
    		paciente.ciudad = select_value(this);
    		$$invalidate(4, paciente);
    	}

    	function select4_change_handler() {
    		paciente.provincia = select_value(this);
    		$$invalidate(4, paciente);
    	}

    	function select5_change_handler() {
    		paciente.nacionalidad = select_value(this);
    		$$invalidate(4, paciente);
    	}

    	function input10_input_handler() {
    		paciente.direccion = this.value;
    		$$invalidate(4, paciente);
    	}

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		Header,
    		Aside,
    		Select2,
    		Loading,
    		ErrorConexion,
    		push,
    		link,
    		onMount,
    		url,
    		user,
    		ciudades,
    		provincias,
    		nacionalidades,
    		params,
    		Toast,
    		asegurado,
    		aseguradoras,
    		aseguradora,
    		usuario,
    		paciente,
    		fechaNacimiento,
    		cargando,
    		msgError,
    		cargarPaciente,
    		actualizarPaciente,
    		cargarAseguradoras
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    		if ("asegurado" in $$props) $$invalidate(1, asegurado = $$props.asegurado);
    		if ("aseguradoras" in $$props) $$invalidate(2, aseguradoras = $$props.aseguradoras);
    		if ("aseguradora" in $$props) $$invalidate(3, aseguradora = $$props.aseguradora);
    		if ("usuario" in $$props) usuario = $$props.usuario;
    		if ("paciente" in $$props) $$invalidate(4, paciente = $$props.paciente);
    		if ("fechaNacimiento" in $$props) $$invalidate(5, fechaNacimiento = $$props.fechaNacimiento);
    		if ("cargando" in $$props) $$invalidate(6, cargando = $$props.cargando);
    		if ("msgError" in $$props) $$invalidate(7, msgError = $$props.msgError);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		params,
    		asegurado,
    		aseguradoras,
    		aseguradora,
    		paciente,
    		fechaNacimiento,
    		cargando,
    		msgError,
    		actualizarPaciente,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		select0_change_handler,
    		input3_input_handler,
    		select1_change_handler,
    		input4_input_handler,
    		input5_input_handler,
    		input6_input_handler,
    		input7_input_handler,
    		input8_change_handler,
    		select2_change_handler,
    		input9_input_handler,
    		select3_change_handler,
    		select4_change_handler,
    		select5_change_handler,
    		input10_input_handler
    	];
    }

    class PacienteEditar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { params: 0 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PacienteEditar",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*params*/ ctx[0] === undefined && !("params" in props)) {
    			console_1$9.warn("<PacienteEditar> was created without expected prop 'params'");
    		}
    	}

    	get params() {
    		throw new Error("<PacienteEditar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<PacienteEditar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

    function validate(uuid) {
      return typeof uuid === 'string' && REGEX.test(uuid);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = [];

    for (var i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1));
    }

    function stringify(arr) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }

      return uuid;
    }

    function v4(options, buf, offset) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return stringify(rnds);
    }

    /* src\Layout\AsideAtencion.svelte generated by Svelte v3.29.0 */
    const file$i = "src\\Layout\\AsideAtencion.svelte";

    function create_fragment$j(ctx) {
    	let aside;
    	let div1;
    	let span0;
    	let a0;
    	let link_action;
    	let t1;
    	let div0;
    	let a1;
    	let t2;
    	let a2;
    	let t3;
    	let div2;
    	let ul;
    	let li0;
    	let a3;
    	let span2;
    	let span1;
    	let t5;
    	let span4;
    	let span3;
    	let t7;
    	let i0;
    	let link_action_1;
    	let active_action;
    	let t8;
    	let li1;
    	let a4;
    	let span6;
    	let span5;
    	let t10;
    	let span7;
    	let i1;
    	let link_action_2;
    	let active_action_1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			aside = element("aside");
    			div1 = element("div");
    			span0 = element("span");
    			a0 = element("a");
    			a0.textContent = "xmedical";
    			t1 = space();
    			div0 = element("div");
    			a1 = element("a");
    			t2 = space();
    			a2 = element("a");
    			t3 = space();
    			div2 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			a3 = element("a");
    			span2 = element("span");
    			span1 = element("span");
    			span1.textContent = "IR A INICIO";
    			t5 = space();
    			span4 = element("span");
    			span3 = element("span");
    			span3.textContent = "1";
    			t7 = space();
    			i0 = element("i");
    			t8 = space();
    			li1 = element("li");
    			a4 = element("a");
    			span6 = element("span");
    			span5 = element("span");
    			span5.textContent = "Historia Clinica";
    			t10 = space();
    			span7 = element("span");
    			i1 = element("i");
    			attr_dev(a0, "href", "/");
    			add_location(a0, file$i, 9, 8, 286);
    			attr_dev(span0, "class", "admin-brand-content");
    			add_location(span0, file$i, 8, 6, 242);
    			attr_dev(a1, "href", "#!");
    			attr_dev(a1, "class", "admin-pin-sidebar btn-ghost btn btn-rounded-circle pinned");
    			add_location(a1, file$i, 14, 8, 438);
    			attr_dev(a2, "href", "#!");
    			attr_dev(a2, "class", "admin-close-sidebar");
    			add_location(a2, file$i, 18, 8, 611);
    			attr_dev(div0, "class", "ml-auto");
    			add_location(div0, file$i, 12, 6, 378);
    			attr_dev(div1, "class", "admin-sidebar-brand");
    			add_location(div1, file$i, 6, 4, 163);
    			attr_dev(span1, "class", "menu-name");
    			add_location(span1, file$i, 30, 14, 1041);
    			attr_dev(span2, "class", "menu-label");
    			add_location(span2, file$i, 29, 12, 1000);
    			attr_dev(span3, "class", "icon-badge badge-success badge badge-pill");
    			add_location(span3, file$i, 33, 14, 1158);
    			attr_dev(i0, "class", "icon-placeholder mdi-24px mdi mdi-home");
    			add_location(i0, file$i, 34, 14, 1238);
    			attr_dev(span4, "class", "menu-icon");
    			add_location(span4, file$i, 32, 12, 1118);
    			attr_dev(a3, "href", "/");
    			attr_dev(a3, "class", "menu-link");
    			add_location(a3, file$i, 28, 10, 947);
    			attr_dev(li0, "class", "menu-item");
    			add_location(li0, file$i, 27, 8, 867);
    			attr_dev(span5, "class", "menu-name");
    			add_location(span5, file$i, 44, 16, 1684);
    			attr_dev(span6, "class", "menu-label");
    			add_location(span6, file$i, 43, 12, 1641);
    			attr_dev(i1, "class", "icon-placeholder mdi-24px mdi mdi-format-list-bulleted-type");
    			add_location(i1, file$i, 47, 16, 1808);
    			attr_dev(span7, "class", "menu-icon");
    			add_location(span7, file$i, 46, 12, 1766);
    			attr_dev(a4, "href", "/pacientes/:idPaciente/historias/:idHistoria");
    			attr_dev(a4, "class", "menu-link");
    			add_location(a4, file$i, 42, 12, 1545);
    			attr_dev(li1, "class", "menu-item");
    			add_location(li1, file$i, 41, 8, 1420);
    			attr_dev(ul, "class", "menu");
    			add_location(ul, file$i, 25, 6, 807);
    			attr_dev(div2, "class", "admin-sidebar-wrapper js-scrollbar");
    			add_location(div2, file$i, 23, 4, 719);
    			attr_dev(aside, "class", "admin-sidebar");
    			add_location(aside, file$i, 5, 2, 128);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, aside, anchor);
    			append_dev(aside, div1);
    			append_dev(div1, span0);
    			append_dev(span0, a0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, a1);
    			append_dev(div0, t2);
    			append_dev(div0, a2);
    			append_dev(aside, t3);
    			append_dev(aside, div2);
    			append_dev(div2, ul);
    			append_dev(ul, li0);
    			append_dev(li0, a3);
    			append_dev(a3, span2);
    			append_dev(span2, span1);
    			append_dev(a3, t5);
    			append_dev(a3, span4);
    			append_dev(span4, span3);
    			append_dev(span4, t7);
    			append_dev(span4, i0);
    			append_dev(ul, t8);
    			append_dev(ul, li1);
    			append_dev(li1, a4);
    			append_dev(a4, span6);
    			append_dev(span6, span5);
    			append_dev(a4, t10);
    			append_dev(a4, span7);
    			append_dev(span7, i1);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link_action = link.call(null, a0)),
    					action_destroyer(link_action_1 = link.call(null, a3)),
    					action_destroyer(active_action = active$1.call(null, li0, { path: "/", className: "active" })),
    					action_destroyer(link_action_2 = link.call(null, a4)),
    					action_destroyer(active_action_1 = active$1.call(null, li1, {
    						path: "/pacientes/:idPaciente/historias/:idHistoria",
    						className: "active"
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(aside);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AsideAtencion", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AsideAtencion> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, active: active$1 });
    	return [];
    }

    class AsideAtencion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AsideAtencion",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src\componentes\Modals\ModalTratamientos.svelte generated by Svelte v3.29.0 */

    const file$j = "src\\componentes\\Modals\\ModalTratamientos.svelte";

    function create_fragment$k(ctx) {
    	let div30;
    	let div29;
    	let div28;
    	let div0;
    	let h5;
    	let t1;
    	let button0;
    	let span0;
    	let t3;
    	let form;
    	let div26;
    	let div3;
    	let div2;
    	let input0;
    	let t4;
    	let input1;
    	let t5;
    	let ul;
    	let div1;
    	let li0;
    	let a0;
    	let t7;
    	let li1;
    	let a1;
    	let i;
    	let t8;
    	let t9;
    	let div9;
    	let div8;
    	let div5;
    	let div4;
    	let input2;
    	let t10;
    	let div7;
    	let div6;
    	let select0;
    	let option0;
    	let t12;
    	let div15;
    	let div14;
    	let div11;
    	let div10;
    	let select1;
    	let option1;
    	let t14;
    	let div13;
    	let div12;
    	let label0;
    	let input3;
    	let t15;
    	let span1;
    	let t16;
    	let span2;
    	let t18;
    	let div21;
    	let div20;
    	let div17;
    	let div16;
    	let input4;
    	let t19;
    	let div19;
    	let div18;
    	let label1;
    	let input5;
    	let t20;
    	let span3;
    	let t21;
    	let span4;
    	let t23;
    	let label2;
    	let input6;
    	let t24;
    	let span5;
    	let t25;
    	let span6;
    	let t27;
    	let div23;
    	let div22;
    	let select2;
    	let option2;
    	let t29;
    	let div25;
    	let div24;
    	let textarea;
    	let t30;
    	let div27;
    	let button1;
    	let t32;
    	let button2;

    	const block = {
    		c: function create() {
    			div30 = element("div");
    			div29 = element("div");
    			div28 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Agregue el tratamiento";
    			t1 = space();
    			button0 = element("button");
    			span0 = element("span");
    			span0.textContent = "";
    			t3 = space();
    			form = element("form");
    			div26 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			input0 = element("input");
    			t4 = space();
    			input1 = element("input");
    			t5 = space();
    			ul = element("ul");
    			div1 = element("div");
    			li0 = element("li");
    			a0 = element("a");
    			a0.textContent = "Acetaminofen";
    			t7 = space();
    			li1 = element("li");
    			a1 = element("a");
    			i = element("i");
    			t8 = text(" Agregar nuevo medicamento");
    			t9 = space();
    			div9 = element("div");
    			div8 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			input2 = element("input");
    			t10 = space();
    			div7 = element("div");
    			div6 = element("div");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "- Unidad de dosis -";
    			t12 = space();
    			div15 = element("div");
    			div14 = element("div");
    			div11 = element("div");
    			div10 = element("div");
    			select1 = element("select");
    			option1 = element("option");
    			option1.textContent = "Via";
    			t14 = space();
    			div13 = element("div");
    			div12 = element("div");
    			label0 = element("label");
    			input3 = element("input");
    			t15 = space();
    			span1 = element("span");
    			t16 = space();
    			span2 = element("span");
    			span2.textContent = "Monodosis";
    			t18 = space();
    			div21 = element("div");
    			div20 = element("div");
    			div17 = element("div");
    			div16 = element("div");
    			input4 = element("input");
    			t19 = space();
    			div19 = element("div");
    			div18 = element("div");
    			label1 = element("label");
    			input5 = element("input");
    			t20 = space();
    			span3 = element("span");
    			t21 = space();
    			span4 = element("span");
    			span4.textContent = "Horas";
    			t23 = space();
    			label2 = element("label");
    			input6 = element("input");
    			t24 = space();
    			span5 = element("span");
    			t25 = space();
    			span6 = element("span");
    			span6.textContent = "Minutos";
    			t27 = space();
    			div23 = element("div");
    			div22 = element("div");
    			select2 = element("select");
    			option2 = element("option");
    			option2.textContent = "Diagnostico para el tratamiento";
    			t29 = space();
    			div25 = element("div");
    			div24 = element("div");
    			textarea = element("textarea");
    			t30 = space();
    			div27 = element("div");
    			button1 = element("button");
    			button1.textContent = "Cerrar";
    			t32 = space();
    			button2 = element("button");
    			button2.textContent = "Agregar";
    			attr_dev(h5, "class", "modal-title");
    			attr_dev(h5, "id", "exampleModalLongTitle");
    			add_location(h5, file$j, 4, 16, 236);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$j, 6, 20, 430);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$j, 5, 16, 332);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$j, 3, 12, 192);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "placeholder", "Medicamento");
    			attr_dev(input0, "data-toggle", "dropdown");
    			add_location(input0, file$j, 13, 28, 787);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "form-control readonly");
    			input1.readOnly = true;
    			attr_dev(input1, "data-bind", "click: limpiarMedicamentoSeleccionado, \r\n                            class: (idMedicamentoSeleccionado() == '')? 'd-none': '',\r\n                            value: nombreMedicamentoSeleccionado");
    			add_location(input1, file$j, 16, 28, 941);
    			attr_dev(a0, "href", "#!");
    			attr_dev(a0, "data-bind", "text: descripcion, click: $parent.seleccionarMedicamento ");
    			add_location(a0, file$j, 23, 40, 1650);
    			add_location(li0, file$j, 22, 36, 1604);
    			attr_dev(div1, "class", "contenidoLista");
    			attr_dev(div1, "data-bind", "foreach: medicamentos");
    			add_location(div1, file$j, 21, 32, 1504);
    			attr_dev(i, "class", "mdi mdi-plus");
    			add_location(i, file$j, 28, 49, 1982);
    			attr_dev(a1, "href", "#!");
    			add_location(a1, file$j, 28, 36, 1969);
    			attr_dev(li1, "class", "defecto");
    			add_location(li1, file$j, 27, 32, 1911);
    			attr_dev(ul, "class", "lista-buscador dropdown-menu");
    			attr_dev(ul, "x-placement", "bottom-start");
    			set_style(ul, "position", "absolute");
    			set_style(ul, "will-change", "transform");
    			set_style(ul, "border-radius", "5px");
    			set_style(ul, "top", "0px");
    			set_style(ul, "left", "0px");
    			set_style(ul, "transform", "translate3d(0px, 36px, 0px)");
    			add_location(ul, file$j, 19, 28, 1236);
    			attr_dev(div2, "class", "form-group buscardor dropdown dropdown-vnc");
    			add_location(div2, file$j, 12, 24, 701);
    			attr_dev(div3, "class", "col-12");
    			add_location(div3, file$j, 11, 20, 655);
    			attr_dev(input2, "type", "number");
    			attr_dev(input2, "class", "form-control");
    			attr_dev(input2, "data-bind", "value: dosis");
    			input2.required = true;
    			attr_dev(input2, "placeholder", "Cantidad dosis");
    			attr_dev(input2, "name", "");
    			add_location(input2, file$j, 39, 36, 2427);
    			attr_dev(div4, "class", "form-group buscardor dropdown");
    			add_location(div4, file$j, 38, 32, 2346);
    			attr_dev(div5, "class", "col-6");
    			add_location(div5, file$j, 37, 28, 2293);
    			option0.__value = "";
    			option0.value = option0.__value;
    			add_location(option0, file$j, 51, 40, 3173);
    			select0.required = true;
    			attr_dev(select0, "class", "form-control");
    			attr_dev(select0, "data-bind", "options: unidades, \r\n                                    optionsCaption: '- Unidad de dosis -',\r\n                                    optionsValue: 'id',\r\n                                    optionsText: 'nombre',\r\n                                    value: unidadSeleccionada");
    			add_location(select0, file$j, 46, 36, 2805);
    			attr_dev(div6, "class", "form-group ");
    			add_location(div6, file$j, 45, 32, 2742);
    			attr_dev(div7, "class", "col-6");
    			add_location(div7, file$j, 44, 28, 2689);
    			attr_dev(div8, "class", "row");
    			add_location(div8, file$j, 36, 24, 2246);
    			attr_dev(div9, "class", "col-12");
    			add_location(div9, file$j, 35, 20, 2200);
    			option1.__value = "";
    			option1.value = option1.__value;
    			add_location(option1, file$j, 64, 40, 3828);
    			attr_dev(select1, "class", "form-control");
    			select1.required = true;
    			attr_dev(select1, "data-bind", "options: vias, value: viaSeleccionada, optionsCaption: 'Va'");
    			add_location(select1, file$j, 62, 36, 3634);
    			attr_dev(div10, "class", "form-group ");
    			add_location(div10, file$j, 61, 32, 3571);
    			attr_dev(div11, "class", "col-6");
    			add_location(div11, file$j, 60, 28, 3518);
    			attr_dev(input3, "type", "checkbox");
    			attr_dev(input3, "name", "option");
    			attr_dev(input3, "data-bind", "checked: monodosis");
    			input3.value = "1";
    			attr_dev(input3, "class", "cstm-switch-input");
    			add_location(input3, file$j, 71, 40, 4196);
    			attr_dev(span1, "class", "cstm-switch-indicator bg-success ");
    			add_location(span1, file$j, 73, 40, 4387);
    			attr_dev(span2, "class", "cstm-switch-description");
    			add_location(span2, file$j, 74, 40, 4484);
    			attr_dev(label0, "class", "cstm-switch mt-2");
    			add_location(label0, file$j, 70, 36, 4122);
    			attr_dev(div12, "class", " m-b-10");
    			add_location(div12, file$j, 69, 32, 4063);
    			attr_dev(div13, "class", "col-6");
    			add_location(div13, file$j, 68, 28, 4010);
    			attr_dev(div14, "class", "row");
    			add_location(div14, file$j, 59, 24, 3471);
    			attr_dev(div15, "class", "col-12");
    			add_location(div15, file$j, 58, 20, 3425);
    			attr_dev(input4, "type", "number");
    			attr_dev(input4, "class", "form-control");
    			input4.required = true;
    			attr_dev(input4, "placeholder", "Intervalo (Tiempo)");
    			attr_dev(input4, "max", "100000");
    			attr_dev(input4, "name", "");
    			add_location(input4, file$j, 85, 36, 4971);
    			attr_dev(div16, "class", "form-group buscardor dropdown");
    			add_location(div16, file$j, 84, 32, 4890);
    			attr_dev(div17, "class", "col-6");
    			add_location(div17, file$j, 83, 28, 4837);
    			attr_dev(input5, "type", "radio");
    			attr_dev(input5, "name", "Tiempo");
    			input5.value = "H";
    			attr_dev(input5, "class", "cstm-switch-input");
    			input5.checked = "checked";
    			add_location(input5, file$j, 92, 40, 5409);
    			attr_dev(span3, "class", "cstm-switch-indicator ");
    			add_location(span3, file$j, 94, 40, 5584);
    			attr_dev(span4, "class", "cstm-switch-description");
    			add_location(span4, file$j, 95, 40, 5670);
    			attr_dev(label1, "class", "cstm-switch mt-2");
    			add_location(label1, file$j, 91, 36, 5335);
    			attr_dev(input6, "type", "radio");
    			input6.value = "M";
    			attr_dev(input6, "class", "cstm-switch-input");
    			add_location(input6, file$j, 98, 40, 5879);
    			attr_dev(span5, "class", "cstm-switch-indicator ");
    			add_location(span5, file$j, 100, 40, 6022);
    			attr_dev(span6, "class", "cstm-switch-description");
    			add_location(span6, file$j, 101, 40, 6108);
    			attr_dev(label2, "class", "cstm-switch mt-2");
    			add_location(label2, file$j, 97, 36, 5805);
    			attr_dev(div18, "class", "m-b-10");
    			add_location(div18, file$j, 90, 32, 5277);
    			attr_dev(div19, "class", "col-6");
    			add_location(div19, file$j, 89, 28, 5224);
    			attr_dev(div20, "class", "row");
    			add_location(div20, file$j, 82, 24, 4790);
    			attr_dev(div21, "class", "col-12");
    			add_location(div21, file$j, 81, 20, 4744);
    			option2.selected = true;
    			option2.disabled = true;
    			option2.__value = "Diagnostico para el tratamiento";
    			option2.value = option2.__value;
    			add_location(option2, file$j, 114, 32, 6783);
    			select2.required = true;
    			attr_dev(select2, "class", "form-control");
    			attr_dev(select2, "data-bind", "options: parent.diagnosticos, \r\n                                optionsCaption: 'Diagnostico para el tratamiento',\r\n                                optionsText: 'problemaMedico',\r\n                                value: diagnostico");
    			add_location(select2, file$j, 110, 28, 6468);
    			attr_dev(div22, "class", "form-group ");
    			add_location(div22, file$j, 109, 24, 6413);
    			attr_dev(div23, "class", "col-12");
    			add_location(div23, file$j, 108, 20, 6367);
    			attr_dev(textarea, "class", "form-control mt-2");
    			attr_dev(textarea, "data-bind", "value: comentario");
    			attr_dev(textarea, "placeholder", "Comentarios");
    			set_style(textarea, "width", "100%");
    			set_style(textarea, "display", "block");
    			attr_dev(textarea, "rows", "3");
    			attr_dev(textarea, "name", "Comentario");
    			add_location(textarea, file$j, 121, 28, 7072);
    			attr_dev(div24, "class", "form-group");
    			add_location(div24, file$j, 120, 24, 7018);
    			attr_dev(div25, "class", "col-12");
    			add_location(div25, file$j, 119, 20, 6972);
    			attr_dev(div26, "class", "modal-body");
    			add_location(div26, file$j, 10, 16, 609);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn btn-secondary");
    			attr_dev(button1, "data-dismiss", "modal");
    			add_location(button1, file$j, 129, 20, 7457);
    			attr_dev(button2, "type", "submit");
    			attr_dev(button2, "class", "btn btn-primary");
    			add_location(button2, file$j, 132, 20, 7611);
    			attr_dev(div27, "class", "modal-footer");
    			add_location(div27, file$j, 128, 16, 7409);
    			attr_dev(form, "data-bind", "submit: agregar");
    			attr_dev(form, "id", "formularioTratamiento");
    			add_location(form, file$j, 9, 12, 530);
    			attr_dev(div28, "class", "modal-content");
    			add_location(div28, file$j, 2, 8, 151);
    			attr_dev(div29, "class", "modal-dialog");
    			attr_dev(div29, "role", "document");
    			add_location(div29, file$j, 1, 4, 99);
    			attr_dev(div30, "class", "modal fade");
    			attr_dev(div30, "id", "modalTratamiento");
    			attr_dev(div30, "tabindex", "-1");
    			attr_dev(div30, "role", "dialog");
    			attr_dev(div30, "aria-hidden", "true");
    			add_location(div30, file$j, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div30, anchor);
    			append_dev(div30, div29);
    			append_dev(div29, div28);
    			append_dev(div28, div0);
    			append_dev(div0, h5);
    			append_dev(div0, t1);
    			append_dev(div0, button0);
    			append_dev(button0, span0);
    			append_dev(div28, t3);
    			append_dev(div28, form);
    			append_dev(form, div26);
    			append_dev(div26, div3);
    			append_dev(div3, div2);
    			append_dev(div2, input0);
    			append_dev(div2, t4);
    			append_dev(div2, input1);
    			append_dev(div2, t5);
    			append_dev(div2, ul);
    			append_dev(ul, div1);
    			append_dev(div1, li0);
    			append_dev(li0, a0);
    			append_dev(ul, t7);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(a1, i);
    			append_dev(a1, t8);
    			append_dev(div26, t9);
    			append_dev(div26, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div5);
    			append_dev(div5, div4);
    			append_dev(div4, input2);
    			append_dev(div8, t10);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, select0);
    			append_dev(select0, option0);
    			append_dev(div26, t12);
    			append_dev(div26, div15);
    			append_dev(div15, div14);
    			append_dev(div14, div11);
    			append_dev(div11, div10);
    			append_dev(div10, select1);
    			append_dev(select1, option1);
    			append_dev(div14, t14);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, label0);
    			append_dev(label0, input3);
    			append_dev(label0, t15);
    			append_dev(label0, span1);
    			append_dev(label0, t16);
    			append_dev(label0, span2);
    			append_dev(div26, t18);
    			append_dev(div26, div21);
    			append_dev(div21, div20);
    			append_dev(div20, div17);
    			append_dev(div17, div16);
    			append_dev(div16, input4);
    			append_dev(div20, t19);
    			append_dev(div20, div19);
    			append_dev(div19, div18);
    			append_dev(div18, label1);
    			append_dev(label1, input5);
    			append_dev(label1, t20);
    			append_dev(label1, span3);
    			append_dev(label1, t21);
    			append_dev(label1, span4);
    			append_dev(div18, t23);
    			append_dev(div18, label2);
    			append_dev(label2, input6);
    			append_dev(label2, t24);
    			append_dev(label2, span5);
    			append_dev(label2, t25);
    			append_dev(label2, span6);
    			append_dev(div26, t27);
    			append_dev(div26, div23);
    			append_dev(div23, div22);
    			append_dev(div22, select2);
    			append_dev(select2, option2);
    			append_dev(div26, t29);
    			append_dev(div26, div25);
    			append_dev(div25, div24);
    			append_dev(div24, textarea);
    			append_dev(form, t30);
    			append_dev(form, div27);
    			append_dev(div27, button1);
    			append_dev(div27, t32);
    			append_dev(div27, button2);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div30);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ModalTratamientos", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ModalTratamientos> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class ModalTratamientos extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalTratamientos",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src\componentes\Modals\ModalInterconsulta.svelte generated by Svelte v3.29.0 */

    const file$k = "src\\componentes\\Modals\\ModalInterconsulta.svelte";

    function create_fragment$l(ctx) {
    	let div15;
    	let div14;
    	let div13;
    	let div0;
    	let h5;
    	let t1;
    	let button;
    	let span;
    	let t3;
    	let div6;
    	let form;
    	let div5;
    	let div1;
    	let label0;
    	let t5;
    	let textarea0;
    	let t6;
    	let div2;
    	let label1;
    	let t8;
    	let textarea1;
    	let t9;
    	let div3;
    	let select0;
    	let option0;
    	let t11;
    	let div4;
    	let select1;
    	let option1;
    	let t13;
    	let div12;
    	let div11;
    	let div8;
    	let a0;
    	let h30;
    	let t14;
    	let div7;
    	let t16;
    	let div10;
    	let a1;
    	let h31;
    	let t17;
    	let div9;

    	const block = {
    		c: function create() {
    			div15 = element("div");
    			div14 = element("div");
    			div13 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Nueva interconsulta";
    			t1 = space();
    			button = element("button");
    			span = element("span");
    			span.textContent = "";
    			t3 = space();
    			div6 = element("div");
    			form = element("form");
    			div5 = element("div");
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Resumen";
    			t5 = space();
    			textarea0 = element("textarea");
    			t6 = space();
    			div2 = element("div");
    			label1 = element("label");
    			label1.textContent = "Manejo / Recomendaciones";
    			t8 = space();
    			textarea1 = element("textarea");
    			t9 = space();
    			div3 = element("div");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "- Departamento -";
    			t11 = space();
    			div4 = element("div");
    			select1 = element("select");
    			option1 = element("option");
    			option1.textContent = "- Especialista sugerido -";
    			t13 = space();
    			div12 = element("div");
    			div11 = element("div");
    			div8 = element("div");
    			a0 = element("a");
    			h30 = element("h3");
    			t14 = space();
    			div7 = element("div");
    			div7.textContent = "Cerrar";
    			t16 = space();
    			div10 = element("div");
    			a1 = element("a");
    			h31 = element("h3");
    			t17 = space();
    			div9 = element("div");
    			div9.textContent = "Solicitar";
    			attr_dev(h5, "class", "modal-title");
    			attr_dev(h5, "id", "modalInterconsulta");
    			add_location(h5, file$k, 5, 20, 361);
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$k, 7, 24, 557);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "close");
    			attr_dev(button, "data-dismiss", "modal");
    			attr_dev(button, "aria-label", "Close");
    			add_location(button, file$k, 6, 20, 455);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$k, 4, 16, 313);
    			attr_dev(label0, "for", "");
    			attr_dev(label0, "class", "text-primary");
    			add_location(label0, file$k, 14, 32, 905);
    			attr_dev(textarea0, "class", "form-control");
    			attr_dev(textarea0, "data-bind", "value: resumen");
    			set_style(textarea0, "width", "100%");
    			set_style(textarea0, "display", "block");
    			set_style(textarea0, "height", "150px");
    			attr_dev(textarea0, "name", "Comentario");
    			add_location(textarea0, file$k, 15, 32, 989);
    			attr_dev(div1, "class", "form-group col-md-12");
    			add_location(div1, file$k, 13, 28, 837);
    			attr_dev(label1, "for", "");
    			attr_dev(label1, "class", "text-primary");
    			add_location(label1, file$k, 19, 32, 1299);
    			attr_dev(textarea1, "class", "form-control");
    			attr_dev(textarea1, "data-bind", "value: recomendaciones");
    			set_style(textarea1, "width", "100%");
    			set_style(textarea1, "display", "block");
    			set_style(textarea1, "height", "150px");
    			attr_dev(textarea1, "name", "Comentario");
    			add_location(textarea1, file$k, 20, 32, 1400);
    			attr_dev(div2, "class", "form-group col-md-12");
    			add_location(div2, file$k, 18, 28, 1231);
    			option0.__value = "";
    			option0.value = option0.__value;
    			add_location(option0, file$k, 26, 36, 1839);
    			attr_dev(select0, "class", "form-control");
    			attr_dev(select0, "id", "sltDepartamentos");
    			set_style(select0, "width", "100%");
    			select0.required = true;
    			add_location(select0, file$k, 25, 32, 1720);
    			attr_dev(div3, "class", "form-group col-lg-12");
    			add_location(div3, file$k, 24, 28, 1652);
    			option1.__value = "";
    			option1.value = option1.__value;
    			add_location(option1, file$k, 31, 36, 2189);
    			attr_dev(select1, "class", "form-control");
    			attr_dev(select1, "id", "sltEspecialistasDepartamento");
    			set_style(select1, "width", "100%");
    			select1.required = true;
    			add_location(select1, file$k, 30, 32, 2058);
    			attr_dev(div4, "class", "form-group col-lg-12");
    			add_location(div4, file$k, 29, 28, 1990);
    			attr_dev(div5, "class", "form-row");
    			add_location(div5, file$k, 12, 24, 785);
    			attr_dev(form, "class", "floating-label col-md-12 show-label");
    			add_location(form, file$k, 11, 20, 709);
    			attr_dev(div6, "class", "modal-body");
    			add_location(div6, file$k, 10, 16, 663);
    			attr_dev(h30, "class", "mdi mdi-close-outline");
    			add_location(h30, file$k, 43, 32, 2670);
    			attr_dev(div7, "class", "text-overline");
    			add_location(div7, file$k, 44, 32, 2743);
    			attr_dev(a0, "href", "/");
    			attr_dev(a0, "class", "text-danger");
    			attr_dev(a0, "data-dismiss", "modal");
    			add_location(a0, file$k, 42, 28, 2583);
    			attr_dev(div8, "class", "col");
    			add_location(div8, file$k, 41, 24, 2536);
    			attr_dev(h31, "class", "mdi mdi-send");
    			add_location(h31, file$k, 49, 32, 3014);
    			attr_dev(div9, "class", "text-overline");
    			add_location(div9, file$k, 50, 32, 3078);
    			attr_dev(a1, "href", "#!");
    			attr_dev(a1, "data-bind", "click: crear");
    			attr_dev(a1, "class", "text-success");
    			add_location(a1, file$k, 48, 28, 2921);
    			attr_dev(div10, "class", "col");
    			add_location(div10, file$k, 47, 24, 2874);
    			attr_dev(div11, "class", "row text-center p-b-10");
    			add_location(div11, file$k, 40, 20, 2474);
    			attr_dev(div12, "class", "modal-footer");
    			add_location(div12, file$k, 39, 16, 2426);
    			attr_dev(div13, "class", "modal-content");
    			add_location(div13, file$k, 3, 12, 268);
    			attr_dev(div14, "class", "modal-dialog");
    			attr_dev(div14, "role", "document");
    			add_location(div14, file$k, 2, 8, 212);
    			attr_dev(div15, "class", "modal fade modal-slide-right");
    			attr_dev(div15, "id", "modalInterconsulta");
    			attr_dev(div15, "tabindex", "-1");
    			attr_dev(div15, "role", "dialog");
    			attr_dev(div15, "aria-labelledby", "modalInterconsulta");
    			set_style(div15, "display", "none");
    			set_style(div15, "padding-right", "16px");
    			attr_dev(div15, "aria-modal", "true");
    			add_location(div15, file$k, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div14);
    			append_dev(div14, div13);
    			append_dev(div13, div0);
    			append_dev(div0, h5);
    			append_dev(div0, t1);
    			append_dev(div0, button);
    			append_dev(button, span);
    			append_dev(div13, t3);
    			append_dev(div13, div6);
    			append_dev(div6, form);
    			append_dev(form, div5);
    			append_dev(div5, div1);
    			append_dev(div1, label0);
    			append_dev(div1, t5);
    			append_dev(div1, textarea0);
    			append_dev(div5, t6);
    			append_dev(div5, div2);
    			append_dev(div2, label1);
    			append_dev(div2, t8);
    			append_dev(div2, textarea1);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, select0);
    			append_dev(select0, option0);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, select1);
    			append_dev(select1, option1);
    			append_dev(div13, t13);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, div8);
    			append_dev(div8, a0);
    			append_dev(a0, h30);
    			append_dev(a0, t14);
    			append_dev(a0, div7);
    			append_dev(div11, t16);
    			append_dev(div11, div10);
    			append_dev(div10, a1);
    			append_dev(a1, h31);
    			append_dev(a1, t17);
    			append_dev(a1, div9);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div15);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ModalInterconsulta", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ModalInterconsulta> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class ModalInterconsulta extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalInterconsulta",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src\componentes\Modals\ModalAntecedentes.svelte generated by Svelte v3.29.0 */

    const file$l = "src\\componentes\\Modals\\ModalAntecedentes.svelte";

    function create_fragment$m(ctx) {
    	let div43;
    	let div42;
    	let div41;
    	let div3;
    	let h5;
    	let t1;
    	let button0;
    	let span0;
    	let t3;
    	let div2;
    	let div1;
    	let div0;
    	let i0;
    	let t4;
    	let i1;
    	let t6;
    	let div40;
    	let div39;
    	let div38;
    	let div12;
    	let div5;
    	let div4;
    	let t8;
    	let div11;
    	let div6;
    	let button1;
    	let i2;
    	let t9;
    	let span1;
    	let t11;
    	let div10;
    	let div9;
    	let div8;
    	let div7;
    	let t12;
    	let div21;
    	let div14;
    	let div13;
    	let t14;
    	let div20;
    	let div15;
    	let button2;
    	let i3;
    	let t15;
    	let span2;
    	let t17;
    	let div19;
    	let div18;
    	let div17;
    	let div16;
    	let t18;
    	let div37;
    	let div23;
    	let div22;
    	let t20;
    	let div36;
    	let div24;
    	let button3;
    	let i4;
    	let t21;
    	let span3;
    	let t23;
    	let div35;
    	let div34;
    	let div33;
    	let div32;
    	let div31;
    	let div26;
    	let div25;
    	let i5;
    	let t24;
    	let span4;
    	let t26;
    	let div29;
    	let div28;
    	let a;
    	let i6;
    	let t27;
    	let div27;
    	let button4;
    	let i7;
    	let t28;
    	let t29;
    	let div30;
    	let textarea;

    	const block = {
    		c: function create() {
    			div43 = element("div");
    			div42 = element("div");
    			div41 = element("div");
    			div3 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Antecedentes";
    			t1 = space();
    			button0 = element("button");
    			span0 = element("span");
    			span0.textContent = "";
    			t3 = space();
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			i0 = element("i");
    			t4 = space();
    			i1 = element("i");
    			i1.textContent = "listo y guardado";
    			t6 = space();
    			div40 = element("div");
    			div39 = element("div");
    			div38 = element("div");
    			div12 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div4.textContent = "Antecedentes Patologicos";
    			t8 = space();
    			div11 = element("div");
    			div6 = element("div");
    			button1 = element("button");
    			i2 = element("i");
    			t9 = space();
    			span1 = element("span");
    			span1.textContent = "Enfermedades Tiroideas";
    			t11 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			t12 = space();
    			div21 = element("div");
    			div14 = element("div");
    			div13 = element("div");
    			div13.textContent = "Antecedentes no Patologicos";
    			t14 = space();
    			div20 = element("div");
    			div15 = element("div");
    			button2 = element("button");
    			i3 = element("i");
    			t15 = space();
    			span2 = element("span");
    			span2.textContent = "Actividad Fisica";
    			t17 = space();
    			div19 = element("div");
    			div18 = element("div");
    			div17 = element("div");
    			div16 = element("div");
    			t18 = space();
    			div37 = element("div");
    			div23 = element("div");
    			div22 = element("div");
    			div22.textContent = "Antecedentes Psiquitricos";
    			t20 = space();
    			div36 = element("div");
    			div24 = element("div");
    			button3 = element("button");
    			i4 = element("i");
    			t21 = space();
    			span3 = element("span");
    			span3.textContent = "Historia Familiar";
    			t23 = space();
    			div35 = element("div");
    			div34 = element("div");
    			div33 = element("div");
    			div32 = element("div");
    			div31 = element("div");
    			div26 = element("div");
    			div25 = element("div");
    			i5 = element("i");
    			t24 = space();
    			span4 = element("span");
    			span4.textContent = "Historia Familiar";
    			t26 = space();
    			div29 = element("div");
    			div28 = element("div");
    			a = element("a");
    			i6 = element("i");
    			t27 = space();
    			div27 = element("div");
    			button4 = element("button");
    			i7 = element("i");
    			t28 = text("\r\n                                                                    Eliminar");
    			t29 = space();
    			div30 = element("div");
    			textarea = element("textarea");
    			attr_dev(h5, "class", "modal-title");
    			attr_dev(h5, "id", "modalAntecedentes");
    			add_location(h5, file$l, 5, 16, 319);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$l, 7, 20, 499);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$l, 6, 16, 401);
    			attr_dev(i0, "class", "mdi mdi-check-all");
    			add_location(i0, file$l, 11, 112, 777);
    			add_location(i1, file$l, 12, 63, 844);
    			attr_dev(div0, "class", "guardando mr-2 text-success");
    			attr_dev(div0, "data-bind", "html: content, class: contentClass");
    			add_location(div0, file$l, 11, 24, 689);
    			attr_dev(div1, "class", "guardar-documento");
    			add_location(div1, file$l, 10, 20, 632);
    			set_style(div2, "margin-right", "40px");
    			add_location(div2, file$l, 9, 16, 577);
    			attr_dev(div3, "class", "modal-header");
    			add_location(div3, file$l, 4, 12, 275);
    			attr_dev(div4, "class", "card-title");
    			attr_dev(div4, "data-bind", "text: nombre");
    			add_location(div4, file$l, 22, 32, 1299);
    			attr_dev(div5, "class", "card-header");
    			add_location(div5, file$l, 21, 28, 1240);
    			attr_dev(i2, "class", "mdi mdi-plus");
    			add_location(i2, file$l, 27, 101, 1794);
    			attr_dev(span1, "data-bind", "text: nombre");
    			add_location(span1, file$l, 29, 40, 1909);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "btn btn-outline-primary btn-sm mb-1 mr-2");
    			set_style(button1, "box-shadow", "none");
    			attr_dev(button1, "data-bind", "click: $parent.agregar");
    			add_location(button1, file$l, 26, 36, 1621);
    			attr_dev(div6, "class", "botones-antecedentes");
    			attr_dev(div6, "data-bind", "foreach: tiposAntecedentesFiltrados");
    			add_location(div6, file$l, 25, 32, 1501);
    			attr_dev(div7, "class", "col-lg-12");
    			attr_dev(div7, "data-bind", "foreach: antecedentesFiltrados");
    			add_location(div7, file$l, 36, 44, 2272);
    			attr_dev(div8, "class", "row");
    			add_location(div8, file$l, 35, 40, 2209);
    			attr_dev(div9, "class", "col-12");
    			add_location(div9, file$l, 34, 36, 2147);
    			attr_dev(div10, "class", "row");
    			add_location(div10, file$l, 33, 32, 2092);
    			attr_dev(div11, "class", "card-body");
    			add_location(div11, file$l, 24, 28, 1444);
    			attr_dev(div12, "class", "card  m-b-30");
    			set_style(div12, "box-shadow", "none");
    			set_style(div12, "border", "#32325d solid 1px");
    			add_location(div12, file$l, 20, 24, 1131);
    			attr_dev(div13, "class", "card-title");
    			attr_dev(div13, "data-bind", "text: nombre");
    			add_location(div13, file$l, 45, 32, 2740);
    			attr_dev(div14, "class", "card-header");
    			add_location(div14, file$l, 44, 28, 2681);
    			attr_dev(i3, "class", "mdi mdi-plus");
    			add_location(i3, file$l, 50, 101, 3238);
    			attr_dev(span2, "data-bind", "text: nombre");
    			add_location(span2, file$l, 52, 40, 3353);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "class", "btn btn-outline-primary btn-sm mb-1 mr-2");
    			set_style(button2, "box-shadow", "none");
    			attr_dev(button2, "data-bind", "click: $parent.agregar");
    			add_location(button2, file$l, 49, 36, 3065);
    			attr_dev(div15, "class", "botones-antecedentes");
    			attr_dev(div15, "data-bind", "foreach: tiposAntecedentesFiltrados");
    			add_location(div15, file$l, 48, 32, 2945);
    			attr_dev(div16, "class", "col-lg-12");
    			attr_dev(div16, "data-bind", "foreach: antecedentesFiltrados");
    			add_location(div16, file$l, 59, 44, 3710);
    			attr_dev(div17, "class", "row");
    			add_location(div17, file$l, 58, 40, 3647);
    			attr_dev(div18, "class", "col-12");
    			add_location(div18, file$l, 57, 36, 3585);
    			attr_dev(div19, "class", "row");
    			add_location(div19, file$l, 56, 32, 3530);
    			attr_dev(div20, "class", "card-body");
    			add_location(div20, file$l, 47, 28, 2888);
    			attr_dev(div21, "class", "card  m-b-30");
    			set_style(div21, "box-shadow", "none");
    			set_style(div21, "border", "#32325d solid 1px");
    			add_location(div21, file$l, 43, 24, 2572);
    			attr_dev(div22, "class", "card-title");
    			attr_dev(div22, "data-bind", "text: nombre");
    			add_location(div22, file$l, 69, 32, 4180);
    			attr_dev(div23, "class", "card-header");
    			add_location(div23, file$l, 68, 28, 4121);
    			attr_dev(i4, "class", "mdi mdi-plus");
    			add_location(i4, file$l, 74, 101, 4677);
    			attr_dev(span3, "data-bind", "text: nombre");
    			add_location(span3, file$l, 76, 40, 4792);
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "class", "btn btn-outline-primary btn-sm mb-1 mr-2");
    			set_style(button3, "box-shadow", "none");
    			attr_dev(button3, "data-bind", "click: $parent.agregar");
    			add_location(button3, file$l, 73, 36, 4504);
    			attr_dev(div24, "class", "botones-antecedentes");
    			attr_dev(div24, "data-bind", "foreach: tiposAntecedentesFiltrados");
    			add_location(div24, file$l, 72, 32, 4384);
    			attr_dev(i5, "class", "mdi mdi-history mdi-18px");
    			add_location(i5, file$l, 86, 80, 5507);
    			attr_dev(span4, "data-bind", "text: nombre");
    			add_location(span4, file$l, 86, 121, 5548);
    			attr_dev(div25, "class", "card-title");
    			add_location(div25, file$l, 86, 56, 5483);
    			attr_dev(div26, "class", "card-header");
    			add_location(div26, file$l, 85, 52, 5400);
    			attr_dev(i6, "class", "icon mdi  mdi-dots-vertical");
    			add_location(i6, file$l, 92, 64, 6094);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "data-toggle", "dropdown");
    			attr_dev(a, "aria-haspopup", "true");
    			attr_dev(a, "aria-expanded", "false");
    			add_location(a, file$l, 91, 60, 5950);
    			attr_dev(i7, "class", "mdi mdi-trash-can-outline");
    			add_location(i7, file$l, 95, 148, 6462);
    			attr_dev(button4, "class", "dropdown-item text-danger");
    			attr_dev(button4, "data-bind", "click: eliminar");
    			attr_dev(button4, "type", "button");
    			add_location(button4, file$l, 95, 64, 6378);
    			attr_dev(div27, "class", "dropdown-menu dropdown-menu-right");
    			add_location(div27, file$l, 94, 60, 6265);
    			attr_dev(div28, "class", "dropdown");
    			add_location(div28, file$l, 90, 56, 5866);
    			attr_dev(div29, "class", "card-controls");
    			add_location(div29, file$l, 89, 52, 5781);
    			attr_dev(textarea, "class", "form-control");
    			attr_dev(textarea, "data-bind", "value: descripcion");
    			set_style(textarea, "width", "100%");
    			set_style(textarea, "display", "block");
    			set_style(textarea, "height", "100px");
    			attr_dev(textarea, "id", "exampleFormControlTextarea1");
    			attr_dev(textarea, "rows", "5");
    			attr_dev(textarea, "name", "Comentario");
    			add_location(textarea, file$l, 101, 56, 6917);
    			attr_dev(div30, "class", "card-body");
    			add_location(div30, file$l, 100, 52, 6836);
    			attr_dev(div31, "class", "card m-b-20 mt-3");
    			set_style(div31, "box-shadow", "none");
    			set_style(div31, "border", "1px grey solid");
    			add_location(div31, file$l, 84, 48, 5266);
    			attr_dev(div32, "class", "col-lg-12");
    			attr_dev(div32, "data-bind", "foreach: antecedentesFiltrados");
    			add_location(div32, file$l, 83, 44, 5150);
    			attr_dev(div33, "class", "row");
    			add_location(div33, file$l, 82, 40, 5087);
    			attr_dev(div34, "class", "col-12");
    			add_location(div34, file$l, 81, 36, 5025);
    			attr_dev(div35, "class", "row");
    			add_location(div35, file$l, 80, 32, 4970);
    			attr_dev(div36, "class", "card-body");
    			add_location(div36, file$l, 71, 28, 4327);
    			attr_dev(div37, "class", "card  m-b-30");
    			set_style(div37, "box-shadow", "none");
    			set_style(div37, "border", "#32325d solid 1px");
    			add_location(div37, file$l, 67, 24, 4012);
    			attr_dev(div38, "class", "col-lg-12");
    			attr_dev(div38, "data-bind", "foreach: gruposAntecedentes");
    			add_location(div38, file$l, 18, 20, 1040);
    			attr_dev(div39, "class", "row");
    			add_location(div39, file$l, 17, 16, 1001);
    			attr_dev(div40, "class", "modal-body");
    			add_location(div40, file$l, 16, 12, 959);
    			attr_dev(div41, "class", "modal-content");
    			add_location(div41, file$l, 3, 8, 234);
    			attr_dev(div42, "class", "modal-dialog");
    			attr_dev(div42, "role", "document");
    			add_location(div42, file$l, 2, 4, 182);
    			attr_dev(div43, "class", "modal fade modal-slide-right");
    			attr_dev(div43, "id", "modalAntecedentes");
    			attr_dev(div43, "tabindex", "-1");
    			attr_dev(div43, "role", "dialog");
    			attr_dev(div43, "aria-labelledby", "modalAntecedentes");
    			set_style(div43, "display", "none");
    			attr_dev(div43, "aria-hidden", "true");
    			add_location(div43, file$l, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div43, anchor);
    			append_dev(div43, div42);
    			append_dev(div42, div41);
    			append_dev(div41, div3);
    			append_dev(div3, h5);
    			append_dev(div3, t1);
    			append_dev(div3, button0);
    			append_dev(button0, span0);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, i0);
    			append_dev(div0, t4);
    			append_dev(div0, i1);
    			append_dev(div41, t6);
    			append_dev(div41, div40);
    			append_dev(div40, div39);
    			append_dev(div39, div38);
    			append_dev(div38, div12);
    			append_dev(div12, div5);
    			append_dev(div5, div4);
    			append_dev(div12, t8);
    			append_dev(div12, div11);
    			append_dev(div11, div6);
    			append_dev(div6, button1);
    			append_dev(button1, i2);
    			append_dev(button1, t9);
    			append_dev(button1, span1);
    			append_dev(div11, t11);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div38, t12);
    			append_dev(div38, div21);
    			append_dev(div21, div14);
    			append_dev(div14, div13);
    			append_dev(div21, t14);
    			append_dev(div21, div20);
    			append_dev(div20, div15);
    			append_dev(div15, button2);
    			append_dev(button2, i3);
    			append_dev(button2, t15);
    			append_dev(button2, span2);
    			append_dev(div20, t17);
    			append_dev(div20, div19);
    			append_dev(div19, div18);
    			append_dev(div18, div17);
    			append_dev(div17, div16);
    			append_dev(div38, t18);
    			append_dev(div38, div37);
    			append_dev(div37, div23);
    			append_dev(div23, div22);
    			append_dev(div37, t20);
    			append_dev(div37, div36);
    			append_dev(div36, div24);
    			append_dev(div24, button3);
    			append_dev(button3, i4);
    			append_dev(button3, t21);
    			append_dev(button3, span3);
    			append_dev(div36, t23);
    			append_dev(div36, div35);
    			append_dev(div35, div34);
    			append_dev(div34, div33);
    			append_dev(div33, div32);
    			append_dev(div32, div31);
    			append_dev(div31, div26);
    			append_dev(div26, div25);
    			append_dev(div25, i5);
    			append_dev(div25, t24);
    			append_dev(div25, span4);
    			append_dev(div31, t26);
    			append_dev(div31, div29);
    			append_dev(div29, div28);
    			append_dev(div28, a);
    			append_dev(a, i6);
    			append_dev(div28, t27);
    			append_dev(div28, div27);
    			append_dev(div27, button4);
    			append_dev(button4, i7);
    			append_dev(button4, t28);
    			append_dev(div31, t29);
    			append_dev(div31, div30);
    			append_dev(div30, textarea);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div43);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ModalAntecedentes", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ModalAntecedentes> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class ModalAntecedentes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalAntecedentes",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src\componentes\OrdenesMedicas.svelte generated by Svelte v3.29.0 */

    const { console: console_1$a } = globals;
    const file$m = "src\\componentes\\OrdenesMedicas.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[39] = list[i];
    	child_ctx[41] = i;
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[45] = list[i];
    	child_ctx[46] = list;
    	child_ctx[47] = i;
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[45] = list[i];
    	return child_ctx;
    }

    function get_each_context_4$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[50] = list[i];
    	child_ctx[51] = list;
    	child_ctx[41] = i;
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[52] = list[i];
    	return child_ctx;
    }

    // (174:40) {#each medicamentos as medicamento}
    function create_each_block_5(ctx) {
    	let li;
    	let div;
    	let t0_value = /*medicamento*/ ctx[52].descripcion + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[18](/*medicamento*/ ctx[52], ...args);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "p-2");
    			set_style(div, "cursor", "pointer");
    			add_location(div, file$m, 175, 48, 6281);
    			add_location(li, file$m, 174, 44, 6227);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div);
    			append_dev(div, t0);
    			append_dev(li, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*medicamentos*/ 32 && t0_value !== (t0_value = /*medicamento*/ ctx[52].descripcion + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(174:40) {#each medicamentos as medicamento}",
    		ctx
    	});

    	return block;
    }

    // (295:28) {:else}
    function create_else_block_2(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let p;
    	let t1;
    	let ul;
    	let t2;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			p.textContent = "No tienes medicamentos agregados";
    			t1 = space();
    			ul = element("ul");
    			t2 = space();
    			attr_dev(p, "class", "alert-body text-center mt-3");
    			add_location(p, file$m, 301, 44, 14079);
    			attr_dev(div0, "class", "alert border alert-light");
    			attr_dev(div0, "role", "alert");
    			add_location(div0, file$m, 297, 40, 13850);
    			attr_dev(ul, "class", "list-info");
    			attr_dev(ul, "data-bind", "foreach: estudios");
    			add_location(ul, file$m, 307, 40, 14435);
    			attr_dev(div1, "class", "col-md-12 mt-3");
    			add_location(div1, file$m, 296, 36, 13780);
    			attr_dev(div2, "class", "row");
    			add_location(div2, file$m, 295, 32, 13725);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(div1, t1);
    			append_dev(div1, ul);
    			append_dev(div2, t2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(295:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (278:36) {#if !disabled}
    function create_if_block_6(ctx) {
    	let div;
    	let i;
    	let mounted;
    	let dispose;

    	function click_handler_2(...args) {
    		return /*click_handler_2*/ ctx[26](/*i*/ ctx[41], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			i = element("i");
    			attr_dev(i, "class", "mdi mdi-close text-red svelte-1mwxgdj");
    			add_location(i, file$m, 283, 44, 13070);
    			attr_dev(div, "class", "icon-borrar svelte-1mwxgdj");
    			attr_dev(div, "data-tooltip", "Eliminar");
    			add_location(div, file$m, 279, 40, 12843);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i);

    			if (!mounted) {
    				dispose = listen_dev(i, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(278:36) {#if !disabled}",
    		ctx
    	});

    	return block;
    }

    // (206:28) {#each medicamentosSeleccionados as med, i}
    function create_each_block_4$1(ctx) {
    	let div8;
    	let div7;
    	let div0;
    	let p;
    	let t0_value = /*med*/ ctx[50].nombre + "";
    	let t0;
    	let t1;
    	let div2;
    	let div1;
    	let label0;
    	let t3;
    	let input0;
    	let t4;
    	let div4;
    	let div3;
    	let label1;
    	let t6;
    	let input1;
    	let t7;
    	let div6;
    	let div5;
    	let label2;
    	let t9;
    	let input2;
    	let t10;
    	let t11;
    	let mounted;
    	let dispose;

    	function input0_input_handler_1() {
    		/*input0_input_handler_1*/ ctx[21].call(input0, /*each_value_4*/ ctx[51], /*i*/ ctx[41]);
    	}

    	function input1_input_handler() {
    		/*input1_input_handler*/ ctx[23].call(input1, /*each_value_4*/ ctx[51], /*i*/ ctx[41]);
    	}

    	function input2_input_handler() {
    		/*input2_input_handler*/ ctx[25].call(input2, /*each_value_4*/ ctx[51], /*i*/ ctx[41]);
    	}

    	let if_block = !/*disabled*/ ctx[9] && create_if_block_6(ctx);

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Concentracin";
    			t3 = space();
    			input0 = element("input");
    			t4 = space();
    			div4 = element("div");
    			div3 = element("div");
    			label1 = element("label");
    			label1.textContent = "Cantidad";
    			t6 = space();
    			input1 = element("input");
    			t7 = space();
    			div6 = element("div");
    			div5 = element("div");
    			label2 = element("label");
    			label2.textContent = "Frecuencia";
    			t9 = space();
    			input2 = element("input");
    			t10 = space();
    			if (if_block) if_block.c();
    			t11 = space();
    			attr_dev(p, "class", "text-primary");
    			set_style(p, "margin", "0");
    			add_location(p, file$m, 215, 44, 8652);
    			attr_dev(div0, "class", "col p-3");
    			set_style(div0, "display", "flex");
    			set_style(div0, "align-items", "center");
    			set_style(div0, "justify-content", "left");
    			add_location(div0, file$m, 211, 40, 8386);
    			set_style(label0, "margin", "0");
    			attr_dev(label0, "class", "form-label text-primary");
    			add_location(label0, file$m, 225, 48, 9283);
    			input0.disabled = /*disabled*/ ctx[9];
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			add_location(input0, file$m, 230, 48, 9629);
    			attr_dev(div1, "class", "mb-2");
    			add_location(div1, file$m, 223, 44, 9109);
    			attr_dev(div2, "class", "col mt-2");
    			add_location(div2, file$m, 222, 40, 9041);
    			set_style(label1, "margin", "0");
    			attr_dev(label1, "class", "form-label text-primary");
    			add_location(label1, file$m, 243, 48, 10507);
    			input1.disabled = /*disabled*/ ctx[9];
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "form-control");
    			add_location(input1, file$m, 248, 48, 10841);
    			attr_dev(div3, "class", "mb-2");
    			add_location(div3, file$m, 241, 44, 10333);
    			attr_dev(div4, "class", "col mt-2");
    			add_location(div4, file$m, 240, 40, 10265);
    			set_style(label2, "margin", "0");
    			attr_dev(label2, "class", "form-label text-primary");
    			add_location(label2, file$m, 261, 48, 11714);
    			input2.disabled = /*disabled*/ ctx[9];
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "class", "form-control");
    			add_location(input2, file$m, 266, 48, 12050);
    			attr_dev(div5, "class", "mb-2");
    			add_location(div5, file$m, 259, 44, 11540);
    			attr_dev(div6, "class", "col mt-2");
    			add_location(div6, file$m, 258, 40, 11472);
    			attr_dev(div7, "class", "row");
    			add_location(div7, file$m, 210, 36, 8327);
    			attr_dev(div8, "class", "col-lg-12 border border-primary rounded mt-3");
    			add_location(div8, file$m, 207, 32, 8160);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			append_dev(div0, p);
    			append_dev(p, t0);
    			append_dev(div7, t1);
    			append_dev(div7, div2);
    			append_dev(div2, div1);
    			append_dev(div1, label0);
    			append_dev(div1, t3);
    			append_dev(div1, input0);
    			set_input_value(input0, /*med*/ ctx[50].concentracion);
    			append_dev(div7, t4);
    			append_dev(div7, div4);
    			append_dev(div4, div3);
    			append_dev(div3, label1);
    			append_dev(div3, t6);
    			append_dev(div3, input1);
    			set_input_value(input1, /*med*/ ctx[50].cantidad);
    			append_dev(div7, t7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, label2);
    			append_dev(div5, t9);
    			append_dev(div5, input2);
    			set_input_value(input2, /*med*/ ctx[50].frecuencia);
    			append_dev(div8, t10);
    			if (if_block) if_block.m(div8, null);
    			append_dev(div8, t11);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "blur", /*blur_handler*/ ctx[20], false, false, false),
    					listen_dev(input0, "input", input0_input_handler_1),
    					listen_dev(input1, "blur", /*blur_handler_1*/ ctx[22], false, false, false),
    					listen_dev(input1, "input", input1_input_handler),
    					listen_dev(input2, "blur", /*blur_handler_2*/ ctx[24], false, false, false),
    					listen_dev(input2, "input", input2_input_handler)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*medicamentosSeleccionados*/ 8 && t0_value !== (t0_value = /*med*/ ctx[50].nombre + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(input0, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*medicamentosSeleccionados*/ 8 && input0.value !== /*med*/ ctx[50].concentracion) {
    				set_input_value(input0, /*med*/ ctx[50].concentracion);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(input1, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*medicamentosSeleccionados*/ 8 && input1.value !== /*med*/ ctx[50].cantidad) {
    				set_input_value(input1, /*med*/ ctx[50].cantidad);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(input2, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*medicamentosSeleccionados*/ 8 && input2.value !== /*med*/ ctx[50].frecuencia) {
    				set_input_value(input2, /*med*/ ctx[50].frecuencia);
    			}

    			if (!/*disabled*/ ctx[9]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_6(ctx);
    					if_block.c();
    					if_block.m(div8, t11);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$1.name,
    		type: "each",
    		source: "(206:28) {#each medicamentosSeleccionados as med, i}",
    		ctx
    	});

    	return block;
    }

    // (394:48) {:else}
    function create_else_block_1(ctx) {
    	let span;
    	let i;

    	const block = {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr_dev(i, "class", "mdi mdi-image");
    			add_location(i, file$m, 397, 56, 18961);
    			attr_dev(span, "class", "badge badge-primary");
    			add_location(span, file$m, 394, 52, 18758);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, i);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(394:48) {:else}",
    		ctx
    	});

    	return block;
    }

    // (386:48) {#if estudio.tipo === "LAB"}
    function create_if_block_5$1(ctx) {
    	let span;
    	let i;

    	const block = {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr_dev(i, "class", "mdi mdi-microscope");
    			add_location(i, file$m, 389, 56, 18436);
    			attr_dev(span, "class", "badge badge-primary");
    			add_location(span, file$m, 386, 52, 18233);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, i);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(386:48) {#if estudio.tipo === \\\"LAB\\\"}",
    		ctx
    	});

    	return block;
    }

    // (372:36) {#each estudios as estudio}
    function create_each_block_3$2(ctx) {
    	let li;
    	let div;
    	let t0;
    	let t1_value = /*estudio*/ ctx[45].descripcion + "";
    	let t1;
    	let t2;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*estudio*/ ctx[45].tipo === "LAB") return create_if_block_5$1;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	function click_handler_3(...args) {
    		return /*click_handler_3*/ ctx[29](/*estudio*/ ctx[45], ...args);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			div = element("div");
    			if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(div, "class", "p-2");
    			set_style(div, "cursor", "pointer");
    			add_location(div, file$m, 381, 44, 17915);
    			add_location(li, file$m, 372, 40, 17345);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div);
    			if_block.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(li, t2);

    			if (!mounted) {
    				dispose = listen_dev(li, "click", click_handler_3, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, t0);
    				}
    			}

    			if (dirty[0] & /*estudios*/ 64 && t1_value !== (t1_value = /*estudio*/ ctx[45].descripcion + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$2.name,
    		type: "each",
    		source: "(372:36) {#each estudios as estudio}",
    		ctx
    	});

    	return block;
    }

    // (421:20) {#if empresa.estudiosCheck}
    function create_if_block_3$2(ctx) {
    	let div;
    	let each_value_1 = /*categoriasEstudios*/ ctx[11];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "row mt-2");
    			add_location(div, file$m, 421, 25, 20105);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*categoriasEstudios, estudiosVistaRapida, agregarEstudio*/ 22528) {
    				each_value_1 = /*categoriasEstudios*/ ctx[11];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(421:20) {#if empresa.estudiosCheck}",
    		ctx
    	});

    	return block;
    }

    // (440:57) {#if categoria.id === estudio.categoria}
    function create_if_block_4$2(ctx) {
    	let div;
    	let input;
    	let input_id_value;
    	let t0;
    	let label;
    	let t1_value = /*estudio*/ ctx[45].descripcion + "";
    	let t1;
    	let label_for_value;
    	let t2;
    	let mounted;
    	let dispose;

    	function input_change_handler() {
    		/*input_change_handler*/ ctx[30].call(input, /*each_value_2*/ ctx[46], /*estudio_index*/ ctx[47]);
    	}

    	function click_handler_4(...args) {
    		return /*click_handler_4*/ ctx[31](/*estudio*/ ctx[45], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t0 = space();
    			label = element("label");
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(input, "id", input_id_value = /*estudio*/ ctx[45].id);
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$m, 441, 65, 21630);
    			attr_dev(label, "for", label_for_value = /*estudio*/ ctx[45].id);
    			add_location(label, file$m, 446, 65, 22045);
    			attr_dev(div, "class", "tag-input mr-2");
    			add_location(div, file$m, 440, 61, 21535);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			input.checked = /*estudio*/ ctx[45].checked;
    			append_dev(div, t0);
    			append_dev(div, label);
    			append_dev(label, t1);
    			append_dev(div, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", input_change_handler),
    					listen_dev(label, "click", click_handler_4, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*estudiosVistaRapida*/ 4096 && input_id_value !== (input_id_value = /*estudio*/ ctx[45].id)) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty[0] & /*estudiosVistaRapida*/ 4096) {
    				input.checked = /*estudio*/ ctx[45].checked;
    			}

    			if (dirty[0] & /*estudiosVistaRapida*/ 4096 && t1_value !== (t1_value = /*estudio*/ ctx[45].descripcion + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*estudiosVistaRapida*/ 4096 && label_for_value !== (label_for_value = /*estudio*/ ctx[45].id)) {
    				attr_dev(label, "for", label_for_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(440:57) {#if categoria.id === estudio.categoria}",
    		ctx
    	});

    	return block;
    }

    // (438:53) {#each estudiosVistaRapida as estudio}
    function create_each_block_2$2(ctx) {
    	let if_block_anchor;
    	let if_block = /*categoria*/ ctx[42].id === /*estudio*/ ctx[45].categoria && create_if_block_4$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*categoria*/ ctx[42].id === /*estudio*/ ctx[45].categoria) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(438:53) {#each estudiosVistaRapida as estudio}",
    		ctx
    	});

    	return block;
    }

    // (423:29) {#each categoriasEstudios as categoria}
    function create_each_block_1$3(ctx) {
    	let div5;
    	let div4;
    	let div3;
    	let div0;
    	let h5;
    	let a;
    	let t0_value = /*categoria*/ ctx[42].Name + "";
    	let t0;
    	let a_data_target_value;
    	let a_aria_controls_value;
    	let t1;
    	let div2;
    	let div1;
    	let div2_id_value;
    	let t2;
    	let each_value_2 = /*estudiosVistaRapida*/ ctx[12];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			attr_dev(a, "href", "#!");
    			attr_dev(a, "class", "d-block");
    			attr_dev(a, "data-toggle", "collapse");
    			attr_dev(a, "data-target", a_data_target_value = `#collapse${/*categoria*/ ctx[42].id}`);
    			attr_dev(a, "aria-expanded", "true");
    			attr_dev(a, "aria-controls", a_aria_controls_value = `collapse${/*categoria*/ ctx[42].id}`);
    			add_location(a, file$m, 429, 53, 20624);
    			attr_dev(h5, "class", "mb-0");
    			add_location(h5, file$m, 428, 49, 20552);
    			attr_dev(div0, "class", "card-header");
    			attr_dev(div0, "id", "headingOne");
    			add_location(div0, file$m, 427, 45, 20460);
    			attr_dev(div1, "class", "card-body");
    			add_location(div1, file$m, 436, 49, 21250);
    			attr_dev(div2, "id", div2_id_value = `collapse${/*categoria*/ ctx[42].id}`);
    			attr_dev(div2, "class", "collapse");
    			attr_dev(div2, "aria-labelledby", "headingOne");
    			attr_dev(div2, "data-parent", "#accordionExample");
    			add_location(div2, file$m, 435, 45, 21085);
    			attr_dev(div3, "class", "card");
    			add_location(div3, file$m, 426, 41, 20395);
    			attr_dev(div4, "class", "accordion ");
    			attr_dev(div4, "id", "accordionExample");
    			add_location(div4, file$m, 425, 37, 20306);
    			attr_dev(div5, "class", "col-lg-12 mb-2");
    			add_location(div5, file$m, 423, 33, 20232);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, h5);
    			append_dev(h5, a);
    			append_dev(a, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div5, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*categoriasEstudios*/ 2048 && t0_value !== (t0_value = /*categoria*/ ctx[42].Name + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*categoriasEstudios*/ 2048 && a_data_target_value !== (a_data_target_value = `#collapse${/*categoria*/ ctx[42].id}`)) {
    				attr_dev(a, "data-target", a_data_target_value);
    			}

    			if (dirty[0] & /*categoriasEstudios*/ 2048 && a_aria_controls_value !== (a_aria_controls_value = `collapse${/*categoria*/ ctx[42].id}`)) {
    				attr_dev(a, "aria-controls", a_aria_controls_value);
    			}

    			if (dirty[0] & /*estudiosVistaRapida, agregarEstudio, categoriasEstudios*/ 22528) {
    				each_value_2 = /*estudiosVistaRapida*/ ctx[12];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}

    			if (dirty[0] & /*categoriasEstudios*/ 2048 && div2_id_value !== (div2_id_value = `collapse${/*categoria*/ ctx[42].id}`)) {
    				attr_dev(div2, "id", div2_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(423:29) {#each categoriasEstudios as categoria}",
    		ctx
    	});

    	return block;
    }

    // (504:32) {:else}
    function create_else_block$2(ctx) {
    	let span;
    	let i;

    	const block = {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr_dev(i, "class", "mdi mdi-image");
    			add_location(i, file$m, 505, 41, 25767);
    			attr_dev(span, "class", "badge badge-primary");
    			add_location(span, file$m, 504, 36, 25691);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, i);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(504:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (500:32) {#if item.tipo === "LAB"}
    function create_if_block_2$5(ctx) {
    	let span;
    	let i;

    	const block = {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr_dev(i, "class", "mdi mdi-microscope");
    			add_location(i, file$m, 501, 41, 25535);
    			attr_dev(span, "class", "badge badge-primary");
    			add_location(span, file$m, 500, 36, 25459);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, i);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(500:32) {#if item.tipo === \\\"LAB\\\"}",
    		ctx
    	});

    	return block;
    }

    // (510:32) {#if !disabled}
    function create_if_block_1$8(ctx) {
    	let div;
    	let a;
    	let i;
    	let mounted;
    	let dispose;

    	function click_handler_5(...args) {
    		return /*click_handler_5*/ ctx[32](/*i*/ ctx[41], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			a = element("a");
    			i = element("i");
    			attr_dev(i, "class", "mdi-18px mdi mdi-trash-can-outline");
    			add_location(i, file$m, 527, 45, 27141);
    			attr_dev(a, "href", "#!");
    			attr_dev(a, "class", "text-danger");
    			add_location(a, file$m, 522, 40, 26827);
    			set_style(div, "position", "absolute");
    			set_style(div, "top", "0");
    			set_style(div, "right", "0");
    			set_style(div, "padding", "10px");
    			set_style(div, "background-color", "white");
    			set_style(div, "border-bottom-left-radius", "5px");
    			add_location(div, file$m, 510, 36, 26036);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a);
    			append_dev(a, i);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", prevent_default(click_handler_5), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(510:32) {#if !disabled}",
    		ctx
    	});

    	return block;
    }

    // (498:24) {#each estudiosSeleccionados.reverse() as item, i}
    function create_each_block$6(ctx) {
    	let li;
    	let t0;
    	let span;
    	let t1_value = /*item*/ ctx[39].descripcion + "";
    	let t1;
    	let t2;

    	function select_block_type_1(ctx, dirty) {
    		if (/*item*/ ctx[39].tipo === "LAB") return create_if_block_2$5;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = !/*disabled*/ ctx[9] && create_if_block_1$8(ctx);

    	const block = {
    		c: function create() {
    			li = element("li");
    			if_block0.c();
    			t0 = text("\r\n                                ");
    			span = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			add_location(span, file$m, 508, 38, 25918);
    			add_location(li, file$m, 498, 28, 25358);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			if_block0.m(li, null);
    			append_dev(li, t0);
    			append_dev(li, span);
    			append_dev(span, t1);
    			append_dev(li, t2);
    			if (if_block1) if_block1.m(li, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(li, t0);
    				}
    			}

    			if (dirty[0] & /*estudiosSeleccionados*/ 16 && t1_value !== (t1_value = /*item*/ ctx[39].descripcion + "")) set_data_dev(t1, t1_value);

    			if (!/*disabled*/ ctx[9]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$8(ctx);
    					if_block1.c();
    					if_block1.m(li, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(498:24) {#each estudiosSeleccionados.reverse() as item, i}",
    		ctx
    	});

    	return block;
    }

    // (536:24) {#if estudiosSeleccionados.length === 0}
    function create_if_block$c(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let p;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			p.textContent = "No tienes agregado ningn estudio";
    			attr_dev(p, "class", "alert-body text-center mt-3");
    			add_location(p, file$m, 542, 40, 27901);
    			attr_dev(div0, "class", "alert border alert-light");
    			attr_dev(div0, "role", "alert");
    			add_location(div0, file$m, 538, 36, 27688);
    			attr_dev(div1, "class", "col-md-12");
    			add_location(div1, file$m, 537, 32, 27627);
    			attr_dev(div2, "class", "row");
    			add_location(div2, file$m, 536, 28, 27576);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(536:24) {#if estudiosSeleccionados.length === 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div29;
    	let h4;
    	let t1;
    	let a0;
    	let i0;
    	let t2;
    	let a0_href_value;
    	let link_action;
    	let t3;
    	let div11;
    	let div2;
    	let div0;
    	let t5;
    	let div1;
    	let a1;
    	let i1;
    	let a1_href_value;
    	let link_action_1;
    	let t6;
    	let div10;
    	let div9;
    	let div8;
    	let div7;
    	let div5;
    	let div4;
    	let input0;
    	let t7;
    	let ul0;
    	let div3;
    	let t8;
    	let li0;
    	let a2;
    	let i2;
    	let t9;
    	let t10;
    	let div6;
    	let t11;
    	let div22;
    	let div14;
    	let div12;
    	let t13;
    	let div13;
    	let a3;
    	let i3;
    	let t14;
    	let a3_href_value;
    	let link_action_2;
    	let t15;
    	let a4;
    	let i4;
    	let t16;
    	let a4_href_value;
    	let link_action_3;
    	let t17;
    	let div21;
    	let div20;
    	let div18;
    	let div17;
    	let div16;
    	let input1;
    	let t18;
    	let ul1;
    	let div15;
    	let t19;
    	let li1;
    	let a5;
    	let i5;
    	let t20;
    	let t21;
    	let div19;
    	let t22;
    	let ul2;
    	let t23;
    	let t24;
    	let div28;
    	let div24;
    	let div23;
    	let t26;
    	let div27;
    	let div26;
    	let div25;
    	let textarea;
    	let mounted;
    	let dispose;
    	let each_value_5 = /*medicamentos*/ ctx[5];
    	validate_each_argument(each_value_5);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks_3[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	let each_value_4 = /*medicamentosSeleccionados*/ ctx[3];
    	validate_each_argument(each_value_4);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks_2[i] = create_each_block_4$1(get_each_context_4$1(ctx, each_value_4, i));
    	}

    	let each1_else = null;

    	if (!each_value_4.length) {
    		each1_else = create_else_block_2(ctx);
    	}

    	let each_value_3 = /*estudios*/ ctx[6];
    	validate_each_argument(each_value_3);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_1[i] = create_each_block_3$2(get_each_context_3$2(ctx, each_value_3, i));
    	}

    	let if_block0 = /*empresa*/ ctx[10].estudiosCheck && create_if_block_3$2(ctx);
    	let each_value = /*estudiosSeleccionados*/ ctx[4].reverse();
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	let if_block1 = /*estudiosSeleccionados*/ ctx[4].length === 0 && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			div29 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Receta";
    			t1 = space();
    			a0 = element("a");
    			i0 = element("i");
    			t2 = text("\r\n        Imprimir todas las recetas");
    			t3 = space();
    			div11 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "Medicamentos";
    			t5 = space();
    			div1 = element("div");
    			a1 = element("a");
    			i1 = element("i");
    			t6 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			input0 = element("input");
    			t7 = space();
    			ul0 = element("ul");
    			div3 = element("div");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t8 = space();
    			li0 = element("li");
    			a2 = element("a");
    			i2 = element("i");
    			t9 = text("Agregar\r\n                                            manualmente");
    			t10 = space();
    			div6 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			if (each1_else) {
    				each1_else.c();
    			}

    			t11 = space();
    			div22 = element("div");
    			div14 = element("div");
    			div12 = element("div");
    			div12.textContent = "Estudios";
    			t13 = space();
    			div13 = element("div");
    			a3 = element("a");
    			i3 = element("i");
    			t14 = text(" Laboratorios");
    			t15 = space();
    			a4 = element("a");
    			i4 = element("i");
    			t16 = text(" Imagenes");
    			t17 = space();
    			div21 = element("div");
    			div20 = element("div");
    			div18 = element("div");
    			div17 = element("div");
    			div16 = element("div");
    			input1 = element("input");
    			t18 = space();
    			ul1 = element("ul");
    			div15 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t19 = space();
    			li1 = element("li");
    			a5 = element("a");
    			i5 = element("i");
    			t20 = text(" Agregar manualmente");
    			t21 = space();
    			div19 = element("div");
    			if (if_block0) if_block0.c();
    			t22 = space();
    			ul2 = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t23 = space();
    			if (if_block1) if_block1.c();
    			t24 = space();
    			div28 = element("div");
    			div24 = element("div");
    			div23 = element("div");
    			div23.textContent = "Instrucciones";
    			t26 = space();
    			div27 = element("div");
    			div26 = element("div");
    			div25 = element("div");
    			textarea = element("textarea");
    			attr_dev(h4, "class", "alert-heading");
    			add_location(h4, file$m, 125, 4, 3831);
    			attr_dev(i0, "class", "mdi mdi-printer");
    			add_location(i0, file$m, 131, 8, 4055);
    			attr_dev(a0, "href", a0_href_value = `/pacientes/${/*idPaciente*/ ctx[8]}/historias/${/*idHistoria*/ ctx[7]}/imprimir/estudios`);
    			attr_dev(a0, "class", "btn btn-outline-primary btn-sm btn-receta svelte-1mwxgdj");
    			add_location(a0, file$m, 126, 4, 3874);
    			attr_dev(div0, "class", "card-title");
    			add_location(div0, file$m, 136, 12, 4215);
    			attr_dev(i1, "class", "mdi mdi-printer");
    			add_location(i1, file$m, 144, 20, 4596);
    			attr_dev(a1, "href", a1_href_value = `/impresion/pacientes/${/*idPaciente*/ ctx[8]}/historias/${/*idHistoria*/ ctx[7]}/medicamentos`);
    			attr_dev(a1, "class", "btn btn-outline-primary btn-sm");
    			attr_dev(a1, "data-tooltip", "Imprimir");
    			add_location(a1, file$m, 138, 16, 4316);
    			attr_dev(div1, "class", "card-controls");
    			add_location(div1, file$m, 137, 12, 4271);
    			attr_dev(div2, "class", "card-header");
    			add_location(div2, file$m, 135, 8, 4176);
    			input0.disabled = /*disabled*/ ctx[9];
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "data-toggle", "dropdown");
    			attr_dev(input0, "aria-haspopup", "true");
    			attr_dev(input0, "aria-expanded", "true");
    			attr_dev(input0, "placeholder", "Buscar medicamentos");
    			add_location(input0, file$m, 154, 32, 4966);
    			attr_dev(div3, "class", "contenidoLista");
    			add_location(div3, file$m, 172, 36, 6076);
    			attr_dev(i2, "class", "mdi mdi-plus");
    			add_location(i2, file$m, 197, 45, 7663);
    			attr_dev(a2, "href", "#!");
    			add_location(a2, file$m, 190, 40, 7222);
    			attr_dev(li0, "class", "defecto");
    			add_location(li0, file$m, 189, 36, 7160);
    			attr_dev(ul0, "class", "lista-buscador dropdown-menu");
    			attr_dev(ul0, "id", "buscador");
    			attr_dev(ul0, "x-placement", "top-start");
    			set_style(ul0, "position", "absolute");
    			set_style(ul0, "will-change", "transform");
    			set_style(ul0, "top", "0px");
    			set_style(ul0, "left", "0px");
    			set_style(ul0, "transform", "translate3d(0px, -128px, 0px)");
    			set_style(ul0, "border-radius", "5px");
    			add_location(ul0, file$m, 166, 32, 5642);
    			attr_dev(div4, "class", "dropdown");
    			add_location(div4, file$m, 153, 28, 4910);
    			attr_dev(div5, "class", "col-lg-6");
    			add_location(div5, file$m, 152, 24, 4858);
    			attr_dev(div6, "class", "col-lg-12");
    			add_location(div6, file$m, 204, 24, 7975);
    			attr_dev(div7, "class", "row");
    			add_location(div7, file$m, 151, 20, 4815);
    			attr_dev(div8, "class", "col-md-12 mb-2");
    			add_location(div8, file$m, 150, 16, 4765);
    			attr_dev(div9, "class", "row");
    			add_location(div9, file$m, 149, 12, 4730);
    			attr_dev(div10, "class", "card-body");
    			add_location(div10, file$m, 148, 8, 4693);
    			attr_dev(div11, "class", "card m-b-20 mt-3");
    			add_location(div11, file$m, 134, 4, 4136);
    			attr_dev(div12, "class", "card-title");
    			add_location(div12, file$m, 323, 12, 14955);
    			attr_dev(i3, "class", "mdi mdi-printer");
    			add_location(i3, file$m, 331, 20, 15341);
    			attr_dev(a3, "href", a3_href_value = `/impresion/pacientes/${/*idPaciente*/ ctx[8]}/historias/${/*idHistoria*/ ctx[7]}/estudios/laboratorios`);
    			attr_dev(a3, "class", "btn btn-outline-primary btn-sm");
    			attr_dev(a3, "data-tooltip", "Imprimir");
    			add_location(a3, file$m, 325, 16, 15052);
    			attr_dev(i4, "class", "mdi mdi-printer");
    			add_location(i4, file$m, 339, 20, 15708);
    			attr_dev(a4, "href", a4_href_value = `/impresion/pacientes/${/*idPaciente*/ ctx[8]}/historias/${/*idHistoria*/ ctx[7]}/estudios/imagenes`);
    			attr_dev(a4, "class", "btn btn-outline-primary btn-sm");
    			attr_dev(a4, "data-tooltip", "Imprimir");
    			add_location(a4, file$m, 333, 16, 15423);
    			attr_dev(div13, "class", "card-controls");
    			add_location(div13, file$m, 324, 12, 15007);
    			attr_dev(div14, "class", "card-header");
    			add_location(div14, file$m, 322, 8, 14916);
    			input1.disabled = /*disabled*/ ctx[9];
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "data-toggle", "dropdown");
    			attr_dev(input1, "aria-haspopup", "true");
    			attr_dev(input1, "aria-expanded", "false");
    			attr_dev(input1, "placeholder", "Buscar estudios");
    			add_location(input1, file$m, 349, 28, 16078);
    			attr_dev(div15, "class", "contenidoLista");
    			attr_dev(div15, "data-bind", "foreach: listado");
    			add_location(div15, file$m, 367, 32, 17073);
    			attr_dev(i5, "class", "mdi mdi-plus");
    			add_location(i5, file$m, 411, 41, 19743);
    			attr_dev(a5, "href", "/");
    			attr_dev(a5, "data-bind", "click: agregarManualmente");
    			add_location(a5, file$m, 408, 36, 19569);
    			attr_dev(li1, "class", "defecto");
    			add_location(li1, file$m, 407, 32, 19511);
    			attr_dev(ul1, "class", "lista-buscador dropdown-menu");
    			attr_dev(ul1, "id", "buscador");
    			attr_dev(ul1, "x-placement", "bottom-start");
    			set_style(ul1, "position", "absolute");
    			set_style(ul1, "will-change", "transform");
    			set_style(ul1, "border-radius", "5px");
    			set_style(ul1, "top", "0px");
    			set_style(ul1, "left", "0px");
    			set_style(ul1, "transform", "translate3d(0px, 36px, 0px)");
    			add_location(ul1, file$m, 361, 28, 16662);
    			attr_dev(div16, "class", "form-group buscardor dropdown dropdown-vnc");
    			add_location(div16, file$m, 348, 24, 15992);
    			attr_dev(div17, "class", "col-lg-6 col-md-12");
    			add_location(div17, file$m, 347, 20, 15934);
    			attr_dev(div18, "class", "col-12 row");
    			add_location(div18, file$m, 346, 16, 15888);
    			attr_dev(ul2, "class", "list-info mt-2");
    			add_location(ul2, file$m, 496, 20, 25225);
    			attr_dev(div19, "class", "col-12");
    			add_location(div19, file$m, 419, 16, 20009);
    			attr_dev(div20, "class", "row");
    			add_location(div20, file$m, 345, 12, 15853);
    			attr_dev(div21, "class", "card-body");
    			add_location(div21, file$m, 344, 8, 15816);
    			attr_dev(div22, "class", "card m-b-20");
    			add_location(div22, file$m, 321, 4, 14881);
    			attr_dev(div23, "class", "card-title");
    			add_location(div23, file$m, 559, 12, 28421);
    			attr_dev(div24, "class", "card-header");
    			add_location(div24, file$m, 558, 8, 28382);
    			textarea.disabled = /*disabled*/ ctx[9];
    			attr_dev(textarea, "class", "form-control");
    			set_style(textarea, "width", "100%");
    			attr_dev(textarea, "rows", "5");
    			add_location(textarea, file$m, 564, 20, 28604);
    			attr_dev(div25, "class", "col-12");
    			add_location(div25, file$m, 563, 16, 28562);
    			attr_dev(div26, "class", "row");
    			add_location(div26, file$m, 562, 12, 28527);
    			attr_dev(div27, "class", "card-body");
    			add_location(div27, file$m, 561, 8, 28490);
    			attr_dev(div28, "class", "card m-b-20");
    			add_location(div28, file$m, 557, 4, 28347);
    			attr_dev(div29, "class", "alert alert-secondary");
    			attr_dev(div29, "role", "alert");
    			add_location(div29, file$m, 124, 0, 3777);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div29, anchor);
    			append_dev(div29, h4);
    			append_dev(div29, t1);
    			append_dev(div29, a0);
    			append_dev(a0, i0);
    			append_dev(a0, t2);
    			append_dev(div29, t3);
    			append_dev(div29, div11);
    			append_dev(div11, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t5);
    			append_dev(div2, div1);
    			append_dev(div1, a1);
    			append_dev(a1, i1);
    			append_dev(div11, t6);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div5);
    			append_dev(div5, div4);
    			append_dev(div4, input0);
    			set_input_value(input0, /*sltBuscarMedicamentos*/ ctx[1]);
    			append_dev(div4, t7);
    			append_dev(div4, ul0);
    			append_dev(ul0, div3);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(div3, null);
    			}

    			append_dev(ul0, t8);
    			append_dev(ul0, li0);
    			append_dev(li0, a2);
    			append_dev(a2, i2);
    			append_dev(a2, t9);
    			append_dev(div7, t10);
    			append_dev(div7, div6);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div6, null);
    			}

    			if (each1_else) {
    				each1_else.m(div6, null);
    			}

    			append_dev(div29, t11);
    			append_dev(div29, div22);
    			append_dev(div22, div14);
    			append_dev(div14, div12);
    			append_dev(div14, t13);
    			append_dev(div14, div13);
    			append_dev(div13, a3);
    			append_dev(a3, i3);
    			append_dev(a3, t14);
    			append_dev(div13, t15);
    			append_dev(div13, a4);
    			append_dev(a4, i4);
    			append_dev(a4, t16);
    			append_dev(div22, t17);
    			append_dev(div22, div21);
    			append_dev(div21, div20);
    			append_dev(div20, div18);
    			append_dev(div18, div17);
    			append_dev(div17, div16);
    			append_dev(div16, input1);
    			set_input_value(input1, /*sltBuscarEstudios*/ ctx[2]);
    			append_dev(div16, t18);
    			append_dev(div16, ul1);
    			append_dev(ul1, div15);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div15, null);
    			}

    			append_dev(ul1, t19);
    			append_dev(ul1, li1);
    			append_dev(li1, a5);
    			append_dev(a5, i5);
    			append_dev(a5, t20);
    			append_dev(div20, t21);
    			append_dev(div20, div19);
    			if (if_block0) if_block0.m(div19, null);
    			append_dev(div19, t22);
    			append_dev(div19, ul2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul2, null);
    			}

    			append_dev(ul2, t23);
    			if (if_block1) if_block1.m(ul2, null);
    			append_dev(div29, t24);
    			append_dev(div29, div28);
    			append_dev(div28, div24);
    			append_dev(div24, div23);
    			append_dev(div28, t26);
    			append_dev(div28, div27);
    			append_dev(div27, div26);
    			append_dev(div26, div25);
    			append_dev(div25, textarea);
    			set_input_value(textarea, /*instrucciones*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link_action = link.call(null, a0)),
    					action_destroyer(link_action_1 = link.call(null, a1)),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[16]),
    					listen_dev(input0, "input", /*input_handler*/ ctx[17], false, false, false),
    					listen_dev(a2, "click", prevent_default(/*click_handler_1*/ ctx[19]), false, true, false),
    					action_destroyer(link_action_2 = link.call(null, a3)),
    					action_destroyer(link_action_3 = link.call(null, a4)),
    					listen_dev(input1, "input", /*input1_input_handler_1*/ ctx[27]),
    					listen_dev(input1, "input", /*input_handler_1*/ ctx[28], false, false, false),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[33]),
    					listen_dev(textarea, "blur", /*blur_handler_3*/ ctx[34], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*idPaciente, idHistoria*/ 384 && a0_href_value !== (a0_href_value = `/pacientes/${/*idPaciente*/ ctx[8]}/historias/${/*idHistoria*/ ctx[7]}/imprimir/estudios`)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty[0] & /*idPaciente, idHistoria*/ 384 && a1_href_value !== (a1_href_value = `/impresion/pacientes/${/*idPaciente*/ ctx[8]}/historias/${/*idHistoria*/ ctx[7]}/medicamentos`)) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(input0, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*sltBuscarMedicamentos*/ 2 && input0.value !== /*sltBuscarMedicamentos*/ ctx[1]) {
    				set_input_value(input0, /*sltBuscarMedicamentos*/ ctx[1]);
    			}

    			if (dirty[0] & /*dispatch, medicamentos*/ 8224) {
    				each_value_5 = /*medicamentos*/ ctx[5];
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_5(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(div3, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_5.length;
    			}

    			if (dirty[0] & /*dispatch, disabled, medicamentosSeleccionados*/ 8712) {
    				each_value_4 = /*medicamentosSeleccionados*/ ctx[3];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4$1(ctx, each_value_4, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_4$1(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(div6, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_4.length;

    				if (each_value_4.length) {
    					if (each1_else) {
    						each1_else.d(1);
    						each1_else = null;
    					}
    				} else if (!each1_else) {
    					each1_else = create_else_block_2(ctx);
    					each1_else.c();
    					each1_else.m(div6, null);
    				}
    			}

    			if (dirty[0] & /*idPaciente, idHistoria*/ 384 && a3_href_value !== (a3_href_value = `/impresion/pacientes/${/*idPaciente*/ ctx[8]}/historias/${/*idHistoria*/ ctx[7]}/estudios/laboratorios`)) {
    				attr_dev(a3, "href", a3_href_value);
    			}

    			if (dirty[0] & /*idPaciente, idHistoria*/ 384 && a4_href_value !== (a4_href_value = `/impresion/pacientes/${/*idPaciente*/ ctx[8]}/historias/${/*idHistoria*/ ctx[7]}/estudios/imagenes`)) {
    				attr_dev(a4, "href", a4_href_value);
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(input1, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*sltBuscarEstudios*/ 4 && input1.value !== /*sltBuscarEstudios*/ ctx[2]) {
    				set_input_value(input1, /*sltBuscarEstudios*/ ctx[2]);
    			}

    			if (dirty[0] & /*dispatch, estudios*/ 8256) {
    				each_value_3 = /*estudios*/ ctx[6];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$2(ctx, each_value_3, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_3$2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div15, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_3.length;
    			}

    			if (/*empresa*/ ctx[10].estudiosCheck) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$2(ctx);
    					if_block0.c();
    					if_block0.m(div19, t22);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*eliminarEstudio, disabled, estudiosSeleccionados*/ 33296) {
    				each_value = /*estudiosSeleccionados*/ ctx[4].reverse();
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul2, t23);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*estudiosSeleccionados*/ ctx[4].length === 0) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block$c(ctx);
    					if_block1.c();
    					if_block1.m(ul2, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*disabled*/ 512) {
    				prop_dev(textarea, "disabled", /*disabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*instrucciones*/ 1) {
    				set_input_value(textarea, /*instrucciones*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div29);
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);
    			if (each1_else) each1_else.d();
    			destroy_each(each_blocks_1, detaching);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks, detaching);
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("OrdenesMedicas", slots, []);
    	let dispatch = createEventDispatcher();
    	let { instrucciones = "" } = $$props;
    	let { medicamentos } = $$props;
    	let { sltBuscarMedicamentos } = $$props;
    	let { sltBuscarEstudios } = $$props;
    	let { medicamentosSeleccionados } = $$props;
    	let { estudios } = $$props;
    	let { estudiosSeleccionados } = $$props;
    	let { idHistoria } = $$props;
    	let { idPaciente } = $$props;
    	let { disabled } = $$props;
    	let empresa = {};
    	let categoriasEstudios = [];
    	let estudiosVistaRapida = [];
    	let selected = [];

    	const cargarEmpresa = () => {
    		const config = {
    			method: "get",
    			url: `${url}/empresas/${user().empresa}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(10, empresa = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const agregarEstudio = ({ id, descripcion, tipo }) => {
    		const index = estudiosSeleccionados.findIndex(estudio => estudio.id == id);
    		const estudio = estudiosSeleccionados.find(estudio => estudio.id == id);

    		if (estudio) {
    			$$invalidate(4, estudiosSeleccionados = estudiosSeleccionados.filter(estudio => estudio.id !== id));
    			dispatch("eliminarEstudio", id);
    			return;
    		} else {
    			dispatch("agregarEstudio", { id, descripcion, tipo });
    		}
    	};

    	const eliminarEstudio = id => {
    		dispatch("eliminarEstudio", id);
    		cargarCategoriasEstudios();
    		cargarEstudiosVistaRapida();
    	};

    	const cargarCategoriasEstudios = () => {
    		const config = {
    			method: "get",
    			url: `${url}/categoriasestudios/display`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(async res => {
    			$$invalidate(11, categoriasEstudios = res.data);
    			await cargarEstudiosVistaRapida();
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarEstudiosVistaRapida = () => {
    		const config = {
    			method: "get",
    			url: `${url}/estudio/vistarapida`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(12, estudiosVistaRapida = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	onMount(() => {
    		cargarEmpresa();
    		cargarCategoriasEstudios();
    	});

    	const writable_props = [
    		"instrucciones",
    		"medicamentos",
    		"sltBuscarMedicamentos",
    		"sltBuscarEstudios",
    		"medicamentosSeleccionados",
    		"estudios",
    		"estudiosSeleccionados",
    		"idHistoria",
    		"idPaciente",
    		"disabled"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$a.warn(`<OrdenesMedicas> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		sltBuscarMedicamentos = this.value;
    		$$invalidate(1, sltBuscarMedicamentos);
    	}

    	const input_handler = () => dispatch("buscarMedicamentos");
    	const click_handler = medicamento => dispatch("agregarMedicamento", medicamento.descripcion);
    	const click_handler_1 = () => dispatch("agregarMedicamento", sltBuscarMedicamentos);
    	const blur_handler = () => dispatch("modificado");

    	function input0_input_handler_1(each_value_4, i) {
    		each_value_4[i].concentracion = this.value;
    		$$invalidate(3, medicamentosSeleccionados);
    	}

    	const blur_handler_1 = () => dispatch("modificado");

    	function input1_input_handler(each_value_4, i) {
    		each_value_4[i].cantidad = this.value;
    		$$invalidate(3, medicamentosSeleccionados);
    	}

    	const blur_handler_2 = () => dispatch("modificado");

    	function input2_input_handler(each_value_4, i) {
    		each_value_4[i].frecuencia = this.value;
    		$$invalidate(3, medicamentosSeleccionados);
    	}

    	const click_handler_2 = i => dispatch("eliminarMedicamento", i);

    	function input1_input_handler_1() {
    		sltBuscarEstudios = this.value;
    		$$invalidate(2, sltBuscarEstudios);
    	}

    	const input_handler_1 = () => dispatch("buscandoEstudios");

    	const click_handler_3 = estudio => dispatch("agregarEstudio", {
    		id: estudio.id,
    		descripcion: estudio.descripcion,
    		tipo: estudio.tipo
    	});

    	function input_change_handler(each_value_2, estudio_index) {
    		each_value_2[estudio_index].checked = this.checked;
    		$$invalidate(12, estudiosVistaRapida);
    	}

    	const click_handler_4 = estudio => agregarEstudio({
    		id: estudio.id,
    		descripcion: estudio.descripcion,
    		tipo: estudio.tipo
    	});

    	const click_handler_5 = i => eliminarEstudio(i);

    	function textarea_input_handler() {
    		instrucciones = this.value;
    		$$invalidate(0, instrucciones);
    	}

    	const blur_handler_3 = () => dispatch("modificado");

    	$$self.$$set = $$props => {
    		if ("instrucciones" in $$props) $$invalidate(0, instrucciones = $$props.instrucciones);
    		if ("medicamentos" in $$props) $$invalidate(5, medicamentos = $$props.medicamentos);
    		if ("sltBuscarMedicamentos" in $$props) $$invalidate(1, sltBuscarMedicamentos = $$props.sltBuscarMedicamentos);
    		if ("sltBuscarEstudios" in $$props) $$invalidate(2, sltBuscarEstudios = $$props.sltBuscarEstudios);
    		if ("medicamentosSeleccionados" in $$props) $$invalidate(3, medicamentosSeleccionados = $$props.medicamentosSeleccionados);
    		if ("estudios" in $$props) $$invalidate(6, estudios = $$props.estudios);
    		if ("estudiosSeleccionados" in $$props) $$invalidate(4, estudiosSeleccionados = $$props.estudiosSeleccionados);
    		if ("idHistoria" in $$props) $$invalidate(7, idHistoria = $$props.idHistoria);
    		if ("idPaciente" in $$props) $$invalidate(8, idPaciente = $$props.idPaciente);
    		if ("disabled" in $$props) $$invalidate(9, disabled = $$props.disabled);
    	};

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		url,
    		user,
    		createEventDispatcher,
    		onMount,
    		link,
    		dispatch,
    		instrucciones,
    		medicamentos,
    		sltBuscarMedicamentos,
    		sltBuscarEstudios,
    		medicamentosSeleccionados,
    		estudios,
    		estudiosSeleccionados,
    		idHistoria,
    		idPaciente,
    		disabled,
    		empresa,
    		categoriasEstudios,
    		estudiosVistaRapida,
    		selected,
    		cargarEmpresa,
    		agregarEstudio,
    		eliminarEstudio,
    		cargarCategoriasEstudios,
    		cargarEstudiosVistaRapida
    	});

    	$$self.$inject_state = $$props => {
    		if ("dispatch" in $$props) $$invalidate(13, dispatch = $$props.dispatch);
    		if ("instrucciones" in $$props) $$invalidate(0, instrucciones = $$props.instrucciones);
    		if ("medicamentos" in $$props) $$invalidate(5, medicamentos = $$props.medicamentos);
    		if ("sltBuscarMedicamentos" in $$props) $$invalidate(1, sltBuscarMedicamentos = $$props.sltBuscarMedicamentos);
    		if ("sltBuscarEstudios" in $$props) $$invalidate(2, sltBuscarEstudios = $$props.sltBuscarEstudios);
    		if ("medicamentosSeleccionados" in $$props) $$invalidate(3, medicamentosSeleccionados = $$props.medicamentosSeleccionados);
    		if ("estudios" in $$props) $$invalidate(6, estudios = $$props.estudios);
    		if ("estudiosSeleccionados" in $$props) $$invalidate(4, estudiosSeleccionados = $$props.estudiosSeleccionados);
    		if ("idHistoria" in $$props) $$invalidate(7, idHistoria = $$props.idHistoria);
    		if ("idPaciente" in $$props) $$invalidate(8, idPaciente = $$props.idPaciente);
    		if ("disabled" in $$props) $$invalidate(9, disabled = $$props.disabled);
    		if ("empresa" in $$props) $$invalidate(10, empresa = $$props.empresa);
    		if ("categoriasEstudios" in $$props) $$invalidate(11, categoriasEstudios = $$props.categoriasEstudios);
    		if ("estudiosVistaRapida" in $$props) $$invalidate(12, estudiosVistaRapida = $$props.estudiosVistaRapida);
    		if ("selected" in $$props) $$invalidate(35, selected = $$props.selected);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*estudiosSeleccionados, estudiosVistaRapida*/ 4112 | $$self.$$.dirty[1] & /*selected*/ 16) {
    			 estudiosSeleccionados.forEach(estudio => {
    				estudiosVistaRapida.forEach(estudioVistaRapida => {
    					if (estudio.id == estudioVistaRapida.id) {
    						estudioVistaRapida.checked = true;
    						$$invalidate(35, selected = selected.filter(select => select.id !== estudioVistaRapida.id));
    						selected.push(estudioVistaRapida);
    						return (($$invalidate(35, selected), $$invalidate(4, estudiosSeleccionados)), $$invalidate(12, estudiosVistaRapida));
    					}

    					$$invalidate(35, selected = selected.filter(select => select.id !== estudioVistaRapida.id));
    					selected.push(estudioVistaRapida);
    					return (($$invalidate(35, selected), $$invalidate(4, estudiosSeleccionados)), $$invalidate(12, estudiosVistaRapida));
    				});
    			});
    		}
    	};

    	return [
    		instrucciones,
    		sltBuscarMedicamentos,
    		sltBuscarEstudios,
    		medicamentosSeleccionados,
    		estudiosSeleccionados,
    		medicamentos,
    		estudios,
    		idHistoria,
    		idPaciente,
    		disabled,
    		empresa,
    		categoriasEstudios,
    		estudiosVistaRapida,
    		dispatch,
    		agregarEstudio,
    		eliminarEstudio,
    		input0_input_handler,
    		input_handler,
    		click_handler,
    		click_handler_1,
    		blur_handler,
    		input0_input_handler_1,
    		blur_handler_1,
    		input1_input_handler,
    		blur_handler_2,
    		input2_input_handler,
    		click_handler_2,
    		input1_input_handler_1,
    		input_handler_1,
    		click_handler_3,
    		input_change_handler,
    		click_handler_4,
    		click_handler_5,
    		textarea_input_handler,
    		blur_handler_3
    	];
    }

    class OrdenesMedicas extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$n,
    			create_fragment$n,
    			safe_not_equal,
    			{
    				instrucciones: 0,
    				medicamentos: 5,
    				sltBuscarMedicamentos: 1,
    				sltBuscarEstudios: 2,
    				medicamentosSeleccionados: 3,
    				estudios: 6,
    				estudiosSeleccionados: 4,
    				idHistoria: 7,
    				idPaciente: 8,
    				disabled: 9
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OrdenesMedicas",
    			options,
    			id: create_fragment$n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*medicamentos*/ ctx[5] === undefined && !("medicamentos" in props)) {
    			console_1$a.warn("<OrdenesMedicas> was created without expected prop 'medicamentos'");
    		}

    		if (/*sltBuscarMedicamentos*/ ctx[1] === undefined && !("sltBuscarMedicamentos" in props)) {
    			console_1$a.warn("<OrdenesMedicas> was created without expected prop 'sltBuscarMedicamentos'");
    		}

    		if (/*sltBuscarEstudios*/ ctx[2] === undefined && !("sltBuscarEstudios" in props)) {
    			console_1$a.warn("<OrdenesMedicas> was created without expected prop 'sltBuscarEstudios'");
    		}

    		if (/*medicamentosSeleccionados*/ ctx[3] === undefined && !("medicamentosSeleccionados" in props)) {
    			console_1$a.warn("<OrdenesMedicas> was created without expected prop 'medicamentosSeleccionados'");
    		}

    		if (/*estudios*/ ctx[6] === undefined && !("estudios" in props)) {
    			console_1$a.warn("<OrdenesMedicas> was created without expected prop 'estudios'");
    		}

    		if (/*estudiosSeleccionados*/ ctx[4] === undefined && !("estudiosSeleccionados" in props)) {
    			console_1$a.warn("<OrdenesMedicas> was created without expected prop 'estudiosSeleccionados'");
    		}

    		if (/*idHistoria*/ ctx[7] === undefined && !("idHistoria" in props)) {
    			console_1$a.warn("<OrdenesMedicas> was created without expected prop 'idHistoria'");
    		}

    		if (/*idPaciente*/ ctx[8] === undefined && !("idPaciente" in props)) {
    			console_1$a.warn("<OrdenesMedicas> was created without expected prop 'idPaciente'");
    		}

    		if (/*disabled*/ ctx[9] === undefined && !("disabled" in props)) {
    			console_1$a.warn("<OrdenesMedicas> was created without expected prop 'disabled'");
    		}
    	}

    	get instrucciones() {
    		throw new Error("<OrdenesMedicas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set instrucciones(value) {
    		throw new Error("<OrdenesMedicas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get medicamentos() {
    		throw new Error("<OrdenesMedicas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set medicamentos(value) {
    		throw new Error("<OrdenesMedicas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sltBuscarMedicamentos() {
    		throw new Error("<OrdenesMedicas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sltBuscarMedicamentos(value) {
    		throw new Error("<OrdenesMedicas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sltBuscarEstudios() {
    		throw new Error("<OrdenesMedicas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sltBuscarEstudios(value) {
    		throw new Error("<OrdenesMedicas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get medicamentosSeleccionados() {
    		throw new Error("<OrdenesMedicas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set medicamentosSeleccionados(value) {
    		throw new Error("<OrdenesMedicas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get estudios() {
    		throw new Error("<OrdenesMedicas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set estudios(value) {
    		throw new Error("<OrdenesMedicas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get estudiosSeleccionados() {
    		throw new Error("<OrdenesMedicas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set estudiosSeleccionados(value) {
    		throw new Error("<OrdenesMedicas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get idHistoria() {
    		throw new Error("<OrdenesMedicas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set idHistoria(value) {
    		throw new Error("<OrdenesMedicas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get idPaciente() {
    		throw new Error("<OrdenesMedicas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set idPaciente(value) {
    		throw new Error("<OrdenesMedicas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<OrdenesMedicas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<OrdenesMedicas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\componentes\SignosVitales.svelte generated by Svelte v3.29.0 */

    function create_fragment$o(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SignosVitales", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SignosVitales> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class SignosVitales extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SignosVitales",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* src\componentes\NoConexion.svelte generated by Svelte v3.29.0 */

    const file$n = "src\\componentes\\NoConexion.svelte";

    function create_fragment$p(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let t0;
    	let h3;
    	let t2;
    	let p;
    	let t4;
    	let button;
    	let i;
    	let t5;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			t0 = space();
    			h3 = element("h3");
    			h3.textContent = "Ocurri un error al comunicarnos con el servidor";
    			t2 = space();
    			p = element("p");
    			p.textContent = "Si el problema persiste, contacte al administrador. Disculpe los inconvenientes";
    			t4 = space();
    			button = element("button");
    			i = element("i");
    			t5 = text(" Recargar");
    			attr_dev(img, "class", "imagen-error svelte-1gsainp");
    			if (img.src !== (img_src_value = "./assets/img/error.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$n, 1, 4, 28);
    			attr_dev(h3, "class", "svelte-1gsainp");
    			add_location(h3, file$n, 2, 4, 96);
    			attr_dev(p, "class", "svelte-1gsainp");
    			add_location(p, file$n, 3, 4, 159);
    			attr_dev(i, "class", "mdi mdi-refresh");
    			add_location(i, file$n, 8, 8, 358);
    			attr_dev(button, "class", "btn btn-outline-primary");
    			add_location(button, file$n, 4, 4, 251);
    			attr_dev(div, "class", "cargando svelte-1gsainp");
    			add_location(div, file$n, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			append_dev(div, t0);
    			append_dev(div, h3);
    			append_dev(div, t2);
    			append_dev(div, p);
    			append_dev(div, t4);
    			append_dev(div, button);
    			append_dev(button, i);
    			append_dev(button, t5);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NoConexion", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NoConexion> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => location.reload();
    	return [click_handler];
    }

    class NoConexion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NoConexion",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* src\Pages\AtencionMedica\HistoriaClinica.svelte generated by Svelte v3.29.0 */

    const { console: console_1$b } = globals;
    const file$o = "src\\Pages\\AtencionMedica\\HistoriaClinica.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[116] = list[i];
    	child_ctx[117] = list;
    	child_ctx[118] = i;
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[119] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[116] = list[i];
    	child_ctx[122] = list;
    	child_ctx[123] = i;
    	return child_ctx;
    }

    function get_each_context_3$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[116] = list[i];
    	child_ctx[124] = list;
    	child_ctx[125] = i;
    	return child_ctx;
    }

    // (497:4) {#if errorServer}
    function create_if_block_19(ctx) {
    	let errorserver;
    	let current;

    	errorserver = new ErrorConexion({
    			props: {
    				msgError: "Ocurrio un error en la conexion con el servidor, vuelva a intentarlo o llame al administrador"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(errorserver.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorserver, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorserver.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorserver.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorserver, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19.name,
    		type: "if",
    		source: "(497:4) {#if errorServer}",
    		ctx
    	});

    	return block;
    }

    // (502:4) {#if serverConexion}
    function create_if_block_18(ctx) {
    	let noconexion;
    	let current;
    	noconexion = new NoConexion({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(noconexion.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(noconexion, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(noconexion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(noconexion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(noconexion, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18.name,
    		type: "if",
    		source: "(502:4) {#if serverConexion}",
    		ctx
    	});

    	return block;
    }

    // (505:4) {#if cargandoHistoria}
    function create_if_block_17(ctx) {
    	let div;
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loading.$$.fragment);
    			attr_dev(div, "class", "cargando svelte-ixmqjg");
    			add_location(div, file$o, 505, 8, 16830);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loading, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(505:4) {#if cargandoHistoria}",
    		ctx
    	});

    	return block;
    }

    // (524:16) {#if !cargando && !errorServer}
    function create_if_block_16(ctx) {
    	let div;
    	let i0;
    	let t0;
    	let i1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			i0 = element("i");
    			t0 = space();
    			i1 = element("i");
    			i1.textContent = "listo y guardado";
    			attr_dev(i0, "class", "mdi mdi-check-all");
    			add_location(i0, file$o, 525, 24, 17553);
    			add_location(i1, file$o, 525, 56, 17585);
    			attr_dev(div, "class", "guardando mr-2 text-success");
    			add_location(div, file$o, 524, 20, 17486);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i0);
    			append_dev(div, t0);
    			append_dev(div, i1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(524:16) {#if !cargando && !errorServer}",
    		ctx
    	});

    	return block;
    }

    // (529:16) {#if errorServer}
    function create_if_block_15(ctx) {
    	let div;
    	let i0;
    	let t0;
    	let i1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			i0 = element("i");
    			t0 = space();
    			i1 = element("i");
    			i1.textContent = "error al guardar";
    			attr_dev(i0, "class", "mdi mdi-close");
    			add_location(i0, file$o, 530, 24, 17782);
    			add_location(i1, file$o, 530, 52, 17810);
    			attr_dev(div, "class", "guardando mr-2 text-danger");
    			add_location(div, file$o, 529, 20, 17716);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i0);
    			append_dev(div, t0);
    			append_dev(div, i1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(529:16) {#if errorServer}",
    		ctx
    	});

    	return block;
    }

    // (534:16) {#if cargando && !errorServer}
    function create_if_block_14(ctx) {
    	let div;
    	let i;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			i = element("i");
    			t = text(" Guardando");
    			attr_dev(i, "class", "mdi mdi-cached mdi-spin");
    			add_location(i, file$o, 535, 24, 18023);
    			attr_dev(div, "class", "guardando mr-2 text-secondary");
    			add_location(div, file$o, 534, 20, 17954);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i);
    			append_dev(div, t);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(534:16) {#if cargando && !errorServer}",
    		ctx
    	});

    	return block;
    }

    // (541:8) {#if historia.estado === "A"}
    function create_if_block_13(ctx) {
    	let button;
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			attr_dev(i, "class", "mdi mdi-content-save-outline");
    			add_location(i, file$o, 547, 16, 18458);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn m-b-15 ml-2 mr-2 btn-lg btn-rounded-circle btn-success flotante svelte-ixmqjg");
    			attr_dev(button, "data-tooltip", "Guardar");
    			add_location(button, file$o, 541, 12, 18210);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*guardarHistoria*/ ctx[41], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(541:8) {#if historia.estado === \\\"A\\\"}",
    		ctx
    	});

    	return block;
    }

    // (562:16) {#if user().roles.includes("admin")}
    function create_if_block_10(ctx) {
    	let t;
    	let if_block1_anchor;
    	let if_block0 = /*historia*/ ctx[7].estado === "C" && create_if_block_12(ctx);
    	let if_block1 = /*historia*/ ctx[7].estado === "A" && create_if_block_11(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*historia*/ ctx[7].estado === "C") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_12(ctx);
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*historia*/ ctx[7].estado === "A") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_11(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(562:16) {#if user().roles.includes(\\\"admin\\\")}",
    		ctx
    	});

    	return block;
    }

    // (563:20) {#if historia.estado === "C"}
    function create_if_block_12(ctx) {
    	let button;
    	let i;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t = text("\r\n                            Abrir Historia");
    			attr_dev(i, "class", "mdi mdi-playlist-plus");
    			add_location(i, file$o, 568, 28, 19469);
    			set_style(button, "box-shadow", "none");
    			attr_dev(button, "class", "btn btn-outline-danger btn-sm");
    			add_location(button, file$o, 563, 24, 19205);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[43], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(563:20) {#if historia.estado === \\\"C\\\"}",
    		ctx
    	});

    	return block;
    }

    // (573:20) {#if historia.estado === "A"}
    function create_if_block_11(ctx) {
    	let button;
    	let i;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t = text("\r\n                            Cerrar Historia");
    			attr_dev(i, "class", "mdi mdi-playlist-remove");
    			add_location(i, file$o, 578, 28, 19945);
    			set_style(button, "box-shadow", "none");
    			attr_dev(button, "class", "btn btn-success btn-sm");
    			add_location(button, file$o, 573, 24, 19687);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[44], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(573:20) {#if historia.estado === \\\"A\\\"}",
    		ctx
    	});

    	return block;
    }

    // (645:16) {#if historia.estado === "A"}
    function create_if_block_9(ctx) {
    	let button;
    	let i;
    	let t0;
    	let sapn;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = space();
    			sapn = element("sapn");
    			sapn.textContent = "Anular";
    			attr_dev(i, "data-bind", "class: icon");
    			attr_dev(i, "class", "mdi mdi-delete");
    			add_location(i, file$o, 650, 24, 23181);
    			attr_dev(sapn, "data-bind", "text: text");
    			add_location(sapn, file$o, 651, 24, 23259);
    			set_style(button, "box-shadow", "none");
    			attr_dev(button, "class", "btn btn-danger btn-sm");
    			add_location(button, file$o, 645, 20, 22942);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);
    			append_dev(button, t0);
    			append_dev(button, sapn);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_3*/ ctx[46], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(645:16) {#if historia.estado === \\\"A\\\"}",
    		ctx
    	});

    	return block;
    }

    // (701:12) {#if empresa.historiaGinecologica}
    function create_if_block_8(ctx) {
    	let div37;
    	let div1;
    	let div0;
    	let t1;
    	let div36;
    	let div18;
    	let div3;
    	let div2;
    	let label0;
    	let t3;
    	let input0;
    	let t4;
    	let div5;
    	let div4;
    	let label1;
    	let t6;
    	let input1;
    	let t7;
    	let div7;
    	let div6;
    	let label2;
    	let t9;
    	let input2;
    	let t10;
    	let div9;
    	let div8;
    	let label3;
    	let t12;
    	let input3;
    	let t13;
    	let div11;
    	let div10;
    	let label4;
    	let t15;
    	let input4;
    	let t16;
    	let div13;
    	let div12;
    	let label5;
    	let t18;
    	let input5;
    	let t19;
    	let div15;
    	let div14;
    	let label6;
    	let t21;
    	let input6;
    	let t22;
    	let div17;
    	let div16;
    	let label7;
    	let t24;
    	let input7;
    	let t25;
    	let hr0;
    	let t26;
    	let div33;
    	let div20;
    	let div19;
    	let label8;
    	let t28;
    	let input8;
    	let t29;
    	let div22;
    	let div21;
    	let label9;
    	let t31;
    	let input9;
    	let t32;
    	let div24;
    	let div23;
    	let label10;
    	let t34;
    	let input10;
    	let t35;
    	let div26;
    	let div25;
    	let label11;
    	let t37;
    	let input11;
    	let t38;
    	let div28;
    	let div27;
    	let label12;
    	let t40;
    	let input12;
    	let t41;
    	let div30;
    	let div29;
    	let label13;
    	let t43;
    	let input13;
    	let t44;
    	let div32;
    	let div31;
    	let label14;
    	let t46;
    	let input14;
    	let t47;
    	let h5;
    	let t49;
    	let hr1;
    	let t50;
    	let div35;
    	let div34;
    	let label15;
    	let input15;
    	let t51;
    	let span0;
    	let t52;
    	let span1;
    	let t54;
    	let label16;
    	let input16;
    	let t55;
    	let span2;
    	let t56;
    	let span3;
    	let t58;
    	let label17;
    	let input17;
    	let t59;
    	let span4;
    	let t60;
    	let span5;
    	let t62;
    	let label18;
    	let input18;
    	let t63;
    	let span6;
    	let t64;
    	let span7;
    	let t66;
    	let label19;
    	let input19;
    	let t67;
    	let span8;
    	let t68;
    	let span9;
    	let t70;
    	let label20;
    	let input20;
    	let t71;
    	let span10;
    	let t72;
    	let span11;
    	let t74;
    	let label21;
    	let input21;
    	let t75;
    	let span12;
    	let t76;
    	let span13;
    	let t78;
    	let label22;
    	let input22;
    	let t79;
    	let span14;
    	let t80;
    	let span15;
    	let t82;
    	let label23;
    	let input23;
    	let t83;
    	let span16;
    	let t84;
    	let span17;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div37 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Historia Ginecologica";
    			t1 = space();
    			div36 = element("div");
    			div18 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			label0 = element("label");
    			label0.textContent = "Fecha ultima menstruacin";
    			t3 = space();
    			input0 = element("input");
    			t4 = space();
    			div5 = element("div");
    			div4 = element("div");
    			label1 = element("label");
    			label1.textContent = "Fecha ultimo pap";
    			t6 = space();
    			input1 = element("input");
    			t7 = space();
    			div7 = element("div");
    			div6 = element("div");
    			label2 = element("label");
    			label2.textContent = "Fecha ultimo parto";
    			t9 = space();
    			input2 = element("input");
    			t10 = space();
    			div9 = element("div");
    			div8 = element("div");
    			label3 = element("label");
    			label3.textContent = "Fecha ultimo aborto";
    			t12 = space();
    			input3 = element("input");
    			t13 = space();
    			div11 = element("div");
    			div10 = element("div");
    			label4 = element("label");
    			label4.textContent = "Fecha ultima cesrea";
    			t15 = space();
    			input4 = element("input");
    			t16 = space();
    			div13 = element("div");
    			div12 = element("div");
    			label5 = element("label");
    			label5.textContent = "Intervalo flujo menstrual";
    			t18 = space();
    			input5 = element("input");
    			t19 = space();
    			div15 = element("div");
    			div14 = element("div");
    			label6 = element("label");
    			label6.textContent = "Cantidad flujo menstrual";
    			t21 = space();
    			input6 = element("input");
    			t22 = space();
    			div17 = element("div");
    			div16 = element("div");
    			label7 = element("label");
    			label7.textContent = "Duracion flujo menstrual";
    			t24 = space();
    			input7 = element("input");
    			t25 = space();
    			hr0 = element("hr");
    			t26 = space();
    			div33 = element("div");
    			div20 = element("div");
    			div19 = element("div");
    			label8 = element("label");
    			label8.textContent = "Gesta";
    			t28 = space();
    			input8 = element("input");
    			t29 = space();
    			div22 = element("div");
    			div21 = element("div");
    			label9 = element("label");
    			label9.textContent = "Para";
    			t31 = space();
    			input9 = element("input");
    			t32 = space();
    			div24 = element("div");
    			div23 = element("div");
    			label10 = element("label");
    			label10.textContent = "Abortos";
    			t34 = space();
    			input10 = element("input");
    			t35 = space();
    			div26 = element("div");
    			div25 = element("div");
    			label11 = element("label");
    			label11.textContent = "Cesreas";
    			t37 = space();
    			input11 = element("input");
    			t38 = space();
    			div28 = element("div");
    			div27 = element("div");
    			label12 = element("label");
    			label12.textContent = "Espontneos";
    			t40 = space();
    			input12 = element("input");
    			t41 = space();
    			div30 = element("div");
    			div29 = element("div");
    			label13 = element("label");
    			label13.textContent = "Provocados";
    			t43 = space();
    			input13 = element("input");
    			t44 = space();
    			div32 = element("div");
    			div31 = element("div");
    			label14 = element("label");
    			label14.textContent = "Legrados";
    			t46 = space();
    			input14 = element("input");
    			t47 = space();
    			h5 = element("h5");
    			h5.textContent = "Planificacin";
    			t49 = space();
    			hr1 = element("hr");
    			t50 = space();
    			div35 = element("div");
    			div34 = element("div");
    			label15 = element("label");
    			input15 = element("input");
    			t51 = space();
    			span0 = element("span");
    			t52 = space();
    			span1 = element("span");
    			span1.textContent = "Sangrado Vaginal";
    			t54 = space();
    			label16 = element("label");
    			input16 = element("input");
    			t55 = space();
    			span2 = element("span");
    			t56 = space();
    			span3 = element("span");
    			span3.textContent = "Vida Sexual Activa";
    			t58 = space();
    			label17 = element("label");
    			input17 = element("input");
    			t59 = space();
    			span4 = element("span");
    			t60 = space();
    			span5 = element("span");
    			span5.textContent = "Anticonceptivos Orales";
    			t62 = space();
    			label18 = element("label");
    			input18 = element("input");
    			t63 = space();
    			span6 = element("span");
    			t64 = space();
    			span7 = element("span");
    			span7.textContent = "DIU";
    			t66 = space();
    			label19 = element("label");
    			input19 = element("input");
    			t67 = space();
    			span8 = element("span");
    			t68 = space();
    			span9 = element("span");
    			span9.textContent = "AQV";
    			t70 = space();
    			label20 = element("label");
    			input20 = element("input");
    			t71 = space();
    			span10 = element("span");
    			t72 = space();
    			span11 = element("span");
    			span11.textContent = "Condn";
    			t74 = space();
    			label21 = element("label");
    			input21 = element("input");
    			t75 = space();
    			span12 = element("span");
    			t76 = space();
    			span13 = element("span");
    			span13.textContent = "Norplant";
    			t78 = space();
    			label22 = element("label");
    			input22 = element("input");
    			t79 = space();
    			span14 = element("span");
    			t80 = space();
    			span15 = element("span");
    			span15.textContent = "Ritmo";
    			t82 = space();
    			label23 = element("label");
    			input23 = element("input");
    			t83 = space();
    			span16 = element("span");
    			t84 = space();
    			span17 = element("span");
    			span17.textContent = "Coito Interruptus";
    			attr_dev(div0, "class", "card-title text-primary");
    			add_location(div0, file$o, 704, 24, 25385);
    			attr_dev(div1, "class", "card-header");
    			add_location(div1, file$o, 703, 20, 25334);
    			attr_dev(label0, "for", "");
    			add_location(label0, file$o, 712, 36, 25769);
    			input0.disabled = /*disabled*/ ctx[26];
    			attr_dev(input0, "type", "date");
    			attr_dev(input0, "class", "form-control");
    			add_location(input0, file$o, 715, 36, 25941);
    			attr_dev(div2, "class", "form-group");
    			add_location(div2, file$o, 711, 32, 25707);
    			attr_dev(div3, "class", "col-lg-3");
    			add_location(div3, file$o, 710, 28, 25651);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$o, 726, 36, 26544);
    			input1.disabled = /*disabled*/ ctx[26];
    			attr_dev(input1, "type", "date");
    			attr_dev(input1, "class", "form-control");
    			add_location(input1, file$o, 727, 36, 26620);
    			attr_dev(div4, "class", "form-group");
    			add_location(div4, file$o, 725, 32, 26482);
    			attr_dev(div5, "class", "col-lg-3");
    			add_location(div5, file$o, 724, 28, 26426);
    			attr_dev(label2, "for", "");
    			add_location(label2, file$o, 738, 36, 27214);
    			input2.disabled = /*disabled*/ ctx[26];
    			attr_dev(input2, "type", "date");
    			attr_dev(input2, "class", "form-control");
    			add_location(input2, file$o, 739, 36, 27292);
    			attr_dev(div6, "class", "form-group");
    			add_location(div6, file$o, 737, 32, 27152);
    			attr_dev(div7, "class", "col-lg-3");
    			add_location(div7, file$o, 736, 28, 27096);
    			attr_dev(label3, "for", "");
    			add_location(label3, file$o, 750, 36, 27888);
    			input3.disabled = /*disabled*/ ctx[26];
    			attr_dev(input3, "type", "date");
    			attr_dev(input3, "class", "form-control");
    			add_location(input3, file$o, 751, 36, 27967);
    			attr_dev(div8, "class", "form-group");
    			add_location(div8, file$o, 749, 32, 27826);
    			attr_dev(div9, "class", "col-lg-3");
    			add_location(div9, file$o, 748, 28, 27770);
    			attr_dev(label4, "for", "");
    			add_location(label4, file$o, 762, 36, 28564);
    			input4.disabled = /*disabled*/ ctx[26];
    			attr_dev(input4, "type", "date");
    			attr_dev(input4, "class", "form-control");
    			add_location(input4, file$o, 765, 36, 28731);
    			attr_dev(div10, "class", "form-group");
    			add_location(div10, file$o, 761, 32, 28502);
    			attr_dev(div11, "class", "col-lg-3");
    			add_location(div11, file$o, 760, 28, 28446);
    			attr_dev(label5, "for", "");
    			add_location(label5, file$o, 776, 36, 29329);
    			input5.disabled = /*disabled*/ ctx[26];
    			attr_dev(input5, "type", "number");
    			attr_dev(input5, "class", "form-control");
    			attr_dev(input5, "placeholder", "Dias");
    			add_location(input5, file$o, 779, 36, 29494);
    			attr_dev(div12, "class", "form-group");
    			add_location(div12, file$o, 775, 32, 29267);
    			attr_dev(div13, "class", "col-lg-3");
    			add_location(div13, file$o, 774, 28, 29211);
    			attr_dev(label6, "for", "");
    			add_location(label6, file$o, 791, 36, 30159);
    			input6.disabled = /*disabled*/ ctx[26];
    			attr_dev(input6, "type", "number");
    			attr_dev(input6, "class", "form-control");
    			attr_dev(input6, "placeholder", "Dias");
    			add_location(input6, file$o, 794, 36, 30323);
    			attr_dev(div14, "class", "form-group");
    			add_location(div14, file$o, 790, 32, 30097);
    			attr_dev(div15, "class", "col-lg-3");
    			add_location(div15, file$o, 789, 28, 30041);
    			attr_dev(label7, "for", "");
    			add_location(label7, file$o, 806, 36, 30987);
    			input7.disabled = /*disabled*/ ctx[26];
    			attr_dev(input7, "type", "number");
    			attr_dev(input7, "class", "form-control");
    			attr_dev(input7, "placeholder", "Dias");
    			add_location(input7, file$o, 809, 36, 31151);
    			attr_dev(div16, "class", "form-group");
    			add_location(div16, file$o, 805, 32, 30925);
    			attr_dev(div17, "class", "col-lg-3");
    			add_location(div17, file$o, 804, 28, 30869);
    			attr_dev(div18, "class", "row");
    			add_location(div18, file$o, 709, 24, 25604);
    			add_location(hr0, file$o, 820, 24, 31725);
    			attr_dev(label8, "for", "");
    			add_location(label8, file$o, 824, 36, 31917);
    			input8.disabled = /*disabled*/ ctx[26];
    			attr_dev(input8, "type", "number");
    			attr_dev(input8, "class", "form-control");
    			add_location(input8, file$o, 825, 36, 31982);
    			attr_dev(div19, "class", "form-group");
    			add_location(div19, file$o, 823, 32, 31855);
    			attr_dev(div20, "class", "col");
    			add_location(div20, file$o, 822, 28, 31804);
    			attr_dev(label9, "for", "");
    			add_location(label9, file$o, 836, 36, 32564);
    			input9.disabled = /*disabled*/ ctx[26];
    			attr_dev(input9, "type", "number");
    			attr_dev(input9, "class", "form-control");
    			add_location(input9, file$o, 837, 36, 32628);
    			attr_dev(div21, "class", "form-group");
    			add_location(div21, file$o, 835, 32, 32502);
    			attr_dev(div22, "class", "col");
    			add_location(div22, file$o, 834, 28, 32451);
    			attr_dev(label10, "for", "");
    			add_location(label10, file$o, 848, 36, 33209);
    			input10.disabled = /*disabled*/ ctx[26];
    			attr_dev(input10, "type", "number");
    			attr_dev(input10, "class", "form-control");
    			add_location(input10, file$o, 849, 36, 33276);
    			attr_dev(div23, "class", "form-group");
    			add_location(div23, file$o, 847, 32, 33147);
    			attr_dev(div24, "class", "col");
    			add_location(div24, file$o, 846, 28, 33096);
    			attr_dev(label11, "for", "");
    			add_location(label11, file$o, 860, 36, 33860);
    			input11.disabled = /*disabled*/ ctx[26];
    			attr_dev(input11, "type", "number");
    			attr_dev(input11, "class", "form-control");
    			add_location(input11, file$o, 861, 36, 33935);
    			attr_dev(div25, "class", "form-group");
    			add_location(div25, file$o, 859, 32, 33798);
    			attr_dev(div26, "class", "col");
    			add_location(div26, file$o, 858, 28, 33747);
    			attr_dev(label12, "for", "");
    			add_location(label12, file$o, 872, 36, 34520);
    			input12.disabled = /*disabled*/ ctx[26];
    			attr_dev(input12, "type", "number");
    			attr_dev(input12, "class", "form-control");
    			add_location(input12, file$o, 873, 36, 34598);
    			attr_dev(div27, "class", "form-group");
    			add_location(div27, file$o, 871, 32, 34458);
    			attr_dev(div28, "class", "col");
    			add_location(div28, file$o, 870, 28, 34407);
    			attr_dev(label13, "for", "");
    			add_location(label13, file$o, 884, 36, 35186);
    			input13.disabled = /*disabled*/ ctx[26];
    			attr_dev(input13, "type", "number");
    			attr_dev(input13, "class", "form-control");
    			add_location(input13, file$o, 885, 36, 35256);
    			attr_dev(div29, "class", "form-group");
    			add_location(div29, file$o, 883, 32, 35124);
    			attr_dev(div30, "class", "col");
    			add_location(div30, file$o, 882, 28, 35073);
    			attr_dev(label14, "for", "");
    			add_location(label14, file$o, 896, 36, 35843);
    			input14.disabled = /*disabled*/ ctx[26];
    			attr_dev(input14, "type", "number");
    			attr_dev(input14, "class", "form-control");
    			add_location(input14, file$o, 897, 36, 35911);
    			attr_dev(div31, "class", "form-group");
    			add_location(div31, file$o, 895, 32, 35781);
    			attr_dev(div32, "class", "col");
    			add_location(div32, file$o, 894, 28, 35730);
    			attr_dev(div33, "class", "row");
    			add_location(div33, file$o, 821, 24, 31757);
    			attr_dev(h5, "class", "mt-3");
    			add_location(h5, file$o, 907, 24, 36411);
    			add_location(hr1, file$o, 908, 24, 36479);
    			input15.disabled = /*disabled*/ ctx[26];
    			attr_dev(input15, "type", "checkbox");
    			attr_dev(input15, "name", "option");
    			input15.__value = "1";
    			input15.value = input15.__value;
    			attr_dev(input15, "class", "cstm-switch-input");
    			add_location(input15, file$o, 912, 36, 36690);
    			attr_dev(span0, "class", "cstm-switch-indicator bg-success ");
    			add_location(span0, file$o, 921, 36, 37218);
    			attr_dev(span1, "class", "cstm-switch-description");
    			add_location(span1, file$o, 924, 36, 37384);
    			attr_dev(label15, "class", "cstm-switch mr-4 mb-4");
    			add_location(label15, file$o, 911, 32, 36615);
    			input16.disabled = /*disabled*/ ctx[26];
    			attr_dev(input16, "type", "checkbox");
    			attr_dev(input16, "name", "option");
    			input16.__value = "1";
    			input16.value = input16.__value;
    			attr_dev(input16, "class", "cstm-switch-input");
    			add_location(input16, file$o, 929, 36, 37676);
    			attr_dev(span2, "class", "cstm-switch-indicator bg-success ");
    			add_location(span2, file$o, 938, 36, 38205);
    			attr_dev(span3, "class", "cstm-switch-description");
    			add_location(span3, file$o, 941, 36, 38371);
    			attr_dev(label16, "class", "cstm-switch mr-4 mb-4");
    			add_location(label16, file$o, 928, 32, 37601);
    			input17.disabled = /*disabled*/ ctx[26];
    			attr_dev(input17, "type", "checkbox");
    			attr_dev(input17, "name", "option");
    			input17.__value = "1";
    			input17.value = input17.__value;
    			attr_dev(input17, "class", "cstm-switch-input");
    			add_location(input17, file$o, 946, 36, 38665);
    			attr_dev(span4, "class", "cstm-switch-indicator bg-success ");
    			add_location(span4, file$o, 955, 36, 39199);
    			attr_dev(span5, "class", "cstm-switch-description");
    			add_location(span5, file$o, 958, 36, 39365);
    			attr_dev(label17, "class", "cstm-switch mr-4 mb-4");
    			add_location(label17, file$o, 945, 32, 38590);
    			input18.disabled = /*disabled*/ ctx[26];
    			attr_dev(input18, "type", "checkbox");
    			attr_dev(input18, "name", "option");
    			input18.__value = "1";
    			input18.value = input18.__value;
    			attr_dev(input18, "class", "cstm-switch-input");
    			add_location(input18, file$o, 963, 36, 39663);
    			attr_dev(span6, "class", "cstm-switch-indicator bg-success ");
    			add_location(span6, file$o, 972, 36, 40179);
    			attr_dev(span7, "class", "cstm-switch-description");
    			add_location(span7, file$o, 975, 36, 40345);
    			attr_dev(label18, "class", "cstm-switch mr-4 mb-4");
    			add_location(label18, file$o, 962, 32, 39588);
    			input19.disabled = /*disabled*/ ctx[26];
    			attr_dev(input19, "type", "checkbox");
    			attr_dev(input19, "name", "option");
    			input19.__value = "1";
    			input19.value = input19.__value;
    			attr_dev(input19, "class", "cstm-switch-input");
    			add_location(input19, file$o, 980, 36, 40624);
    			attr_dev(span8, "class", "cstm-switch-indicator bg-success ");
    			add_location(span8, file$o, 989, 36, 41140);
    			attr_dev(span9, "class", "cstm-switch-description");
    			add_location(span9, file$o, 992, 36, 41306);
    			attr_dev(label19, "class", "cstm-switch mr-4 mb-4");
    			add_location(label19, file$o, 979, 32, 40549);
    			input20.disabled = /*disabled*/ ctx[26];
    			attr_dev(input20, "type", "checkbox");
    			attr_dev(input20, "name", "option");
    			input20.__value = "1";
    			input20.value = input20.__value;
    			attr_dev(input20, "class", "cstm-switch-input");
    			add_location(input20, file$o, 997, 36, 41585);
    			attr_dev(span10, "class", "cstm-switch-indicator bg-success ");
    			add_location(span10, file$o, 1006, 36, 42104);
    			attr_dev(span11, "class", "cstm-switch-description");
    			add_location(span11, file$o, 1009, 36, 42270);
    			attr_dev(label20, "class", "cstm-switch mr-4 mb-4");
    			add_location(label20, file$o, 996, 32, 41510);
    			input21.disabled = /*disabled*/ ctx[26];
    			attr_dev(input21, "type", "checkbox");
    			attr_dev(input21, "name", "option");
    			input21.__value = "1";
    			input21.value = input21.__value;
    			attr_dev(input21, "class", "cstm-switch-input");
    			add_location(input21, file$o, 1014, 36, 42559);
    			attr_dev(span12, "class", "cstm-switch-indicator bg-success ");
    			add_location(span12, file$o, 1023, 36, 43080);
    			attr_dev(span13, "class", "cstm-switch-description");
    			add_location(span13, file$o, 1026, 36, 43246);
    			attr_dev(label21, "class", "cstm-switch mr-4 mb-4");
    			add_location(label21, file$o, 1013, 32, 42484);
    			input22.disabled = /*disabled*/ ctx[26];
    			attr_dev(input22, "type", "checkbox");
    			attr_dev(input22, "name", "option");
    			input22.__value = "1";
    			input22.value = input22.__value;
    			attr_dev(input22, "class", "cstm-switch-input");
    			add_location(input22, file$o, 1031, 36, 43530);
    			attr_dev(span14, "class", "cstm-switch-indicator bg-success ");
    			add_location(span14, file$o, 1040, 36, 44048);
    			attr_dev(span15, "class", "cstm-switch-description");
    			add_location(span15, file$o, 1043, 36, 44214);
    			attr_dev(label22, "class", "cstm-switch mr-4 mb-4");
    			add_location(label22, file$o, 1030, 32, 43455);
    			input23.disabled = /*disabled*/ ctx[26];
    			attr_dev(input23, "type", "checkbox");
    			attr_dev(input23, "name", "option");
    			input23.__value = "1";
    			input23.value = input23.__value;
    			attr_dev(input23, "class", "cstm-switch-input");
    			add_location(input23, file$o, 1048, 36, 44495);
    			attr_dev(span16, "class", "cstm-switch-indicator bg-success ");
    			add_location(span16, file$o, 1057, 36, 45024);
    			attr_dev(span17, "class", "cstm-switch-description");
    			add_location(span17, file$o, 1060, 36, 45190);
    			attr_dev(label23, "class", "cstm-switch mr-4 mb-4");
    			add_location(label23, file$o, 1047, 32, 44420);
    			attr_dev(div34, "class", "col-lg-12");
    			add_location(div34, file$o, 910, 28, 36558);
    			attr_dev(div35, "class", "row");
    			add_location(div35, file$o, 909, 24, 36511);
    			attr_dev(div36, "class", "card-body");
    			add_location(div36, file$o, 708, 20, 25555);
    			attr_dev(div37, "class", "card m-b-20 border border-primary");
    			add_location(div37, file$o, 702, 16, 25265);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div37, anchor);
    			append_dev(div37, div1);
    			append_dev(div1, div0);
    			append_dev(div37, t1);
    			append_dev(div37, div36);
    			append_dev(div36, div18);
    			append_dev(div18, div3);
    			append_dev(div3, div2);
    			append_dev(div2, label0);
    			append_dev(div2, t3);
    			append_dev(div2, input0);
    			set_input_value(input0, /*historiaGinecologica*/ ctx[19].fechaUltimaMenstruacion);
    			append_dev(div18, t4);
    			append_dev(div18, div5);
    			append_dev(div5, div4);
    			append_dev(div4, label1);
    			append_dev(div4, t6);
    			append_dev(div4, input1);
    			set_input_value(input1, /*historiaGinecologica*/ ctx[19].fechaUltimoPap);
    			append_dev(div18, t7);
    			append_dev(div18, div7);
    			append_dev(div7, div6);
    			append_dev(div6, label2);
    			append_dev(div6, t9);
    			append_dev(div6, input2);
    			set_input_value(input2, /*historiaGinecologica*/ ctx[19].fechaUltimoParto);
    			append_dev(div18, t10);
    			append_dev(div18, div9);
    			append_dev(div9, div8);
    			append_dev(div8, label3);
    			append_dev(div8, t12);
    			append_dev(div8, input3);
    			set_input_value(input3, /*historiaGinecologica*/ ctx[19].fechaUltimoAborto);
    			append_dev(div18, t13);
    			append_dev(div18, div11);
    			append_dev(div11, div10);
    			append_dev(div10, label4);
    			append_dev(div10, t15);
    			append_dev(div10, input4);
    			set_input_value(input4, /*historiaGinecologica*/ ctx[19].fechaUltimoCesarea);
    			append_dev(div18, t16);
    			append_dev(div18, div13);
    			append_dev(div13, div12);
    			append_dev(div12, label5);
    			append_dev(div12, t18);
    			append_dev(div12, input5);
    			set_input_value(input5, /*historiaGinecologica*/ ctx[19].intervaloFlujoMenstrual);
    			append_dev(div18, t19);
    			append_dev(div18, div15);
    			append_dev(div15, div14);
    			append_dev(div14, label6);
    			append_dev(div14, t21);
    			append_dev(div14, input6);
    			set_input_value(input6, /*historiaGinecologica*/ ctx[19].cantidadFlujoMenstrual);
    			append_dev(div18, t22);
    			append_dev(div18, div17);
    			append_dev(div17, div16);
    			append_dev(div16, label7);
    			append_dev(div16, t24);
    			append_dev(div16, input7);
    			set_input_value(input7, /*historiaGinecologica*/ ctx[19].duracionFlujoMenstrual);
    			append_dev(div36, t25);
    			append_dev(div36, hr0);
    			append_dev(div36, t26);
    			append_dev(div36, div33);
    			append_dev(div33, div20);
    			append_dev(div20, div19);
    			append_dev(div19, label8);
    			append_dev(div19, t28);
    			append_dev(div19, input8);
    			set_input_value(input8, /*historiaGinecologica*/ ctx[19].gesta);
    			append_dev(div33, t29);
    			append_dev(div33, div22);
    			append_dev(div22, div21);
    			append_dev(div21, label9);
    			append_dev(div21, t31);
    			append_dev(div21, input9);
    			set_input_value(input9, /*historiaGinecologica*/ ctx[19].para);
    			append_dev(div33, t32);
    			append_dev(div33, div24);
    			append_dev(div24, div23);
    			append_dev(div23, label10);
    			append_dev(div23, t34);
    			append_dev(div23, input10);
    			set_input_value(input10, /*historiaGinecologica*/ ctx[19].abortos);
    			append_dev(div33, t35);
    			append_dev(div33, div26);
    			append_dev(div26, div25);
    			append_dev(div25, label11);
    			append_dev(div25, t37);
    			append_dev(div25, input11);
    			set_input_value(input11, /*historiaGinecologica*/ ctx[19].cesareas);
    			append_dev(div33, t38);
    			append_dev(div33, div28);
    			append_dev(div28, div27);
    			append_dev(div27, label12);
    			append_dev(div27, t40);
    			append_dev(div27, input12);
    			set_input_value(input12, /*historiaGinecologica*/ ctx[19].espontaneos);
    			append_dev(div33, t41);
    			append_dev(div33, div30);
    			append_dev(div30, div29);
    			append_dev(div29, label13);
    			append_dev(div29, t43);
    			append_dev(div29, input13);
    			set_input_value(input13, /*historiaGinecologica*/ ctx[19].provocados);
    			append_dev(div33, t44);
    			append_dev(div33, div32);
    			append_dev(div32, div31);
    			append_dev(div31, label14);
    			append_dev(div31, t46);
    			append_dev(div31, input14);
    			set_input_value(input14, /*historiaGinecologica*/ ctx[19].legrados);
    			append_dev(div36, t47);
    			append_dev(div36, h5);
    			append_dev(div36, t49);
    			append_dev(div36, hr1);
    			append_dev(div36, t50);
    			append_dev(div36, div35);
    			append_dev(div35, div34);
    			append_dev(div34, label15);
    			append_dev(label15, input15);
    			input15.checked = /*historiaGinecologica*/ ctx[19].sangradoVaginal;
    			append_dev(label15, t51);
    			append_dev(label15, span0);
    			append_dev(label15, t52);
    			append_dev(label15, span1);
    			append_dev(div34, t54);
    			append_dev(div34, label16);
    			append_dev(label16, input16);
    			input16.checked = /*historiaGinecologica*/ ctx[19].vidaSexualActiva;
    			append_dev(label16, t55);
    			append_dev(label16, span2);
    			append_dev(label16, t56);
    			append_dev(label16, span3);
    			append_dev(div34, t58);
    			append_dev(div34, label17);
    			append_dev(label17, input17);
    			input17.checked = /*historiaGinecologica*/ ctx[19].anticonceptivosOrales;
    			append_dev(label17, t59);
    			append_dev(label17, span4);
    			append_dev(label17, t60);
    			append_dev(label17, span5);
    			append_dev(div34, t62);
    			append_dev(div34, label18);
    			append_dev(label18, input18);
    			input18.checked = /*historiaGinecologica*/ ctx[19].diu;
    			append_dev(label18, t63);
    			append_dev(label18, span6);
    			append_dev(label18, t64);
    			append_dev(label18, span7);
    			append_dev(div34, t66);
    			append_dev(div34, label19);
    			append_dev(label19, input19);
    			input19.checked = /*historiaGinecologica*/ ctx[19].aqv;
    			append_dev(label19, t67);
    			append_dev(label19, span8);
    			append_dev(label19, t68);
    			append_dev(label19, span9);
    			append_dev(div34, t70);
    			append_dev(div34, label20);
    			append_dev(label20, input20);
    			input20.checked = /*historiaGinecologica*/ ctx[19].condon;
    			append_dev(label20, t71);
    			append_dev(label20, span10);
    			append_dev(label20, t72);
    			append_dev(label20, span11);
    			append_dev(div34, t74);
    			append_dev(div34, label21);
    			append_dev(label21, input21);
    			input21.checked = /*historiaGinecologica*/ ctx[19].norplant;
    			append_dev(label21, t75);
    			append_dev(label21, span12);
    			append_dev(label21, t76);
    			append_dev(label21, span13);
    			append_dev(div34, t78);
    			append_dev(div34, label22);
    			append_dev(label22, input22);
    			input22.checked = /*historiaGinecologica*/ ctx[19].ritmo;
    			append_dev(label22, t79);
    			append_dev(label22, span14);
    			append_dev(label22, t80);
    			append_dev(label22, span15);
    			append_dev(div34, t82);
    			append_dev(div34, label23);
    			append_dev(label23, input23);
    			input23.checked = /*historiaGinecologica*/ ctx[19].coitoInterruptus;
    			append_dev(label23, t83);
    			append_dev(label23, span16);
    			append_dev(label23, t84);
    			append_dev(label23, span17);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[49]),
    					listen_dev(input1, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[50]),
    					listen_dev(input2, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[51]),
    					listen_dev(input3, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[52]),
    					listen_dev(input4, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[53]),
    					listen_dev(input5, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[54]),
    					listen_dev(input6, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[55]),
    					listen_dev(input7, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input7, "input", /*input7_input_handler*/ ctx[56]),
    					listen_dev(input8, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input8, "input", /*input8_input_handler*/ ctx[57]),
    					listen_dev(input9, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input9, "input", /*input9_input_handler*/ ctx[58]),
    					listen_dev(input10, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input10, "input", /*input10_input_handler*/ ctx[59]),
    					listen_dev(input11, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input11, "input", /*input11_input_handler*/ ctx[60]),
    					listen_dev(input12, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input12, "input", /*input12_input_handler*/ ctx[61]),
    					listen_dev(input13, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input13, "input", /*input13_input_handler*/ ctx[62]),
    					listen_dev(input14, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input14, "input", /*input14_input_handler*/ ctx[63]),
    					listen_dev(input15, "change", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input15, "change", /*input15_change_handler*/ ctx[64]),
    					listen_dev(input16, "change", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input16, "change", /*input16_change_handler*/ ctx[65]),
    					listen_dev(input17, "change", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input17, "change", /*input17_change_handler*/ ctx[66]),
    					listen_dev(input18, "change", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input18, "change", /*input18_change_handler*/ ctx[67]),
    					listen_dev(input19, "change", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input19, "change", /*input19_change_handler*/ ctx[68]),
    					listen_dev(input20, "change", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input20, "change", /*input20_change_handler*/ ctx[69]),
    					listen_dev(input21, "change", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input21, "change", /*input21_change_handler*/ ctx[70]),
    					listen_dev(input22, "change", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input22, "change", /*input22_change_handler*/ ctx[71]),
    					listen_dev(input23, "change", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input23, "change", /*input23_change_handler*/ ctx[72])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input0, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				set_input_value(input0, /*historiaGinecologica*/ ctx[19].fechaUltimaMenstruacion);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input1, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				set_input_value(input1, /*historiaGinecologica*/ ctx[19].fechaUltimoPap);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input2, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				set_input_value(input2, /*historiaGinecologica*/ ctx[19].fechaUltimoParto);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input3, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				set_input_value(input3, /*historiaGinecologica*/ ctx[19].fechaUltimoAborto);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input4, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				set_input_value(input4, /*historiaGinecologica*/ ctx[19].fechaUltimoCesarea);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input5, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288 && to_number(input5.value) !== /*historiaGinecologica*/ ctx[19].intervaloFlujoMenstrual) {
    				set_input_value(input5, /*historiaGinecologica*/ ctx[19].intervaloFlujoMenstrual);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input6, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288 && to_number(input6.value) !== /*historiaGinecologica*/ ctx[19].cantidadFlujoMenstrual) {
    				set_input_value(input6, /*historiaGinecologica*/ ctx[19].cantidadFlujoMenstrual);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input7, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288 && to_number(input7.value) !== /*historiaGinecologica*/ ctx[19].duracionFlujoMenstrual) {
    				set_input_value(input7, /*historiaGinecologica*/ ctx[19].duracionFlujoMenstrual);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input8, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288 && to_number(input8.value) !== /*historiaGinecologica*/ ctx[19].gesta) {
    				set_input_value(input8, /*historiaGinecologica*/ ctx[19].gesta);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input9, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288 && to_number(input9.value) !== /*historiaGinecologica*/ ctx[19].para) {
    				set_input_value(input9, /*historiaGinecologica*/ ctx[19].para);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input10, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288 && to_number(input10.value) !== /*historiaGinecologica*/ ctx[19].abortos) {
    				set_input_value(input10, /*historiaGinecologica*/ ctx[19].abortos);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input11, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288 && to_number(input11.value) !== /*historiaGinecologica*/ ctx[19].cesareas) {
    				set_input_value(input11, /*historiaGinecologica*/ ctx[19].cesareas);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input12, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288 && to_number(input12.value) !== /*historiaGinecologica*/ ctx[19].espontaneos) {
    				set_input_value(input12, /*historiaGinecologica*/ ctx[19].espontaneos);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input13, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288 && to_number(input13.value) !== /*historiaGinecologica*/ ctx[19].provocados) {
    				set_input_value(input13, /*historiaGinecologica*/ ctx[19].provocados);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input14, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288 && to_number(input14.value) !== /*historiaGinecologica*/ ctx[19].legrados) {
    				set_input_value(input14, /*historiaGinecologica*/ ctx[19].legrados);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input15, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				input15.checked = /*historiaGinecologica*/ ctx[19].sangradoVaginal;
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input16, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				input16.checked = /*historiaGinecologica*/ ctx[19].vidaSexualActiva;
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input17, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				input17.checked = /*historiaGinecologica*/ ctx[19].anticonceptivosOrales;
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input18, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				input18.checked = /*historiaGinecologica*/ ctx[19].diu;
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input19, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				input19.checked = /*historiaGinecologica*/ ctx[19].aqv;
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input20, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				input20.checked = /*historiaGinecologica*/ ctx[19].condon;
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input21, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				input21.checked = /*historiaGinecologica*/ ctx[19].norplant;
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input22, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				input22.checked = /*historiaGinecologica*/ ctx[19].ritmo;
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input23, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historiaGinecologica*/ 524288) {
    				input23.checked = /*historiaGinecologica*/ ctx[19].coitoInterruptus;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div37);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(701:12) {#if empresa.historiaGinecologica}",
    		ctx
    	});

    	return block;
    }

    // (1071:12) {#if empresa.signosVitales}
    function create_if_block_7(ctx) {
    	let div22;
    	let div1;
    	let div0;
    	let t1;
    	let div21;
    	let div20;
    	let div6;
    	let div5;
    	let label0;
    	let i0;
    	let t2;
    	let t3;
    	let div4;
    	let div2;
    	let input0;
    	let t4;
    	let div3;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let t8;
    	let div10;
    	let div9;
    	let label1;
    	let i1;
    	let t9;
    	let t10;
    	let div8;
    	let div7;
    	let input1;
    	let t11;
    	let div14;
    	let div13;
    	let label2;
    	let i2;
    	let t12;
    	let t13;
    	let div12;
    	let div11;
    	let input2;
    	let t14;
    	let div19;
    	let div18;
    	let label3;
    	let i3;
    	let t15;
    	let t16;
    	let div17;
    	let div15;
    	let input3;
    	let t17;
    	let div16;
    	let input4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div22 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Signos vitales";
    			t1 = space();
    			div21 = element("div");
    			div20 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			label0 = element("label");
    			i0 = element("i");
    			t2 = text(" Temperatura");
    			t3 = space();
    			div4 = element("div");
    			div2 = element("div");
    			input0 = element("input");
    			t4 = space();
    			div3 = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "C";
    			option1 = element("option");
    			option1.textContent = "K";
    			option2 = element("option");
    			option2.textContent = "F";
    			t8 = space();
    			div10 = element("div");
    			div9 = element("div");
    			label1 = element("label");
    			i1 = element("i");
    			t9 = text(" Frecuencia respiratoria");
    			t10 = space();
    			div8 = element("div");
    			div7 = element("div");
    			input1 = element("input");
    			t11 = space();
    			div14 = element("div");
    			div13 = element("div");
    			label2 = element("label");
    			i2 = element("i");
    			t12 = text(" Frecuencia cardiaca");
    			t13 = space();
    			div12 = element("div");
    			div11 = element("div");
    			input2 = element("input");
    			t14 = space();
    			div19 = element("div");
    			div18 = element("div");
    			label3 = element("label");
    			i3 = element("i");
    			t15 = text(" Presion alterial (mmHg)");
    			t16 = space();
    			div17 = element("div");
    			div15 = element("div");
    			input3 = element("input");
    			t17 = space();
    			div16 = element("div");
    			input4 = element("input");
    			attr_dev(div0, "class", "card-title");
    			add_location(div0, file$o, 1074, 24, 45781);
    			attr_dev(div1, "class", "card-header");
    			add_location(div1, file$o, 1073, 20, 45730);
    			attr_dev(i0, "class", "mdi mdi-thermometer mdi-18px");
    			add_location(i0, file$o, 1081, 41, 46145);
    			attr_dev(label0, "for", "");
    			add_location(label0, file$o, 1080, 36, 46089);
    			input0.disabled = /*disabled*/ ctx[26];
    			attr_dev(input0, "type", "number");
    			attr_dev(input0, "class", "form-control");
    			add_location(input0, file$o, 1087, 44, 46496);
    			attr_dev(div2, "class", "col-lg-7");
    			add_location(div2, file$o, 1086, 40, 46428);
    			option0.__value = "C";
    			option0.value = option0.__value;
    			option0.selected = true;
    			add_location(option0, file$o, 1103, 48, 47531);
    			option1.__value = "K";
    			option1.value = option1.__value;
    			add_location(option1, file$o, 1106, 48, 47723);
    			option2.__value = "F";
    			option2.value = option2.__value;
    			add_location(option2, file$o, 1107, 48, 47802);
    			attr_dev(select, "class", "form-control");
    			select.disabled = /*disabled*/ ctx[26];
    			if (/*temperatura*/ ctx[8].tipo === void 0) add_render_callback(() => /*select_change_handler*/ ctx[74].call(select));
    			add_location(select, file$o, 1097, 44, 47141);
    			attr_dev(div3, "class", "col-lg-5");
    			add_location(div3, file$o, 1095, 40, 46988);
    			attr_dev(div4, "class", "row");
    			add_location(div4, file$o, 1085, 36, 46369);
    			attr_dev(div5, "class", "form-group");
    			add_location(div5, file$o, 1079, 32, 46027);
    			attr_dev(div6, "class", "col-lg-3");
    			add_location(div6, file$o, 1078, 28, 45971);
    			attr_dev(i1, "class", "mdi mdi-chart-line mdi-18px");
    			add_location(i1, file$o, 1116, 41, 48258);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$o, 1115, 36, 48202);
    			input1.disabled = /*disabled*/ ctx[26];
    			attr_dev(input1, "type", "number");
    			attr_dev(input1, "class", "form-control");
    			add_location(input1, file$o, 1122, 44, 48621);
    			attr_dev(div7, "class", "col-lg-12");
    			add_location(div7, file$o, 1121, 40, 48552);
    			attr_dev(div8, "class", "row");
    			add_location(div8, file$o, 1120, 36, 48493);
    			attr_dev(div9, "class", "form-group");
    			add_location(div9, file$o, 1114, 32, 48140);
    			attr_dev(div10, "class", "col-lg-3");
    			add_location(div10, file$o, 1113, 28, 48084);
    			attr_dev(i2, "class", "mdi mdi-heart-pulse mdi-18px");
    			add_location(i2, file$o, 1136, 41, 49409);
    			attr_dev(label2, "for", "");
    			add_location(label2, file$o, 1135, 36, 49353);
    			input2.disabled = /*disabled*/ ctx[26];
    			attr_dev(input2, "type", "number");
    			attr_dev(input2, "class", "form-control");
    			add_location(input2, file$o, 1142, 44, 49769);
    			attr_dev(div11, "class", "col-lg-12");
    			add_location(div11, file$o, 1141, 40, 49700);
    			attr_dev(div12, "class", "row");
    			add_location(div12, file$o, 1140, 36, 49641);
    			attr_dev(div13, "class", "form-group");
    			add_location(div13, file$o, 1134, 32, 49291);
    			attr_dev(div14, "class", "col-lg-3");
    			add_location(div14, file$o, 1133, 28, 49235);
    			attr_dev(i3, "class", "mdi mdi-heart-pulse mdi-18px");
    			add_location(i3, file$o, 1156, 41, 50553);
    			attr_dev(label3, "for", "");
    			add_location(label3, file$o, 1155, 36, 50497);
    			input3.disabled = /*disabled*/ ctx[26];
    			attr_dev(input3, "type", "number");
    			attr_dev(input3, "class", "form-control");
    			add_location(input3, file$o, 1162, 44, 50916);
    			attr_dev(div15, "class", "col-lg-6");
    			add_location(div15, file$o, 1161, 40, 50848);
    			input4.disabled = /*disabled*/ ctx[26];
    			attr_dev(input4, "type", "number");
    			attr_dev(input4, "class", "form-control");
    			add_location(input4, file$o, 1171, 44, 51477);
    			attr_dev(div16, "class", "col-lg-6");
    			add_location(div16, file$o, 1170, 40, 51409);
    			attr_dev(div17, "class", "row");
    			add_location(div17, file$o, 1160, 36, 50789);
    			attr_dev(div18, "class", "form-group");
    			add_location(div18, file$o, 1154, 32, 50435);
    			attr_dev(div19, "class", "col-lg-3");
    			add_location(div19, file$o, 1153, 28, 50379);
    			attr_dev(div20, "class", "row");
    			add_location(div20, file$o, 1077, 24, 45924);
    			attr_dev(div21, "class", "card-body");
    			add_location(div21, file$o, 1076, 20, 45875);
    			attr_dev(div22, "class", "card m-b-20 margen-mobile autosave");
    			add_location(div22, file$o, 1072, 16, 45660);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div22, anchor);
    			append_dev(div22, div1);
    			append_dev(div1, div0);
    			append_dev(div22, t1);
    			append_dev(div22, div21);
    			append_dev(div21, div20);
    			append_dev(div20, div6);
    			append_dev(div6, div5);
    			append_dev(div5, label0);
    			append_dev(label0, i0);
    			append_dev(label0, t2);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, input0);
    			set_input_value(input0, /*temperatura*/ ctx[8].valor);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			append_dev(div3, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			select_option(select, /*temperatura*/ ctx[8].tipo);
    			append_dev(div20, t8);
    			append_dev(div20, div10);
    			append_dev(div10, div9);
    			append_dev(div9, label1);
    			append_dev(label1, i1);
    			append_dev(label1, t9);
    			append_dev(div9, t10);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, input1);
    			set_input_value(input1, /*historia*/ ctx[7].frecuenciaRespiratoria);
    			append_dev(div20, t11);
    			append_dev(div20, div14);
    			append_dev(div14, div13);
    			append_dev(div13, label2);
    			append_dev(label2, i2);
    			append_dev(label2, t12);
    			append_dev(div13, t13);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, input2);
    			set_input_value(input2, /*historia*/ ctx[7].frecuenciaCardiaca);
    			append_dev(div20, t14);
    			append_dev(div20, div19);
    			append_dev(div19, div18);
    			append_dev(div18, label3);
    			append_dev(label3, i3);
    			append_dev(label3, t15);
    			append_dev(div18, t16);
    			append_dev(div18, div17);
    			append_dev(div17, div15);
    			append_dev(div15, input3);
    			set_input_value(input3, /*presionAlterial*/ ctx[9].mm);
    			append_dev(div17, t17);
    			append_dev(div17, div16);
    			append_dev(div16, input4);
    			set_input_value(input4, /*presionAlterial*/ ctx[9].Hg);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler_1*/ ctx[73]),
    					listen_dev(select, "change", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[74]),
    					listen_dev(input1, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler_1*/ ctx[75]),
    					listen_dev(input2, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler_1*/ ctx[76]),
    					listen_dev(input3, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler_1*/ ctx[77]),
    					listen_dev(input4, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input4, "input", /*input4_input_handler_1*/ ctx[78])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input0, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*temperatura*/ 256 && to_number(input0.value) !== /*temperatura*/ ctx[8].valor) {
    				set_input_value(input0, /*temperatura*/ ctx[8].valor);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(select, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*temperatura*/ 256) {
    				select_option(select, /*temperatura*/ ctx[8].tipo);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input1, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historia*/ 128 && to_number(input1.value) !== /*historia*/ ctx[7].frecuenciaRespiratoria) {
    				set_input_value(input1, /*historia*/ ctx[7].frecuenciaRespiratoria);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input2, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historia*/ 128 && to_number(input2.value) !== /*historia*/ ctx[7].frecuenciaCardiaca) {
    				set_input_value(input2, /*historia*/ ctx[7].frecuenciaCardiaca);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input3, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*presionAlterial*/ 512 && to_number(input3.value) !== /*presionAlterial*/ ctx[9].mm) {
    				set_input_value(input3, /*presionAlterial*/ ctx[9].mm);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input4, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*presionAlterial*/ 512 && to_number(input4.value) !== /*presionAlterial*/ ctx[9].Hg) {
    				set_input_value(input4, /*presionAlterial*/ ctx[9].Hg);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div22);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(1071:12) {#if empresa.signosVitales}",
    		ctx
    	});

    	return block;
    }

    // (1187:12) {#if empresa.otrosParametros}
    function create_if_block_6$1(ctx) {
    	let div29;
    	let div1;
    	let div0;
    	let t1;
    	let div28;
    	let div27;
    	let div6;
    	let div5;
    	let label0;
    	let i0;
    	let t2;
    	let t3;
    	let div4;
    	let div2;
    	let input0;
    	let t4;
    	let div3;
    	let select;
    	let option0;
    	let option1;
    	let t7;
    	let div12;
    	let div11;
    	let label1;
    	let i1;
    	let t8;
    	let t9;
    	let div10;
    	let div9;
    	let div8;
    	let input1;
    	let t10;
    	let div7;
    	let span0;
    	let t12;
    	let div18;
    	let div17;
    	let label2;
    	let i2;
    	let t13;
    	let t14;
    	let div16;
    	let div15;
    	let div14;
    	let input2;
    	let t15;
    	let div13;
    	let span1;
    	let t17;
    	let div22;
    	let div21;
    	let label3;
    	let i3;
    	let t18;
    	let t19;
    	let div20;
    	let div19;
    	let input3;
    	let t20;
    	let div26;
    	let div25;
    	let label4;
    	let t22;
    	let div24;
    	let div23;
    	let input4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div29 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Otros Parametros";
    			t1 = space();
    			div28 = element("div");
    			div27 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			label0 = element("label");
    			i0 = element("i");
    			t2 = text(" Peso");
    			t3 = space();
    			div4 = element("div");
    			div2 = element("div");
    			input0 = element("input");
    			t4 = space();
    			div3 = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Lb";
    			option1 = element("option");
    			option1.textContent = "Kg";
    			t7 = space();
    			div12 = element("div");
    			div11 = element("div");
    			label1 = element("label");
    			i1 = element("i");
    			t8 = text(" Escala de glasgow");
    			t9 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			input1 = element("input");
    			t10 = space();
    			div7 = element("div");
    			span0 = element("span");
    			span0.textContent = "/ 15";
    			t12 = space();
    			div18 = element("div");
    			div17 = element("div");
    			label2 = element("label");
    			i2 = element("i");
    			t13 = text(" Escala\r\n                                        de dolor");
    			t14 = space();
    			div16 = element("div");
    			div15 = element("div");
    			div14 = element("div");
    			input2 = element("input");
    			t15 = space();
    			div13 = element("div");
    			span1 = element("span");
    			span1.textContent = "/ 10";
    			t17 = space();
    			div22 = element("div");
    			div21 = element("div");
    			label3 = element("label");
    			i3 = element("i");
    			t18 = text(" Saturacin\r\n                                        de oxigeno");
    			t19 = space();
    			div20 = element("div");
    			div19 = element("div");
    			input3 = element("input");
    			t20 = space();
    			div26 = element("div");
    			div25 = element("div");
    			label4 = element("label");
    			label4.textContent = "Otros";
    			t22 = space();
    			div24 = element("div");
    			div23 = element("div");
    			input4 = element("input");
    			attr_dev(div0, "class", "card-title");
    			add_location(div0, file$o, 1189, 24, 52310);
    			attr_dev(div1, "class", "card-header");
    			add_location(div1, file$o, 1188, 20, 52259);
    			attr_dev(i0, "class", "mdi mdi-weight-pound");
    			add_location(i0, file$o, 1196, 41, 52676);
    			attr_dev(label0, "for", "");
    			add_location(label0, file$o, 1195, 36, 52620);
    			input0.disabled = /*disabled*/ ctx[26];
    			attr_dev(input0, "type", "number");
    			attr_dev(input0, "class", "form-control");
    			add_location(input0, file$o, 1200, 44, 52926);
    			attr_dev(div2, "class", "col-lg-7");
    			add_location(div2, file$o, 1199, 40, 52858);
    			option0.__value = "Lb";
    			option0.value = option0.__value;
    			add_location(option0, file$o, 1216, 48, 53947);
    			option1.__value = "Kg";
    			option1.value = option1.__value;
    			add_location(option1, file$o, 1217, 48, 54027);
    			attr_dev(select, "class", "form-control");
    			select.disabled = /*disabled*/ ctx[26];
    			if (/*peso*/ ctx[10].tipo === void 0) add_render_callback(() => /*select_change_handler_1*/ ctx[80].call(select));
    			add_location(select, file$o, 1210, 44, 53564);
    			attr_dev(div3, "class", "col-lg-5");
    			add_location(div3, file$o, 1208, 40, 53411);
    			attr_dev(div4, "class", "row");
    			add_location(div4, file$o, 1198, 36, 52799);
    			attr_dev(div5, "class", "form-group");
    			add_location(div5, file$o, 1194, 32, 52558);
    			attr_dev(div6, "class", "col-lg-3");
    			add_location(div6, file$o, 1193, 28, 52502);
    			attr_dev(i1, "class", "mdi mdi-human");
    			add_location(i1, file$o, 1226, 41, 54484);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$o, 1225, 36, 54428);
    			input1.disabled = /*disabled*/ ctx[26];
    			attr_dev(input1, "type", "number");
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "max", "15");
    			attr_dev(input1, "maxlength", "2");
    			attr_dev(input1, "aria-label", "Recipient's username");
    			attr_dev(input1, "aria-describedby", "basic-addon2");
    			add_location(input1, file$o, 1234, 48, 55006);
    			attr_dev(span0, "class", "input-group-text");
    			attr_dev(span0, "id", "basic-addon2");
    			add_location(span0, file$o, 1246, 52, 55874);
    			attr_dev(div7, "class", "input-group-append");
    			add_location(div7, file$o, 1245, 48, 55788);
    			attr_dev(div8, "class", "input-group");
    			set_style(div8, "width", "100%", 1);
    			set_style(div8, "float", "right");
    			add_location(div8, file$o, 1230, 44, 54741);
    			attr_dev(div9, "class", "col-lg-12");
    			add_location(div9, file$o, 1229, 40, 54672);
    			attr_dev(div10, "class", "row");
    			add_location(div10, file$o, 1228, 36, 54613);
    			attr_dev(div11, "class", "form-group");
    			add_location(div11, file$o, 1224, 32, 54366);
    			attr_dev(div12, "class", "col-lg-3");
    			add_location(div12, file$o, 1223, 28, 54310);
    			attr_dev(i2, "class", "mdi mdi-emoticon-happy");
    			add_location(i2, file$o, 1260, 41, 56640);
    			attr_dev(label2, "for", "");
    			add_location(label2, file$o, 1259, 36, 56584);
    			input2.disabled = /*disabled*/ ctx[26];
    			attr_dev(input2, "type", "number");
    			attr_dev(input2, "class", "form-control");
    			attr_dev(input2, "max", "10");
    			attr_dev(input2, "maxlength", "2");
    			attr_dev(input2, "aria-label", "Recipient's username");
    			attr_dev(input2, "aria-describedby", "basic-addon2");
    			add_location(input2, file$o, 1269, 48, 57210);
    			attr_dev(span1, "class", "input-group-text");
    			attr_dev(span1, "id", "basic-addon2");
    			add_location(span1, file$o, 1281, 52, 58076);
    			attr_dev(div13, "class", "input-group-append");
    			add_location(div13, file$o, 1280, 48, 57990);
    			attr_dev(div14, "class", "input-group");
    			set_style(div14, "width", "100%", 1);
    			set_style(div14, "float", "right");
    			add_location(div14, file$o, 1265, 44, 56945);
    			attr_dev(div15, "class", "col-lg-12");
    			add_location(div15, file$o, 1264, 40, 56876);
    			attr_dev(div16, "class", "row");
    			add_location(div16, file$o, 1263, 36, 56817);
    			attr_dev(div17, "class", "form-group");
    			add_location(div17, file$o, 1258, 32, 56522);
    			attr_dev(div18, "class", "col-lg-3");
    			add_location(div18, file$o, 1257, 28, 56466);
    			attr_dev(i3, "class", "mdi mdi-opacity");
    			add_location(i3, file$o, 1295, 41, 58842);
    			attr_dev(label3, "for", "");
    			add_location(label3, file$o, 1294, 36, 58786);
    			input3.disabled = /*disabled*/ ctx[26];
    			attr_dev(input3, "type", "number");
    			attr_dev(input3, "class", "form-control");
    			add_location(input3, file$o, 1300, 44, 59153);
    			attr_dev(div19, "class", "col-lg-12");
    			add_location(div19, file$o, 1299, 40, 59084);
    			attr_dev(div20, "class", "row");
    			add_location(div20, file$o, 1298, 36, 59025);
    			attr_dev(div21, "class", "form-group");
    			add_location(div21, file$o, 1293, 32, 58724);
    			attr_dev(div22, "class", "col-lg-3");
    			add_location(div22, file$o, 1292, 28, 58668);
    			attr_dev(label4, "for", "");
    			add_location(label4, file$o, 1313, 36, 59881);
    			input4.disabled = /*disabled*/ ctx[26];
    			attr_dev(input4, "type", "text");
    			attr_dev(input4, "class", "form-control");
    			add_location(input4, file$o, 1316, 44, 60074);
    			attr_dev(div23, "class", "col-lg-12");
    			add_location(div23, file$o, 1315, 40, 60005);
    			attr_dev(div24, "class", "row");
    			add_location(div24, file$o, 1314, 36, 59946);
    			attr_dev(div25, "class", "form-group");
    			add_location(div25, file$o, 1312, 32, 59819);
    			attr_dev(div26, "class", "col-lg-12");
    			add_location(div26, file$o, 1311, 28, 59762);
    			attr_dev(div27, "class", "row");
    			add_location(div27, file$o, 1192, 24, 52455);
    			attr_dev(div28, "class", "card-body");
    			add_location(div28, file$o, 1191, 20, 52406);
    			attr_dev(div29, "class", "card m-b-20");
    			add_location(div29, file$o, 1187, 16, 52212);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div29, anchor);
    			append_dev(div29, div1);
    			append_dev(div1, div0);
    			append_dev(div29, t1);
    			append_dev(div29, div28);
    			append_dev(div28, div27);
    			append_dev(div27, div6);
    			append_dev(div6, div5);
    			append_dev(div5, label0);
    			append_dev(label0, i0);
    			append_dev(label0, t2);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, input0);
    			set_input_value(input0, /*peso*/ ctx[10].valor);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			append_dev(div3, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			select_option(select, /*peso*/ ctx[10].tipo);
    			append_dev(div27, t7);
    			append_dev(div27, div12);
    			append_dev(div12, div11);
    			append_dev(div11, label1);
    			append_dev(label1, i1);
    			append_dev(label1, t8);
    			append_dev(div11, t9);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, input1);
    			set_input_value(input1, /*historia*/ ctx[7].escalaGalsgow);
    			append_dev(div8, t10);
    			append_dev(div8, div7);
    			append_dev(div7, span0);
    			append_dev(div27, t12);
    			append_dev(div27, div18);
    			append_dev(div18, div17);
    			append_dev(div17, label2);
    			append_dev(label2, i2);
    			append_dev(label2, t13);
    			append_dev(div17, t14);
    			append_dev(div17, div16);
    			append_dev(div16, div15);
    			append_dev(div15, div14);
    			append_dev(div14, input2);
    			set_input_value(input2, /*historia*/ ctx[7].escalaDolor);
    			append_dev(div14, t15);
    			append_dev(div14, div13);
    			append_dev(div13, span1);
    			append_dev(div27, t17);
    			append_dev(div27, div22);
    			append_dev(div22, div21);
    			append_dev(div21, label3);
    			append_dev(label3, i3);
    			append_dev(label3, t18);
    			append_dev(div21, t19);
    			append_dev(div21, div20);
    			append_dev(div20, div19);
    			append_dev(div19, input3);
    			set_input_value(input3, /*historia*/ ctx[7].saturacionOxigeno);
    			append_dev(div27, t20);
    			append_dev(div27, div26);
    			append_dev(div26, div25);
    			append_dev(div25, label4);
    			append_dev(div25, t22);
    			append_dev(div25, div24);
    			append_dev(div24, div23);
    			append_dev(div23, input4);
    			set_input_value(input4, /*historia*/ ctx[7].otrosParametros);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler_2*/ ctx[79]),
    					listen_dev(select, "change", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(select, "change", /*select_change_handler_1*/ ctx[80]),
    					listen_dev(input1, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler_2*/ ctx[81]),
    					listen_dev(input2, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler_2*/ ctx[82]),
    					listen_dev(input3, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler_2*/ ctx[83]),
    					listen_dev(input4, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input4, "input", /*input4_input_handler_2*/ ctx[84])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input0, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*peso*/ 1024 && to_number(input0.value) !== /*peso*/ ctx[10].valor) {
    				set_input_value(input0, /*peso*/ ctx[10].valor);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(select, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*peso*/ 1024) {
    				select_option(select, /*peso*/ ctx[10].tipo);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input1, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historia*/ 128 && to_number(input1.value) !== /*historia*/ ctx[7].escalaGalsgow) {
    				set_input_value(input1, /*historia*/ ctx[7].escalaGalsgow);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input2, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historia*/ 128 && to_number(input2.value) !== /*historia*/ ctx[7].escalaDolor) {
    				set_input_value(input2, /*historia*/ ctx[7].escalaDolor);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input3, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historia*/ 128 && to_number(input3.value) !== /*historia*/ ctx[7].saturacionOxigeno) {
    				set_input_value(input3, /*historia*/ ctx[7].saturacionOxigeno);
    			}

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input4, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historia*/ 128 && input4.value !== /*historia*/ ctx[7].otrosParametros) {
    				set_input_value(input4, /*historia*/ ctx[7].otrosParametros);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div29);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(1187:12) {#if empresa.otrosParametros}",
    		ctx
    	});

    	return block;
    }

    // (1373:12) {#if empresa.exploracionFisica}
    function create_if_block_3$3(ctx) {
    	let div7;
    	let div1;
    	let div0;
    	let t1;
    	let div6;
    	let div5;
    	let div2;
    	let t2;
    	let hr;
    	let t3;
    	let div4;
    	let div3;
    	let each_value_3 = /*exploracionFisica*/ ctx[22];
    	validate_each_argument(each_value_3);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_1[i] = create_each_block_3$3(get_each_context_3$3(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*exploracionFisica*/ ctx[22];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Exploracin Fisica";
    			t1 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div2 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t2 = space();
    			hr = element("hr");
    			t3 = space();
    			div4 = element("div");
    			div3 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "card-title");
    			add_location(div0, file$o, 1375, 24, 62642);
    			attr_dev(div1, "class", "card-header");
    			add_location(div1, file$o, 1374, 20, 62591);
    			attr_dev(div2, "class", "col-12");
    			add_location(div2, file$o, 1379, 28, 62843);
    			add_location(hr, file$o, 1393, 28, 63636);
    			attr_dev(div3, "class", "row mt-2");
    			add_location(div3, file$o, 1395, 32, 63726);
    			attr_dev(div4, "class", "col-12");
    			add_location(div4, file$o, 1394, 28, 63672);
    			attr_dev(div5, "class", "row");
    			add_location(div5, file$o, 1378, 24, 62796);
    			attr_dev(div6, "class", "card-body");
    			add_location(div6, file$o, 1377, 20, 62747);
    			attr_dev(div7, "class", "card m-b-20");
    			add_location(div7, file$o, 1373, 16, 62544);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div1);
    			append_dev(div1, div0);
    			append_dev(div7, t1);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div2, null);
    			}

    			append_dev(div5, t2);
    			append_dev(div5, hr);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, div3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div3, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*disabled, exploracionFisica*/ 71303168 | dirty[1] & /*guardarHistoria*/ 1024) {
    				each_value_3 = /*exploracionFisica*/ ctx[22];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$3(ctx, each_value_3, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_3$3(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_3.length;
    			}

    			if (dirty[0] & /*disabled, exploracionFisica*/ 71303168 | dirty[1] & /*guardarHistoria*/ 1024) {
    				each_value_2 = /*exploracionFisica*/ ctx[22];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$3(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div3, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(1373:12) {#if empresa.exploracionFisica}",
    		ctx
    	});

    	return block;
    }

    // (1382:36) {#if !item.activo}
    function create_if_block_5$2(ctx) {
    	let button;
    	let t_value = /*item*/ ctx[116].nombre + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler_4(...args) {
    		return /*click_handler_4*/ ctx[86](/*item*/ ctx[116], /*each_value_3*/ ctx[124], /*item_index_1*/ ctx[125], ...args);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "btn btn-outline-primary mr-2");
    			button.disabled = /*disabled*/ ctx[26];
    			add_location(button, file$o, 1382, 40, 63028);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_4, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*exploracionFisica*/ 4194304 && t_value !== (t_value = /*item*/ ctx[116].nombre + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[26]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(1382:36) {#if !item.activo}",
    		ctx
    	});

    	return block;
    }

    // (1381:32) {#each exploracionFisica as item}
    function create_each_block_3$3(ctx) {
    	let if_block_anchor;
    	let if_block = !/*item*/ ctx[116].activo && create_if_block_5$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*item*/ ctx[116].activo) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_5$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$3.name,
    		type: "each",
    		source: "(1381:32) {#each exploracionFisica as item}",
    		ctx
    	});

    	return block;
    }

    // (1398:40) {#if item.activo}
    function create_if_block_4$3(ctx) {
    	let div4;
    	let div3;
    	let div1;
    	let div0;
    	let t0_value = /*item*/ ctx[116].nombre + "";
    	let t0;
    	let t1;
    	let div2;
    	let textarea;
    	let t2;
    	let mounted;
    	let dispose;

    	function textarea_input_handler() {
    		/*textarea_input_handler*/ ctx[87].call(textarea, /*each_value_2*/ ctx[122], /*item_index*/ ctx[123]);
    	}

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			textarea = element("textarea");
    			t2 = space();
    			attr_dev(div0, "class", "card-title");
    			add_location(div0, file$o, 1403, 56, 64290);
    			attr_dev(div1, "class", "card-header");
    			add_location(div1, file$o, 1402, 52, 64207);
    			textarea.disabled = /*disabled*/ ctx[26];
    			attr_dev(textarea, "class", "form-control");
    			attr_dev(textarea, "rows", "5");
    			add_location(textarea, file$o, 1408, 56, 64648);
    			attr_dev(div2, "class", "card-body");
    			add_location(div2, file$o, 1407, 52, 64567);
    			attr_dev(div3, "class", "card m-t-10 m-b-20 border border-primary");
    			add_location(div3, file$o, 1399, 48, 63996);
    			attr_dev(div4, "class", "col-lg-4");
    			add_location(div4, file$o, 1398, 44, 63924);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, textarea);
    			set_input_value(textarea, /*item*/ ctx[116].text);
    			append_dev(div4, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "input", textarea_input_handler),
    					listen_dev(textarea, "blur", /*guardarHistoria*/ ctx[41], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*exploracionFisica*/ 4194304 && t0_value !== (t0_value = /*item*/ ctx[116].nombre + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(textarea, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*exploracionFisica*/ 4194304) {
    				set_input_value(textarea, /*item*/ ctx[116].text);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(1398:40) {#if item.activo}",
    		ctx
    	});

    	return block;
    }

    // (1397:36) {#each exploracionFisica as item}
    function create_each_block_2$3(ctx) {
    	let if_block_anchor;
    	let if_block = /*item*/ ctx[116].activo && create_if_block_4$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*item*/ ctx[116].activo) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$3.name,
    		type: "each",
    		source: "(1397:36) {#each exploracionFisica as item}",
    		ctx
    	});

    	return block;
    }

    // (1477:40) {#each filtroDiagnostico as diagnostico}
    function create_each_block_1$4(ctx) {
    	let li;
    	let div;
    	let span;
    	let t0_value = /*diagnostico*/ ctx[119].c + "";
    	let t0;
    	let t1;
    	let t2_value = /*diagnostico*/ ctx[119].d + "";
    	let t2;
    	let mounted;
    	let dispose;

    	function click_handler_5(...args) {
    		return /*click_handler_5*/ ctx[89](/*diagnostico*/ ctx[119], ...args);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			div = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    			attr_dev(span, "class", "badge badge-primary");
    			add_location(span, file$o, 1485, 52, 68708);
    			attr_dev(div, "class", "p-2");
    			add_location(div, file$o, 1478, 48, 68249);
    			add_location(li, file$o, 1477, 44, 68195);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div);
    			append_dev(div, span);
    			append_dev(span, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler_5, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*filtroDiagnostico*/ 134217728 && t0_value !== (t0_value = /*diagnostico*/ ctx[119].c + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*filtroDiagnostico*/ 134217728 && t2_value !== (t2_value = /*diagnostico*/ ctx[119].d + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(1477:40) {#each filtroDiagnostico as diagnostico}",
    		ctx
    	});

    	return block;
    }

    // (1518:40) {#if !disabled}
    function create_if_block_2$6(ctx) {
    	let div;
    	let a0;
    	let i0;
    	let t;
    	let a1;
    	let i1;
    	let mounted;
    	let dispose;

    	function click_handler_7(...args) {
    		return /*click_handler_7*/ ctx[91](/*i*/ ctx[118], ...args);
    	}

    	function click_handler_8(...args) {
    		return /*click_handler_8*/ ctx[92](/*i*/ ctx[118], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			a0 = element("a");
    			i0 = element("i");
    			t = space();
    			a1 = element("a");
    			i1 = element("i");
    			attr_dev(i0, "class", "mdi-18px mdi mdi-comment-plus-outline");
    			add_location(i0, file$o, 1530, 53, 71504);
    			attr_dev(a0, "href", "#!");
    			attr_dev(a0, "class", "text-primary");
    			attr_dev(a0, "data-tooltip", "Comentar");
    			add_location(a0, file$o, 1522, 48, 70939);
    			attr_dev(i1, "class", "mdi-18px mdi mdi-trash-can-outline");
    			add_location(i1, file$o, 1540, 53, 72204);
    			attr_dev(a1, "href", "#!");
    			attr_dev(a1, "class", "text-danger");
    			attr_dev(a1, "data-tooltip", "Eliminar");
    			add_location(a1, file$o, 1534, 48, 71769);
    			set_style(div, "position", "absolute");
    			set_style(div, "top", "0");
    			set_style(div, "right", "0");
    			set_style(div, "padding", "10px");
    			set_style(div, "background-color", "white");
    			set_style(div, "border-bottom-left-radius", "5px");
    			add_location(div, file$o, 1519, 44, 70672);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a0);
    			append_dev(a0, i0);
    			append_dev(div, t);
    			append_dev(div, a1);
    			append_dev(a1, i1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", prevent_default(click_handler_7), false, true, false),
    					listen_dev(a1, "click", prevent_default(click_handler_8), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(1518:40) {#if !disabled}",
    		ctx
    	});

    	return block;
    }

    // (1547:40) {#if item.comentario !== undefined}
    function create_if_block_1$9(ctx) {
    	let div1;
    	let div0;
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[93].call(input, /*each_value*/ ctx[117], /*i*/ ctx[118]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			input.disabled = /*disabled*/ ctx[26];
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "form-control border-primary");
    			attr_dev(input, "placeholder", "Comentario");
    			add_location(input, file$o, 1549, 52, 72781);
    			attr_dev(div0, "class", "col");
    			add_location(div0, file$o, 1548, 48, 72710);
    			attr_dev(div1, "class", "row mt-3");
    			add_location(div1, file$o, 1547, 44, 72638);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			set_input_value(input, /*item*/ ctx[116].comentario);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(input, "input", input_input_handler)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*diagnosticosSeleccionados*/ 32 && input.value !== /*item*/ ctx[116].comentario) {
    				set_input_value(input, /*item*/ ctx[116].comentario);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(1547:40) {#if item.comentario !== undefined}",
    		ctx
    	});

    	return block;
    }

    // (1513:32) {#each diagnosticosSeleccionados as item, i}
    function create_each_block$7(ctx) {
    	let li;
    	let span0;
    	let t0_value = /*item*/ ctx[116].c + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2_value = /*item*/ ctx[116].d + "";
    	let t2;
    	let t3;
    	let t4;
    	let if_block0 = !/*disabled*/ ctx[26] && create_if_block_2$6(ctx);
    	let if_block1 = /*item*/ ctx[116].comentario !== undefined && create_if_block_1$9(ctx);

    	const block = {
    		c: function create() {
    			li = element("li");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = text("");
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block0) if_block0.c();
    			t4 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(span0, "class", "badge badge-primary");
    			add_location(span0, file$o, 1514, 40, 70338);
    			add_location(span1, file$o, 1516, 47, 70481);
    			add_location(li, file$o, 1513, 36, 70292);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span0);
    			append_dev(span0, t0);
    			append_dev(li, t1);
    			append_dev(li, span1);
    			append_dev(span1, t2);
    			append_dev(li, t3);
    			if (if_block0) if_block0.m(li, null);
    			append_dev(li, t4);
    			if (if_block1) if_block1.m(li, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*diagnosticosSeleccionados*/ 32 && t0_value !== (t0_value = /*item*/ ctx[116].c + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*diagnosticosSeleccionados*/ 32 && t2_value !== (t2_value = /*item*/ ctx[116].d + "")) set_data_dev(t2, t2_value);

    			if (!/*disabled*/ ctx[26]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$6(ctx);
    					if_block0.c();
    					if_block0.m(li, t4);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*item*/ ctx[116].comentario !== undefined) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$9(ctx);
    					if_block1.c();
    					if_block1.m(li, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(1513:32) {#each diagnosticosSeleccionados as item, i}",
    		ctx
    	});

    	return block;
    }

    // (1563:32) {#if diagnosticosSeleccionados.length === 0}
    function create_if_block$d(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let p;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			p.textContent = "No tienes agregado ningn\r\n                                                    diagnostico";
    			attr_dev(p, "class", "alert-body text-center mt-3");
    			add_location(p, file$o, 1569, 48, 74052);
    			attr_dev(div0, "class", "alert border alert-light");
    			attr_dev(div0, "role", "alert");
    			add_location(div0, file$o, 1565, 44, 73807);
    			attr_dev(div1, "class", "col-md-12");
    			add_location(div1, file$o, 1564, 40, 73738);
    			attr_dev(div2, "class", "row");
    			add_location(div2, file$o, 1563, 36, 73679);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(1563:32) {#if diagnosticosSeleccionados.length === 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let asideatencion;
    	let t0;
    	let div6;
    	let t1;
    	let t2;
    	let t3;
    	let div5;
    	let div0;
    	let h5;
    	let span0;
    	let t5;
    	let span1;
    	let t6_value = /*paciente*/ ctx[1].nombres + "";
    	let t6;
    	let t7;
    	let t8_value = /*paciente*/ ctx[1].apellidos + "";
    	let t8;
    	let t9;
    	let div2;
    	let div1;
    	let t10;
    	let t11;
    	let t12;
    	let t13;
    	let div4;
    	let div3;
    	let button0;
    	let i0;
    	let t14;
    	let sapn0;
    	let t16;
    	let show_if = user().roles.includes("admin");
    	let t17;
    	let a0;
    	let i1;
    	let t18;
    	let sapn1;
    	let a0_href_value;
    	let t20;
    	let button1;
    	let i2;
    	let t21;
    	let t22;
    	let t23;
    	let header;
    	let t24;
    	let main;
    	let div48;
    	let div47;
    	let div10;
    	let div8;
    	let div7;
    	let t26;
    	let div9;
    	let textarea0;
    	let t27;
    	let div14;
    	let div12;
    	let div11;
    	let t29;
    	let div13;
    	let textarea1;
    	let t30;
    	let t31;
    	let t32;
    	let t33;
    	let div21;
    	let div16;
    	let div15;
    	let t35;
    	let div19;
    	let div18;
    	let a1;
    	let i3;
    	let t36;
    	let div17;
    	let button2;
    	let t38;
    	let button3;
    	let t40;
    	let button4;
    	let t42;
    	let div20;
    	let textarea2;
    	let t43;
    	let t44;
    	let div33;
    	let div23;
    	let div22;
    	let t46;
    	let div26;
    	let div25;
    	let a2;
    	let i4;
    	let t47;
    	let div24;
    	let button5;
    	let i5;
    	let t48;
    	let t49;
    	let div32;
    	let div31;
    	let div29;
    	let div28;
    	let input0;
    	let t50;
    	let ul0;
    	let div27;
    	let t51;
    	let li;
    	let a3;
    	let i6;
    	let t52;
    	let t53;
    	let div30;
    	let ul1;
    	let t54;
    	let t55;
    	let ordenesmedicas;
    	let updating_idHistoria;
    	let updating_idPaciente;
    	let updating_estudiosSeleccionados;
    	let updating_medicamentosSeleccionados;
    	let updating_sltBuscarMedicamentos;
    	let updating_sltBuscarEstudios;
    	let updating_medicamentos;
    	let updating_instrucciones;
    	let updating_estudios;
    	let t56;
    	let div37;
    	let div35;
    	let div34;
    	let t58;
    	let div36;
    	let textarea3;
    	let t59;
    	let div46;
    	let div45;
    	let div44;
    	let div39;
    	let div38;
    	let t61;
    	let div43;
    	let div42;
    	let div40;
    	let label0;
    	let t63;
    	let input1;
    	let t64;
    	let div41;
    	let label1;
    	let t66;
    	let input2;
    	let t67;
    	let modaldatospaciente;
    	let t68;
    	let modaltratamientos;
    	let t69;
    	let modalinterconsulta;
    	let t70;
    	let modalantecedentes;
    	let t71;
    	let modalnuevacita;
    	let current;
    	let mounted;
    	let dispose;
    	asideatencion = new AsideAtencion({ $$inline: true });
    	let if_block0 = /*errorServer*/ ctx[20] && create_if_block_19(ctx);
    	let if_block1 = /*serverConexion*/ ctx[23] && create_if_block_18(ctx);
    	let if_block2 = /*cargandoHistoria*/ ctx[24] && create_if_block_17(ctx);
    	let if_block3 = !/*cargando*/ ctx[13] && !/*errorServer*/ ctx[20] && create_if_block_16(ctx);
    	let if_block4 = /*errorServer*/ ctx[20] && create_if_block_15(ctx);
    	let if_block5 = /*cargando*/ ctx[13] && !/*errorServer*/ ctx[20] && create_if_block_14(ctx);
    	let if_block6 = /*historia*/ ctx[7].estado === "A" && create_if_block_13(ctx);
    	let if_block7 = show_if && create_if_block_10(ctx);
    	let if_block8 = /*historia*/ ctx[7].estado === "A" && create_if_block_9(ctx);
    	header = new Header({ $$inline: true });
    	let if_block9 = /*empresa*/ ctx[21].historiaGinecologica && create_if_block_8(ctx);
    	let if_block10 = /*empresa*/ ctx[21].signosVitales && create_if_block_7(ctx);
    	let if_block11 = /*empresa*/ ctx[21].otrosParametros && create_if_block_6$1(ctx);
    	let if_block12 = /*empresa*/ ctx[21].exploracionFisica && create_if_block_3$3(ctx);
    	let each_value_1 = /*filtroDiagnostico*/ ctx[27];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	let each_value = /*diagnosticosSeleccionados*/ ctx[5];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	let if_block13 = /*diagnosticosSeleccionados*/ ctx[5].length === 0 && create_if_block$d(ctx);

    	function ordenesmedicas_idHistoria_binding(value) {
    		/*ordenesmedicas_idHistoria_binding*/ ctx[94].call(null, value);
    	}

    	function ordenesmedicas_idPaciente_binding(value) {
    		/*ordenesmedicas_idPaciente_binding*/ ctx[95].call(null, value);
    	}

    	function ordenesmedicas_estudiosSeleccionados_binding(value) {
    		/*ordenesmedicas_estudiosSeleccionados_binding*/ ctx[96].call(null, value);
    	}

    	function ordenesmedicas_medicamentosSeleccionados_binding(value) {
    		/*ordenesmedicas_medicamentosSeleccionados_binding*/ ctx[97].call(null, value);
    	}

    	function ordenesmedicas_sltBuscarMedicamentos_binding(value) {
    		/*ordenesmedicas_sltBuscarMedicamentos_binding*/ ctx[98].call(null, value);
    	}

    	function ordenesmedicas_sltBuscarEstudios_binding(value) {
    		/*ordenesmedicas_sltBuscarEstudios_binding*/ ctx[99].call(null, value);
    	}

    	function ordenesmedicas_medicamentos_binding(value) {
    		/*ordenesmedicas_medicamentos_binding*/ ctx[100].call(null, value);
    	}

    	function ordenesmedicas_instrucciones_binding(value) {
    		/*ordenesmedicas_instrucciones_binding*/ ctx[101].call(null, value);
    	}

    	function ordenesmedicas_estudios_binding(value) {
    		/*ordenesmedicas_estudios_binding*/ ctx[102].call(null, value);
    	}

    	let ordenesmedicas_props = { disabled: /*disabled*/ ctx[26] };

    	if (/*params*/ ctx[0].idHistoria !== void 0) {
    		ordenesmedicas_props.idHistoria = /*params*/ ctx[0].idHistoria;
    	}

    	if (/*params*/ ctx[0].idPaciente !== void 0) {
    		ordenesmedicas_props.idPaciente = /*params*/ ctx[0].idPaciente;
    	}

    	if (/*estudiosSeleccionados*/ ctx[18] !== void 0) {
    		ordenesmedicas_props.estudiosSeleccionados = /*estudiosSeleccionados*/ ctx[18];
    	}

    	if (/*medicamentosSeleccionados*/ ctx[15] !== void 0) {
    		ordenesmedicas_props.medicamentosSeleccionados = /*medicamentosSeleccionados*/ ctx[15];
    	}

    	if (/*sltBuscarMedicamentos*/ ctx[14] !== void 0) {
    		ordenesmedicas_props.sltBuscarMedicamentos = /*sltBuscarMedicamentos*/ ctx[14];
    	}

    	if (/*sltBuscarEstudios*/ ctx[16] !== void 0) {
    		ordenesmedicas_props.sltBuscarEstudios = /*sltBuscarEstudios*/ ctx[16];
    	}

    	if (/*medicamentos*/ ctx[6] !== void 0) {
    		ordenesmedicas_props.medicamentos = /*medicamentos*/ ctx[6];
    	}

    	if (/*historia*/ ctx[7].instrucciones !== void 0) {
    		ordenesmedicas_props.instrucciones = /*historia*/ ctx[7].instrucciones;
    	}

    	if (/*estudios*/ ctx[17] !== void 0) {
    		ordenesmedicas_props.estudios = /*estudios*/ ctx[17];
    	}

    	ordenesmedicas = new OrdenesMedicas({
    			props: ordenesmedicas_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(ordenesmedicas, "idHistoria", ordenesmedicas_idHistoria_binding));
    	binding_callbacks.push(() => bind(ordenesmedicas, "idPaciente", ordenesmedicas_idPaciente_binding));
    	binding_callbacks.push(() => bind(ordenesmedicas, "estudiosSeleccionados", ordenesmedicas_estudiosSeleccionados_binding));
    	binding_callbacks.push(() => bind(ordenesmedicas, "medicamentosSeleccionados", ordenesmedicas_medicamentosSeleccionados_binding));
    	binding_callbacks.push(() => bind(ordenesmedicas, "sltBuscarMedicamentos", ordenesmedicas_sltBuscarMedicamentos_binding));
    	binding_callbacks.push(() => bind(ordenesmedicas, "sltBuscarEstudios", ordenesmedicas_sltBuscarEstudios_binding));
    	binding_callbacks.push(() => bind(ordenesmedicas, "medicamentos", ordenesmedicas_medicamentos_binding));
    	binding_callbacks.push(() => bind(ordenesmedicas, "instrucciones", ordenesmedicas_instrucciones_binding));
    	binding_callbacks.push(() => bind(ordenesmedicas, "estudios", ordenesmedicas_estudios_binding));
    	ordenesmedicas.$on("eliminarEstudio", /*eliminarEstudios*/ ctx[39]);
    	ordenesmedicas.$on("agregarEstudio", /*agregarEstudio*/ ctx[34]);
    	ordenesmedicas.$on("buscandoEstudios", /*searchEstudios*/ ctx[33]);
    	ordenesmedicas.$on("modificado", /*guardarHistoria*/ ctx[41]);
    	ordenesmedicas.$on("buscarMedicamentos", /*searchMedicamentos*/ ctx[31]);
    	ordenesmedicas.$on("agregarMedicamento", /*agregarMedicamento*/ ctx[40]);
    	ordenesmedicas.$on("eliminarMedicamento", /*eliminarMedicamento*/ ctx[37]);

    	modaldatospaciente = new ModalDatosPaciente({
    			props: {
    				paciente: /*paciente*/ ctx[1],
    				edad: /*edad*/ ctx[2],
    				seguro: /*seguro*/ ctx[3]
    			},
    			$$inline: true
    		});

    	modaltratamientos = new ModalTratamientos({ $$inline: true });
    	modalinterconsulta = new ModalInterconsulta({ $$inline: true });
    	modalantecedentes = new ModalAntecedentes({ $$inline: true });

    	modalnuevacita = new ModalNuevaCita({
    			props: {
    				pacienteSeleccionado: /*pacienteSeleccionado*/ ctx[25]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(asideatencion.$$.fragment);
    			t0 = space();
    			div6 = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			div5 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			span0 = element("span");
    			span0.textContent = "Historia Clinica";
    			t5 = space();
    			span1 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			div2 = element("div");
    			div1 = element("div");
    			if (if_block3) if_block3.c();
    			t10 = space();
    			if (if_block4) if_block4.c();
    			t11 = space();
    			if (if_block5) if_block5.c();
    			t12 = space();
    			if (if_block6) if_block6.c();
    			t13 = space();
    			div4 = element("div");
    			div3 = element("div");
    			button0 = element("button");
    			i0 = element("i");
    			t14 = space();
    			sapn0 = element("sapn");
    			sapn0.textContent = "Datos del Paciente";
    			t16 = space();
    			if (if_block7) if_block7.c();
    			t17 = space();
    			a0 = element("a");
    			i1 = element("i");
    			t18 = space();
    			sapn1 = element("sapn");
    			sapn1.textContent = "Imprimir";
    			t20 = space();
    			button1 = element("button");
    			i2 = element("i");
    			t21 = text("\r\n                    Nueva cita");
    			t22 = space();
    			if (if_block8) if_block8.c();
    			t23 = space();
    			create_component(header.$$.fragment);
    			t24 = space();
    			main = element("main");
    			div48 = element("div");
    			div47 = element("div");
    			div10 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			div7.textContent = "Motivo de consulta";
    			t26 = space();
    			div9 = element("div");
    			textarea0 = element("textarea");
    			t27 = space();
    			div14 = element("div");
    			div12 = element("div");
    			div11 = element("div");
    			div11.textContent = "Historia de la enfermedad";
    			t29 = space();
    			div13 = element("div");
    			textarea1 = element("textarea");
    			t30 = space();
    			if (if_block9) if_block9.c();
    			t31 = space();
    			if (if_block10) if_block10.c();
    			t32 = space();
    			if (if_block11) if_block11.c();
    			t33 = space();
    			div21 = element("div");
    			div16 = element("div");
    			div15 = element("div");
    			div15.textContent = "Examen Fisico";
    			t35 = space();
    			div19 = element("div");
    			div18 = element("div");
    			a1 = element("a");
    			i3 = element("i");
    			t36 = space();
    			div17 = element("div");
    			button2 = element("button");
    			button2.textContent = "Action";
    			t38 = space();
    			button3 = element("button");
    			button3.textContent = "Another action";
    			t40 = space();
    			button4 = element("button");
    			button4.textContent = "Something else here";
    			t42 = space();
    			div20 = element("div");
    			textarea2 = element("textarea");
    			t43 = space();
    			if (if_block12) if_block12.c();
    			t44 = space();
    			div33 = element("div");
    			div23 = element("div");
    			div22 = element("div");
    			div22.textContent = "Diagnosticos";
    			t46 = space();
    			div26 = element("div");
    			div25 = element("div");
    			a2 = element("a");
    			i4 = element("i");
    			t47 = space();
    			div24 = element("div");
    			button5 = element("button");
    			i5 = element("i");
    			t48 = text("\r\n                                Agregar nuevo diagnostico");
    			t49 = space();
    			div32 = element("div");
    			div31 = element("div");
    			div29 = element("div");
    			div28 = element("div");
    			input0 = element("input");
    			t50 = space();
    			ul0 = element("ul");
    			div27 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t51 = space();
    			li = element("li");
    			a3 = element("a");
    			i6 = element("i");
    			t52 = text("Agregar manualmente");
    			t53 = space();
    			div30 = element("div");
    			ul1 = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t54 = space();
    			if (if_block13) if_block13.c();
    			t55 = space();
    			create_component(ordenesmedicas.$$.fragment);
    			t56 = space();
    			div37 = element("div");
    			div35 = element("div");
    			div34 = element("div");
    			div34.textContent = "Observaciones";
    			t58 = space();
    			div36 = element("div");
    			textarea3 = element("textarea");
    			t59 = space();
    			div46 = element("div");
    			div45 = element("div");
    			div44 = element("div");
    			div39 = element("div");
    			div38 = element("div");
    			div38.textContent = "Fecha y hora";
    			t61 = space();
    			div43 = element("div");
    			div42 = element("div");
    			div40 = element("div");
    			label0 = element("label");
    			label0.textContent = "Fecha";
    			t63 = space();
    			input1 = element("input");
    			t64 = space();
    			div41 = element("div");
    			label1 = element("label");
    			label1.textContent = "Hora";
    			t66 = space();
    			input2 = element("input");
    			t67 = space();
    			create_component(modaldatospaciente.$$.fragment);
    			t68 = space();
    			create_component(modaltratamientos.$$.fragment);
    			t69 = space();
    			create_component(modalinterconsulta.$$.fragment);
    			t70 = space();
    			create_component(modalantecedentes.$$.fragment);
    			t71 = space();
    			create_component(modalnuevacita.$$.fragment);
    			attr_dev(span0, "class", "badge badge-primary");
    			attr_dev(span0, "data-bind", "text: titulo");
    			add_location(span0, file$o, 513, 16, 16997);
    			attr_dev(span1, "data-bind", "text: paciente().nombreParaMostrar");
    			add_location(span1, file$o, 516, 16, 17137);
    			add_location(h5, file$o, 512, 12, 16975);
    			attr_dev(div0, "class", "col-md-6");
    			add_location(div0, file$o, 511, 8, 16939);
    			attr_dev(div1, "class", "guardar-documento");
    			add_location(div1, file$o, 522, 12, 17384);
    			attr_dev(div2, "class", "col-md-6");
    			set_style(div2, "text-align", "right");
    			add_location(div2, file$o, 521, 8, 17321);
    			attr_dev(i0, "data-bind", "class: icon");
    			attr_dev(i0, "class", "mdi mdi-comment-eye");
    			add_location(i0, file$o, 558, 20, 18914);
    			attr_dev(sapn0, "data-bind", "text: text");
    			add_location(sapn0, file$o, 559, 20, 18993);
    			attr_dev(button0, "data-toggle", "modal");
    			attr_dev(button0, "data-target", "#modalDatosPersonales");
    			set_style(button0, "box-shadow", "none");
    			attr_dev(button0, "class", "btn btn-outline-secondary btn-sm");
    			add_location(button0, file$o, 552, 16, 18660);
    			attr_dev(i1, "data-bind", "class: icon");
    			attr_dev(i1, "class", "mdi mdi-printer");
    			add_location(i1, file$o, 609, 20, 21268);
    			attr_dev(sapn1, "data-bind", "text: text");
    			add_location(sapn1, file$o, 610, 20, 21343);
    			attr_dev(a0, "href", a0_href_value = `/#/pacientes/${/*params*/ ctx[0].idPaciente}/historias/${/*params*/ ctx[0].idHistoria}/imprimir`);
    			attr_dev(a0, "target", "_blank");
    			set_style(a0, "box-shadow", "none");
    			attr_dev(a0, "class", "btn btn-outline-dark btn-sm btn-hover-white");
    			add_location(a0, file$o, 603, 16, 20965);
    			attr_dev(i2, "class", "mdi mdi-calendar-multiselect");
    			add_location(i2, file$o, 631, 20, 22341);
    			set_style(button1, "box-shadow", "none");
    			attr_dev(button1, "class", "btn btn-outline-success btn-sm btn-hover-white");
    			attr_dev(button1, "data-toggle", "modal");
    			attr_dev(button1, "data-target", "#modalNuevaCita");
    			add_location(button1, file$o, 613, 16, 21429);
    			attr_dev(div3, "class", "dropdown");
    			attr_dev(div3, "data-bind", "foreach: actionButtons");
    			add_location(div3, file$o, 551, 12, 18585);
    			attr_dev(div4, "class", "col-lg-12");
    			add_location(div4, file$o, 550, 8, 18548);
    			attr_dev(div5, "class", "row");
    			add_location(div5, file$o, 510, 4, 16912);
    			attr_dev(div6, "class", "contenedor-datos");
    			attr_dev(div6, "id", "divHeaderBar");
    			add_location(div6, file$o, 495, 0, 16495);
    			attr_dev(div7, "class", "card-title");
    			add_location(div7, file$o, 668, 20, 23753);
    			attr_dev(div8, "class", "card-header");
    			add_location(div8, file$o, 667, 16, 23706);
    			textarea0.disabled = /*disabled*/ ctx[26];
    			attr_dev(textarea0, "class", "form-control");
    			set_style(textarea0, "width", "100%");
    			set_style(textarea0, "display", "block");
    			set_style(textarea0, "height", "150px");
    			attr_dev(textarea0, "rows", "3");
    			attr_dev(textarea0, "name", "Comentario");
    			attr_dev(textarea0, "data-bind", "value: atencionMedica.motivoConsulta");
    			add_location(textarea0, file$o, 671, 20, 23888);
    			attr_dev(div9, "class", "card-body");
    			add_location(div9, file$o, 670, 16, 23843);
    			attr_dev(div10, "data-bind", "if: perfil().motivoConsulta");
    			attr_dev(div10, "class", "card m-b-20 margen-mobile");
    			add_location(div10, file$o, 663, 12, 23561);
    			attr_dev(div11, "class", "card-title");
    			add_location(div11, file$o, 685, 20, 24501);
    			attr_dev(div12, "class", "card-header");
    			add_location(div12, file$o, 684, 16, 24454);
    			textarea1.disabled = /*disabled*/ ctx[26];
    			attr_dev(textarea1, "class", "form-control");
    			attr_dev(textarea1, "data-bind", "value: atencionMedica.historiaEnfermedad");
    			set_style(textarea1, "width", "100%");
    			set_style(textarea1, "display", "block");
    			set_style(textarea1, "height", "150px");
    			attr_dev(textarea1, "rows", "3");
    			attr_dev(textarea1, "name", "Comentario");
    			add_location(textarea1, file$o, 688, 20, 24643);
    			attr_dev(div13, "class", "card-body");
    			add_location(div13, file$o, 687, 16, 24598);
    			attr_dev(div14, "class", "card m-b-20 autosave");
    			add_location(div14, file$o, 683, 12, 24402);
    			attr_dev(div15, "class", "card-title");
    			add_location(div15, file$o, 1334, 20, 60867);
    			attr_dev(div16, "class", "card-header");
    			add_location(div16, file$o, 1333, 16, 60820);
    			attr_dev(i3, "class", "icon mdi  mdi-dots-vertical");
    			add_location(i3, file$o, 1344, 28, 61299);
    			attr_dev(a1, "href", "/");
    			attr_dev(a1, "data-toggle", "dropdown");
    			attr_dev(a1, "aria-haspopup", "true");
    			attr_dev(a1, "aria-expanded", "false");
    			add_location(a1, file$o, 1338, 24, 61049);
    			attr_dev(button2, "class", "dropdown-item");
    			attr_dev(button2, "type", "button");
    			add_location(button2, file$o, 1347, 28, 61473);
    			attr_dev(button3, "class", "dropdown-item");
    			attr_dev(button3, "type", "button");
    			add_location(button3, file$o, 1350, 28, 61626);
    			attr_dev(button4, "class", "dropdown-item");
    			attr_dev(button4, "type", "button");
    			add_location(button4, file$o, 1353, 28, 61787);
    			attr_dev(div17, "class", "dropdown-menu dropdown-menu-right");
    			add_location(div17, file$o, 1346, 24, 61396);
    			attr_dev(div18, "class", "dropdown");
    			add_location(div18, file$o, 1337, 20, 61001);
    			attr_dev(div19, "class", "card-controls");
    			add_location(div19, file$o, 1336, 16, 60952);
    			textarea2.disabled = /*disabled*/ ctx[26];
    			attr_dev(textarea2, "class", "form-control");
    			set_style(textarea2, "width", "100%");
    			set_style(textarea2, "display", "block");
    			attr_dev(textarea2, "rows", "5");
    			attr_dev(textarea2, "name", "Comentario");
    			add_location(textarea2, file$o, 1360, 20, 62070);
    			attr_dev(div20, "class", "card-body");
    			add_location(div20, file$o, 1359, 16, 62025);
    			attr_dev(div21, "class", "card m-b-20 autosave");
    			add_location(div21, file$o, 1332, 12, 60768);
    			attr_dev(div22, "class", "card-title");
    			add_location(div22, file$o, 1429, 20, 65657);
    			attr_dev(div23, "class", "card-header");
    			add_location(div23, file$o, 1428, 16, 65610);
    			attr_dev(i4, "class", "icon mdi  mdi-dots-vertical");
    			add_location(i4, file$o, 1439, 28, 66088);
    			attr_dev(a2, "href", "/");
    			attr_dev(a2, "data-toggle", "dropdown");
    			attr_dev(a2, "aria-haspopup", "true");
    			attr_dev(a2, "aria-expanded", "false");
    			add_location(a2, file$o, 1433, 24, 65838);
    			attr_dev(i5, "class", "mdi mdi-plus");
    			add_location(i5, file$o, 1445, 33, 66419);
    			attr_dev(button5, "class", "dropdown-item text-success");
    			attr_dev(button5, "type", "button");
    			add_location(button5, file$o, 1442, 28, 66262);
    			attr_dev(div24, "class", "dropdown-menu dropdown-menu-right");
    			add_location(div24, file$o, 1441, 24, 66185);
    			attr_dev(div25, "class", "dropdown");
    			add_location(div25, file$o, 1432, 20, 65790);
    			attr_dev(div26, "class", "card-controls");
    			add_location(div26, file$o, 1431, 16, 65741);
    			input0.disabled = /*disabled*/ ctx[26];
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "id", "txtBusquedaProblemaMedico");
    			attr_dev(input0, "data-toggle", "dropdown");
    			attr_dev(input0, "aria-haspopup", "true");
    			attr_dev(input0, "aria-expanded", "true");
    			attr_dev(input0, "autocomplete", "off");
    			add_location(input0, file$o, 1457, 32, 66936);
    			attr_dev(i6, "class", "mdi mdi-plus");
    			add_location(i6, file$o, 1500, 49, 69678);
    			attr_dev(a3, "href", "#!");
    			add_location(a3, file$o, 1494, 44, 69266);
    			attr_dev(li, "class", "defecto");
    			add_location(li, file$o, 1493, 40, 69200);
    			attr_dev(div27, "class", "contenidoLista");
    			add_location(div27, file$o, 1475, 36, 68039);
    			attr_dev(ul0, "class", "lista-buscador dropdown-menu");
    			attr_dev(ul0, "id", "buscador");
    			attr_dev(ul0, "x-placement", "top-start");
    			set_style(ul0, "position", "absolute");
    			set_style(ul0, "will-change", "transform");
    			set_style(ul0, "top", "0px");
    			set_style(ul0, "left", "0px");
    			set_style(ul0, "transform", "translate3d(0px, -128px, 0px)");
    			set_style(ul0, "border-radius", "5px");
    			add_location(ul0, file$o, 1469, 32, 67605);
    			attr_dev(div28, "class", "form-group buscardor dropdown dropdown-vnc");
    			add_location(div28, file$o, 1454, 28, 66783);
    			attr_dev(div29, "class", "col-12");
    			add_location(div29, file$o, 1453, 24, 66733);
    			attr_dev(ul1, "class", "list-info");
    			add_location(ul1, file$o, 1511, 28, 70154);
    			attr_dev(div30, "class", "col-md-12");
    			add_location(div30, file$o, 1510, 24, 70101);
    			attr_dev(div31, "class", "row");
    			add_location(div31, file$o, 1452, 20, 66690);
    			attr_dev(div32, "class", "card-body");
    			add_location(div32, file$o, 1451, 16, 66645);
    			attr_dev(div33, "class", "card m-b-20");
    			add_location(div33, file$o, 1427, 12, 65567);
    			attr_dev(div34, "class", "card-title");
    			add_location(div34, file$o, 1607, 20, 75719);
    			attr_dev(div35, "class", "card-header");
    			add_location(div35, file$o, 1606, 16, 75672);
    			textarea3.disabled = /*disabled*/ ctx[26];
    			attr_dev(textarea3, "class", "form-control");
    			set_style(textarea3, "width", "100%");
    			set_style(textarea3, "display", "block");
    			set_style(textarea3, "height", "150px");
    			attr_dev(textarea3, "rows", "3");
    			add_location(textarea3, file$o, 1610, 20, 75849);
    			attr_dev(div36, "class", "card-body");
    			add_location(div36, file$o, 1609, 16, 75804);
    			attr_dev(div37, "class", "card m-b-20 margen-mobile autosave");
    			add_location(div37, file$o, 1605, 12, 75606);
    			attr_dev(div38, "class", "card-title");
    			add_location(div38, file$o, 1625, 28, 76432);
    			attr_dev(div39, "class", "card-header");
    			add_location(div39, file$o, 1624, 24, 76377);
    			attr_dev(label0, "for", "");
    			add_location(label0, file$o, 1632, 36, 76809);
    			attr_dev(input1, "type", "date");
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "placeholder", "Fecha");
    			input1.disabled = true;
    			add_location(input1, file$o, 1633, 36, 76874);
    			attr_dev(div40, "class", "form-group floating-label col-md-6 show-label");
    			add_location(div40, file$o, 1629, 32, 76641);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$o, 1644, 36, 77448);
    			attr_dev(input2, "type", "time");
    			attr_dev(input2, "placeholder", "Hora");
    			attr_dev(input2, "class", "form-control");
    			input2.disabled = true;
    			add_location(input2, file$o, 1645, 36, 77512);
    			attr_dev(div41, "class", "form-group floating-label col-md-6 show-label");
    			add_location(div41, file$o, 1641, 32, 77280);
    			attr_dev(div42, "class", "form-row");
    			add_location(div42, file$o, 1628, 28, 76585);
    			attr_dev(div43, "class", "card-body");
    			add_location(div43, file$o, 1627, 24, 76532);
    			attr_dev(div44, "class", "card m-b-20");
    			add_location(div44, file$o, 1623, 20, 76326);
    			attr_dev(div45, "class", "col-lg-6");
    			add_location(div45, file$o, 1622, 16, 76282);
    			attr_dev(div46, "class", "row");
    			add_location(div46, file$o, 1621, 12, 76247);
    			attr_dev(div47, "class", "col-lg-12");
    			set_style(div47, "margin-top", "150px");
    			add_location(div47, file$o, 662, 8, 23498);
    			attr_dev(div48, "class", "container m-b-30");
    			add_location(div48, file$o, 661, 4, 23458);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$o, 660, 0, 23427);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(asideatencion, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div6, anchor);
    			if (if_block0) if_block0.m(div6, null);
    			append_dev(div6, t1);
    			if (if_block1) if_block1.m(div6, null);
    			append_dev(div6, t2);
    			if (if_block2) if_block2.m(div6, null);
    			append_dev(div6, t3);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, h5);
    			append_dev(h5, span0);
    			append_dev(h5, t5);
    			append_dev(h5, span1);
    			append_dev(span1, t6);
    			append_dev(span1, t7);
    			append_dev(span1, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div2);
    			append_dev(div2, div1);
    			if (if_block3) if_block3.m(div1, null);
    			append_dev(div1, t10);
    			if (if_block4) if_block4.m(div1, null);
    			append_dev(div1, t11);
    			if (if_block5) if_block5.m(div1, null);
    			append_dev(div5, t12);
    			if (if_block6) if_block6.m(div5, null);
    			append_dev(div5, t13);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(button0, i0);
    			append_dev(button0, t14);
    			append_dev(button0, sapn0);
    			append_dev(div3, t16);
    			if (if_block7) if_block7.m(div3, null);
    			append_dev(div3, t17);
    			append_dev(div3, a0);
    			append_dev(a0, i1);
    			append_dev(a0, t18);
    			append_dev(a0, sapn1);
    			append_dev(div3, t20);
    			append_dev(div3, button1);
    			append_dev(button1, i2);
    			append_dev(button1, t21);
    			append_dev(div3, t22);
    			if (if_block8) if_block8.m(div3, null);
    			insert_dev(target, t23, anchor);
    			mount_component(header, target, anchor);
    			insert_dev(target, t24, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, div48);
    			append_dev(div48, div47);
    			append_dev(div47, div10);
    			append_dev(div10, div8);
    			append_dev(div8, div7);
    			append_dev(div10, t26);
    			append_dev(div10, div9);
    			append_dev(div9, textarea0);
    			set_input_value(textarea0, /*historia*/ ctx[7].motivoConsulta);
    			append_dev(div47, t27);
    			append_dev(div47, div14);
    			append_dev(div14, div12);
    			append_dev(div12, div11);
    			append_dev(div14, t29);
    			append_dev(div14, div13);
    			append_dev(div13, textarea1);
    			set_input_value(textarea1, /*historia*/ ctx[7].historiaEnfermedad);
    			append_dev(div47, t30);
    			if (if_block9) if_block9.m(div47, null);
    			append_dev(div47, t31);
    			if (if_block10) if_block10.m(div47, null);
    			append_dev(div47, t32);
    			if (if_block11) if_block11.m(div47, null);
    			append_dev(div47, t33);
    			append_dev(div47, div21);
    			append_dev(div21, div16);
    			append_dev(div16, div15);
    			append_dev(div21, t35);
    			append_dev(div21, div19);
    			append_dev(div19, div18);
    			append_dev(div18, a1);
    			append_dev(a1, i3);
    			append_dev(div18, t36);
    			append_dev(div18, div17);
    			append_dev(div17, button2);
    			append_dev(div17, t38);
    			append_dev(div17, button3);
    			append_dev(div17, t40);
    			append_dev(div17, button4);
    			append_dev(div21, t42);
    			append_dev(div21, div20);
    			append_dev(div20, textarea2);
    			set_input_value(textarea2, /*historia*/ ctx[7].examenFisico);
    			append_dev(div47, t43);
    			if (if_block12) if_block12.m(div47, null);
    			append_dev(div47, t44);
    			append_dev(div47, div33);
    			append_dev(div33, div23);
    			append_dev(div23, div22);
    			append_dev(div33, t46);
    			append_dev(div33, div26);
    			append_dev(div26, div25);
    			append_dev(div25, a2);
    			append_dev(a2, i4);
    			append_dev(div25, t47);
    			append_dev(div25, div24);
    			append_dev(div24, button5);
    			append_dev(button5, i5);
    			append_dev(button5, t48);
    			append_dev(div33, t49);
    			append_dev(div33, div32);
    			append_dev(div32, div31);
    			append_dev(div31, div29);
    			append_dev(div29, div28);
    			append_dev(div28, input0);
    			set_input_value(input0, /*inpBuscarDiagnostico*/ ctx[4]);
    			append_dev(div28, t50);
    			append_dev(div28, ul0);
    			append_dev(ul0, div27);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div27, null);
    			}

    			append_dev(div27, t51);
    			append_dev(div27, li);
    			append_dev(li, a3);
    			append_dev(a3, i6);
    			append_dev(a3, t52);
    			append_dev(div31, t53);
    			append_dev(div31, div30);
    			append_dev(div30, ul1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul1, null);
    			}

    			append_dev(ul1, t54);
    			if (if_block13) if_block13.m(ul1, null);
    			append_dev(div47, t55);
    			mount_component(ordenesmedicas, div47, null);
    			append_dev(div47, t56);
    			append_dev(div47, div37);
    			append_dev(div37, div35);
    			append_dev(div35, div34);
    			append_dev(div37, t58);
    			append_dev(div37, div36);
    			append_dev(div36, textarea3);
    			set_input_value(textarea3, /*historia*/ ctx[7].observaciones);
    			append_dev(div47, t59);
    			append_dev(div47, div46);
    			append_dev(div46, div45);
    			append_dev(div45, div44);
    			append_dev(div44, div39);
    			append_dev(div39, div38);
    			append_dev(div44, t61);
    			append_dev(div44, div43);
    			append_dev(div43, div42);
    			append_dev(div42, div40);
    			append_dev(div40, label0);
    			append_dev(div40, t63);
    			append_dev(div40, input1);
    			set_input_value(input1, /*fecha*/ ctx[11]);
    			append_dev(div42, t64);
    			append_dev(div42, div41);
    			append_dev(div41, label1);
    			append_dev(div41, t66);
    			append_dev(div41, input2);
    			set_input_value(input2, /*hora*/ ctx[12]);
    			insert_dev(target, t67, anchor);
    			mount_component(modaldatospaciente, target, anchor);
    			insert_dev(target, t68, anchor);
    			mount_component(modaltratamientos, target, anchor);
    			insert_dev(target, t69, anchor);
    			mount_component(modalinterconsulta, target, anchor);
    			insert_dev(target, t70, anchor);
    			mount_component(modalantecedentes, target, anchor);
    			insert_dev(target, t71, anchor);
    			mount_component(modalnuevacita, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button1, "click", prevent_default(/*click_handler_2*/ ctx[45]), false, true, false),
    					listen_dev(textarea0, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(textarea0, "input", /*textarea0_input_handler*/ ctx[47]),
    					listen_dev(textarea1, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(textarea1, "input", /*textarea1_input_handler*/ ctx[48]),
    					listen_dev(textarea2, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(textarea2, "input", /*textarea2_input_handler*/ ctx[85]),
    					listen_dev(input0, "keyup", /*searchDiagnosticos*/ ctx[32], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler_3*/ ctx[88]),
    					listen_dev(a3, "click", prevent_default(/*click_handler_6*/ ctx[90]), false, true, false),
    					listen_dev(textarea3, "blur", /*guardarHistoria*/ ctx[41], false, false, false),
    					listen_dev(textarea3, "input", /*textarea3_input_handler*/ ctx[103]),
    					listen_dev(input1, "input", /*input1_input_handler_3*/ ctx[104]),
    					listen_dev(input2, "blur", /*blur_handler*/ ctx[105], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler_3*/ ctx[106])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*errorServer*/ ctx[20]) {
    				if (if_block0) {
    					if (dirty[0] & /*errorServer*/ 1048576) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_19(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div6, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*serverConexion*/ ctx[23]) {
    				if (if_block1) {
    					if (dirty[0] & /*serverConexion*/ 8388608) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_18(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div6, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*cargandoHistoria*/ ctx[24]) {
    				if (if_block2) {
    					if (dirty[0] & /*cargandoHistoria*/ 16777216) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_17(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div6, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*paciente*/ 2) && t6_value !== (t6_value = /*paciente*/ ctx[1].nombres + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty[0] & /*paciente*/ 2) && t8_value !== (t8_value = /*paciente*/ ctx[1].apellidos + "")) set_data_dev(t8, t8_value);

    			if (!/*cargando*/ ctx[13] && !/*errorServer*/ ctx[20]) {
    				if (if_block3) ; else {
    					if_block3 = create_if_block_16(ctx);
    					if_block3.c();
    					if_block3.m(div1, t10);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (/*errorServer*/ ctx[20]) {
    				if (if_block4) ; else {
    					if_block4 = create_if_block_15(ctx);
    					if_block4.c();
    					if_block4.m(div1, t11);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (/*cargando*/ ctx[13] && !/*errorServer*/ ctx[20]) {
    				if (if_block5) ; else {
    					if_block5 = create_if_block_14(ctx);
    					if_block5.c();
    					if_block5.m(div1, null);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*historia*/ ctx[7].estado === "A") {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);
    				} else {
    					if_block6 = create_if_block_13(ctx);
    					if_block6.c();
    					if_block6.m(div5, t13);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}

    			if (show_if) if_block7.p(ctx, dirty);

    			if (!current || dirty[0] & /*params*/ 1 && a0_href_value !== (a0_href_value = `/#/pacientes/${/*params*/ ctx[0].idPaciente}/historias/${/*params*/ ctx[0].idHistoria}/imprimir`)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (/*historia*/ ctx[7].estado === "A") {
    				if (if_block8) {
    					if_block8.p(ctx, dirty);
    				} else {
    					if_block8 = create_if_block_9(ctx);
    					if_block8.c();
    					if_block8.m(div3, null);
    				}
    			} else if (if_block8) {
    				if_block8.d(1);
    				if_block8 = null;
    			}

    			if (!current || dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(textarea0, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historia*/ 128) {
    				set_input_value(textarea0, /*historia*/ ctx[7].motivoConsulta);
    			}

    			if (!current || dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(textarea1, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historia*/ 128) {
    				set_input_value(textarea1, /*historia*/ ctx[7].historiaEnfermedad);
    			}

    			if (/*empresa*/ ctx[21].historiaGinecologica) {
    				if (if_block9) {
    					if_block9.p(ctx, dirty);
    				} else {
    					if_block9 = create_if_block_8(ctx);
    					if_block9.c();
    					if_block9.m(div47, t31);
    				}
    			} else if (if_block9) {
    				if_block9.d(1);
    				if_block9 = null;
    			}

    			if (/*empresa*/ ctx[21].signosVitales) {
    				if (if_block10) {
    					if_block10.p(ctx, dirty);
    				} else {
    					if_block10 = create_if_block_7(ctx);
    					if_block10.c();
    					if_block10.m(div47, t32);
    				}
    			} else if (if_block10) {
    				if_block10.d(1);
    				if_block10 = null;
    			}

    			if (/*empresa*/ ctx[21].otrosParametros) {
    				if (if_block11) {
    					if_block11.p(ctx, dirty);
    				} else {
    					if_block11 = create_if_block_6$1(ctx);
    					if_block11.c();
    					if_block11.m(div47, t33);
    				}
    			} else if (if_block11) {
    				if_block11.d(1);
    				if_block11 = null;
    			}

    			if (!current || dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(textarea2, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historia*/ 128) {
    				set_input_value(textarea2, /*historia*/ ctx[7].examenFisico);
    			}

    			if (/*empresa*/ ctx[21].exploracionFisica) {
    				if (if_block12) {
    					if_block12.p(ctx, dirty);
    				} else {
    					if_block12 = create_if_block_3$3(ctx);
    					if_block12.c();
    					if_block12.m(div47, t44);
    				}
    			} else if (if_block12) {
    				if_block12.d(1);
    				if_block12 = null;
    			}

    			if (!current || dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(input0, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*inpBuscarDiagnostico*/ 16 && input0.value !== /*inpBuscarDiagnostico*/ ctx[4]) {
    				set_input_value(input0, /*inpBuscarDiagnostico*/ ctx[4]);
    			}

    			if (dirty[0] & /*filtroDiagnostico*/ 134217728 | dirty[1] & /*seleccionarDiagnostico*/ 2048) {
    				each_value_1 = /*filtroDiagnostico*/ ctx[27];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$4(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div27, t51);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty[0] & /*disabled, diagnosticosSeleccionados*/ 67108896 | dirty[1] & /*guardarHistoria, eliminarDiagnostico, agregarComentarioDiagnostico*/ 1184) {
    				each_value = /*diagnosticosSeleccionados*/ ctx[5];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul1, t54);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*diagnosticosSeleccionados*/ ctx[5].length === 0) {
    				if (if_block13) ; else {
    					if_block13 = create_if_block$d(ctx);
    					if_block13.c();
    					if_block13.m(ul1, null);
    				}
    			} else if (if_block13) {
    				if_block13.d(1);
    				if_block13 = null;
    			}

    			const ordenesmedicas_changes = {};
    			if (dirty[0] & /*disabled*/ 67108864) ordenesmedicas_changes.disabled = /*disabled*/ ctx[26];

    			if (!updating_idHistoria && dirty[0] & /*params*/ 1) {
    				updating_idHistoria = true;
    				ordenesmedicas_changes.idHistoria = /*params*/ ctx[0].idHistoria;
    				add_flush_callback(() => updating_idHistoria = false);
    			}

    			if (!updating_idPaciente && dirty[0] & /*params*/ 1) {
    				updating_idPaciente = true;
    				ordenesmedicas_changes.idPaciente = /*params*/ ctx[0].idPaciente;
    				add_flush_callback(() => updating_idPaciente = false);
    			}

    			if (!updating_estudiosSeleccionados && dirty[0] & /*estudiosSeleccionados*/ 262144) {
    				updating_estudiosSeleccionados = true;
    				ordenesmedicas_changes.estudiosSeleccionados = /*estudiosSeleccionados*/ ctx[18];
    				add_flush_callback(() => updating_estudiosSeleccionados = false);
    			}

    			if (!updating_medicamentosSeleccionados && dirty[0] & /*medicamentosSeleccionados*/ 32768) {
    				updating_medicamentosSeleccionados = true;
    				ordenesmedicas_changes.medicamentosSeleccionados = /*medicamentosSeleccionados*/ ctx[15];
    				add_flush_callback(() => updating_medicamentosSeleccionados = false);
    			}

    			if (!updating_sltBuscarMedicamentos && dirty[0] & /*sltBuscarMedicamentos*/ 16384) {
    				updating_sltBuscarMedicamentos = true;
    				ordenesmedicas_changes.sltBuscarMedicamentos = /*sltBuscarMedicamentos*/ ctx[14];
    				add_flush_callback(() => updating_sltBuscarMedicamentos = false);
    			}

    			if (!updating_sltBuscarEstudios && dirty[0] & /*sltBuscarEstudios*/ 65536) {
    				updating_sltBuscarEstudios = true;
    				ordenesmedicas_changes.sltBuscarEstudios = /*sltBuscarEstudios*/ ctx[16];
    				add_flush_callback(() => updating_sltBuscarEstudios = false);
    			}

    			if (!updating_medicamentos && dirty[0] & /*medicamentos*/ 64) {
    				updating_medicamentos = true;
    				ordenesmedicas_changes.medicamentos = /*medicamentos*/ ctx[6];
    				add_flush_callback(() => updating_medicamentos = false);
    			}

    			if (!updating_instrucciones && dirty[0] & /*historia*/ 128) {
    				updating_instrucciones = true;
    				ordenesmedicas_changes.instrucciones = /*historia*/ ctx[7].instrucciones;
    				add_flush_callback(() => updating_instrucciones = false);
    			}

    			if (!updating_estudios && dirty[0] & /*estudios*/ 131072) {
    				updating_estudios = true;
    				ordenesmedicas_changes.estudios = /*estudios*/ ctx[17];
    				add_flush_callback(() => updating_estudios = false);
    			}

    			ordenesmedicas.$set(ordenesmedicas_changes);

    			if (!current || dirty[0] & /*disabled*/ 67108864) {
    				prop_dev(textarea3, "disabled", /*disabled*/ ctx[26]);
    			}

    			if (dirty[0] & /*historia*/ 128) {
    				set_input_value(textarea3, /*historia*/ ctx[7].observaciones);
    			}

    			if (dirty[0] & /*fecha*/ 2048) {
    				set_input_value(input1, /*fecha*/ ctx[11]);
    			}

    			if (dirty[0] & /*hora*/ 4096) {
    				set_input_value(input2, /*hora*/ ctx[12]);
    			}

    			const modaldatospaciente_changes = {};
    			if (dirty[0] & /*paciente*/ 2) modaldatospaciente_changes.paciente = /*paciente*/ ctx[1];
    			if (dirty[0] & /*edad*/ 4) modaldatospaciente_changes.edad = /*edad*/ ctx[2];
    			if (dirty[0] & /*seguro*/ 8) modaldatospaciente_changes.seguro = /*seguro*/ ctx[3];
    			modaldatospaciente.$set(modaldatospaciente_changes);
    			const modalnuevacita_changes = {};
    			if (dirty[0] & /*pacienteSeleccionado*/ 33554432) modalnuevacita_changes.pacienteSeleccionado = /*pacienteSeleccionado*/ ctx[25];
    			modalnuevacita.$set(modalnuevacita_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(asideatencion.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(header.$$.fragment, local);
    			transition_in(ordenesmedicas.$$.fragment, local);
    			transition_in(modaldatospaciente.$$.fragment, local);
    			transition_in(modaltratamientos.$$.fragment, local);
    			transition_in(modalinterconsulta.$$.fragment, local);
    			transition_in(modalantecedentes.$$.fragment, local);
    			transition_in(modalnuevacita.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(asideatencion.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(header.$$.fragment, local);
    			transition_out(ordenesmedicas.$$.fragment, local);
    			transition_out(modaldatospaciente.$$.fragment, local);
    			transition_out(modaltratamientos.$$.fragment, local);
    			transition_out(modalinterconsulta.$$.fragment, local);
    			transition_out(modalantecedentes.$$.fragment, local);
    			transition_out(modalnuevacita.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(asideatencion, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div6);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    			if (if_block8) if_block8.d();
    			if (detaching) detach_dev(t23);
    			destroy_component(header, detaching);
    			if (detaching) detach_dev(t24);
    			if (detaching) detach_dev(main);
    			if (if_block9) if_block9.d();
    			if (if_block10) if_block10.d();
    			if (if_block11) if_block11.d();
    			if (if_block12) if_block12.d();
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if (if_block13) if_block13.d();
    			destroy_component(ordenesmedicas);
    			if (detaching) detach_dev(t67);
    			destroy_component(modaldatospaciente, detaching);
    			if (detaching) detach_dev(t68);
    			destroy_component(modaltratamientos, detaching);
    			if (detaching) detach_dev(t69);
    			destroy_component(modalinterconsulta, detaching);
    			if (detaching) detach_dev(t70);
    			destroy_component(modalantecedentes, detaching);
    			if (detaching) detach_dev(t71);
    			destroy_component(modalnuevacita, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function calcularEdad$2(fecha) {
    	var hoy = new Date();
    	var cumpleanos = new Date(fecha);
    	var edad = hoy.getFullYear() - cumpleanos.getFullYear();
    	var m = hoy.getMonth() - cumpleanos.getMonth();

    	if (m < 0 || m === 0 && hoy.getDate() < cumpleanos.getDate()) {
    		edad--;
    	}

    	return edad;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HistoriaClinica", slots, []);

    	const Toast = Swal.mixin({
    		toast: true,
    		position: "top-end",
    		showConfirmButton: false,
    		timer: 3000,
    		timerProgressBar: true,
    		didOpen: toast => {
    			toast.addEventListener("mouseenter", Swal.stopTimer);
    			toast.addEventListener("mouseleave", Swal.resumeTimer);
    		}
    	});

    	let { params = "" } = $$props;
    	let paciente = {};
    	let edad = "";
    	let seguro = "";
    	let diagnosticos = [];
    	let inpBuscarDiagnostico = "";
    	let diagnosticosSeleccionados = [];
    	let medicamentos = [];
    	let historia = {};
    	let temperatura = {};
    	let presionAlterial = {};
    	let peso = {};
    	let timeout = null;
    	let fecha = "";
    	let hora = "";
    	let cargando = false;
    	let sltBuscarMedicamentos = "";
    	let medicamentosSeleccionados = [];
    	let sltBuscarEstudios = "";
    	let estudios = [];
    	let estudiosSeleccionados = [];
    	let historiaGinecologica = {};
    	let errorServer = false;
    	let empresa = {};
    	let exploracionFisica = [];
    	let serverConexion = false;
    	let cargandoHistoria = false;
    	let pacienteSeleccionado = {};
    	let disabled = false;

    	const cargarEmpresa = () => {
    		const config = {
    			method: "get",
    			url: `${url}/empresas/${user().empresa}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(21, empresa = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const abrirHistoria = id => {
    		Swal.fire({
    			title: "Ests seguro?",
    			text: "Se abrir la historia y tendra acceso a modificarla de nuevo!",
    			icon: "warning",
    			showCancelButton: true,
    			confirmButtonColor: "#3085d6",
    			cancelButtonColor: "#d33",
    			confirmButtonText: "Si, Abirla!",
    			cancelButtonText: "Cancelar"
    		}).then(result => {
    			if (result.isConfirmed) {
    				const config = {
    					method: "put",
    					url: `${url}/historias/${id}/abrir`,
    					headers: {
    						Authorization: `${localStorage.getItem("auth")}`
    					}
    				};

    				axios$1(config).then(res => {
    					if (res.status === 200) {
    						cargarHistoria();
    					}
    				}).catch(err => {
    					
    				});
    			}
    		});
    	};

    	const cerrarHistoria = id => {
    		Swal.fire({
    			title: "Ests seguro?",
    			text: "Se cerrara la historia y no podra modificarla en el futuro!",
    			icon: "warning",
    			showCancelButton: true,
    			confirmButtonColor: "#3085d6",
    			cancelButtonColor: "#d33",
    			confirmButtonText: "Si, Cerrarla!",
    			cancelButtonText: "Cancelar"
    		}).then(result => {
    			if (result.isConfirmed) {
    				const config = {
    					method: "put",
    					url: `${url}/historias/${id}/cerrar`,
    					headers: {
    						Authorization: `${localStorage.getItem("auth")}`
    					}
    				};

    				axios$1(config).then(res => {
    					if (res.status === 200) {
    						cargarHistoria();
    					}
    				}).catch(err => {
    					
    				});
    			}
    		});
    	};

    	const eliminarHistoria = id => {
    		Swal.fire({
    			title: "Ests seguro?",
    			text: "Se eliminar esta historia clnica, sin embargo, los datos no se perdern, puedes recuperarlos en el futuro!",
    			icon: "warning",
    			showCancelButton: true,
    			confirmButtonColor: "#3085d6",
    			cancelButtonColor: "#d33",
    			confirmButtonText: "Si, Eliminarlo!",
    			cancelButtonText: "Cancelar"
    		}).then(result => {
    			if (result.isConfirmed) {
    				const config = {
    					method: "delete",
    					url: `${url}/historias/${id}`,
    					headers: {
    						Authorization: `${localStorage.getItem("auth")}`
    					}
    				};

    				axios$1(config).then(res => {
    					if (res.status === 200) {
    						push(`/pacientes/perfil/${params.idPaciente}`);
    					}
    				}).catch(err => {
    					
    				});
    			}
    		});
    	};

    	const searchMedicamentos = () => {
    		if (timeout) {
    			window.clearTimeout(timeout);
    		}

    		timeout = setTimeout(
    			function () {
    				cargarMedicamentos();
    			},
    			300
    		);
    	};

    	function searchDiagnosticos() {
    		if (timeout) {
    			window.clearTimeout(timeout);
    		}

    		timeout = setTimeout(
    			function () {
    				cargarDiagnosticos();
    			},
    			300
    		);
    	}

    	const searchEstudios = () => {
    		if (timeout) {
    			window.clearTimeout(timeout);
    		}

    		timeout = setTimeout(
    			function () {
    				cargarEstudios();
    			},
    			300
    		);
    	};

    	const agregarEstudio = obj => {
    		$$invalidate(18, estudiosSeleccionados = [...estudiosSeleccionados, obj.detail]);
    		$$invalidate(7, historia.estudios = estudiosSeleccionados, historia);
    		guardarHistoria();
    		$$invalidate(16, sltBuscarEstudios = "");
    	};

    	const agregarDiagnosticoPersonalizado = nombre => {
    		const diagnostico = { d: nombre, c: "PERS", id: v4() };
    		$$invalidate(5, diagnosticosSeleccionados = [...diagnosticosSeleccionados, diagnostico]);
    		guardarHistoria();
    	};

    	const agregarComentarioDiagnostico = position => {
    		if (diagnosticosSeleccionados[position].comentario === undefined) {
    			$$invalidate(5, diagnosticosSeleccionados[position].comentario = "", diagnosticosSeleccionados);
    			$$invalidate(7, historia.diagnosticos = diagnosticosSeleccionados, historia);
    			guardarHistoria();
    		} else {
    			delete diagnosticosSeleccionados[position].comentario;
    			$$invalidate(5, diagnosticosSeleccionados);
    			$$invalidate(7, historia.diagnosticos = diagnosticosSeleccionados, historia);
    			guardarHistoria();
    		}
    	};

    	const eliminarMedicamento = event => {
    		if (confirm("Desea eliminar el medicamento?")) {
    			medicamentosSeleccionados.splice(event.detail, 1);
    			$$invalidate(15, medicamentosSeleccionados);
    			$$invalidate(7, historia.medicamentos = medicamentosSeleccionados, historia);
    			guardarHistoria();
    		}
    	};

    	const eliminarDiagnostico = position => {
    		Swal.fire({
    			title: "Esta seguro?",
    			text: "Esta accin eliminara el diagnostico de la consulta, pero puede agregarlo nuevamente luego.!",
    			icon: "warning",
    			showCancelButton: true,
    			confirmButtonColor: "#3085d6",
    			cancelButtonColor: "#d33",
    			confirmButtonText: "Si, Eliminar!",
    			cancelButtonText: "Cancelar"
    		}).then(result => {
    			if (result.isConfirmed) {
    				diagnosticosSeleccionados.splice(position, 1);
    				$$invalidate(5, diagnosticosSeleccionados);
    				$$invalidate(7, historia.diagnosticos = diagnosticosSeleccionados, historia);
    				guardarHistoria();

    				Toast.fire({
    					icon: "success",
    					title: "Se ha eliminado correctamente"
    				});
    			}
    		});
    	};

    	const eliminarEstudios = event => {
    		$$invalidate(18, estudiosSeleccionados = estudiosSeleccionados.filter(estudio => estudio.id !== event.detail));
    		$$invalidate(7, historia.estudios = estudiosSeleccionados, historia);
    		guardarHistoria();

    		Toast.fire({
    			icon: "success",
    			title: "Se ha eliminado correctamente"
    		});
    	};

    	const agregarMedicamento = event => {
    		if (!event.detail) {
    			return false;
    		}

    		const medicamento = {
    			nombre: event.detail,
    			concentracion: "",
    			cantidad: "",
    			frecuencia: ""
    		};

    		$$invalidate(15, medicamentosSeleccionados = [...medicamentosSeleccionados, medicamento]);
    		$$invalidate(7, historia.medicamentos = medicamentosSeleccionados, historia);
    		$$invalidate(14, sltBuscarMedicamentos = "");
    		guardarHistoria();
    	};

    	const cargarEstudios = () => {
    		const config = {
    			method: "get",
    			url: `${url}/estudios?b=${sltBuscarEstudios}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(17, estudios = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarMedicamentos = () => {
    		const config = {
    			method: "get",
    			url: `${url}/medicamentos?b=${sltBuscarMedicamentos}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(6, medicamentos = res.data);
    		}).catch(error => {
    			console.error(error);
    		});
    	};

    	const guardarHistoria = () => {
    		$$invalidate(20, errorServer = false);
    		$$invalidate(13, cargando = true);
    		$$invalidate(7, historia.diagnosticos = diagnosticosSeleccionados, historia);
    		delete historia.id;

    		const config = {
    			method: "put",
    			url: `${url}/historias/${params.idHistoria}`,
    			data: historia,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		try {
    			axios$1(config).then(res => {
    				$$invalidate(13, cargando = false);

    				if (res.status !== 200) {
    					$$invalidate(20, errorServer = true);
    				}
    			}).catch(error => {
    				if (error) {
    					$$invalidate(20, errorServer = true);
    					$$invalidate(13, cargando = false);
    				}

    				$$invalidate(13, cargando = false);
    				console.error(error);
    			});
    		} catch(error) {
    			$$invalidate(20, errorServer = true);
    			$$invalidate(13, cargando = false);
    		}
    	};

    	async function cargarPaciente() {
    		$$invalidate(24, cargandoHistoria = true);

    		const config = {
    			method: "get",
    			url: `${url}/pacientes/${params.idPaciente}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		try {
    			let promesa = await axios$1(config);
    			$$invalidate(24, cargandoHistoria = false);

    			if (promesa.status == 200) {
    				$$invalidate(1, paciente = await promesa.data);
    				$$invalidate(2, edad = calcularEdad$2(paciente.fechaNacimiento));

    				if (paciente.seguroMedico.length !== 0) {
    					$$invalidate(3, seguro = paciente.seguroMedico[0].nombre);
    				} else {
    					$$invalidate(3, seguro = "N/A");
    				}
    			} else {
    				$$invalidate(23, serverConexion = true);
    				console.error(promesa.statusText);
    			}
    		} catch(error) {
    			$$invalidate(24, cargandoHistoria = false);
    			$$invalidate(23, serverConexion = true);
    			console.error(promesa.statusText);
    		}
    	}

    	const cargarHistoria = async () => {
    		try {
    			const config = {
    				method: "get",
    				url: `${url}/historias/${params.idHistoria}`,
    				headers: {
    					Authorization: `${localStorage.getItem("auth")}`
    				}
    			};

    			let promesa = await axios$1(config);
    			$$invalidate(7, historia = promesa.data);
    			$$invalidate(8, temperatura = promesa.data.temperatura);
    			$$invalidate(9, presionAlterial = promesa.data.presionAlterial);
    			$$invalidate(10, peso = promesa.data.peso);
    			$$invalidate(5, diagnosticosSeleccionados = promesa.data.diagnosticos);
    			$$invalidate(11, fecha = promesa.data.fechaHora.split("T")[0]);
    			$$invalidate(15, medicamentosSeleccionados = promesa.data.medicamentos);
    			$$invalidate(18, estudiosSeleccionados = promesa.data.estudios);
    			$$invalidate(19, historiaGinecologica = promesa.data.historiaGinecologica);
    			$$invalidate(22, exploracionFisica = promesa.data.exploracionFisica || []);
    			let obtenerHora = promesa.data.fechaHora.split("T")[1].split("Z")[0].split(".")[0].split(":");
    			$$invalidate(12, hora = obtenerHora[0] + ":" + obtenerHora[1]);
    		} catch(error) {
    			$$invalidate(23, serverConexion = true);
    			console.error(error);
    		}
    	};

    	function cargarDiagnosticos() {
    		const config = {
    			method: "get",
    			url: `${url}/diagnosticos?b=${inpBuscarDiagnostico}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		setTimeout(
    			() => {
    				axios$1(config).then(res => {
    					$$invalidate(107, diagnosticos = res.data);
    				}).catch(error => {
    					console.log(error);
    				});
    			},
    			1000
    		);
    	}

    	function seleccionarDiagnostico(id) {
    		const config = {
    			method: "get",
    			url: `${url}/diagnosticos/${id}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(5, diagnosticosSeleccionados = [...diagnosticosSeleccionados, res.data]);
    			guardarHistoria();
    		});

    		$$invalidate(4, inpBuscarDiagnostico = "");
    	}

    	onMount(async () => {
    		jQuery("html, body").animate({ scrollTop: 0 }, "slow");
    		await cargarPaciente();
    		await cargarHistoria();
    		cargarDiagnosticos();
    		cargarMedicamentos();
    		cargarEstudios();
    		cargarEmpresa();
    	});

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$b.warn(`<HistoriaClinica> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => abrirHistoria(params.idHistoria);
    	const click_handler_1 = () => cerrarHistoria(params.idHistoria);

    	const click_handler_2 = () => $$invalidate(25, pacienteSeleccionado = {
    		id: paciente.id,
    		nombres: paciente.nombres,
    		apellidos: paciente.apellidos,
    		sexo: paciente.sexo,
    		fechaNacimiento: paciente.fechaNacimiento,
    		nacionalidad: paciente.nacionalidad,
    		telefono: paciente.telefono,
    		celular: paciente.celular,
    		cedula: paciente.cedula
    	});

    	const click_handler_3 = () => eliminarHistoria(params.idHistoria);

    	function textarea0_input_handler() {
    		historia.motivoConsulta = this.value;
    		$$invalidate(7, historia);
    	}

    	function textarea1_input_handler() {
    		historia.historiaEnfermedad = this.value;
    		$$invalidate(7, historia);
    	}

    	function input0_input_handler() {
    		historiaGinecologica.fechaUltimaMenstruacion = this.value;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input1_input_handler() {
    		historiaGinecologica.fechaUltimoPap = this.value;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input2_input_handler() {
    		historiaGinecologica.fechaUltimoParto = this.value;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input3_input_handler() {
    		historiaGinecologica.fechaUltimoAborto = this.value;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input4_input_handler() {
    		historiaGinecologica.fechaUltimoCesarea = this.value;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input5_input_handler() {
    		historiaGinecologica.intervaloFlujoMenstrual = to_number(this.value);
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input6_input_handler() {
    		historiaGinecologica.cantidadFlujoMenstrual = to_number(this.value);
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input7_input_handler() {
    		historiaGinecologica.duracionFlujoMenstrual = to_number(this.value);
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input8_input_handler() {
    		historiaGinecologica.gesta = to_number(this.value);
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input9_input_handler() {
    		historiaGinecologica.para = to_number(this.value);
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input10_input_handler() {
    		historiaGinecologica.abortos = to_number(this.value);
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input11_input_handler() {
    		historiaGinecologica.cesareas = to_number(this.value);
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input12_input_handler() {
    		historiaGinecologica.espontaneos = to_number(this.value);
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input13_input_handler() {
    		historiaGinecologica.provocados = to_number(this.value);
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input14_input_handler() {
    		historiaGinecologica.legrados = to_number(this.value);
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input15_change_handler() {
    		historiaGinecologica.sangradoVaginal = this.checked;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input16_change_handler() {
    		historiaGinecologica.vidaSexualActiva = this.checked;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input17_change_handler() {
    		historiaGinecologica.anticonceptivosOrales = this.checked;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input18_change_handler() {
    		historiaGinecologica.diu = this.checked;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input19_change_handler() {
    		historiaGinecologica.aqv = this.checked;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input20_change_handler() {
    		historiaGinecologica.condon = this.checked;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input21_change_handler() {
    		historiaGinecologica.norplant = this.checked;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input22_change_handler() {
    		historiaGinecologica.ritmo = this.checked;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input23_change_handler() {
    		historiaGinecologica.coitoInterruptus = this.checked;
    		$$invalidate(19, historiaGinecologica);
    	}

    	function input0_input_handler_1() {
    		temperatura.valor = to_number(this.value);
    		$$invalidate(8, temperatura);
    	}

    	function select_change_handler() {
    		temperatura.tipo = select_value(this);
    		$$invalidate(8, temperatura);
    	}

    	function input1_input_handler_1() {
    		historia.frecuenciaRespiratoria = to_number(this.value);
    		$$invalidate(7, historia);
    	}

    	function input2_input_handler_1() {
    		historia.frecuenciaCardiaca = to_number(this.value);
    		$$invalidate(7, historia);
    	}

    	function input3_input_handler_1() {
    		presionAlterial.mm = to_number(this.value);
    		$$invalidate(9, presionAlterial);
    	}

    	function input4_input_handler_1() {
    		presionAlterial.Hg = to_number(this.value);
    		$$invalidate(9, presionAlterial);
    	}

    	function input0_input_handler_2() {
    		peso.valor = to_number(this.value);
    		$$invalidate(10, peso);
    	}

    	function select_change_handler_1() {
    		peso.tipo = select_value(this);
    		$$invalidate(10, peso);
    	}

    	function input1_input_handler_2() {
    		historia.escalaGalsgow = to_number(this.value);
    		$$invalidate(7, historia);
    	}

    	function input2_input_handler_2() {
    		historia.escalaDolor = to_number(this.value);
    		$$invalidate(7, historia);
    	}

    	function input3_input_handler_2() {
    		historia.saturacionOxigeno = to_number(this.value);
    		$$invalidate(7, historia);
    	}

    	function input4_input_handler_2() {
    		historia.otrosParametros = this.value;
    		$$invalidate(7, historia);
    	}

    	function textarea2_input_handler() {
    		historia.examenFisico = this.value;
    		$$invalidate(7, historia);
    	}

    	const click_handler_4 = (item, each_value_3, item_index_1) => {
    		$$invalidate(22, each_value_3[item_index_1].activo = true, exploracionFisica);
    		guardarHistoria();
    	};

    	function textarea_input_handler(each_value_2, item_index) {
    		each_value_2[item_index].text = this.value;
    		$$invalidate(22, exploracionFisica);
    	}

    	function input0_input_handler_3() {
    		inpBuscarDiagnostico = this.value;
    		$$invalidate(4, inpBuscarDiagnostico);
    	}

    	const click_handler_5 = diagnostico => seleccionarDiagnostico(diagnostico.c);
    	const click_handler_6 = () => agregarDiagnosticoPersonalizado(inpBuscarDiagnostico);
    	const click_handler_7 = i => agregarComentarioDiagnostico(i);
    	const click_handler_8 = i => eliminarDiagnostico(i);

    	function input_input_handler(each_value, i) {
    		each_value[i].comentario = this.value;
    		$$invalidate(5, diagnosticosSeleccionados);
    	}

    	function ordenesmedicas_idHistoria_binding(value) {
    		params.idHistoria = value;
    		$$invalidate(0, params);
    	}

    	function ordenesmedicas_idPaciente_binding(value) {
    		params.idPaciente = value;
    		$$invalidate(0, params);
    	}

    	function ordenesmedicas_estudiosSeleccionados_binding(value) {
    		estudiosSeleccionados = value;
    		$$invalidate(18, estudiosSeleccionados);
    	}

    	function ordenesmedicas_medicamentosSeleccionados_binding(value) {
    		medicamentosSeleccionados = value;
    		$$invalidate(15, medicamentosSeleccionados);
    	}

    	function ordenesmedicas_sltBuscarMedicamentos_binding(value) {
    		sltBuscarMedicamentos = value;
    		$$invalidate(14, sltBuscarMedicamentos);
    	}

    	function ordenesmedicas_sltBuscarEstudios_binding(value) {
    		sltBuscarEstudios = value;
    		$$invalidate(16, sltBuscarEstudios);
    	}

    	function ordenesmedicas_medicamentos_binding(value) {
    		medicamentos = value;
    		$$invalidate(6, medicamentos);
    	}

    	function ordenesmedicas_instrucciones_binding(value) {
    		historia.instrucciones = value;
    		$$invalidate(7, historia);
    	}

    	function ordenesmedicas_estudios_binding(value) {
    		estudios = value;
    		$$invalidate(17, estudios);
    	}

    	function textarea3_input_handler() {
    		historia.observaciones = this.value;
    		$$invalidate(7, historia);
    	}

    	function input1_input_handler_3() {
    		fecha = this.value;
    		$$invalidate(11, fecha);
    	}

    	const blur_handler = () => console.log(hora);

    	function input2_input_handler_3() {
    		hora = this.value;
    		$$invalidate(12, hora);
    	}

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		link,
    		push,
    		Loading,
    		axios: axios$1,
    		onMount,
    		url,
    		user,
    		uuid: v4,
    		Header,
    		AsideAtencion,
    		ModalDatosPaciente,
    		ModalTratamientos,
    		ModalInterconsulta,
    		ModalAntecedentes,
    		OrdenesMedicas,
    		SignosVitales,
    		ErrorServer: ErrorConexion,
    		NoConexion,
    		ErrorConexion,
    		ModalNuevaCita,
    		Toast,
    		params,
    		paciente,
    		edad,
    		seguro,
    		diagnosticos,
    		inpBuscarDiagnostico,
    		diagnosticosSeleccionados,
    		medicamentos,
    		historia,
    		temperatura,
    		presionAlterial,
    		peso,
    		timeout,
    		fecha,
    		hora,
    		cargando,
    		sltBuscarMedicamentos,
    		medicamentosSeleccionados,
    		sltBuscarEstudios,
    		estudios,
    		estudiosSeleccionados,
    		historiaGinecologica,
    		errorServer,
    		empresa,
    		exploracionFisica,
    		serverConexion,
    		cargandoHistoria,
    		pacienteSeleccionado,
    		disabled,
    		cargarEmpresa,
    		abrirHistoria,
    		cerrarHistoria,
    		eliminarHistoria,
    		searchMedicamentos,
    		searchDiagnosticos,
    		searchEstudios,
    		agregarEstudio,
    		agregarDiagnosticoPersonalizado,
    		agregarComentarioDiagnostico,
    		eliminarMedicamento,
    		eliminarDiagnostico,
    		eliminarEstudios,
    		agregarMedicamento,
    		cargarEstudios,
    		cargarMedicamentos,
    		guardarHistoria,
    		cargarPaciente,
    		cargarHistoria,
    		cargarDiagnosticos,
    		seleccionarDiagnostico,
    		calcularEdad: calcularEdad$2,
    		filtroDiagnostico
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    		if ("paciente" in $$props) $$invalidate(1, paciente = $$props.paciente);
    		if ("edad" in $$props) $$invalidate(2, edad = $$props.edad);
    		if ("seguro" in $$props) $$invalidate(3, seguro = $$props.seguro);
    		if ("diagnosticos" in $$props) $$invalidate(107, diagnosticos = $$props.diagnosticos);
    		if ("inpBuscarDiagnostico" in $$props) $$invalidate(4, inpBuscarDiagnostico = $$props.inpBuscarDiagnostico);
    		if ("diagnosticosSeleccionados" in $$props) $$invalidate(5, diagnosticosSeleccionados = $$props.diagnosticosSeleccionados);
    		if ("medicamentos" in $$props) $$invalidate(6, medicamentos = $$props.medicamentos);
    		if ("historia" in $$props) $$invalidate(7, historia = $$props.historia);
    		if ("temperatura" in $$props) $$invalidate(8, temperatura = $$props.temperatura);
    		if ("presionAlterial" in $$props) $$invalidate(9, presionAlterial = $$props.presionAlterial);
    		if ("peso" in $$props) $$invalidate(10, peso = $$props.peso);
    		if ("timeout" in $$props) timeout = $$props.timeout;
    		if ("fecha" in $$props) $$invalidate(11, fecha = $$props.fecha);
    		if ("hora" in $$props) $$invalidate(12, hora = $$props.hora);
    		if ("cargando" in $$props) $$invalidate(13, cargando = $$props.cargando);
    		if ("sltBuscarMedicamentos" in $$props) $$invalidate(14, sltBuscarMedicamentos = $$props.sltBuscarMedicamentos);
    		if ("medicamentosSeleccionados" in $$props) $$invalidate(15, medicamentosSeleccionados = $$props.medicamentosSeleccionados);
    		if ("sltBuscarEstudios" in $$props) $$invalidate(16, sltBuscarEstudios = $$props.sltBuscarEstudios);
    		if ("estudios" in $$props) $$invalidate(17, estudios = $$props.estudios);
    		if ("estudiosSeleccionados" in $$props) $$invalidate(18, estudiosSeleccionados = $$props.estudiosSeleccionados);
    		if ("historiaGinecologica" in $$props) $$invalidate(19, historiaGinecologica = $$props.historiaGinecologica);
    		if ("errorServer" in $$props) $$invalidate(20, errorServer = $$props.errorServer);
    		if ("empresa" in $$props) $$invalidate(21, empresa = $$props.empresa);
    		if ("exploracionFisica" in $$props) $$invalidate(22, exploracionFisica = $$props.exploracionFisica);
    		if ("serverConexion" in $$props) $$invalidate(23, serverConexion = $$props.serverConexion);
    		if ("cargandoHistoria" in $$props) $$invalidate(24, cargandoHistoria = $$props.cargandoHistoria);
    		if ("pacienteSeleccionado" in $$props) $$invalidate(25, pacienteSeleccionado = $$props.pacienteSeleccionado);
    		if ("disabled" in $$props) $$invalidate(26, disabled = $$props.disabled);
    		if ("filtroDiagnostico" in $$props) $$invalidate(27, filtroDiagnostico = $$props.filtroDiagnostico);
    	};

    	let filtroDiagnostico;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*historia*/ 128) {
    			 if (historia.estado === "C") {
    				$$invalidate(26, disabled = true);
    			} else {
    				$$invalidate(26, disabled = false);
    			}
    		}

    		if ($$self.$$.dirty[3] & /*diagnosticos*/ 16384) {
    			 $$invalidate(27, filtroDiagnostico = diagnosticos);
    		}
    	};

    	return [
    		params,
    		paciente,
    		edad,
    		seguro,
    		inpBuscarDiagnostico,
    		diagnosticosSeleccionados,
    		medicamentos,
    		historia,
    		temperatura,
    		presionAlterial,
    		peso,
    		fecha,
    		hora,
    		cargando,
    		sltBuscarMedicamentos,
    		medicamentosSeleccionados,
    		sltBuscarEstudios,
    		estudios,
    		estudiosSeleccionados,
    		historiaGinecologica,
    		errorServer,
    		empresa,
    		exploracionFisica,
    		serverConexion,
    		cargandoHistoria,
    		pacienteSeleccionado,
    		disabled,
    		filtroDiagnostico,
    		abrirHistoria,
    		cerrarHistoria,
    		eliminarHistoria,
    		searchMedicamentos,
    		searchDiagnosticos,
    		searchEstudios,
    		agregarEstudio,
    		agregarDiagnosticoPersonalizado,
    		agregarComentarioDiagnostico,
    		eliminarMedicamento,
    		eliminarDiagnostico,
    		eliminarEstudios,
    		agregarMedicamento,
    		guardarHistoria,
    		seleccionarDiagnostico,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		textarea0_input_handler,
    		textarea1_input_handler,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input5_input_handler,
    		input6_input_handler,
    		input7_input_handler,
    		input8_input_handler,
    		input9_input_handler,
    		input10_input_handler,
    		input11_input_handler,
    		input12_input_handler,
    		input13_input_handler,
    		input14_input_handler,
    		input15_change_handler,
    		input16_change_handler,
    		input17_change_handler,
    		input18_change_handler,
    		input19_change_handler,
    		input20_change_handler,
    		input21_change_handler,
    		input22_change_handler,
    		input23_change_handler,
    		input0_input_handler_1,
    		select_change_handler,
    		input1_input_handler_1,
    		input2_input_handler_1,
    		input3_input_handler_1,
    		input4_input_handler_1,
    		input0_input_handler_2,
    		select_change_handler_1,
    		input1_input_handler_2,
    		input2_input_handler_2,
    		input3_input_handler_2,
    		input4_input_handler_2,
    		textarea2_input_handler,
    		click_handler_4,
    		textarea_input_handler,
    		input0_input_handler_3,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		click_handler_8,
    		input_input_handler,
    		ordenesmedicas_idHistoria_binding,
    		ordenesmedicas_idPaciente_binding,
    		ordenesmedicas_estudiosSeleccionados_binding,
    		ordenesmedicas_medicamentosSeleccionados_binding,
    		ordenesmedicas_sltBuscarMedicamentos_binding,
    		ordenesmedicas_sltBuscarEstudios_binding,
    		ordenesmedicas_medicamentos_binding,
    		ordenesmedicas_instrucciones_binding,
    		ordenesmedicas_estudios_binding,
    		textarea3_input_handler,
    		input1_input_handler_3,
    		blur_handler,
    		input2_input_handler_3
    	];
    }

    class HistoriaClinica extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, { params: 0 }, [-1, -1, -1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HistoriaClinica",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get params() {
    		throw new Error("<HistoriaClinica>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<HistoriaClinica>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Home\Login.svelte generated by Svelte v3.29.0 */

    const { console: console_1$c } = globals;
    const file$p = "src\\Pages\\Home\\Login.svelte";

    // (59:12) {#if cargando}
    function create_if_block$e(ctx) {
    	let div;
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loading.$$.fragment);
    			attr_dev(div, "class", "cargando");
    			add_location(div, file$p, 59, 16, 1891);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loading, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(59:12) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let div9;
    	let div8;
    	let div6;
    	let t0;
    	let div5;
    	let div4;
    	let div0;
    	let p0;
    	let img;
    	let img_src_value;
    	let t1;
    	let p1;
    	let t3;
    	let form;
    	let div3;
    	let div1;
    	let label0;
    	let t5;
    	let input0;
    	let t6;
    	let div2;
    	let label1;
    	let t8;
    	let input1;
    	let t9;
    	let button;
    	let t11;
    	let a;
    	let link_action;
    	let t13;
    	let div7;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*cargando*/ ctx[2] && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			div8 = element("div");
    			div6 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			p0 = element("p");
    			img = element("img");
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "xmedical pro";
    			t3 = space();
    			form = element("form");
    			div3 = element("div");
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Correo";
    			t5 = space();
    			input0 = element("input");
    			t6 = space();
    			div2 = element("div");
    			label1 = element("label");
    			label1.textContent = "Contrasea";
    			t8 = space();
    			input1 = element("input");
    			t9 = space();
    			button = element("button");
    			button.textContent = "Entrar";
    			t11 = space();
    			a = element("a");
    			a.textContent = "CREAR CUENTA GRATIS";
    			t13 = space();
    			div7 = element("div");
    			if (img.src !== (img_src_value = "assets/img/logo.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "80");
    			attr_dev(img, "alt", "");
    			add_location(img, file$p, 67, 28, 2207);
    			add_location(p0, file$p, 66, 24, 2174);
    			attr_dev(p1, "class", "admin-brand-content");
    			add_location(p1, file$p, 70, 24, 2314);
    			attr_dev(div0, "class", "p-b-20 text-center");
    			add_location(div0, file$p, 65, 20, 2116);
    			attr_dev(label0, "for", "");
    			add_location(label0, file$p, 77, 32, 2693);
    			attr_dev(input0, "type", "email");
    			input0.required = "true";
    			attr_dev(input0, "autocomplete", "username");
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "placeholder", "Correo");
    			add_location(input0, file$p, 78, 32, 2755);
    			attr_dev(div1, "class", "form-group floating-label col-md-12");
    			add_location(div1, file$p, 76, 28, 2610);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$p, 81, 32, 3029);
    			attr_dev(input1, "type", "password");
    			attr_dev(input1, "autocomplete", "current-password");
    			attr_dev(input1, "placeholder", "Contrasea");
    			input1.required = "true";
    			attr_dev(input1, "class", "form-control ");
    			add_location(input1, file$p, 82, 32, 3102);
    			attr_dev(div2, "class", "form-group floating-label col-md-12");
    			add_location(div2, file$p, 80, 28, 2946);
    			attr_dev(div3, "class", "form-row");
    			add_location(div3, file$p, 75, 24, 2558);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "btn btn-primary btn-block btn-lg");
    			add_location(button, file$p, 86, 24, 3348);
    			attr_dev(a, "href", "/register");
    			attr_dev(a, "class", "btn btn-outline-success btn-block mt-2");
    			add_location(a, file$p, 87, 24, 3452);
    			attr_dev(form, "class", "needs-validation");
    			add_location(form, file$p, 74, 20, 2467);
    			attr_dev(div4, "class", "mx-auto col-md-8");
    			add_location(div4, file$p, 64, 16, 2064);
    			attr_dev(div5, "class", "row align-items-center m-h-100");
    			add_location(div5, file$p, 63, 12, 2002);
    			attr_dev(div6, "class", "col-lg-4  bg-white");
    			add_location(div6, file$p, 57, 8, 1813);
    			attr_dev(div7, "class", "col-lg-8 d-none d-md-block bg-cover");
    			set_style(div7, "background-image", "url('assets/img/login.svg')");
    			add_location(div7, file$p, 97, 8, 3834);
    			attr_dev(div8, "class", "row ");
    			add_location(div8, file$p, 56, 4, 1785);
    			attr_dev(div9, "class", "container-fluid");
    			add_location(div9, file$p, 55, 0, 1750);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div8);
    			append_dev(div8, div6);
    			if (if_block) if_block.m(div6, null);
    			append_dev(div6, t0);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div0, p0);
    			append_dev(p0, img);
    			append_dev(div0, t1);
    			append_dev(div0, p1);
    			append_dev(div4, t3);
    			append_dev(div4, form);
    			append_dev(form, div3);
    			append_dev(div3, div1);
    			append_dev(div1, label0);
    			append_dev(div1, t5);
    			append_dev(div1, input0);
    			set_input_value(input0, /*inpCorreo*/ ctx[0]);
    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			append_dev(div2, label1);
    			append_dev(div2, t8);
    			append_dev(div2, input1);
    			set_input_value(input1, /*inpPassword*/ ctx[1]);
    			append_dev(form, t9);
    			append_dev(form, button);
    			append_dev(form, t11);
    			append_dev(form, a);
    			append_dev(div8, t13);
    			append_dev(div8, div7);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[4]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[5]),
    					action_destroyer(link_action = link.call(null, a)),
    					listen_dev(form, "submit", prevent_default(/*login*/ ctx[3]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*cargando*/ ctx[2]) {
    				if (if_block) {
    					if (dirty & /*cargando*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div6, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*inpCorreo*/ 1 && input0.value !== /*inpCorreo*/ ctx[0]) {
    				set_input_value(input0, /*inpCorreo*/ ctx[0]);
    			}

    			if (dirty & /*inpPassword*/ 2 && input1.value !== /*inpPassword*/ ctx[1]) {
    				set_input_value(input1, /*inpPassword*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Login", slots, []);
    	let inpCorreo = "";
    	let inpPassword = "";
    	let cargando = false;

    	const login = () => {
    		$$invalidate(2, cargando = true);
    		const data = { correo: inpCorreo, password: inpPassword };

    		const config = {
    			method: "post",
    			url: `${url}/login`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			},
    			data
    		};

    		axios$1(config).then(res => {
    			$$invalidate(2, cargando = false);
    			localStorage.setItem("auth", res.data);
    			console.log(res.data);

    			if (res.status === 403) {
    				Swal.fire({
    					icon: "error",
    					title: "Oops...",
    					text: "Usuario o contrase&ntilde;a incorrectos!",
    					footer: "<a href=\"\">Why do I have this issue?</a>"
    				});
    			}

    			if (isLogin()) {
    				return push("/");
    			}
    		}).catch(err => {
    			$$invalidate(2, cargando = false);

    			if (err.response.status === 403) {
    				Swal.fire({
    					icon: "error",
    					title: "Oops...",
    					text: "Usuario o contrasea incorrectos, intenta de nuevo!"
    				});
    			}
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$c.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		inpCorreo = this.value;
    		$$invalidate(0, inpCorreo);
    	}

    	function input1_input_handler() {
    		inpPassword = this.value;
    		$$invalidate(1, inpPassword);
    	}

    	$$self.$capture_state = () => ({
    		url,
    		isLogin,
    		axios: axios$1,
    		push,
    		link,
    		Loading,
    		inpCorreo,
    		inpPassword,
    		cargando,
    		login
    	});

    	$$self.$inject_state = $$props => {
    		if ("inpCorreo" in $$props) $$invalidate(0, inpCorreo = $$props.inpCorreo);
    		if ("inpPassword" in $$props) $$invalidate(1, inpPassword = $$props.inpPassword);
    		if ("cargando" in $$props) $$invalidate(2, cargando = $$props.cargando);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		inpCorreo,
    		inpPassword,
    		cargando,
    		login,
    		input0_input_handler,
    		input1_input_handler
    	];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* src\Pages\Home\Register.svelte generated by Svelte v3.29.0 */
    const file$q = "src\\Pages\\Home\\Register.svelte";

    function create_fragment$s(ctx) {
    	let div13;
    	let div12;
    	let div10;
    	let div9;
    	let div8;
    	let form;
    	let div0;
    	let p0;
    	let img;
    	let img_src_value;
    	let t0;
    	let p1;
    	let t2;
    	let div6;
    	let div1;
    	let label0;
    	let t4;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let t8;
    	let div2;
    	let label1;
    	let t10;
    	let input0;
    	let t11;
    	let div3;
    	let label2;
    	let t13;
    	let input1;
    	let t14;
    	let div4;
    	let label3;
    	let t16;
    	let input2;
    	let t17;
    	let div5;
    	let label4;
    	let t19;
    	let input3;
    	let t20;
    	let div7;
    	let label5;
    	let t22;
    	let input4;
    	let t23;
    	let p2;
    	let label6;
    	let input5;
    	let t24;
    	let span0;
    	let t25;
    	let span1;
    	let t27;
    	let button;
    	let t29;
    	let p3;
    	let a;
    	let link_action;
    	let t31;
    	let div11;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div13 = element("div");
    			div12 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			form = element("form");
    			div0 = element("div");
    			p0 = element("p");
    			img = element("img");
    			t0 = space();
    			p1 = element("p");
    			p1.textContent = "registro xmedical";
    			t2 = space();
    			div6 = element("div");
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Titulo";
    			t4 = space();
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "- seleccionar titulo - ";
    			option1 = element("option");
    			option1.textContent = "Dr";
    			option2 = element("option");
    			option2.textContent = "Dra";
    			t8 = space();
    			div2 = element("div");
    			label1 = element("label");
    			label1.textContent = "Nombre";
    			t10 = space();
    			input0 = element("input");
    			t11 = space();
    			div3 = element("div");
    			label2 = element("label");
    			label2.textContent = "Apellido";
    			t13 = space();
    			input1 = element("input");
    			t14 = space();
    			div4 = element("div");
    			label3 = element("label");
    			label3.textContent = "Correo Electronico";
    			t16 = space();
    			input2 = element("input");
    			t17 = space();
    			div5 = element("div");
    			label4 = element("label");
    			label4.textContent = "Contrasea";
    			t19 = space();
    			input3 = element("input");
    			t20 = space();
    			div7 = element("div");
    			label5 = element("label");
    			label5.textContent = "Repetir Contrasea";
    			t22 = space();
    			input4 = element("input");
    			t23 = space();
    			p2 = element("p");
    			label6 = element("label");
    			input5 = element("input");
    			t24 = space();
    			span0 = element("span");
    			t25 = space();
    			span1 = element("span");
    			span1.textContent = "Aceptar terminos y condiciones.";
    			t27 = space();
    			button = element("button");
    			button.textContent = "Crear cuenta";
    			t29 = space();
    			p3 = element("p");
    			a = element("a");
    			a.textContent = "Estas registrado?";
    			t31 = space();
    			div11 = element("div");
    			if (img.src !== (img_src_value = "assets/img/logo.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "80");
    			attr_dev(img, "alt", "");
    			add_location(img, file$q, 17, 32, 680);
    			add_location(p0, file$q, 16, 28, 643);
    			attr_dev(p1, "class", "admin-brand-content");
    			add_location(p1, file$q, 20, 28, 795);
    			attr_dev(div0, "class", "p-b-20 text-center");
    			add_location(div0, file$q, 15, 24, 581);
    			attr_dev(label0, "for", "");
    			add_location(label0, file$q, 26, 32, 1104);
    			option0.__value = "";
    			option0.value = option0.__value;
    			add_location(option0, file$q, 28, 36, 1242);
    			option1.__value = "Dr";
    			option1.value = option1.__value;
    			add_location(option1, file$q, 29, 36, 1330);
    			option2.__value = "Dra";
    			option2.value = option2.__value;
    			add_location(option2, file$q, 30, 36, 1398);
    			attr_dev(select, "class", "form-control");
    			select.required = true;
    			add_location(select, file$q, 27, 32, 1166);
    			attr_dev(div1, "class", "form-group floating-label col-md-12");
    			add_location(div1, file$q, 25, 28, 1021);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$q, 34, 32, 1622);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			input0.required = true;
    			attr_dev(input0, "placeholder", "Nombre");
    			add_location(input0, file$q, 35, 32, 1684);
    			attr_dev(div2, "class", "form-group floating-label col-md-12");
    			add_location(div2, file$q, 33, 28, 1539);
    			attr_dev(label2, "for", "");
    			add_location(label2, file$q, 38, 32, 1903);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "form-control");
    			input1.required = true;
    			attr_dev(input1, "placeholder", "Apellido");
    			add_location(input1, file$q, 39, 32, 1967);
    			attr_dev(div3, "class", "form-group floating-label col-md-12");
    			add_location(div3, file$q, 37, 28, 1820);
    			attr_dev(label3, "for", "");
    			add_location(label3, file$q, 42, 32, 2188);
    			attr_dev(input2, "type", "email");
    			input2.required = "";
    			attr_dev(input2, "class", "form-control");
    			attr_dev(input2, "placeholder", "Correo Electronico");
    			add_location(input2, file$q, 43, 32, 2262);
    			attr_dev(div4, "class", "form-group floating-label col-md-12");
    			add_location(div4, file$q, 41, 28, 2105);
    			attr_dev(label4, "for", "");
    			add_location(label4, file$q, 46, 32, 2497);
    			attr_dev(input3, "type", "password");
    			input3.required = "";
    			attr_dev(input3, "placeholder", "Contrasea");
    			attr_dev(input3, "class", "form-control ");
    			attr_dev(input3, "id", "password");
    			add_location(input3, file$q, 47, 32, 2563);
    			attr_dev(div5, "class", "form-group floating-label col-md-12");
    			add_location(div5, file$q, 45, 28, 2414);
    			attr_dev(div6, "class", "form-row");
    			add_location(div6, file$q, 24, 24, 969);
    			attr_dev(label5, "for", "");
    			add_location(label5, file$q, 51, 28, 2822);
    			attr_dev(input4, "type", "password");
    			attr_dev(input4, "class", "form-control");
    			input4.required = "";
    			attr_dev(input4, "id", "confirm_password");
    			attr_dev(input4, "placeholder", "Repetir Contrasea");
    			add_location(input4, file$q, 52, 28, 2892);
    			attr_dev(div7, "class", "form-group floating-label");
    			add_location(div7, file$q, 50, 24, 2753);
    			attr_dev(input5, "type", "checkbox");
    			input5.checked = "";
    			attr_dev(input5, "name", "option");
    			input5.value = "1";
    			attr_dev(input5, "class", "cstm-switch-input");
    			add_location(input5, file$q, 57, 32, 3166);
    			attr_dev(span0, "class", "cstm-switch-indicator ");
    			add_location(span0, file$q, 58, 32, 3284);
    			attr_dev(span1, "class", "cstm-switch-description");
    			add_location(span1, file$q, 59, 32, 3362);
    			attr_dev(label6, "class", "cstm-switch");
    			add_location(label6, file$q, 56, 28, 3105);
    			attr_dev(p2, "class", "");
    			add_location(p2, file$q, 55, 24, 3063);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "btn btn-primary btn-block btn-lg");
    			add_location(button, file$q, 65, 24, 3541);
    			attr_dev(form, "class", "needs-validation");
    			attr_dev(form, "action", "#");
    			form.noValidate = "novalidate";
    			add_location(form, file$q, 14, 20, 489);
    			attr_dev(a, "href", "/login");
    			attr_dev(a, "class", "text-underline");
    			add_location(a, file$q, 69, 24, 3733);
    			attr_dev(p3, "class", "text-right p-t-10");
    			add_location(p3, file$q, 68, 20, 3678);
    			attr_dev(div8, "class", "mx-auto col-md-8");
    			add_location(div8, file$q, 13, 16, 437);
    			attr_dev(div9, "class", "row align-items-center m-h-100");
    			add_location(div9, file$q, 12, 12, 375);
    			attr_dev(div10, "class", "col-lg-4  bg-white");
    			add_location(div10, file$q, 11, 8, 329);
    			attr_dev(div11, "class", "col-lg-8 d-none d-md-block bg-cover");
    			set_style(div11, "background-image", "url('assets/img/register.svg')");
    			add_location(div11, file$q, 75, 8, 3901);
    			attr_dev(div12, "class", "row ");
    			add_location(div12, file$q, 10, 4, 301);
    			attr_dev(div13, "class", "container-fluid");
    			add_location(div13, file$q, 9, 0, 266);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div13, anchor);
    			append_dev(div13, div12);
    			append_dev(div12, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, form);
    			append_dev(form, div0);
    			append_dev(div0, p0);
    			append_dev(p0, img);
    			append_dev(div0, t0);
    			append_dev(div0, p1);
    			append_dev(form, t2);
    			append_dev(form, div6);
    			append_dev(div6, div1);
    			append_dev(div1, label0);
    			append_dev(div1, t4);
    			append_dev(div1, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(div6, t8);
    			append_dev(div6, div2);
    			append_dev(div2, label1);
    			append_dev(div2, t10);
    			append_dev(div2, input0);
    			append_dev(div6, t11);
    			append_dev(div6, div3);
    			append_dev(div3, label2);
    			append_dev(div3, t13);
    			append_dev(div3, input1);
    			append_dev(div6, t14);
    			append_dev(div6, div4);
    			append_dev(div4, label3);
    			append_dev(div4, t16);
    			append_dev(div4, input2);
    			append_dev(div6, t17);
    			append_dev(div6, div5);
    			append_dev(div5, label4);
    			append_dev(div5, t19);
    			append_dev(div5, input3);
    			append_dev(form, t20);
    			append_dev(form, div7);
    			append_dev(div7, label5);
    			append_dev(div7, t22);
    			append_dev(div7, input4);
    			append_dev(form, t23);
    			append_dev(form, p2);
    			append_dev(p2, label6);
    			append_dev(label6, input5);
    			append_dev(label6, t24);
    			append_dev(label6, span0);
    			append_dev(label6, t25);
    			append_dev(label6, span1);
    			append_dev(form, t27);
    			append_dev(form, button);
    			append_dev(div8, t29);
    			append_dev(div8, p3);
    			append_dev(p3, a);
    			append_dev(div12, t31);
    			append_dev(div12, div11);

    			if (!mounted) {
    				dispose = action_destroyer(link_action = link.call(null, a));
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div13);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Register", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Register> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ url, isLogin, axios: axios$1, push, link, Loading });
    	return [];
    }

    class Register extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Register",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src\componentes\Modals\ModalRolesUsuario.svelte generated by Svelte v3.29.0 */

    const file$r = "src\\componentes\\Modals\\ModalRolesUsuario.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[5] = list;
    	child_ctx[6] = i;
    	return child_ctx;
    }

    // (35:28) {#each rolesMapeado as role}
    function create_each_block$8(ctx) {
    	let div;
    	let label;
    	let span0;
    	let t0_value = /*role*/ ctx[4].displayName + "";
    	let t0;
    	let t1;
    	let a;
    	let i;
    	let t2;
    	let input;
    	let t3;
    	let span1;
    	let t4;
    	let mounted;
    	let dispose;

    	function input_change_handler() {
    		/*input_change_handler*/ ctx[3].call(input, /*each_value*/ ctx[5], /*role_index*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			a = element("a");
    			i = element("i");
    			t2 = space();
    			input = element("input");
    			t3 = space();
    			span1 = element("span");
    			t4 = space();
    			attr_dev(i, "class", "mdi-18px mdi mdi-information-outline");
    			add_location(i, file$r, 42, 70, 2368);
    			attr_dev(a, "href", "#!");
    			attr_dev(a, "data-toggle", "popover");
    			attr_dev(a, "title", "Informacion Administrador");
    			attr_dev(a, "data-trigger", "focus");
    			attr_dev(a, "data-placement", "bottom");
    			attr_dev(a, "data-content", "And here's some amazing content. It's very engaging. Right?");
    			attr_dev(a, "class", "icon-rol");
    			add_location(a, file$r, 38, 69, 1946);
    			attr_dev(span0, "class", "cstm-switch-description mr-auto bd-highlight");
    			add_location(span0, file$r, 37, 45, 1817);
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "class", "cstm-switch-input");
    			add_location(input, file$r, 44, 45, 2536);
    			attr_dev(span1, "class", "cstm-switch-indicator bg-success bd-highlight");
    			add_location(span1, file$r, 47, 45, 2759);
    			attr_dev(label, "class", "cstm-switch d-flex bd-highlight");
    			add_location(label, file$r, 36, 41, 1723);
    			attr_dev(div, "class", "lista-rol m-b-10");
    			add_location(div, file$r, 35, 37, 1650);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(label, span0);
    			append_dev(span0, t0);
    			append_dev(span0, t1);
    			append_dev(span0, a);
    			append_dev(a, i);
    			append_dev(label, t2);
    			append_dev(label, input);
    			input.checked = /*role*/ ctx[4].active;
    			append_dev(label, t3);
    			append_dev(label, span1);
    			append_dev(div, t4);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", input_change_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*rolesMapeado*/ 2 && t0_value !== (t0_value = /*role*/ ctx[4].displayName + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*rolesMapeado*/ 2) {
    				input.checked = /*role*/ ctx[4].active;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(35:28) {#each rolesMapeado as role}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let div6;
    	let div5;
    	let div4;
    	let div0;
    	let h5;
    	let t0_value = /*usuario*/ ctx[0].nombre + "";
    	let t0;
    	let t1;
    	let t2_value = /*usuario*/ ctx[0].apellido + "";
    	let t2;
    	let t3;
    	let button;
    	let span0;
    	let t5;
    	let div3;
    	let form;
    	let input0;
    	let t6;
    	let p;
    	let span1;
    	let t7_value = /*usuario*/ ctx[0].correo + "";
    	let t7;
    	let t8;
    	let div1;
    	let label;
    	let t10;
    	let input1;
    	let t11;
    	let div2;
    	let each_value = /*rolesMapeado*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			button = element("button");
    			span0 = element("span");
    			span0.textContent = "";
    			t5 = space();
    			div3 = element("div");
    			form = element("form");
    			input0 = element("input");
    			t6 = space();
    			p = element("p");
    			span1 = element("span");
    			t7 = text(t7_value);
    			t8 = space();
    			div1 = element("div");
    			label = element("label");
    			label.textContent = "Buscar";
    			t10 = space();
    			input1 = element("input");
    			t11 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h5, "class", "modal-title");
    			attr_dev(h5, "id", "modalRolesLabel");
    			add_location(h5, file$r, 18, 20, 661);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$r, 20, 24, 870);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "close");
    			attr_dev(button, "data-dismiss", "modal");
    			attr_dev(button, "aria-label", "Close");
    			add_location(button, file$r, 19, 20, 768);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$r, 17, 16, 613);
    			attr_dev(input0, "type", "hidden");
    			attr_dev(input0, "name", "idPaciente");
    			input0.value = "";
    			add_location(input0, file$r, 26, 24, 1062);
    			attr_dev(span1, "class", "badge badge-soft-primary");
    			set_style(span1, "font-size", "17px");
    			add_location(span1, file$r, 27, 27, 1139);
    			add_location(p, file$r, 27, 24, 1136);
    			attr_dev(label, "for", "");
    			add_location(label, file$r, 30, 28, 1351);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "placeholder", "Buscar roles");
    			add_location(input1, file$r, 31, 28, 1409);
    			attr_dev(div1, "class", "form-group floating-label");
    			add_location(div1, file$r, 29, 24, 1282);
    			attr_dev(div2, "class", "roles");
    			add_location(div2, file$r, 33, 24, 1534);
    			attr_dev(form, "id", "");
    			add_location(form, file$r, 25, 20, 1024);
    			attr_dev(div3, "class", "modal-body");
    			add_location(div3, file$r, 23, 16, 976);
    			attr_dev(div4, "class", "modal-content");
    			add_location(div4, file$r, 16, 12, 568);
    			attr_dev(div5, "class", "modal-dialog");
    			attr_dev(div5, "role", "document");
    			add_location(div5, file$r, 15, 8, 512);
    			attr_dev(div6, "class", "modal fade modal-slide-right");
    			attr_dev(div6, "id", "modalRoles");
    			attr_dev(div6, "tabindex", "-1");
    			attr_dev(div6, "role", "dialog");
    			attr_dev(div6, "aria-labelledby", "modalRolesLabel");
    			set_style(div6, "display", "none");
    			set_style(div6, "padding-right", "16px");
    			attr_dev(div6, "aria-modal", "true");
    			add_location(div6, file$r, 13, 0, 311);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div0, h5);
    			append_dev(h5, t0);
    			append_dev(h5, t1);
    			append_dev(h5, t2);
    			append_dev(div0, t3);
    			append_dev(div0, button);
    			append_dev(button, span0);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			append_dev(div3, form);
    			append_dev(form, input0);
    			append_dev(form, t6);
    			append_dev(form, p);
    			append_dev(p, span1);
    			append_dev(span1, t7);
    			append_dev(form, t8);
    			append_dev(form, div1);
    			append_dev(div1, label);
    			append_dev(div1, t10);
    			append_dev(div1, input1);
    			append_dev(form, t11);
    			append_dev(form, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*usuario*/ 1 && t0_value !== (t0_value = /*usuario*/ ctx[0].nombre + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*usuario*/ 1 && t2_value !== (t2_value = /*usuario*/ ctx[0].apellido + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*usuario*/ 1 && t7_value !== (t7_value = /*usuario*/ ctx[0].correo + "")) set_data_dev(t7, t7_value);

    			if (dirty & /*rolesMapeado*/ 2) {
    				each_value = /*rolesMapeado*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ModalRolesUsuario", slots, []);
    	let { usuario = {} } = $$props;
    	let { roles = [] } = $$props;
    	const writable_props = ["usuario", "roles"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ModalRolesUsuario> was created with unknown prop '${key}'`);
    	});

    	function input_change_handler(each_value, role_index) {
    		each_value[role_index].active = this.checked;
    		(($$invalidate(1, rolesMapeado), $$invalidate(2, roles)), $$invalidate(0, usuario));
    	}

    	$$self.$$set = $$props => {
    		if ("usuario" in $$props) $$invalidate(0, usuario = $$props.usuario);
    		if ("roles" in $$props) $$invalidate(2, roles = $$props.roles);
    	};

    	$$self.$capture_state = () => ({ usuario, roles, rolesMapeado });

    	$$self.$inject_state = $$props => {
    		if ("usuario" in $$props) $$invalidate(0, usuario = $$props.usuario);
    		if ("roles" in $$props) $$invalidate(2, roles = $$props.roles);
    		if ("rolesMapeado" in $$props) $$invalidate(1, rolesMapeado = $$props.rolesMapeado);
    	};

    	let rolesMapeado;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*roles, usuario*/ 5) {
    			 $$invalidate(1, rolesMapeado = roles.map(x => {
    				return {
    					id: x.id,
    					name: x.name,
    					displayName: x.displayName,
    					active: usuario.roles.some(y => x.name === y)
    				};
    			}));
    		}
    	};

    	return [usuario, rolesMapeado, roles, input_change_handler];
    }

    class ModalRolesUsuario extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, { usuario: 0, roles: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalRolesUsuario",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get usuario() {
    		throw new Error("<ModalRolesUsuario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set usuario(value) {
    		throw new Error("<ModalRolesUsuario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get roles() {
    		throw new Error("<ModalRolesUsuario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set roles(value) {
    		throw new Error("<ModalRolesUsuario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Usuarios\Index.svelte generated by Svelte v3.29.0 */

    const { console: console_1$d } = globals;

    const file$s = "src\\Pages\\Usuarios\\Index.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (129:28) {#if user().roles.includes('admin')}
    function create_if_block$f(ctx) {
    	let a0;
    	let i0;
    	let t;
    	let a1;
    	let i1;
    	let a1_href_value;
    	let link_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			i0 = element("i");
    			t = space();
    			a1 = element("a");
    			i1 = element("i");
    			attr_dev(i0, "class", "mdi mdi-trash-can-outline");
    			add_location(i0, file$s, 134, 33, 4349);
    			attr_dev(a0, "href", "#!");
    			attr_dev(a0, "class", "btn btn-outline-danger");
    			attr_dev(a0, "data-tooltip", "Eliminar");
    			add_location(a0, file$s, 129, 33, 4097);
    			attr_dev(i1, "class", "mdi mdi-send");
    			add_location(i1, file$s, 142, 37, 4797);
    			attr_dev(a1, "href", a1_href_value = `/pacientes/perfil/${/*usuario*/ ctx[9].id}`);
    			attr_dev(a1, "class", "btn btn-outline-primary");
    			attr_dev(a1, "data-tooltip", "Perfil");
    			add_location(a1, file$s, 136, 33, 4464);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			append_dev(a0, i0);
    			insert_dev(target, t, anchor);
    			insert_dev(target, a1, anchor);
    			append_dev(a1, i1);

    			if (!mounted) {
    				dispose = action_destroyer(link_action = link.call(null, a1));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*usuarios*/ 1 && a1_href_value !== (a1_href_value = `/pacientes/perfil/${/*usuario*/ ctx[9].id}`)) {
    				attr_dev(a1, "href", a1_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(a1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(129:28) {#if user().roles.includes('admin')}",
    		ctx
    	});

    	return block;
    }

    // (110:16) {#each usuarios as usuario}
    function create_each_block$9(ctx) {
    	let tr;
    	let td0;
    	let div;
    	let img;
    	let img_src_value;
    	let t0;
    	let td1;
    	let t1_value = /*usuario*/ ctx[9].nombre + "";
    	let t1;
    	let t2;
    	let t3_value = /*usuario*/ ctx[9].apellido + "";
    	let t3;
    	let t4;
    	let td2;
    	let t5_value = /*usuario*/ ctx[9].correo + "";
    	let t5;
    	let t6;
    	let td3;
    	let button;
    	let i;
    	let t7;
    	let show_if = user().roles.includes("admin");
    	let t8;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[6](/*usuario*/ ctx[9], ...args);
    	}

    	let if_block = show_if && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			div = element("div");
    			img = element("img");
    			t0 = space();
    			td1 = element("td");
    			t1 = text(t1_value);
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = space();
    			td2 = element("td");
    			t5 = text(t5_value);
    			t6 = space();
    			td3 = element("td");
    			button = element("button");
    			i = element("i");
    			t7 = space();
    			if (if_block) if_block.c();
    			t8 = space();
    			if (img.src !== (img_src_value = "assets/img/users/user-1.jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "avatar-img avatar-sm rounded-circle");
    			attr_dev(img, "alt", "");
    			add_location(img, file$s, 112, 59, 3087);
    			attr_dev(div, "class", "avatar avatar-sm ");
    			add_location(div, file$s, 112, 28, 3056);
    			add_location(td0, file$s, 111, 24, 3022);
    			add_location(td1, file$s, 114, 24, 3240);
    			add_location(td2, file$s, 115, 24, 3310);
    			attr_dev(i, "class", "mdi mdi-security");
    			add_location(i, file$s, 126, 32, 3925);
    			attr_dev(button, "href", "#!");
    			attr_dev(button, "class", "btn btn-outline-secondary");
    			attr_dev(button, "data-tooltip", "Roles");
    			attr_dev(button, "data-toggle", "modal");
    			attr_dev(button, "data-target", "#modalRoles");
    			add_location(button, file$s, 118, 28, 3489);
    			attr_dev(td3, "class", "text-right");
    			add_location(td3, file$s, 116, 24, 3361);
    			add_location(tr, file$s, 110, 20, 2992);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, div);
    			append_dev(div, img);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, t1);
    			append_dev(td1, t2);
    			append_dev(td1, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td2);
    			append_dev(td2, t5);
    			append_dev(tr, t6);
    			append_dev(tr, td3);
    			append_dev(td3, button);
    			append_dev(button, i);
    			append_dev(td3, t7);
    			if (if_block) if_block.m(td3, null);
    			append_dev(tr, t8);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*usuarios*/ 1 && t1_value !== (t1_value = /*usuario*/ ctx[9].nombre + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*usuarios*/ 1 && t3_value !== (t3_value = /*usuario*/ ctx[9].apellido + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*usuarios*/ 1 && t5_value !== (t5_value = /*usuario*/ ctx[9].correo + "")) set_data_dev(t5, t5_value);
    			if (show_if) if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(110:16) {#each usuarios as usuario}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let modalrolesusuario;
    	let updating_usuario;
    	let updating_roles;
    	let t2;
    	let section;
    	let div3;
    	let div0;
    	let t3;
    	let div2;
    	let h5;
    	let t5;
    	let div1;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t6;
    	let th1;
    	let t8;
    	let th2;
    	let t10;
    	let th3;
    	let t11;
    	let tbody;
    	let current;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });

    	function modalrolesusuario_usuario_binding(value) {
    		/*modalrolesusuario_usuario_binding*/ ctx[4].call(null, value);
    	}

    	function modalrolesusuario_roles_binding(value) {
    		/*modalrolesusuario_roles_binding*/ ctx[5].call(null, value);
    	}

    	let modalrolesusuario_props = {};

    	if (/*usuarioModal*/ ctx[1] !== void 0) {
    		modalrolesusuario_props.usuario = /*usuarioModal*/ ctx[1];
    	}

    	if (/*roles*/ ctx[2] !== void 0) {
    		modalrolesusuario_props.roles = /*roles*/ ctx[2];
    	}

    	modalrolesusuario = new ModalRolesUsuario({
    			props: modalrolesusuario_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(modalrolesusuario, "usuario", modalrolesusuario_usuario_binding));
    	binding_callbacks.push(() => bind(modalrolesusuario, "roles", modalrolesusuario_roles_binding));
    	let each_value = /*usuarios*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			create_component(modalrolesusuario.$$.fragment);
    			t2 = space();
    			section = element("section");
    			div3 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div2 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Usuarios";
    			t5 = space();
    			div1 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t6 = space();
    			th1 = element("th");
    			th1.textContent = "Nombre";
    			t8 = space();
    			th2 = element("th");
    			th2.textContent = "Usuario";
    			t10 = space();
    			th3 = element("th");
    			t11 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "row");
    			add_location(div0, file$s, 87, 6, 2227);
    			add_location(h5, file$s, 89, 8, 2299);
    			add_location(th0, file$s, 101, 20, 2734);
    			add_location(th1, file$s, 102, 20, 2765);
    			add_location(th2, file$s, 103, 20, 2802);
    			add_location(th3, file$s, 105, 20, 2842);
    			add_location(tr, file$s, 100, 16, 2708);
    			add_location(thead, file$s, 99, 16, 2683);
    			add_location(tbody, file$s, 108, 16, 2918);
    			attr_dev(table, "class", "table align-td-middle table-card");
    			add_location(table, file$s, 98, 12, 2617);
    			attr_dev(div1, "class", "table-responsive");
    			add_location(div1, file$s, 97, 8, 2573);
    			attr_dev(div2, "class", "col-md-12 mt-3 m-b-30");
    			add_location(div2, file$s, 88, 6, 2254);
    			attr_dev(div3, "class", "p-2");
    			add_location(div3, file$s, 86, 4, 2202);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$s, 85, 2, 2165);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$s, 78, 0, 2004);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			mount_component(modalrolesusuario, main, null);
    			append_dev(main, t2);
    			append_dev(main, section);
    			append_dev(section, div3);
    			append_dev(div3, div0);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, h5);
    			append_dev(div2, t5);
    			append_dev(div2, div1);
    			append_dev(div1, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t6);
    			append_dev(tr, th1);
    			append_dev(tr, t8);
    			append_dev(tr, th2);
    			append_dev(tr, t10);
    			append_dev(tr, th3);
    			append_dev(table, t11);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const modalrolesusuario_changes = {};

    			if (!updating_usuario && dirty & /*usuarioModal*/ 2) {
    				updating_usuario = true;
    				modalrolesusuario_changes.usuario = /*usuarioModal*/ ctx[1];
    				add_flush_callback(() => updating_usuario = false);
    			}

    			if (!updating_roles && dirty & /*roles*/ 4) {
    				updating_roles = true;
    				modalrolesusuario_changes.roles = /*roles*/ ctx[2];
    				add_flush_callback(() => updating_roles = false);
    			}

    			modalrolesusuario.$set(modalrolesusuario_changes);

    			if (dirty & /*usuarios, user, cargarUsuarioSeleccionado*/ 9) {
    				each_value = /*usuarios*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(modalrolesusuario.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(modalrolesusuario.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			destroy_component(modalrolesusuario);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Index", slots, []);
    	let usuarios = [];
    	let usuarioModal = { roles: [] };
    	let roles = [];

    	const cargarRoles = () => {
    		const config = {
    			method: "get",
    			url: `${url}/roles`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(2, roles = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarUsuarioSeleccionado = id => {
    		const config = {
    			method: "get",
    			url: `${url}/usuarios/${id}`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(1, usuarioModal = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	function cargarPacientes() {
    		const config = {
    			method: "get",
    			url: `${url}/usuarios`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			let { data } = res;
    			$$invalidate(0, usuarios = data);
    		}).catch(err => {
    			console.error(err);
    		});
    	}

    	onMount(() => {
    		cargarPacientes();
    		cargarRoles();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$d.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	function modalrolesusuario_usuario_binding(value) {
    		usuarioModal = value;
    		$$invalidate(1, usuarioModal);
    	}

    	function modalrolesusuario_roles_binding(value) {
    		roles = value;
    		$$invalidate(2, roles);
    	}

    	const click_handler = usuario => cargarUsuarioSeleccionado(usuario.id);

    	$$self.$capture_state = () => ({
    		link,
    		onMount,
    		url,
    		user,
    		axios: axios$1,
    		Header,
    		Aside,
    		ModalRolesUsuario,
    		usuarios,
    		usuarioModal,
    		roles,
    		cargarRoles,
    		cargarUsuarioSeleccionado,
    		cargarPacientes
    	});

    	$$self.$inject_state = $$props => {
    		if ("usuarios" in $$props) $$invalidate(0, usuarios = $$props.usuarios);
    		if ("usuarioModal" in $$props) $$invalidate(1, usuarioModal = $$props.usuarioModal);
    		if ("roles" in $$props) $$invalidate(2, roles = $$props.roles);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		usuarios,
    		usuarioModal,
    		roles,
    		cargarUsuarioSeleccionado,
    		modalrolesusuario_usuario_binding,
    		modalrolesusuario_roles_binding,
    		click_handler
    	];
    }

    class Index$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src\Pages\AtencionMedica\Index.svelte generated by Svelte v3.29.0 */

    const { console: console_1$e } = globals;
    const file$t = "src\\Pages\\AtencionMedica\\Index.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (115:2) {#if errorServer}
    function create_if_block_2$7(ctx) {
    	let errorserver;
    	let current;

    	errorserver = new ErrorConexion({
    			props: {
    				msgError: "Ocurrio un error al conectar con el servidor, vuelva a intentar o contacte al administrador"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(errorserver.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorserver, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorserver.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorserver.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorserver, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(115:2) {#if errorServer}",
    		ctx
    	});

    	return block;
    }

    // (154:20) {#if historia.activo}
    function create_if_block_1$a(ctx) {
    	let tr;
    	let td0;
    	let div;
    	let span;
    	let t0_value = /*historia*/ ctx[11].paciente.nombres[0] + "";
    	let t0;
    	let t1_value = /*historia*/ ctx[11].paciente.apellidos[0] + "";
    	let t1;
    	let t2;
    	let td1;
    	let t3_value = /*historia*/ ctx[11].paciente.nombres + "";
    	let t3;
    	let t4;
    	let t5_value = /*historia*/ ctx[11].paciente.apellidos + "";
    	let t5;
    	let t6;
    	let td2;
    	let t7_value = /*historia*/ ctx[11].paciente.cedula + "";
    	let t7;
    	let t8;
    	let td3;
    	let t9_value = calcularEdad(/*historia*/ ctx[11].paciente.fechaNacimiento) + "";
    	let t9;
    	let t10;
    	let t11;
    	let td4;
    	let t12_value = /*historia*/ ctx[11].paciente.sexo + "";
    	let t12;
    	let t13;
    	let td5;
    	let t14_value = new Date(/*historia*/ ctx[11].fechaHora).toLocaleDateString("es-DO") + "";
    	let t14;
    	let t15;
    	let td6;
    	let a0;
    	let i0;
    	let t16;
    	let a1;
    	let i1;
    	let a1_href_value;
    	let link_action;
    	let t17;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[7](/*historia*/ ctx[11], ...args);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			div = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			td1 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			t5 = text(t5_value);
    			t6 = space();
    			td2 = element("td");
    			t7 = text(t7_value);
    			t8 = space();
    			td3 = element("td");
    			t9 = text(t9_value);
    			t10 = text(" aos");
    			t11 = space();
    			td4 = element("td");
    			t12 = text(t12_value);
    			t13 = space();
    			td5 = element("td");
    			t14 = text(t14_value);
    			t15 = space();
    			td6 = element("td");
    			a0 = element("a");
    			i0 = element("i");
    			t16 = space();
    			a1 = element("a");
    			i1 = element("i");
    			t17 = space();
    			attr_dev(span, "class", "avatar-title rounded-circle ");
    			add_location(span, file$t, 157, 32, 5066);
    			attr_dev(div, "class", "avatar avatar-sm");
    			add_location(div, file$t, 156, 28, 5002);
    			add_location(td0, file$t, 155, 24, 4968);
    			add_location(td1, file$t, 160, 24, 5271);
    			add_location(td2, file$t, 161, 24, 5363);
    			add_location(td3, file$t, 162, 24, 5424);
    			add_location(td4, file$t, 163, 24, 5513);
    			add_location(td5, file$t, 164, 24, 5572);
    			attr_dev(i0, "class", "mdi mdi-close");
    			add_location(i0, file$t, 173, 32, 6119);
    			attr_dev(a0, "href", "#!");
    			attr_dev(a0, "class", "btn btn-outline-danger");
    			attr_dev(a0, "data-tooltip", "Eliminar");
    			add_location(a0, file$t, 167, 28, 5793);
    			attr_dev(i1, "class", "mdi mdi-send");
    			add_location(i1, file$t, 181, 32, 6540);
    			attr_dev(a1, "href", a1_href_value = `/pacientes/${/*historia*/ ctx[11].paciente.id}/historias/${/*historia*/ ctx[11].id}`);
    			attr_dev(a1, "class", "btn btn-outline-primary");
    			attr_dev(a1, "data-tooltip", "Ver");
    			add_location(a1, file$t, 175, 28, 6212);
    			attr_dev(td6, "class", "text-right");
    			add_location(td6, file$t, 165, 24, 5665);
    			add_location(tr, file$t, 154, 20, 4938);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, div);
    			append_dev(div, span);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td1);
    			append_dev(td1, t3);
    			append_dev(td1, t4);
    			append_dev(td1, t5);
    			append_dev(tr, t6);
    			append_dev(tr, td2);
    			append_dev(td2, t7);
    			append_dev(tr, t8);
    			append_dev(tr, td3);
    			append_dev(td3, t9);
    			append_dev(td3, t10);
    			append_dev(tr, t11);
    			append_dev(tr, td4);
    			append_dev(td4, t12);
    			append_dev(tr, t13);
    			append_dev(tr, td5);
    			append_dev(td5, t14);
    			append_dev(tr, t15);
    			append_dev(tr, td6);
    			append_dev(td6, a0);
    			append_dev(a0, i0);
    			append_dev(td6, t16);
    			append_dev(td6, a1);
    			append_dev(a1, i1);
    			append_dev(tr, t17);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", prevent_default(click_handler), false, true, false),
    					action_destroyer(link_action = link.call(null, a1))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*historias*/ 1 && t0_value !== (t0_value = /*historia*/ ctx[11].paciente.nombres[0] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*historias*/ 1 && t1_value !== (t1_value = /*historia*/ ctx[11].paciente.apellidos[0] + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*historias*/ 1 && t3_value !== (t3_value = /*historia*/ ctx[11].paciente.nombres + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*historias*/ 1 && t5_value !== (t5_value = /*historia*/ ctx[11].paciente.apellidos + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*historias*/ 1 && t7_value !== (t7_value = /*historia*/ ctx[11].paciente.cedula + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*historias*/ 1 && t9_value !== (t9_value = calcularEdad(/*historia*/ ctx[11].paciente.fechaNacimiento) + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*historias*/ 1 && t12_value !== (t12_value = /*historia*/ ctx[11].paciente.sexo + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*historias*/ 1 && t14_value !== (t14_value = new Date(/*historia*/ ctx[11].fechaHora).toLocaleDateString("es-DO") + "")) set_data_dev(t14, t14_value);

    			if (dirty & /*historias*/ 1 && a1_href_value !== (a1_href_value = `/pacientes/${/*historia*/ ctx[11].paciente.id}/historias/${/*historia*/ ctx[11].id}`)) {
    				attr_dev(a1, "href", a1_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(154:20) {#if historia.activo}",
    		ctx
    	});

    	return block;
    }

    // (153:16) {#each historias as historia}
    function create_each_block$a(ctx) {
    	let if_block_anchor;
    	let if_block = /*historia*/ ctx[11].activo && create_if_block_1$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*historia*/ ctx[11].activo) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$a(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(153:16) {#each historias as historia}",
    		ctx
    	});

    	return block;
    }

    // (193:8) {#if cargando}
    function create_if_block$g(ctx) {
    	let div1;
    	let div0;
    	let span;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span = element("span");
    			span.textContent = "Loading...";
    			attr_dev(span, "class", "sr-only");
    			add_location(span, file$t, 195, 21, 6959);
    			attr_dev(div0, "class", "spinner-border text-secondary");
    			attr_dev(div0, "role", "status");
    			add_location(div0, file$t, 194, 17, 6879);
    			attr_dev(div1, "class", "text-center");
    			add_location(div1, file$t, 193, 13, 6835);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(193:8) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let t2;
    	let section;
    	let div9;
    	let div0;
    	let t3;
    	let div8;
    	let h5;
    	let t5;
    	let div6;
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let div1;
    	let label;
    	let t7;
    	let input;
    	let t8;
    	let div7;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t9;
    	let th1;
    	let t11;
    	let th2;
    	let t13;
    	let th3;
    	let t15;
    	let th4;
    	let t17;
    	let th5;
    	let t19;
    	let th6;
    	let t20;
    	let tbody;
    	let t21;
    	let current;
    	let mounted;
    	let dispose;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });
    	let if_block0 = /*errorServer*/ ctx[1] && create_if_block_2$7(ctx);
    	let each_value = /*historias*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	let if_block1 = /*cargando*/ ctx[3] && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			section = element("section");
    			div9 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div8 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Consultas mdicas";
    			t5 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			label = element("label");
    			label.textContent = "Buscar historias";
    			t7 = space();
    			input = element("input");
    			t8 = space();
    			div7 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t9 = space();
    			th1 = element("th");
    			th1.textContent = "Nombre";
    			t11 = space();
    			th2 = element("th");
    			th2.textContent = "Cedula";
    			t13 = space();
    			th3 = element("th");
    			th3.textContent = "Edad";
    			t15 = space();
    			th4 = element("th");
    			th4.textContent = "Sexo";
    			t17 = space();
    			th5 = element("th");
    			th5.textContent = "Fecha";
    			t19 = space();
    			th6 = element("th");
    			t20 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t21 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "row");
    			add_location(div0, file$t, 121, 6, 3588);
    			add_location(h5, file$t, 123, 8, 3660);
    			attr_dev(label, "for", "Buscar");
    			add_location(label, file$t, 130, 32, 3984);
    			attr_dev(input, "type", "search");
    			attr_dev(input, "class", "form-control");
    			attr_dev(input, "placeholder", "Nombres, Apellidos o Cedula");
    			add_location(input, file$t, 131, 32, 4062);
    			attr_dev(div1, "class", "form-group");
    			add_location(div1, file$t, 129, 28, 3926);
    			attr_dev(div2, "class", "col-lg-4");
    			add_location(div2, file$t, 128, 24, 3874);
    			attr_dev(div3, "class", "row");
    			add_location(div3, file$t, 127, 20, 3831);
    			attr_dev(div4, "class", "col-12");
    			add_location(div4, file$t, 126, 16, 3789);
    			attr_dev(div5, "class", "row");
    			add_location(div5, file$t, 125, 8, 3754);
    			attr_dev(div6, "class", "alert alert-secondary");
    			attr_dev(div6, "role", "alert");
    			add_location(div6, file$t, 124, 8, 3696);
    			add_location(th0, file$t, 142, 20, 4532);
    			add_location(th1, file$t, 143, 20, 4563);
    			add_location(th2, file$t, 144, 20, 4600);
    			add_location(th3, file$t, 145, 20, 4637);
    			add_location(th4, file$t, 146, 20, 4672);
    			add_location(th5, file$t, 147, 20, 4707);
    			add_location(th6, file$t, 148, 20, 4743);
    			add_location(tr, file$t, 141, 16, 4506);
    			add_location(thead, file$t, 140, 16, 4481);
    			add_location(tbody, file$t, 151, 16, 4819);
    			attr_dev(table, "class", "table align-td-middle table-card");
    			add_location(table, file$t, 139, 12, 4415);
    			attr_dev(div7, "class", "table-responsive");
    			add_location(div7, file$t, 138, 8, 4371);
    			attr_dev(div8, "class", "col-md-12 mt-3 m-b-30");
    			add_location(div8, file$t, 122, 6, 3615);
    			attr_dev(div9, "class", "p-2");
    			add_location(div9, file$t, 120, 4, 3563);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$t, 119, 2, 3526);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$t, 112, 0, 3304);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t2);
    			append_dev(main, section);
    			append_dev(section, div9);
    			append_dev(div9, div0);
    			append_dev(div9, t3);
    			append_dev(div9, div8);
    			append_dev(div8, h5);
    			append_dev(div8, t5);
    			append_dev(div8, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, label);
    			append_dev(div1, t7);
    			append_dev(div1, input);
    			set_input_value(input, /*sltBuscarHistorias*/ ctx[2]);
    			append_dev(div8, t8);
    			append_dev(div8, div7);
    			append_dev(div7, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t9);
    			append_dev(tr, th1);
    			append_dev(tr, t11);
    			append_dev(tr, th2);
    			append_dev(tr, t13);
    			append_dev(tr, th3);
    			append_dev(tr, t15);
    			append_dev(tr, th4);
    			append_dev(tr, t17);
    			append_dev(tr, th5);
    			append_dev(tr, t19);
    			append_dev(tr, th6);
    			append_dev(table, t20);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(div8, t21);
    			if (if_block1) if_block1.m(div8, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(input, "input", /*searchHistorias*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*errorServer*/ ctx[1]) {
    				if (if_block0) {
    					if (dirty & /*errorServer*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(main, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*sltBuscarHistorias*/ 4) {
    				set_input_value(input, /*sltBuscarHistorias*/ ctx[2]);
    			}

    			if (dirty & /*historias, eliminarHistoria, Date, calcularEdad*/ 33) {
    				each_value = /*historias*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*cargando*/ ctx[3]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block$g(ctx);
    					if_block1.c();
    					if_block1.m(div8, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks, detaching);
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Index", slots, []);

    	const Toast = Swal.mixin({
    		toast: true,
    		position: "top-end",
    		showConfirmButton: false,
    		timer: 3000,
    		timerProgressBar: true,
    		didOpen: toast => {
    			toast.addEventListener("mouseenter", Swal.stopTimer);
    			toast.addEventListener("mouseleave", Swal.resumeTimer);
    		}
    	});

    	let historias = [];
    	let errorServer = false;
    	let sltBuscarHistorias = "";
    	let timeout = null;
    	let cargando = false;

    	const searchHistorias = () => {
    		if (timeout) {
    			window.clearTimeout(timeout);
    		}

    		timeout = setTimeout(
    			function () {
    				cargarHistorias();
    			},
    			300
    		);
    	};

    	const eliminarHistoria = idHistoria => {
    		const config = {
    			method: "delete",
    			url: `${url}/historias/${idHistoria}`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		Swal.fire({
    			title: "Estas seguro?",
    			text: "La historia se eliminara, sin embargo los datos no ser perdern y se podrn recuperar en el futuro!",
    			icon: "warning",
    			showCancelButton: true,
    			confirmButtonColor: "#3085d6",
    			cancelButtonColor: "#d33",
    			confirmButtonText: "Si, Eliminar!",
    			cancelButtonText: "Cancelar"
    		}).then(result => {
    			if (result.isConfirmed) {
    				axios$1(config).then(res => {
    					if (res.status === 200) {
    						cargarHistorias();

    						Toast.fire({
    							icon: "success",
    							title: "Se ha eliminado correctamente"
    						});
    					}
    				});
    			}
    		});
    	};

    	function cargarHistorias() {
    		$$invalidate(3, cargando = true);

    		const config = {
    			method: "get",
    			url: `${url}/historias?b=${sltBuscarHistorias}`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		try {
    			axios$1(config).then(res => {
    				$$invalidate(3, cargando = false);

    				if (res.status === 200) {
    					let { data } = res;
    					$$invalidate(0, historias = data);
    				}

    				if (res.status === 500) {
    					$$invalidate(1, errorServer = true);
    				}
    			}).catch(err => {
    				if (err) {
    					$$invalidate(1, errorServer = true);
    				}

    				console.error(err);
    			});
    		} catch(error) {
    			$$invalidate(3, cargando = false);

    			if (error) {
    				$$invalidate(1, errorServer = true);
    			}
    		}
    	}

    	onMount(() => {
    		cargarHistorias();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$e.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		sltBuscarHistorias = this.value;
    		$$invalidate(2, sltBuscarHistorias);
    	}

    	const click_handler = historia => eliminarHistoria(historia.id);

    	$$self.$capture_state = () => ({
    		link,
    		onMount,
    		axios: axios$1,
    		url,
    		calcularEdad,
    		Header,
    		Aside,
    		ErrorServer: ErrorConexion,
    		Toast,
    		historias,
    		errorServer,
    		sltBuscarHistorias,
    		timeout,
    		cargando,
    		searchHistorias,
    		eliminarHistoria,
    		cargarHistorias
    	});

    	$$self.$inject_state = $$props => {
    		if ("historias" in $$props) $$invalidate(0, historias = $$props.historias);
    		if ("errorServer" in $$props) $$invalidate(1, errorServer = $$props.errorServer);
    		if ("sltBuscarHistorias" in $$props) $$invalidate(2, sltBuscarHistorias = $$props.sltBuscarHistorias);
    		if ("timeout" in $$props) timeout = $$props.timeout;
    		if ("cargando" in $$props) $$invalidate(3, cargando = $$props.cargando);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		historias,
    		errorServer,
    		sltBuscarHistorias,
    		cargando,
    		searchHistorias,
    		eliminarHistoria,
    		input_input_handler,
    		click_handler
    	];
    }

    class Index$3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src\Pages\Recetas\Medicamentos.svelte generated by Svelte v3.29.0 */

    const { console: console_1$f } = globals;
    const file$u = "src\\Pages\\Recetas\\Medicamentos.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (100:4) {#if errorServer}
    function create_if_block$h(ctx) {
    	let errorconexion;
    	let current;

    	errorconexion = new ErrorConexion({
    			props: { msgError: "msgError" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(errorconexion.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorconexion, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorconexion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorconexion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorconexion, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(100:4) {#if errorServer}",
    		ctx
    	});

    	return block;
    }

    // (182:40) {#each medicamentos as medicamento}
    function create_each_block$b(ctx) {
    	let tr;
    	let td0;
    	let p0;
    	let t0_value = /*medicamento*/ ctx[11].nombre + "";
    	let t0;
    	let t1;
    	let p1;
    	let t2;
    	let t3_value = /*medicamento*/ ctx[11].concentracion + "";
    	let t3;
    	let t4;
    	let td1;
    	let t5_value = /*medicamento*/ ctx[11].cantidad + "";
    	let t5;
    	let t6;
    	let td2;
    	let t7_value = /*medicamento*/ ctx[11].frecuencia + "";
    	let t7;
    	let t8;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			p0 = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			p1 = element("p");
    			t2 = text("De ");
    			t3 = text(t3_value);
    			t4 = space();
    			td1 = element("td");
    			t5 = text(t5_value);
    			t6 = space();
    			td2 = element("td");
    			t7 = text(t7_value);
    			t8 = space();
    			attr_dev(p0, "class", "text-black m-0");
    			add_location(p0, file$u, 184, 52, 7170);
    			attr_dev(p1, "class", "text-muted");
    			set_style(p1, "padding-bottom", "0");
    			set_style(p1, "margin-bottom", "0");
    			add_location(p1, file$u, 185, 52, 7274);
    			attr_dev(td0, "class", " svelte-q2phs0");
    			add_location(td0, file$u, 183, 48, 7103);
    			attr_dev(td1, "class", "text-center svelte-q2phs0");
    			add_location(td1, file$u, 189, 48, 7592);
    			attr_dev(td2, "class", "text-center svelte-q2phs0");
    			add_location(td2, file$u, 190, 48, 7693);
    			add_location(tr, file$u, 182, 44, 7049);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, p0);
    			append_dev(p0, t0);
    			append_dev(td0, t1);
    			append_dev(td0, p1);
    			append_dev(p1, t2);
    			append_dev(p1, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td1);
    			append_dev(td1, t5);
    			append_dev(tr, t6);
    			append_dev(tr, td2);
    			append_dev(td2, t7);
    			append_dev(tr, t8);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*medicamentos*/ 8 && t0_value !== (t0_value = /*medicamento*/ ctx[11].nombre + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*medicamentos*/ 8 && t3_value !== (t3_value = /*medicamento*/ ctx[11].concentracion + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*medicamentos*/ 8 && t5_value !== (t5_value = /*medicamento*/ ctx[11].cantidad + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*medicamentos*/ 8 && t7_value !== (t7_value = /*medicamento*/ ctx[11].frecuencia + "")) set_data_dev(t7, t7_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(182:40) {#each medicamentos as medicamento}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let t2;
    	let section;
    	let div8;
    	let div7;
    	let div6;
    	let div5;
    	let div4;
    	let div1;
    	let div0;
    	let t3;
    	let div3;
    	let div2;
    	let t5;
    	let h4;
    	let t6_value = /*paciente*/ ctx[0].nombres + "";
    	let t6;
    	let t7;
    	let t8_value = /*paciente*/ ctx[0].apellidos + "";
    	let t8;
    	let t9;
    	let p0;
    	let t10;
    	let t11_value = /*historia*/ ctx[1].id + "";
    	let t11;
    	let t12;
    	let br0;
    	let t13;
    	let t14_value = new Date(/*historia*/ ctx[1].createdAt).toLocaleDateString("es-DO") + "";
    	let t14;
    	let t15;
    	let button;
    	let i;
    	let t16;
    	let t17;
    	let div24;
    	let div23;
    	let div22;
    	let div21;
    	let div20;
    	let div19;
    	let div11;
    	let div10;
    	let img;
    	let img_src_value;
    	let t18;
    	let div9;
    	let span;
    	let t19_value = /*empresa*/ ctx[2].nombre + "";
    	let t19;
    	let t20;
    	let t21;
    	let br1;
    	let t22;
    	let t23_value = (/*empresa*/ ctx[2].especialidades || "") + "";
    	let t23;
    	let t24;
    	let br2;
    	let t25;
    	let t26_value = /*empresa*/ ctx[2].direccion + "";
    	let t26;
    	let t27;
    	let br3;
    	let t28;
    	let t29_value = /*empresa*/ ctx[2].telefono + "";
    	let t29;
    	let t30;
    	let br4;
    	let t31;
    	let t32_value = /*empresa*/ ctx[2].correo + "";
    	let t32;
    	let t33;
    	let br5;
    	let t34;
    	let div12;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t36;
    	let th1;
    	let t38;
    	let th2;
    	let t40;
    	let tbody;
    	let t41;
    	let div17;
    	let div13;
    	let t42;
    	let div16;
    	let h5;
    	let t43_value = /*paciente*/ ctx[0].nombres + "";
    	let t43;
    	let t44;
    	let t45_value = /*paciente*/ ctx[0].apellidos + "";
    	let t45;
    	let t46;
    	let div14;
    	let t47;
    	let t48_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "";
    	let t48;
    	let t49;
    	let t50;
    	let div15;
    	let t53;
    	let div18;
    	let hr;
    	let t54;
    	let p1;
    	let t56;
    	let p2;
    	let strong;
    	let current;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });
    	let if_block = /*errorServer*/ ctx[5] && create_if_block$h(ctx);
    	let each_value = /*medicamentos*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			section = element("section");
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div2.textContent = "Para:";
    			t5 = space();
    			h4 = element("h4");
    			t6 = text(t6_value);
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			p0 = element("p");
    			t10 = text("ID Consulta #");
    			t11 = text(t11_value);
    			t12 = space();
    			br0 = element("br");
    			t13 = text("\r\n                                    Fecha Consulta : ");
    			t14 = text(t14_value);
    			t15 = space();
    			button = element("button");
    			i = element("i");
    			t16 = text("\r\n                                    Imprimir");
    			t17 = space();
    			div24 = element("div");
    			div23 = element("div");
    			div22 = element("div");
    			div21 = element("div");
    			div20 = element("div");
    			div19 = element("div");
    			div11 = element("div");
    			div10 = element("div");
    			img = element("img");
    			t18 = space();
    			div9 = element("div");
    			span = element("span");
    			t19 = text(t19_value);
    			t20 = text(",");
    			t21 = space();
    			br1 = element("br");
    			t22 = space();
    			t23 = text(t23_value);
    			t24 = space();
    			br2 = element("br");
    			t25 = space();
    			t26 = text(t26_value);
    			t27 = space();
    			br3 = element("br");
    			t28 = text("\r\n                                            Tel.: ");
    			t29 = text(t29_value);
    			t30 = space();
    			br4 = element("br");
    			t31 = space();
    			t32 = text(t32_value);
    			t33 = space();
    			br5 = element("br");
    			t34 = space();
    			div12 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Medicamento";
    			t36 = space();
    			th1 = element("th");
    			th1.textContent = "Cantidad";
    			t38 = space();
    			th2 = element("th");
    			th2.textContent = "Frecuencia";
    			t40 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t41 = space();
    			div17 = element("div");
    			div13 = element("div");
    			t42 = space();
    			div16 = element("div");
    			h5 = element("h5");
    			t43 = text(t43_value);
    			t44 = space();
    			t45 = text(t45_value);
    			t46 = space();
    			div14 = element("div");
    			t47 = text("Edad: ");
    			t48 = text(t48_value);
    			t49 = text(" aos");
    			t50 = space();
    			div15 = element("div");
    			div15.textContent = `Fecha: ${new Date().toLocaleDateString("es-DO")}`;
    			t53 = space();
    			div18 = element("div");
    			hr = element("hr");
    			t54 = space();
    			p1 = element("p");
    			p1.textContent = "Firma del especialista";
    			t56 = space();
    			p2 = element("p");
    			strong = element("strong");
    			strong.textContent = `${user().title}. ${user().name}`;
    			attr_dev(div0, "class", "avatar-title bg-success rounded-circle mdi mdi-receipt  ");
    			add_location(div0, file$u, 110, 32, 3219);
    			attr_dev(div1, "class", "avatar avatar mr-3");
    			add_location(div1, file$u, 109, 28, 3153);
    			attr_dev(div2, "class", "opacity-75");
    			add_location(div2, file$u, 115, 32, 3455);
    			attr_dev(h4, "class", "m-b-0");
    			add_location(h4, file$u, 116, 32, 3524);
    			add_location(br0, file$u, 118, 63, 3708);
    			attr_dev(p0, "class", "opacity-75");
    			add_location(p0, file$u, 117, 32, 3621);
    			attr_dev(i, "class", "mdi\r\n                                mdi-printer");
    			add_location(i, file$u, 121, 89, 3954);
    			attr_dev(button, "class", "btn btn-white-translucent");
    			attr_dev(button, "id", "printDiv");
    			add_location(button, file$u, 121, 32, 3897);
    			attr_dev(div3, "class", "media-body");
    			add_location(div3, file$u, 114, 28, 3397);
    			attr_dev(div4, "class", "media");
    			add_location(div4, file$u, 108, 24, 3104);
    			attr_dev(div5, "class", "col-md-6 text-white p-b-30");
    			add_location(div5, file$u, 107, 20, 3038);
    			attr_dev(div6, "class", "row p-b-60 p-t-60");
    			add_location(div6, file$u, 105, 16, 2983);
    			attr_dev(div7, "class", "container");
    			add_location(div7, file$u, 104, 12, 2942);
    			attr_dev(div8, "class", "bg-dark m-b-30");
    			add_location(div8, file$u, 103, 8, 2900);
    			if (img.src !== (img_src_value = /*logo*/ ctx[4])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "logo svelte-q2phs0");
    			attr_dev(img, "alt", "");
    			add_location(img, file$u, 158, 40, 5676);
    			attr_dev(span, "class", "h4 font-primary");
    			add_location(span, file$u, 160, 44, 5820);
    			add_location(br1, file$u, 160, 100, 5876);
    			add_location(br2, file$u, 161, 75, 5957);
    			add_location(br3, file$u, 162, 64, 6027);
    			add_location(br4, file$u, 163, 69, 6102);
    			add_location(br5, file$u, 164, 61, 6169);
    			attr_dev(div9, "class", "m-t-10");
    			add_location(div9, file$u, 159, 40, 5754);
    			attr_dev(div10, "class", "col-md-12 empresa-datos svelte-q2phs0");
    			add_location(div10, file$u, 157, 36, 5597);
    			attr_dev(div11, "class", "row");
    			add_location(div11, file$u, 156, 32, 5542);
    			attr_dev(th0, "class", "");
    			add_location(th0, file$u, 175, 44, 6583);
    			attr_dev(th1, "class", "text-center");
    			add_location(th1, file$u, 176, 44, 6658);
    			attr_dev(th2, "class", "text-center");
    			add_location(th2, file$u, 177, 44, 6741);
    			add_location(tr, file$u, 174, 40, 6533);
    			add_location(thead, file$u, 173, 40, 6484);
    			add_location(tbody, file$u, 180, 40, 6919);
    			attr_dev(table, "class", "table m-t-50");
    			add_location(table, file$u, 172, 36, 6414);
    			attr_dev(div12, "class", "table-responsive ");
    			add_location(div12, file$u, 171, 32, 6345);
    			attr_dev(div13, "class", "col-md-6");
    			add_location(div13, file$u, 197, 36, 8071);
    			attr_dev(h5, "class", "font-primary");
    			add_location(h5, file$u, 201, 40, 8260);
    			attr_dev(div14, "class", "");
    			add_location(div14, file$u, 202, 40, 8371);
    			attr_dev(div15, "class", "");
    			add_location(div15, file$u, 203, 40, 8484);
    			attr_dev(div16, "class", "col-md-6 text-right my-auto");
    			add_location(div16, file$u, 200, 36, 8177);
    			attr_dev(div17, "class", "row");
    			add_location(div17, file$u, 196, 32, 8016);
    			add_location(hr, file$u, 207, 36, 8726);
    			set_style(p1, "margin-bottom", "0");
    			add_location(p1, file$u, 208, 36, 8768);
    			add_location(strong, file$u, 209, 39, 8864);
    			add_location(p2, file$u, 209, 36, 8861);
    			attr_dev(div18, "class", "firma svelte-q2phs0");
    			add_location(div18, file$u, 206, 32, 8669);
    			attr_dev(div19, "class", "card-body");
    			add_location(div19, file$u, 155, 28, 5485);
    			attr_dev(div20, "class", "card");
    			add_location(div20, file$u, 154, 24, 5437);
    			attr_dev(div21, "class", "col-md-12 m-b-40");
    			add_location(div21, file$u, 153, 20, 5381);
    			attr_dev(div22, "class", "row");
    			add_location(div22, file$u, 152, 16, 5342);
    			attr_dev(div23, "class", "container");
    			attr_dev(div23, "id", "printableArea");
    			add_location(div23, file$u, 151, 12, 5282);
    			attr_dev(div24, "class", "pull-up");
    			add_location(div24, file$u, 150, 8, 5247);
    			attr_dev(section, "class", "admin-content ");
    			add_location(section, file$u, 102, 4, 2858);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$u, 97, 2, 2731);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			if (if_block) if_block.m(main, null);
    			append_dev(main, t2);
    			append_dev(main, section);
    			append_dev(section, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div3, t5);
    			append_dev(div3, h4);
    			append_dev(h4, t6);
    			append_dev(h4, t7);
    			append_dev(h4, t8);
    			append_dev(div3, t9);
    			append_dev(div3, p0);
    			append_dev(p0, t10);
    			append_dev(p0, t11);
    			append_dev(p0, t12);
    			append_dev(p0, br0);
    			append_dev(p0, t13);
    			append_dev(p0, t14);
    			append_dev(div3, t15);
    			append_dev(div3, button);
    			append_dev(button, i);
    			append_dev(button, t16);
    			append_dev(section, t17);
    			append_dev(section, div24);
    			append_dev(div24, div23);
    			append_dev(div23, div22);
    			append_dev(div22, div21);
    			append_dev(div21, div20);
    			append_dev(div20, div19);
    			append_dev(div19, div11);
    			append_dev(div11, div10);
    			append_dev(div10, img);
    			append_dev(div10, t18);
    			append_dev(div10, div9);
    			append_dev(div9, span);
    			append_dev(span, t19);
    			append_dev(span, t20);
    			append_dev(div9, t21);
    			append_dev(div9, br1);
    			append_dev(div9, t22);
    			append_dev(div9, t23);
    			append_dev(div9, t24);
    			append_dev(div9, br2);
    			append_dev(div9, t25);
    			append_dev(div9, t26);
    			append_dev(div9, t27);
    			append_dev(div9, br3);
    			append_dev(div9, t28);
    			append_dev(div9, t29);
    			append_dev(div9, t30);
    			append_dev(div9, br4);
    			append_dev(div9, t31);
    			append_dev(div9, t32);
    			append_dev(div9, t33);
    			append_dev(div9, br5);
    			append_dev(div19, t34);
    			append_dev(div19, div12);
    			append_dev(div12, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t36);
    			append_dev(tr, th1);
    			append_dev(tr, t38);
    			append_dev(tr, th2);
    			append_dev(table, t40);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(div19, t41);
    			append_dev(div19, div17);
    			append_dev(div17, div13);
    			append_dev(div17, t42);
    			append_dev(div17, div16);
    			append_dev(div16, h5);
    			append_dev(h5, t43);
    			append_dev(h5, t44);
    			append_dev(h5, t45);
    			append_dev(div16, t46);
    			append_dev(div16, div14);
    			append_dev(div14, t47);
    			append_dev(div14, t48);
    			append_dev(div14, t49);
    			append_dev(div16, t50);
    			append_dev(div16, div15);
    			append_dev(div19, t53);
    			append_dev(div19, div18);
    			append_dev(div18, hr);
    			append_dev(div18, t54);
    			append_dev(div18, p1);
    			append_dev(div18, t56);
    			append_dev(div18, p2);
    			append_dev(p2, strong);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*paciente*/ 1) && t6_value !== (t6_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*paciente*/ 1) && t8_value !== (t8_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty & /*historia*/ 2) && t11_value !== (t11_value = /*historia*/ ctx[1].id + "")) set_data_dev(t11, t11_value);
    			if ((!current || dirty & /*historia*/ 2) && t14_value !== (t14_value = new Date(/*historia*/ ctx[1].createdAt).toLocaleDateString("es-DO") + "")) set_data_dev(t14, t14_value);

    			if (!current || dirty & /*logo*/ 16 && img.src !== (img_src_value = /*logo*/ ctx[4])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if ((!current || dirty & /*empresa*/ 4) && t19_value !== (t19_value = /*empresa*/ ctx[2].nombre + "")) set_data_dev(t19, t19_value);
    			if ((!current || dirty & /*empresa*/ 4) && t23_value !== (t23_value = (/*empresa*/ ctx[2].especialidades || "") + "")) set_data_dev(t23, t23_value);
    			if ((!current || dirty & /*empresa*/ 4) && t26_value !== (t26_value = /*empresa*/ ctx[2].direccion + "")) set_data_dev(t26, t26_value);
    			if ((!current || dirty & /*empresa*/ 4) && t29_value !== (t29_value = /*empresa*/ ctx[2].telefono + "")) set_data_dev(t29, t29_value);
    			if ((!current || dirty & /*empresa*/ 4) && t32_value !== (t32_value = /*empresa*/ ctx[2].correo + "")) set_data_dev(t32, t32_value);

    			if (dirty & /*medicamentos*/ 8) {
    				each_value = /*medicamentos*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if ((!current || dirty & /*paciente*/ 1) && t43_value !== (t43_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t43, t43_value);
    			if ((!current || dirty & /*paciente*/ 1) && t45_value !== (t45_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t45, t45_value);
    			if ((!current || dirty & /*paciente*/ 1) && t48_value !== (t48_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "")) set_data_dev(t48, t48_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Medicamentos", slots, []);
    	let { params } = $$props;
    	let errorServer = false;
    	let paciente = {};
    	let historia = {};
    	let empresa = {};
    	let medicamentos = [];
    	let logo = "";

    	const cargarImagenEmpresa = (idConsultorio, idImagen) => {
    		const config = {
    			method: "get",
    			url: `${url}/imagenes/${idConsultorio}/${idImagen}`,
    			responseType: "blob",
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(4, logo = URL.createObjectURL(res.data));
    			console.log(logo);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarPaciente = () => {
    		const config = {
    			method: "get",
    			url: `${url}/pacientes/${params.idPaciente}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(0, paciente = res.data);
    			console.log(paciente);
    		});
    	};

    	const cargarHistoria = () => {
    		const config = {
    			method: "get",
    			url: `${url}/historias/${params.idHistoria}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(1, historia = res.data);
    			$$invalidate(3, medicamentos = res.data.medicamentos);
    			console.log(historia);
    		});
    	};

    	const cargarEmpresa = () => {
    		const config = {
    			method: "get",
    			url: `${url}/empresas/${user().empresa}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(2, empresa = res.data);
    			cargarImagenEmpresa(empresa.id, empresa.logo);
    			console.log(empresa);
    		});
    	};

    	onMount(() => {
    		jQuery("html, body").animate({ scrollTop: 0 }, "slow");
    		cargarPaciente();
    		cargarHistoria();
    		cargarEmpresa();

    		window.onafterprint = event => {
    			location.reload();
    		};
    	});

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$f.warn(`<Medicamentos> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(6, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		onMount,
    		calcularEdad,
    		url,
    		user,
    		Header,
    		Aside,
    		ErrorConexion,
    		params,
    		errorServer,
    		paciente,
    		historia,
    		empresa,
    		medicamentos,
    		logo,
    		cargarImagenEmpresa,
    		cargarPaciente,
    		cargarHistoria,
    		cargarEmpresa
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(6, params = $$props.params);
    		if ("errorServer" in $$props) $$invalidate(5, errorServer = $$props.errorServer);
    		if ("paciente" in $$props) $$invalidate(0, paciente = $$props.paciente);
    		if ("historia" in $$props) $$invalidate(1, historia = $$props.historia);
    		if ("empresa" in $$props) $$invalidate(2, empresa = $$props.empresa);
    		if ("medicamentos" in $$props) $$invalidate(3, medicamentos = $$props.medicamentos);
    		if ("logo" in $$props) $$invalidate(4, logo = $$props.logo);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [paciente, historia, empresa, medicamentos, logo, errorServer, params];
    }

    class Medicamentos extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { params: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Medicamentos",
    			options,
    			id: create_fragment$w.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*params*/ ctx[6] === undefined && !("params" in props)) {
    			console_1$f.warn("<Medicamentos> was created without expected prop 'params'");
    		}
    	}

    	get params() {
    		throw new Error("<Medicamentos>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Medicamentos>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Recetas\Estudios.svelte generated by Svelte v3.29.0 */

    const { console: console_1$g } = globals;
    const file$v = "src\\Pages\\Recetas\\Estudios.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (97:4) {#if errorServer}
    function create_if_block_2$8(ctx) {
    	let errorconexion;
    	let current;

    	errorconexion = new ErrorConexion({
    			props: { msgError: "msgError" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(errorconexion.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorconexion, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorconexion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorconexion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorconexion, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(97:4) {#if errorServer}",
    		ctx
    	});

    	return block;
    }

    // (175:43) {#if estudio.tipo === 'LAB'}
    function create_if_block_1$b(ctx) {
    	let div;
    	let t0_value = /*estudio*/ ctx[11].descripcion + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "col-lg-3 mb-3 estudio svelte-1ta81s6");
    			add_location(div, file$v, 175, 47, 6772);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*estudios*/ 8 && t0_value !== (t0_value = /*estudio*/ ctx[11].descripcion + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(175:43) {#if estudio.tipo === 'LAB'}",
    		ctx
    	});

    	return block;
    }

    // (174:39) {#each estudios as estudio}
    function create_each_block$c(ctx) {
    	let if_block_anchor;
    	let if_block = /*estudio*/ ctx[11].tipo === "LAB" && create_if_block_1$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*estudio*/ ctx[11].tipo === "LAB") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$b(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(174:39) {#each estudios as estudio}",
    		ctx
    	});

    	return block;
    }

    // (183:32) {#if historia.instrucciones}
    function create_if_block$i(ctx) {
    	let div1;
    	let div0;
    	let strong;
    	let t1;
    	let t2_value = /*historia*/ ctx[1].instrucciones + "";
    	let t2;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			strong = element("strong");
    			strong.textContent = "Observaciones:";
    			t1 = space();
    			t2 = text(t2_value);
    			add_location(strong, file$v, 184, 41, 7282);
    			add_location(div0, file$v, 184, 36, 7277);
    			attr_dev(div1, "class", "bg-light pie svelte-1ta81s6");
    			add_location(div1, file$v, 183, 32, 7213);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, strong);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*historia*/ 2 && t2_value !== (t2_value = /*historia*/ ctx[1].instrucciones + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(183:32) {#if historia.instrucciones}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let t2;
    	let section;
    	let div8;
    	let div7;
    	let div6;
    	let div5;
    	let div4;
    	let div1;
    	let div0;
    	let t3;
    	let div3;
    	let div2;
    	let t5;
    	let h4;
    	let t6_value = /*paciente*/ ctx[0].nombres + "";
    	let t6;
    	let t7;
    	let t8_value = /*paciente*/ ctx[0].apellidos + "";
    	let t8;
    	let t9;
    	let p0;
    	let t10;
    	let t11_value = /*historia*/ ctx[1].id + "";
    	let t11;
    	let t12;
    	let br0;
    	let t13;
    	let t14_value = new Date(/*historia*/ ctx[1].createdAt).toLocaleDateString("es-DO") + "";
    	let t14;
    	let t15;
    	let button;
    	let i;
    	let t16;
    	let t17;
    	let div27;
    	let div26;
    	let div25;
    	let div24;
    	let div23;
    	let div22;
    	let div11;
    	let div10;
    	let img;
    	let img_src_value;
    	let t18;
    	let div9;
    	let span;
    	let t19_value = /*empresa*/ ctx[2].nombre + "";
    	let t19;
    	let t20;
    	let t21;
    	let br1;
    	let t22;
    	let t23_value = (/*empresa*/ ctx[2].especialidades || "") + "";
    	let t23;
    	let t24;
    	let br2;
    	let t25;
    	let t26_value = /*empresa*/ ctx[2].direccion + "";
    	let t26;
    	let t27;
    	let br3;
    	let t28;
    	let t29_value = /*empresa*/ ctx[2].telefono + "";
    	let t29;
    	let t30;
    	let br4;
    	let t31;
    	let t32_value = /*empresa*/ ctx[2].correo + "";
    	let t32;
    	let t33;
    	let br5;
    	let t34;
    	let div13;
    	let div12;
    	let t36;
    	let hr0;
    	let t37;
    	let div15;
    	let div14;
    	let t38;
    	let t39;
    	let div20;
    	let div16;
    	let t40;
    	let div19;
    	let h5;
    	let t41_value = /*paciente*/ ctx[0].nombres + "";
    	let t41;
    	let t42;
    	let t43_value = /*paciente*/ ctx[0].apellidos + "";
    	let t43;
    	let t44;
    	let div17;
    	let t45;
    	let t46_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "";
    	let t46;
    	let t47;
    	let t48;
    	let div18;
    	let t51;
    	let div21;
    	let hr1;
    	let t52;
    	let p1;
    	let t54;
    	let p2;
    	let strong;
    	let current;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });
    	let if_block0 = /*errorServer*/ ctx[5] && create_if_block_2$8(ctx);
    	let each_value = /*estudios*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	let if_block1 = /*historia*/ ctx[1].instrucciones && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			section = element("section");
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div2.textContent = "Para:";
    			t5 = space();
    			h4 = element("h4");
    			t6 = text(t6_value);
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			p0 = element("p");
    			t10 = text("ID Consulta #");
    			t11 = text(t11_value);
    			t12 = space();
    			br0 = element("br");
    			t13 = text("\r\n                                    Fecha Consulta : ");
    			t14 = text(t14_value);
    			t15 = space();
    			button = element("button");
    			i = element("i");
    			t16 = text("\r\n                                    Imprimir");
    			t17 = space();
    			div27 = element("div");
    			div26 = element("div");
    			div25 = element("div");
    			div24 = element("div");
    			div23 = element("div");
    			div22 = element("div");
    			div11 = element("div");
    			div10 = element("div");
    			img = element("img");
    			t18 = space();
    			div9 = element("div");
    			span = element("span");
    			t19 = text(t19_value);
    			t20 = text(",");
    			t21 = space();
    			br1 = element("br");
    			t22 = space();
    			t23 = text(t23_value);
    			t24 = space();
    			br2 = element("br");
    			t25 = space();
    			t26 = text(t26_value);
    			t27 = space();
    			br3 = element("br");
    			t28 = text("\r\n                                            Tel.: ");
    			t29 = text(t29_value);
    			t30 = space();
    			br4 = element("br");
    			t31 = space();
    			t32 = text(t32_value);
    			t33 = space();
    			br5 = element("br");
    			t34 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div12.textContent = "Estudios de laboratorios";
    			t36 = space();
    			hr0 = element("hr");
    			t37 = space();
    			div15 = element("div");
    			div14 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t38 = space();
    			if (if_block1) if_block1.c();
    			t39 = space();
    			div20 = element("div");
    			div16 = element("div");
    			t40 = space();
    			div19 = element("div");
    			h5 = element("h5");
    			t41 = text(t41_value);
    			t42 = space();
    			t43 = text(t43_value);
    			t44 = space();
    			div17 = element("div");
    			t45 = text("Edad: ");
    			t46 = text(t46_value);
    			t47 = text(" aos");
    			t48 = space();
    			div18 = element("div");
    			div18.textContent = `Fecha: ${new Date().toLocaleDateString("es-DO")}`;
    			t51 = space();
    			div21 = element("div");
    			hr1 = element("hr");
    			t52 = space();
    			p1 = element("p");
    			p1.textContent = "Firma del especialista";
    			t54 = space();
    			p2 = element("p");
    			strong = element("strong");
    			strong.textContent = `${user().title}. ${user().name}`;
    			attr_dev(div0, "class", "avatar-title bg-success rounded-circle mdi mdi-receipt  ");
    			add_location(div0, file$v, 107, 32, 3120);
    			attr_dev(div1, "class", "avatar avatar mr-3");
    			add_location(div1, file$v, 106, 28, 3054);
    			attr_dev(div2, "class", "opacity-75");
    			add_location(div2, file$v, 112, 32, 3356);
    			attr_dev(h4, "class", "m-b-0");
    			add_location(h4, file$v, 113, 32, 3425);
    			add_location(br0, file$v, 115, 63, 3609);
    			attr_dev(p0, "class", "opacity-75");
    			add_location(p0, file$v, 114, 32, 3522);
    			attr_dev(i, "class", "mdi\r\n                                mdi-printer");
    			add_location(i, file$v, 118, 89, 3855);
    			attr_dev(button, "class", "btn btn-white-translucent");
    			attr_dev(button, "id", "printDiv");
    			add_location(button, file$v, 118, 32, 3798);
    			attr_dev(div3, "class", "media-body");
    			add_location(div3, file$v, 111, 28, 3298);
    			attr_dev(div4, "class", "media");
    			add_location(div4, file$v, 105, 24, 3005);
    			attr_dev(div5, "class", "col-md-6 text-white p-b-30");
    			add_location(div5, file$v, 104, 20, 2939);
    			attr_dev(div6, "class", "row p-b-60 p-t-60");
    			add_location(div6, file$v, 102, 16, 2884);
    			attr_dev(div7, "class", "container");
    			add_location(div7, file$v, 101, 12, 2843);
    			attr_dev(div8, "class", "bg-dark m-b-30");
    			add_location(div8, file$v, 100, 8, 2801);
    			if (img.src !== (img_src_value = /*logo*/ ctx[4])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "logo svelte-1ta81s6");
    			attr_dev(img, "alt", "");
    			add_location(img, file$v, 155, 40, 5577);
    			attr_dev(span, "class", "h4 font-primary");
    			add_location(span, file$v, 157, 44, 5721);
    			add_location(br1, file$v, 157, 100, 5777);
    			add_location(br2, file$v, 158, 75, 5858);
    			add_location(br3, file$v, 159, 64, 5928);
    			add_location(br4, file$v, 160, 69, 6003);
    			add_location(br5, file$v, 161, 61, 6070);
    			attr_dev(div9, "class", "m-t-10");
    			add_location(div9, file$v, 156, 40, 5655);
    			attr_dev(div10, "class", "col-md-12 empresa-datos svelte-1ta81s6");
    			add_location(div10, file$v, 154, 36, 5498);
    			attr_dev(div11, "class", "row");
    			add_location(div11, file$v, 153, 32, 5443);
    			add_location(div12, file$v, 168, 36, 6313);
    			attr_dev(div13, "class", "bg-light cabecera svelte-1ta81s6");
    			add_location(div13, file$v, 167, 32, 6244);
    			set_style(hr0, "margin", "0");
    			add_location(hr0, file$v, 170, 32, 6422);
    			attr_dev(div14, "class", "row mt-3 mb-3 contenedor-estudios svelte-1ta81s6");
    			add_location(div14, file$v, 172, 35, 6535);
    			attr_dev(div15, "class", "col-12");
    			add_location(div15, file$v, 171, 32, 6478);
    			attr_dev(div16, "class", "col-md-6");
    			add_location(div16, file$v, 189, 36, 7514);
    			attr_dev(h5, "class", "font-primary");
    			add_location(h5, file$v, 193, 40, 7703);
    			attr_dev(div17, "class", "");
    			add_location(div17, file$v, 194, 40, 7814);
    			attr_dev(div18, "class", "");
    			add_location(div18, file$v, 195, 40, 7927);
    			attr_dev(div19, "class", "col-md-6 text-right my-auto");
    			add_location(div19, file$v, 192, 36, 7620);
    			attr_dev(div20, "class", "row");
    			add_location(div20, file$v, 188, 32, 7459);
    			add_location(hr1, file$v, 199, 36, 8169);
    			set_style(p1, "margin-bottom", "0");
    			add_location(p1, file$v, 200, 36, 8211);
    			add_location(strong, file$v, 201, 39, 8307);
    			add_location(p2, file$v, 201, 36, 8304);
    			attr_dev(div21, "class", "firma svelte-1ta81s6");
    			add_location(div21, file$v, 198, 32, 8112);
    			attr_dev(div22, "class", "card-body");
    			add_location(div22, file$v, 152, 28, 5386);
    			attr_dev(div23, "class", "card");
    			add_location(div23, file$v, 151, 24, 5338);
    			attr_dev(div24, "class", "col-md-12 m-b-40");
    			add_location(div24, file$v, 150, 20, 5282);
    			attr_dev(div25, "class", "row");
    			add_location(div25, file$v, 149, 16, 5243);
    			attr_dev(div26, "class", "container");
    			attr_dev(div26, "id", "printableArea");
    			add_location(div26, file$v, 148, 12, 5183);
    			attr_dev(div27, "class", "pull-up");
    			add_location(div27, file$v, 147, 8, 5148);
    			attr_dev(section, "class", "admin-content ");
    			add_location(section, file$v, 99, 4, 2759);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$v, 94, 2, 2632);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t2);
    			append_dev(main, section);
    			append_dev(section, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div3, t5);
    			append_dev(div3, h4);
    			append_dev(h4, t6);
    			append_dev(h4, t7);
    			append_dev(h4, t8);
    			append_dev(div3, t9);
    			append_dev(div3, p0);
    			append_dev(p0, t10);
    			append_dev(p0, t11);
    			append_dev(p0, t12);
    			append_dev(p0, br0);
    			append_dev(p0, t13);
    			append_dev(p0, t14);
    			append_dev(div3, t15);
    			append_dev(div3, button);
    			append_dev(button, i);
    			append_dev(button, t16);
    			append_dev(section, t17);
    			append_dev(section, div27);
    			append_dev(div27, div26);
    			append_dev(div26, div25);
    			append_dev(div25, div24);
    			append_dev(div24, div23);
    			append_dev(div23, div22);
    			append_dev(div22, div11);
    			append_dev(div11, div10);
    			append_dev(div10, img);
    			append_dev(div10, t18);
    			append_dev(div10, div9);
    			append_dev(div9, span);
    			append_dev(span, t19);
    			append_dev(span, t20);
    			append_dev(div9, t21);
    			append_dev(div9, br1);
    			append_dev(div9, t22);
    			append_dev(div9, t23);
    			append_dev(div9, t24);
    			append_dev(div9, br2);
    			append_dev(div9, t25);
    			append_dev(div9, t26);
    			append_dev(div9, t27);
    			append_dev(div9, br3);
    			append_dev(div9, t28);
    			append_dev(div9, t29);
    			append_dev(div9, t30);
    			append_dev(div9, br4);
    			append_dev(div9, t31);
    			append_dev(div9, t32);
    			append_dev(div9, t33);
    			append_dev(div9, br5);
    			append_dev(div22, t34);
    			append_dev(div22, div13);
    			append_dev(div13, div12);
    			append_dev(div22, t36);
    			append_dev(div22, hr0);
    			append_dev(div22, t37);
    			append_dev(div22, div15);
    			append_dev(div15, div14);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div14, null);
    			}

    			append_dev(div22, t38);
    			if (if_block1) if_block1.m(div22, null);
    			append_dev(div22, t39);
    			append_dev(div22, div20);
    			append_dev(div20, div16);
    			append_dev(div20, t40);
    			append_dev(div20, div19);
    			append_dev(div19, h5);
    			append_dev(h5, t41);
    			append_dev(h5, t42);
    			append_dev(h5, t43);
    			append_dev(div19, t44);
    			append_dev(div19, div17);
    			append_dev(div17, t45);
    			append_dev(div17, t46);
    			append_dev(div17, t47);
    			append_dev(div19, t48);
    			append_dev(div19, div18);
    			append_dev(div22, t51);
    			append_dev(div22, div21);
    			append_dev(div21, hr1);
    			append_dev(div21, t52);
    			append_dev(div21, p1);
    			append_dev(div21, t54);
    			append_dev(div21, p2);
    			append_dev(p2, strong);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*paciente*/ 1) && t6_value !== (t6_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*paciente*/ 1) && t8_value !== (t8_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty & /*historia*/ 2) && t11_value !== (t11_value = /*historia*/ ctx[1].id + "")) set_data_dev(t11, t11_value);
    			if ((!current || dirty & /*historia*/ 2) && t14_value !== (t14_value = new Date(/*historia*/ ctx[1].createdAt).toLocaleDateString("es-DO") + "")) set_data_dev(t14, t14_value);

    			if (!current || dirty & /*logo*/ 16 && img.src !== (img_src_value = /*logo*/ ctx[4])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if ((!current || dirty & /*empresa*/ 4) && t19_value !== (t19_value = /*empresa*/ ctx[2].nombre + "")) set_data_dev(t19, t19_value);
    			if ((!current || dirty & /*empresa*/ 4) && t23_value !== (t23_value = (/*empresa*/ ctx[2].especialidades || "") + "")) set_data_dev(t23, t23_value);
    			if ((!current || dirty & /*empresa*/ 4) && t26_value !== (t26_value = /*empresa*/ ctx[2].direccion + "")) set_data_dev(t26, t26_value);
    			if ((!current || dirty & /*empresa*/ 4) && t29_value !== (t29_value = /*empresa*/ ctx[2].telefono + "")) set_data_dev(t29, t29_value);
    			if ((!current || dirty & /*empresa*/ 4) && t32_value !== (t32_value = /*empresa*/ ctx[2].correo + "")) set_data_dev(t32, t32_value);

    			if (dirty & /*estudios*/ 8) {
    				each_value = /*estudios*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div14, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*historia*/ ctx[1].instrucciones) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$i(ctx);
    					if_block1.c();
    					if_block1.m(div22, t39);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if ((!current || dirty & /*paciente*/ 1) && t41_value !== (t41_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t41, t41_value);
    			if ((!current || dirty & /*paciente*/ 1) && t43_value !== (t43_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t43, t43_value);
    			if ((!current || dirty & /*paciente*/ 1) && t46_value !== (t46_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "")) set_data_dev(t46, t46_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks, detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Estudios", slots, []);
    	let { params } = $$props;
    	let errorServer = false;
    	let paciente = {};
    	let historia = {};
    	let empresa = {};
    	let estudios = [];
    	let logo = "";

    	const cargarImagenEmpresa = (idConsultorio, idImagen) => {
    		const config = {
    			method: "get",
    			url: `${url}/imagenes/${idConsultorio}/${idImagen}`,
    			responseType: "blob",
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(4, logo = URL.createObjectURL(res.data));
    			console.log(logo);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarPaciente = () => {
    		const config = {
    			method: "get",
    			url: `${url}/pacientes/${params.idPaciente}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(0, paciente = res.data);
    			console.log(paciente);
    		});
    	};

    	const cargarHistoria = () => {
    		const config = {
    			method: "get",
    			url: `${url}/historias/${params.idHistoria}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(1, historia = res.data);
    			$$invalidate(3, estudios = res.data.estudios);
    			console.log(historia);
    		});
    	};

    	const cargarEmpresa = () => {
    		const config = {
    			method: "get",
    			url: `${url}/empresas/${user().empresa}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(2, empresa = res.data);
    			cargarImagenEmpresa(empresa.id, empresa.logo);
    			console.log(empresa);
    		});
    	};

    	onMount(() => {
    		jQuery("html, body").animate({ scrollTop: 0 }, "slow");
    		cargarPaciente();
    		cargarHistoria();
    		cargarEmpresa();
    	});

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$g.warn(`<Estudios> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(6, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		onMount,
    		calcularEdad,
    		url,
    		user,
    		Header,
    		Aside,
    		ErrorConexion,
    		params,
    		errorServer,
    		paciente,
    		historia,
    		empresa,
    		estudios,
    		logo,
    		cargarImagenEmpresa,
    		cargarPaciente,
    		cargarHistoria,
    		cargarEmpresa
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(6, params = $$props.params);
    		if ("errorServer" in $$props) $$invalidate(5, errorServer = $$props.errorServer);
    		if ("paciente" in $$props) $$invalidate(0, paciente = $$props.paciente);
    		if ("historia" in $$props) $$invalidate(1, historia = $$props.historia);
    		if ("empresa" in $$props) $$invalidate(2, empresa = $$props.empresa);
    		if ("estudios" in $$props) $$invalidate(3, estudios = $$props.estudios);
    		if ("logo" in $$props) $$invalidate(4, logo = $$props.logo);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [paciente, historia, empresa, estudios, logo, errorServer, params];
    }

    class Estudios extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, { params: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Estudios",
    			options,
    			id: create_fragment$x.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*params*/ ctx[6] === undefined && !("params" in props)) {
    			console_1$g.warn("<Estudios> was created without expected prop 'params'");
    		}
    	}

    	get params() {
    		throw new Error("<Estudios>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Estudios>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Recetas\Imagenes.svelte generated by Svelte v3.29.0 */

    const { console: console_1$h } = globals;
    const file$w = "src\\Pages\\Recetas\\Imagenes.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (100:4) {#if errorServer}
    function create_if_block_2$9(ctx) {
    	let errorconexion;
    	let current;

    	errorconexion = new ErrorConexion({
    			props: { msgError: "msgError" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(errorconexion.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorconexion, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorconexion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorconexion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorconexion, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(100:4) {#if errorServer}",
    		ctx
    	});

    	return block;
    }

    // (178:43) {#if estudio.tipo === 'IMG'}
    function create_if_block_1$c(ctx) {
    	let div;
    	let t0_value = /*estudio*/ ctx[11].descripcion + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "col-lg-3 mb-3 estudio svelte-n1341u");
    			add_location(div, file$w, 178, 47, 6855);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*estudios*/ 8 && t0_value !== (t0_value = /*estudio*/ ctx[11].descripcion + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(178:43) {#if estudio.tipo === 'IMG'}",
    		ctx
    	});

    	return block;
    }

    // (177:39) {#each estudios as estudio}
    function create_each_block$d(ctx) {
    	let if_block_anchor;
    	let if_block = /*estudio*/ ctx[11].tipo === "IMG" && create_if_block_1$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*estudio*/ ctx[11].tipo === "IMG") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$c(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(177:39) {#each estudios as estudio}",
    		ctx
    	});

    	return block;
    }

    // (186:32) {#if historia.instrucciones}
    function create_if_block$j(ctx) {
    	let div1;
    	let div0;
    	let strong;
    	let t1;
    	let t2_value = /*historia*/ ctx[1].instrucciones + "";
    	let t2;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			strong = element("strong");
    			strong.textContent = "Observaciones:";
    			t1 = space();
    			t2 = text(t2_value);
    			add_location(strong, file$w, 187, 41, 7365);
    			add_location(div0, file$w, 187, 36, 7360);
    			attr_dev(div1, "class", "bg-light pie svelte-n1341u");
    			add_location(div1, file$w, 186, 32, 7296);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, strong);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*historia*/ 2 && t2_value !== (t2_value = /*historia*/ ctx[1].instrucciones + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(186:32) {#if historia.instrucciones}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let t2;
    	let section;
    	let div8;
    	let div7;
    	let div6;
    	let div5;
    	let div4;
    	let div1;
    	let div0;
    	let t3;
    	let div3;
    	let div2;
    	let t5;
    	let h4;
    	let t6_value = /*paciente*/ ctx[0].nombres + "";
    	let t6;
    	let t7;
    	let t8_value = /*paciente*/ ctx[0].apellidos + "";
    	let t8;
    	let t9;
    	let p0;
    	let t10;
    	let t11_value = /*historia*/ ctx[1].id + "";
    	let t11;
    	let t12;
    	let br0;
    	let t13;
    	let t14_value = new Date(/*historia*/ ctx[1].createdAt).toLocaleDateString("es-DO") + "";
    	let t14;
    	let t15;
    	let button;
    	let i;
    	let t16;
    	let t17;
    	let div27;
    	let div26;
    	let div25;
    	let div24;
    	let div23;
    	let div22;
    	let div11;
    	let div10;
    	let img;
    	let img_src_value;
    	let t18;
    	let div9;
    	let span;
    	let t19_value = /*empresa*/ ctx[2].nombre + "";
    	let t19;
    	let t20;
    	let t21;
    	let br1;
    	let t22;
    	let t23_value = (/*empresa*/ ctx[2].especialidades || "") + "";
    	let t23;
    	let t24;
    	let br2;
    	let t25;
    	let t26_value = /*empresa*/ ctx[2].direccion + "";
    	let t26;
    	let t27;
    	let br3;
    	let t28;
    	let t29_value = /*empresa*/ ctx[2].telefono + "";
    	let t29;
    	let t30;
    	let br4;
    	let t31;
    	let t32_value = /*empresa*/ ctx[2].correo + "";
    	let t32;
    	let t33;
    	let br5;
    	let t34;
    	let div13;
    	let div12;
    	let t36;
    	let hr0;
    	let t37;
    	let div15;
    	let div14;
    	let t38;
    	let t39;
    	let div20;
    	let div16;
    	let t40;
    	let div19;
    	let h5;
    	let t41_value = /*paciente*/ ctx[0].nombres + "";
    	let t41;
    	let t42;
    	let t43_value = /*paciente*/ ctx[0].apellidos + "";
    	let t43;
    	let t44;
    	let div17;
    	let t45;
    	let t46_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "";
    	let t46;
    	let t47;
    	let t48;
    	let div18;
    	let t51;
    	let div21;
    	let hr1;
    	let t52;
    	let p1;
    	let t54;
    	let p2;
    	let strong;
    	let current;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });
    	let if_block0 = /*errorServer*/ ctx[5] && create_if_block_2$9(ctx);
    	let each_value = /*estudios*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	let if_block1 = /*historia*/ ctx[1].instrucciones && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			section = element("section");
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div2.textContent = "Para:";
    			t5 = space();
    			h4 = element("h4");
    			t6 = text(t6_value);
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			p0 = element("p");
    			t10 = text("ID Consulta #");
    			t11 = text(t11_value);
    			t12 = space();
    			br0 = element("br");
    			t13 = text("\r\n                                    Fecha Consulta : ");
    			t14 = text(t14_value);
    			t15 = space();
    			button = element("button");
    			i = element("i");
    			t16 = text("\r\n                                    Imprimir");
    			t17 = space();
    			div27 = element("div");
    			div26 = element("div");
    			div25 = element("div");
    			div24 = element("div");
    			div23 = element("div");
    			div22 = element("div");
    			div11 = element("div");
    			div10 = element("div");
    			img = element("img");
    			t18 = space();
    			div9 = element("div");
    			span = element("span");
    			t19 = text(t19_value);
    			t20 = text(",");
    			t21 = space();
    			br1 = element("br");
    			t22 = space();
    			t23 = text(t23_value);
    			t24 = space();
    			br2 = element("br");
    			t25 = space();
    			t26 = text(t26_value);
    			t27 = space();
    			br3 = element("br");
    			t28 = text("\r\n                                            Tel.: ");
    			t29 = text(t29_value);
    			t30 = space();
    			br4 = element("br");
    			t31 = space();
    			t32 = text(t32_value);
    			t33 = space();
    			br5 = element("br");
    			t34 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div12.textContent = "Estudios de imagenes";
    			t36 = space();
    			hr0 = element("hr");
    			t37 = space();
    			div15 = element("div");
    			div14 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t38 = space();
    			if (if_block1) if_block1.c();
    			t39 = space();
    			div20 = element("div");
    			div16 = element("div");
    			t40 = space();
    			div19 = element("div");
    			h5 = element("h5");
    			t41 = text(t41_value);
    			t42 = space();
    			t43 = text(t43_value);
    			t44 = space();
    			div17 = element("div");
    			t45 = text("Edad: ");
    			t46 = text(t46_value);
    			t47 = text(" aos");
    			t48 = space();
    			div18 = element("div");
    			div18.textContent = `Fecha: ${new Date().toLocaleDateString("es-DO")}`;
    			t51 = space();
    			div21 = element("div");
    			hr1 = element("hr");
    			t52 = space();
    			p1 = element("p");
    			p1.textContent = "Firma del especialista";
    			t54 = space();
    			p2 = element("p");
    			strong = element("strong");
    			strong.textContent = `${user().title}. ${user().name}`;
    			attr_dev(div0, "class", "avatar-title bg-success rounded-circle mdi mdi-receipt  ");
    			add_location(div0, file$w, 110, 32, 3207);
    			attr_dev(div1, "class", "avatar avatar mr-3");
    			add_location(div1, file$w, 109, 28, 3141);
    			attr_dev(div2, "class", "opacity-75");
    			add_location(div2, file$w, 115, 32, 3443);
    			attr_dev(h4, "class", "m-b-0");
    			add_location(h4, file$w, 116, 32, 3512);
    			add_location(br0, file$w, 118, 63, 3696);
    			attr_dev(p0, "class", "opacity-75");
    			add_location(p0, file$w, 117, 32, 3609);
    			attr_dev(i, "class", "mdi\r\n                                mdi-printer");
    			add_location(i, file$w, 121, 89, 3942);
    			attr_dev(button, "class", "btn btn-white-translucent");
    			attr_dev(button, "id", "printDiv");
    			add_location(button, file$w, 121, 32, 3885);
    			attr_dev(div3, "class", "media-body");
    			add_location(div3, file$w, 114, 28, 3385);
    			attr_dev(div4, "class", "media");
    			add_location(div4, file$w, 108, 24, 3092);
    			attr_dev(div5, "class", "col-md-6 text-white p-b-30");
    			add_location(div5, file$w, 107, 20, 3026);
    			attr_dev(div6, "class", "row p-b-60 p-t-60");
    			add_location(div6, file$w, 105, 16, 2971);
    			attr_dev(div7, "class", "container");
    			add_location(div7, file$w, 104, 12, 2930);
    			attr_dev(div8, "class", "bg-dark m-b-30");
    			add_location(div8, file$w, 103, 8, 2888);
    			if (img.src !== (img_src_value = /*logo*/ ctx[4])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "logo svelte-n1341u");
    			attr_dev(img, "alt", "");
    			add_location(img, file$w, 158, 40, 5664);
    			attr_dev(span, "class", "h4 font-primary");
    			add_location(span, file$w, 160, 44, 5808);
    			add_location(br1, file$w, 160, 100, 5864);
    			add_location(br2, file$w, 161, 75, 5945);
    			add_location(br3, file$w, 162, 64, 6015);
    			add_location(br4, file$w, 163, 69, 6090);
    			add_location(br5, file$w, 164, 61, 6157);
    			attr_dev(div9, "class", "m-t-10");
    			add_location(div9, file$w, 159, 40, 5742);
    			attr_dev(div10, "class", "col-md-12 empresa-datos svelte-n1341u");
    			add_location(div10, file$w, 157, 36, 5585);
    			attr_dev(div11, "class", "row");
    			add_location(div11, file$w, 156, 32, 5530);
    			add_location(div12, file$w, 171, 36, 6400);
    			attr_dev(div13, "class", "bg-light cabecera svelte-n1341u");
    			add_location(div13, file$w, 170, 32, 6331);
    			set_style(hr0, "margin", "0");
    			add_location(hr0, file$w, 173, 32, 6505);
    			attr_dev(div14, "class", "row mt-3 mb-3 contenedor-estudios svelte-n1341u");
    			add_location(div14, file$w, 175, 35, 6618);
    			attr_dev(div15, "class", "col-12");
    			add_location(div15, file$w, 174, 32, 6561);
    			attr_dev(div16, "class", "col-md-6");
    			add_location(div16, file$w, 192, 36, 7597);
    			attr_dev(h5, "class", "font-primary");
    			add_location(h5, file$w, 196, 40, 7786);
    			attr_dev(div17, "class", "");
    			add_location(div17, file$w, 197, 40, 7897);
    			attr_dev(div18, "class", "");
    			add_location(div18, file$w, 198, 40, 8010);
    			attr_dev(div19, "class", "col-md-6 text-right my-auto");
    			add_location(div19, file$w, 195, 36, 7703);
    			attr_dev(div20, "class", "row");
    			add_location(div20, file$w, 191, 32, 7542);
    			add_location(hr1, file$w, 202, 36, 8252);
    			set_style(p1, "margin-bottom", "0");
    			add_location(p1, file$w, 203, 36, 8294);
    			add_location(strong, file$w, 204, 39, 8390);
    			add_location(p2, file$w, 204, 36, 8387);
    			attr_dev(div21, "class", "firma svelte-n1341u");
    			add_location(div21, file$w, 201, 32, 8195);
    			attr_dev(div22, "class", "card-body");
    			add_location(div22, file$w, 155, 28, 5473);
    			attr_dev(div23, "class", "card");
    			add_location(div23, file$w, 154, 24, 5425);
    			attr_dev(div24, "class", "col-md-12 m-b-40");
    			add_location(div24, file$w, 153, 20, 5369);
    			attr_dev(div25, "class", "row");
    			add_location(div25, file$w, 152, 16, 5330);
    			attr_dev(div26, "class", "container");
    			attr_dev(div26, "id", "printableArea");
    			add_location(div26, file$w, 151, 12, 5270);
    			attr_dev(div27, "class", "pull-up");
    			add_location(div27, file$w, 150, 8, 5235);
    			attr_dev(section, "class", "admin-content ");
    			add_location(section, file$w, 102, 4, 2846);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$w, 97, 2, 2719);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t2);
    			append_dev(main, section);
    			append_dev(section, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div3, t5);
    			append_dev(div3, h4);
    			append_dev(h4, t6);
    			append_dev(h4, t7);
    			append_dev(h4, t8);
    			append_dev(div3, t9);
    			append_dev(div3, p0);
    			append_dev(p0, t10);
    			append_dev(p0, t11);
    			append_dev(p0, t12);
    			append_dev(p0, br0);
    			append_dev(p0, t13);
    			append_dev(p0, t14);
    			append_dev(div3, t15);
    			append_dev(div3, button);
    			append_dev(button, i);
    			append_dev(button, t16);
    			append_dev(section, t17);
    			append_dev(section, div27);
    			append_dev(div27, div26);
    			append_dev(div26, div25);
    			append_dev(div25, div24);
    			append_dev(div24, div23);
    			append_dev(div23, div22);
    			append_dev(div22, div11);
    			append_dev(div11, div10);
    			append_dev(div10, img);
    			append_dev(div10, t18);
    			append_dev(div10, div9);
    			append_dev(div9, span);
    			append_dev(span, t19);
    			append_dev(span, t20);
    			append_dev(div9, t21);
    			append_dev(div9, br1);
    			append_dev(div9, t22);
    			append_dev(div9, t23);
    			append_dev(div9, t24);
    			append_dev(div9, br2);
    			append_dev(div9, t25);
    			append_dev(div9, t26);
    			append_dev(div9, t27);
    			append_dev(div9, br3);
    			append_dev(div9, t28);
    			append_dev(div9, t29);
    			append_dev(div9, t30);
    			append_dev(div9, br4);
    			append_dev(div9, t31);
    			append_dev(div9, t32);
    			append_dev(div9, t33);
    			append_dev(div9, br5);
    			append_dev(div22, t34);
    			append_dev(div22, div13);
    			append_dev(div13, div12);
    			append_dev(div22, t36);
    			append_dev(div22, hr0);
    			append_dev(div22, t37);
    			append_dev(div22, div15);
    			append_dev(div15, div14);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div14, null);
    			}

    			append_dev(div22, t38);
    			if (if_block1) if_block1.m(div22, null);
    			append_dev(div22, t39);
    			append_dev(div22, div20);
    			append_dev(div20, div16);
    			append_dev(div20, t40);
    			append_dev(div20, div19);
    			append_dev(div19, h5);
    			append_dev(h5, t41);
    			append_dev(h5, t42);
    			append_dev(h5, t43);
    			append_dev(div19, t44);
    			append_dev(div19, div17);
    			append_dev(div17, t45);
    			append_dev(div17, t46);
    			append_dev(div17, t47);
    			append_dev(div19, t48);
    			append_dev(div19, div18);
    			append_dev(div22, t51);
    			append_dev(div22, div21);
    			append_dev(div21, hr1);
    			append_dev(div21, t52);
    			append_dev(div21, p1);
    			append_dev(div21, t54);
    			append_dev(div21, p2);
    			append_dev(p2, strong);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*paciente*/ 1) && t6_value !== (t6_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*paciente*/ 1) && t8_value !== (t8_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty & /*historia*/ 2) && t11_value !== (t11_value = /*historia*/ ctx[1].id + "")) set_data_dev(t11, t11_value);
    			if ((!current || dirty & /*historia*/ 2) && t14_value !== (t14_value = new Date(/*historia*/ ctx[1].createdAt).toLocaleDateString("es-DO") + "")) set_data_dev(t14, t14_value);

    			if (!current || dirty & /*logo*/ 16 && img.src !== (img_src_value = /*logo*/ ctx[4])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if ((!current || dirty & /*empresa*/ 4) && t19_value !== (t19_value = /*empresa*/ ctx[2].nombre + "")) set_data_dev(t19, t19_value);
    			if ((!current || dirty & /*empresa*/ 4) && t23_value !== (t23_value = (/*empresa*/ ctx[2].especialidades || "") + "")) set_data_dev(t23, t23_value);
    			if ((!current || dirty & /*empresa*/ 4) && t26_value !== (t26_value = /*empresa*/ ctx[2].direccion + "")) set_data_dev(t26, t26_value);
    			if ((!current || dirty & /*empresa*/ 4) && t29_value !== (t29_value = /*empresa*/ ctx[2].telefono + "")) set_data_dev(t29, t29_value);
    			if ((!current || dirty & /*empresa*/ 4) && t32_value !== (t32_value = /*empresa*/ ctx[2].correo + "")) set_data_dev(t32, t32_value);

    			if (dirty & /*estudios*/ 8) {
    				each_value = /*estudios*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div14, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*historia*/ ctx[1].instrucciones) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$j(ctx);
    					if_block1.c();
    					if_block1.m(div22, t39);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if ((!current || dirty & /*paciente*/ 1) && t41_value !== (t41_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t41, t41_value);
    			if ((!current || dirty & /*paciente*/ 1) && t43_value !== (t43_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t43, t43_value);
    			if ((!current || dirty & /*paciente*/ 1) && t46_value !== (t46_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "")) set_data_dev(t46, t46_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks, detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Imagenes", slots, []);
    	let { params } = $$props;
    	let errorServer = false;
    	let paciente = {};
    	let historia = {};
    	let empresa = {};
    	let estudios = [];
    	let logo = "";

    	const cargarImagenEmpresa = (idConsultorio, idImagen) => {
    		const config = {
    			method: "get",
    			url: `${url}/imagenes/${idConsultorio}/${idImagen}`,
    			responseType: "blob",
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(4, logo = URL.createObjectURL(res.data));
    			console.log(logo);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarPaciente = () => {
    		const config = {
    			method: "get",
    			url: `${url}/pacientes/${params.idPaciente}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(0, paciente = res.data);
    			console.log(paciente);
    		});
    	};

    	const cargarHistoria = () => {
    		const config = {
    			method: "get",
    			url: `${url}/historias/${params.idHistoria}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(1, historia = res.data);
    			$$invalidate(3, estudios = res.data.estudios);
    			console.log(historia);
    		});
    	};

    	const cargarEmpresa = () => {
    		const config = {
    			method: "get",
    			url: `${url}/empresas/${user().empresa}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(2, empresa = res.data);
    			cargarImagenEmpresa(empresa.id, empresa.logo);
    			console.log(empresa);
    		});
    	};

    	onMount(() => {
    		jQuery("html, body").animate({ scrollTop: 0 }, "slow");
    		cargarPaciente();
    		cargarHistoria();
    		cargarEmpresa();

    		window.onafterprint = event => {
    			location.reload();
    		};
    	});

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$h.warn(`<Imagenes> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(6, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		onMount,
    		calcularEdad,
    		url,
    		user,
    		Header,
    		Aside,
    		ErrorConexion,
    		params,
    		errorServer,
    		paciente,
    		historia,
    		empresa,
    		estudios,
    		logo,
    		cargarImagenEmpresa,
    		cargarPaciente,
    		cargarHistoria,
    		cargarEmpresa
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(6, params = $$props.params);
    		if ("errorServer" in $$props) $$invalidate(5, errorServer = $$props.errorServer);
    		if ("paciente" in $$props) $$invalidate(0, paciente = $$props.paciente);
    		if ("historia" in $$props) $$invalidate(1, historia = $$props.historia);
    		if ("empresa" in $$props) $$invalidate(2, empresa = $$props.empresa);
    		if ("estudios" in $$props) $$invalidate(3, estudios = $$props.estudios);
    		if ("logo" in $$props) $$invalidate(4, logo = $$props.logo);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [paciente, historia, empresa, estudios, logo, errorServer, params];
    }

    class Imagenes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, { params: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Imagenes",
    			options,
    			id: create_fragment$y.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*params*/ ctx[6] === undefined && !("params" in props)) {
    			console_1$h.warn("<Imagenes> was created without expected prop 'params'");
    		}
    	}

    	get params() {
    		throw new Error("<Imagenes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Imagenes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\Pages\Recetas\Indicaciones\Index.svelte generated by Svelte v3.29.0 */
    const file$x = "src\\Pages\\Recetas\\Indicaciones\\Index.svelte";

    // (35:2) {#if errorServer}
    function create_if_block$k(ctx) {
    	let errorserver;
    	let current;

    	errorserver = new ErrorConexion({
    			props: {
    				msgError: "Ocurrio un error al contactar al servidor, vuelva a intentar o contacte al administrador"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(errorserver.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorserver, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorserver.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorserver.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorserver, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(35:2) {#if errorServer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let t2;
    	let section;
    	let div10;
    	let div0;
    	let t3;
    	let div9;
    	let h5;
    	let t4;
    	let a0;
    	let i0;
    	let t5;
    	let link_action;
    	let t6;
    	let div6;
    	let div5;
    	let div4;
    	let div3;
    	let div2;
    	let div1;
    	let label;
    	let t8;
    	let input;
    	let t9;
    	let div8;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t10;
    	let th1;
    	let t12;
    	let th2;
    	let t14;
    	let th3;
    	let t16;
    	let th4;
    	let t18;
    	let th5;
    	let t19;
    	let tbody;
    	let tr1;
    	let td0;
    	let div7;
    	let span;
    	let t21;
    	let td1;
    	let t23;
    	let td2;
    	let t25;
    	let td3;
    	let t27;
    	let td4;
    	let t29;
    	let td5;
    	let a1;
    	let i1;
    	let t30;
    	let a2;
    	let i2;
    	let a2_href_value;
    	let link_action_1;
    	let current;
    	let mounted;
    	let dispose;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });
    	let if_block = /*errorServer*/ ctx[1] && create_if_block$k(ctx);

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			section = element("section");
    			div10 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div9 = element("div");
    			h5 = element("h5");
    			t4 = text("Recetas ");
    			a0 = element("a");
    			i0 = element("i");
    			t5 = text(" CREAR");
    			t6 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			label = element("label");
    			label.textContent = "Buscar recetas";
    			t8 = space();
    			input = element("input");
    			t9 = space();
    			div8 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			t10 = space();
    			th1 = element("th");
    			th1.textContent = "Nombre paciente";
    			t12 = space();
    			th2 = element("th");
    			th2.textContent = "Cedula";
    			t14 = space();
    			th3 = element("th");
    			th3.textContent = "Celular";
    			t16 = space();
    			th4 = element("th");
    			th4.textContent = "Tipo Indicacion";
    			t18 = space();
    			th5 = element("th");
    			t19 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			div7 = element("div");
    			span = element("span");
    			span.textContent = "VN";
    			t21 = space();
    			td1 = element("td");
    			td1.textContent = "Vladimir Nunez";
    			t23 = space();
    			td2 = element("td");
    			td2.textContent = "40223257938";
    			t25 = space();
    			td3 = element("td");
    			td3.textContent = "8498502828";
    			t27 = space();
    			td4 = element("td");
    			td4.textContent = "Medicamentos";
    			t29 = space();
    			td5 = element("td");
    			a1 = element("a");
    			i1 = element("i");
    			t30 = space();
    			a2 = element("a");
    			i2 = element("i");
    			attr_dev(div0, "class", "row");
    			add_location(div0, file$x, 41, 6, 1032);
    			attr_dev(i0, "class", "mdi mdi-plus");
    			add_location(i0, file$x, 43, 87, 1183);
    			attr_dev(a0, "href", "/pacientes/crear");
    			attr_dev(a0, "class", "btn btn-primary btn-sm");
    			add_location(a0, file$x, 43, 20, 1116);
    			add_location(h5, file$x, 43, 8, 1104);
    			attr_dev(label, "for", "Buscar");
    			add_location(label, file$x, 50, 36, 1549);
    			attr_dev(input, "type", "search");
    			attr_dev(input, "class", "form-control");
    			attr_dev(input, "placeholder", "Nombres o Apelidos");
    			add_location(input, file$x, 51, 36, 1629);
    			attr_dev(div1, "class", "form-group");
    			add_location(div1, file$x, 49, 32, 1487);
    			attr_dev(div2, "class", "col-lg-4");
    			add_location(div2, file$x, 48, 28, 1431);
    			attr_dev(div3, "class", "row");
    			add_location(div3, file$x, 47, 24, 1384);
    			attr_dev(div4, "class", "col-12");
    			add_location(div4, file$x, 46, 20, 1338);
    			attr_dev(div5, "class", "row");
    			add_location(div5, file$x, 45, 12, 1299);
    			attr_dev(div6, "class", "alert alert-secondary");
    			attr_dev(div6, "role", "alert");
    			add_location(div6, file$x, 44, 8, 1237);
    			add_location(th0, file$x, 62, 20, 2120);
    			add_location(th1, file$x, 63, 20, 2151);
    			add_location(th2, file$x, 64, 20, 2197);
    			add_location(th3, file$x, 65, 20, 2234);
    			add_location(th4, file$x, 66, 20, 2272);
    			add_location(th5, file$x, 67, 20, 2318);
    			add_location(tr0, file$x, 61, 16, 2094);
    			add_location(thead, file$x, 60, 16, 2069);
    			attr_dev(span, "class", "avatar-title rounded-circle ");
    			add_location(span, file$x, 74, 32, 2551);
    			attr_dev(div7, "class", "avatar avatar-sm");
    			add_location(div7, file$x, 73, 28, 2487);
    			add_location(td0, file$x, 72, 24, 2453);
    			add_location(td1, file$x, 77, 24, 2696);
    			add_location(td2, file$x, 78, 24, 2745);
    			add_location(td3, file$x, 79, 24, 2791);
    			add_location(td4, file$x, 80, 24, 2836);
    			attr_dev(i1, "class", "mdi mdi-close");
    			add_location(i1, file$x, 88, 32, 3242);
    			attr_dev(a1, "href", "#!");
    			attr_dev(a1, "class", "btn btn-outline-danger");
    			attr_dev(a1, "data-tooltip", "Eliminar");
    			add_location(a1, file$x, 83, 28, 3011);
    			attr_dev(i2, "class", "mdi mdi-send");
    			add_location(i2, file$x, 96, 32, 3639);
    			attr_dev(a2, "href", a2_href_value = `/receta/paciente/190213892384032`);
    			attr_dev(a2, "class", "btn btn-outline-primary");
    			attr_dev(a2, "data-tooltip", "Perfil");
    			add_location(a2, file$x, 90, 28, 3335);
    			attr_dev(td5, "class", "text-right");
    			add_location(td5, file$x, 81, 24, 2883);
    			add_location(tr1, file$x, 71, 20, 2423);
    			add_location(tbody, file$x, 70, 16, 2394);
    			attr_dev(table, "class", "table align-td-middle table-card");
    			add_location(table, file$x, 59, 12, 2003);
    			attr_dev(div8, "class", "table-responsive");
    			add_location(div8, file$x, 58, 8, 1959);
    			attr_dev(div9, "class", "col-md-12 mt-3 m-b-30");
    			add_location(div9, file$x, 42, 6, 1059);
    			attr_dev(div10, "class", "p-2");
    			add_location(div10, file$x, 40, 4, 1007);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$x, 39, 2, 970);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$x, 32, 0, 762);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			if (if_block) if_block.m(main, null);
    			append_dev(main, t2);
    			append_dev(main, section);
    			append_dev(section, div10);
    			append_dev(div10, div0);
    			append_dev(div10, t3);
    			append_dev(div10, div9);
    			append_dev(div9, h5);
    			append_dev(h5, t4);
    			append_dev(h5, a0);
    			append_dev(a0, i0);
    			append_dev(a0, t5);
    			append_dev(div9, t6);
    			append_dev(div9, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, label);
    			append_dev(div1, t8);
    			append_dev(div1, input);
    			set_input_value(input, /*sltBuscarIndicaciones*/ ctx[0]);
    			append_dev(div9, t9);
    			append_dev(div9, div8);
    			append_dev(div8, table);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t10);
    			append_dev(tr0, th1);
    			append_dev(tr0, t12);
    			append_dev(tr0, th2);
    			append_dev(tr0, t14);
    			append_dev(tr0, th3);
    			append_dev(tr0, t16);
    			append_dev(tr0, th4);
    			append_dev(tr0, t18);
    			append_dev(tr0, th5);
    			append_dev(table, t19);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, div7);
    			append_dev(div7, span);
    			append_dev(tr1, t21);
    			append_dev(tr1, td1);
    			append_dev(tr1, t23);
    			append_dev(tr1, td2);
    			append_dev(tr1, t25);
    			append_dev(tr1, td3);
    			append_dev(tr1, t27);
    			append_dev(tr1, td4);
    			append_dev(tr1, t29);
    			append_dev(tr1, td5);
    			append_dev(td5, a1);
    			append_dev(a1, i1);
    			append_dev(td5, t30);
    			append_dev(td5, a2);
    			append_dev(a2, i2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link_action = link.call(null, a0)),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[3]),
    					listen_dev(input, "input", /*searchIndicaciones*/ ctx[2], false, false, false),
    					action_destroyer(link_action_1 = link.call(null, a2))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*sltBuscarIndicaciones*/ 1) {
    				set_input_value(input, /*sltBuscarIndicaciones*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Index", slots, []);
    	let indaciones = [];
    	let errorServer = false;
    	let sltBuscarIndicaciones = "";
    	let timeout = null;

    	const searchIndicaciones = () => {
    		if (timeout) {
    			window.clearTimeout(timeout);
    		}

    		timeout = setTimeout(
    			function () {
    				/*function*/ 
    			},
    			300
    		);
    	};

    	onMount(() => {
    		
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		sltBuscarIndicaciones = this.value;
    		$$invalidate(0, sltBuscarIndicaciones);
    	}

    	$$self.$capture_state = () => ({
    		link,
    		onMount,
    		url,
    		calcularEdad,
    		axios: axios$1,
    		Header,
    		Aside,
    		ErrorServer: ErrorConexion,
    		indaciones,
    		errorServer,
    		sltBuscarIndicaciones,
    		timeout,
    		searchIndicaciones
    	});

    	$$self.$inject_state = $$props => {
    		if ("indaciones" in $$props) indaciones = $$props.indaciones;
    		if ("errorServer" in $$props) $$invalidate(1, errorServer = $$props.errorServer);
    		if ("sltBuscarIndicaciones" in $$props) $$invalidate(0, sltBuscarIndicaciones = $$props.sltBuscarIndicaciones);
    		if ("timeout" in $$props) timeout = $$props.timeout;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sltBuscarIndicaciones, errorServer, searchIndicaciones, input_input_handler];
    }

    class Index$4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    /* src\Pages\Recetas\ImprimirRecetas.svelte generated by Svelte v3.29.0 */

    const { console: console_1$i } = globals;
    const file$y = "src\\Pages\\Recetas\\ImprimirRecetas.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	return child_ctx;
    }

    // (102:4) {#if errorServer}
    function create_if_block_5$3(ctx) {
    	let errorconexion;
    	let current;

    	errorconexion = new ErrorConexion({
    			props: { msgError: "msgError" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(errorconexion.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorconexion, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorconexion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorconexion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorconexion, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(102:4) {#if errorServer}",
    		ctx
    	});

    	return block;
    }

    // (161:43) {#if estudio.tipo === 'LAB'}
    function create_if_block_4$4(ctx) {
    	let div;
    	let t0_value = /*estudio*/ ctx[15].descripcion + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "col-lg-3 mb-3 estudio svelte-1c6uu9z");
    			add_location(div, file$y, 161, 47, 5928);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*estudios*/ 8 && t0_value !== (t0_value = /*estudio*/ ctx[15].descripcion + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(161:43) {#if estudio.tipo === 'LAB'}",
    		ctx
    	});

    	return block;
    }

    // (160:39) {#each estudios as estudio}
    function create_each_block_2$4(ctx) {
    	let if_block_anchor;
    	let if_block = /*estudio*/ ctx[15].tipo === "LAB" && create_if_block_4$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*estudio*/ ctx[15].tipo === "LAB") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$4.name,
    		type: "each",
    		source: "(160:39) {#each estudios as estudio}",
    		ctx
    	});

    	return block;
    }

    // (169:32) {#if historia.instrucciones}
    function create_if_block_3$4(ctx) {
    	let div1;
    	let div0;
    	let strong;
    	let t1;
    	let t2_value = /*historia*/ ctx[1].instrucciones + "";
    	let t2;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			strong = element("strong");
    			strong.textContent = "Observaciones:";
    			t1 = space();
    			t2 = text(t2_value);
    			add_location(strong, file$y, 170, 41, 6438);
    			add_location(div0, file$y, 170, 36, 6433);
    			attr_dev(div1, "class", "bg-light pie svelte-1c6uu9z");
    			add_location(div1, file$y, 169, 32, 6369);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, strong);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*historia*/ 2 && t2_value !== (t2_value = /*historia*/ ctx[1].instrucciones + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(169:32) {#if historia.instrucciones}",
    		ctx
    	});

    	return block;
    }

    // (229:43) {#if estudio.tipo === 'IMG'}
    function create_if_block_2$a(ctx) {
    	let div;
    	let t0_value = /*estudio*/ ctx[15].descripcion + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "col-lg-3 mb-3 estudio svelte-1c6uu9z");
    			add_location(div, file$y, 229, 47, 9577);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*estudios*/ 8 && t0_value !== (t0_value = /*estudio*/ ctx[15].descripcion + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(229:43) {#if estudio.tipo === 'IMG'}",
    		ctx
    	});

    	return block;
    }

    // (228:39) {#each estudios as estudio}
    function create_each_block_1$5(ctx) {
    	let if_block_anchor;
    	let if_block = /*estudio*/ ctx[15].tipo === "IMG" && create_if_block_2$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*estudio*/ ctx[15].tipo === "IMG") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$a(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(228:39) {#each estudios as estudio}",
    		ctx
    	});

    	return block;
    }

    // (237:32) {#if historia.instrucciones}
    function create_if_block_1$d(ctx) {
    	let div1;
    	let div0;
    	let strong;
    	let t1;
    	let t2_value = /*historia*/ ctx[1].instrucciones + "";
    	let t2;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			strong = element("strong");
    			strong.textContent = "Observaciones:";
    			t1 = space();
    			t2 = text(t2_value);
    			add_location(strong, file$y, 238, 41, 10087);
    			add_location(div0, file$y, 238, 36, 10082);
    			attr_dev(div1, "class", "bg-light pie svelte-1c6uu9z");
    			add_location(div1, file$y, 237, 32, 10018);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, strong);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*historia*/ 2 && t2_value !== (t2_value = /*historia*/ ctx[1].instrucciones + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(237:32) {#if historia.instrucciones}",
    		ctx
    	});

    	return block;
    }

    // (304:40) {#each medicamentos as medicamento}
    function create_each_block$e(ctx) {
    	let tr;
    	let td0;
    	let p0;
    	let t0_value = /*medicamento*/ ctx[12].nombre + "";
    	let t0;
    	let t1;
    	let p1;
    	let t2;
    	let t3_value = /*medicamento*/ ctx[12].concentracion + "";
    	let t3;
    	let t4;
    	let td1;
    	let t5_value = /*medicamento*/ ctx[12].cantidad + "";
    	let t5;
    	let t6;
    	let td2;
    	let t7_value = /*medicamento*/ ctx[12].frecuencia + "";
    	let t7;
    	let t8;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			p0 = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			p1 = element("p");
    			t2 = text("De ");
    			t3 = text(t3_value);
    			t4 = space();
    			td1 = element("td");
    			t5 = text(t5_value);
    			t6 = space();
    			td2 = element("td");
    			t7 = text(t7_value);
    			t8 = space();
    			attr_dev(p0, "class", "text-black m-0");
    			add_location(p0, file$y, 306, 52, 13743);
    			attr_dev(p1, "class", "text-muted");
    			set_style(p1, "padding-bottom", "0");
    			set_style(p1, "margin-bottom", "0");
    			add_location(p1, file$y, 307, 52, 13847);
    			attr_dev(td0, "class", "");
    			add_location(td0, file$y, 305, 48, 13676);
    			attr_dev(td1, "class", "text-center");
    			add_location(td1, file$y, 311, 48, 14165);
    			attr_dev(td2, "class", "text-center");
    			add_location(td2, file$y, 312, 48, 14266);
    			add_location(tr, file$y, 304, 44, 13622);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, p0);
    			append_dev(p0, t0);
    			append_dev(td0, t1);
    			append_dev(td0, p1);
    			append_dev(p1, t2);
    			append_dev(p1, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td1);
    			append_dev(td1, t5);
    			append_dev(tr, t6);
    			append_dev(tr, td2);
    			append_dev(td2, t7);
    			append_dev(tr, t8);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*medicamentos*/ 16 && t0_value !== (t0_value = /*medicamento*/ ctx[12].nombre + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*medicamentos*/ 16 && t3_value !== (t3_value = /*medicamento*/ ctx[12].concentracion + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*medicamentos*/ 16 && t5_value !== (t5_value = /*medicamento*/ ctx[12].cantidad + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*medicamentos*/ 16 && t7_value !== (t7_value = /*medicamento*/ ctx[12].frecuencia + "")) set_data_dev(t7, t7_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(304:40) {#each medicamentos as medicamento}",
    		ctx
    	});

    	return block;
    }

    // (319:32) {#if historia.instrucciones}
    function create_if_block$l(ctx) {
    	let div1;
    	let div0;
    	let strong;
    	let t1;
    	let t2_value = /*historia*/ ctx[1].instrucciones + "";
    	let t2;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			strong = element("strong");
    			strong.textContent = "Observaciones:";
    			t1 = space();
    			t2 = text(t2_value);
    			add_location(strong, file$y, 320, 41, 14720);
    			add_location(div0, file$y, 320, 36, 14715);
    			attr_dev(div1, "class", "bg-light pie svelte-1c6uu9z");
    			add_location(div1, file$y, 319, 32, 14651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, strong);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*historia*/ 2 && t2_value !== (t2_value = /*historia*/ ctx[1].instrucciones + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(319:32) {#if historia.instrucciones}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let t2;
    	let section;
    	let div8;
    	let div7;
    	let div6;
    	let div5;
    	let div4;
    	let div1;
    	let div0;
    	let t3;
    	let div3;
    	let div2;
    	let t5;
    	let h4;
    	let t6_value = /*paciente*/ ctx[0].nombres + "";
    	let t6;
    	let t7;
    	let t8_value = /*paciente*/ ctx[0].apellidos + "";
    	let t8;
    	let t9;
    	let p0;
    	let t10;
    	let t11_value = /*historia*/ ctx[1].id + "";
    	let t11;
    	let t12;
    	let br0;
    	let t13;
    	let t14_value = new Date(/*historia*/ ctx[1].createdAt).toLocaleDateString("es-DO") + "";
    	let t14;
    	let t15;
    	let button;
    	let i;
    	let t16;
    	let t17;
    	let div65;
    	let div64;
    	let div26;
    	let div25;
    	let div24;
    	let div23;
    	let div10;
    	let div9;
    	let img0;
    	let img0_src_value;
    	let t18;
    	let address0;
    	let span0;
    	let t19_value = /*empresa*/ ctx[2].nombre + "";
    	let t19;
    	let t20;
    	let t21;
    	let br1;
    	let t22;
    	let t23_value = (/*empresa*/ ctx[2].especialidades || "") + "";
    	let t23;
    	let t24;
    	let br2;
    	let t25;
    	let t26_value = /*empresa*/ ctx[2].direccion + "";
    	let t26;
    	let t27;
    	let br3;
    	let t28;
    	let t29_value = /*empresa*/ ctx[2].telefono + "";
    	let t29;
    	let t30;
    	let br4;
    	let t31;
    	let t32_value = /*empresa*/ ctx[2].correo + "";
    	let t32;
    	let t33;
    	let br5;
    	let t34;
    	let div12;
    	let div11;
    	let t36;
    	let hr0;
    	let t37;
    	let div14;
    	let div13;
    	let t38;
    	let t39;
    	let div19;
    	let div15;
    	let t40;
    	let div18;
    	let h50;
    	let t41_value = /*paciente*/ ctx[0].nombres + "";
    	let t41;
    	let t42;
    	let t43_value = /*paciente*/ ctx[0].apellidos + "";
    	let t43;
    	let t44;
    	let div16;
    	let t45;
    	let t46_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "";
    	let t46;
    	let t47;
    	let t48;
    	let div17;
    	let t51;
    	let div20;
    	let hr1;
    	let t52;
    	let p1;
    	let t54;
    	let p2;
    	let strong0;
    	let t58;
    	let div22;
    	let hr2;
    	let t59;
    	let div21;
    	let t62;
    	let div27;
    	let t63;
    	let div45;
    	let div44;
    	let div43;
    	let div42;
    	let div29;
    	let div28;
    	let img1;
    	let img1_src_value;
    	let t64;
    	let address1;
    	let span1;
    	let t65_value = /*empresa*/ ctx[2].nombre + "";
    	let t65;
    	let t66;
    	let t67;
    	let br6;
    	let t68;
    	let t69_value = (/*empresa*/ ctx[2].especialidades || "") + "";
    	let t69;
    	let t70;
    	let br7;
    	let t71;
    	let t72_value = /*empresa*/ ctx[2].direccion + "";
    	let t72;
    	let t73;
    	let br8;
    	let t74;
    	let t75_value = /*empresa*/ ctx[2].telefono + "";
    	let t75;
    	let t76;
    	let br9;
    	let t77;
    	let t78_value = /*empresa*/ ctx[2].correo + "";
    	let t78;
    	let t79;
    	let br10;
    	let t80;
    	let div31;
    	let div30;
    	let t82;
    	let hr3;
    	let t83;
    	let div33;
    	let div32;
    	let t84;
    	let t85;
    	let div38;
    	let div34;
    	let t86;
    	let div37;
    	let h51;
    	let t87_value = /*paciente*/ ctx[0].nombres + "";
    	let t87;
    	let t88;
    	let t89_value = /*paciente*/ ctx[0].apellidos + "";
    	let t89;
    	let t90;
    	let div35;
    	let t91;
    	let t92_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "";
    	let t92;
    	let t93;
    	let t94;
    	let div36;
    	let t97;
    	let div39;
    	let hr4;
    	let t98;
    	let p3;
    	let t100;
    	let p4;
    	let strong1;
    	let t104;
    	let div41;
    	let hr5;
    	let t105;
    	let div40;
    	let t108;
    	let div46;
    	let t109;
    	let div63;
    	let div62;
    	let div61;
    	let div60;
    	let div48;
    	let div47;
    	let img2;
    	let img2_src_value;
    	let t110;
    	let address2;
    	let span2;
    	let t111_value = /*empresa*/ ctx[2].nombre + "";
    	let t111;
    	let t112;
    	let t113;
    	let br11;
    	let t114;
    	let t115_value = (/*empresa*/ ctx[2].especialidades || "") + "";
    	let t115;
    	let t116;
    	let br12;
    	let t117;
    	let t118_value = /*empresa*/ ctx[2].direccion + "";
    	let t118;
    	let t119;
    	let br13;
    	let t120;
    	let t121_value = /*empresa*/ ctx[2].telefono + "";
    	let t121;
    	let t122;
    	let br14;
    	let t123;
    	let t124_value = /*empresa*/ ctx[2].correo + "";
    	let t124;
    	let t125;
    	let br15;
    	let t126;
    	let div50;
    	let div49;
    	let t128;
    	let hr6;
    	let t129;
    	let div51;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t131;
    	let th1;
    	let t133;
    	let th2;
    	let t135;
    	let tbody;
    	let t136;
    	let t137;
    	let div56;
    	let div52;
    	let t138;
    	let div55;
    	let h52;
    	let t139_value = /*paciente*/ ctx[0].nombres + "";
    	let t139;
    	let t140;
    	let t141_value = /*paciente*/ ctx[0].apellidos + "";
    	let t141;
    	let t142;
    	let div53;
    	let t143;
    	let t144_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "";
    	let t144;
    	let t145;
    	let t146;
    	let div54;
    	let t149;
    	let div57;
    	let hr7;
    	let t150;
    	let p5;
    	let t152;
    	let p6;
    	let strong2;
    	let t156;
    	let div59;
    	let hr8;
    	let t157;
    	let div58;
    	let current;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });
    	let if_block0 = /*errorServer*/ ctx[6] && create_if_block_5$3(ctx);
    	let each_value_2 = /*estudios*/ ctx[3];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i));
    	}

    	let if_block1 = /*historia*/ ctx[1].instrucciones && create_if_block_3$4(ctx);
    	let each_value_1 = /*estudios*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	let if_block2 = /*historia*/ ctx[1].instrucciones && create_if_block_1$d(ctx);
    	let each_value = /*medicamentos*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	let if_block3 = /*historia*/ ctx[1].instrucciones && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			section = element("section");
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div2.textContent = "Para:";
    			t5 = space();
    			h4 = element("h4");
    			t6 = text(t6_value);
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			p0 = element("p");
    			t10 = text("ID Consulta #");
    			t11 = text(t11_value);
    			t12 = space();
    			br0 = element("br");
    			t13 = text("\r\n                                    Fecha Consulta : ");
    			t14 = text(t14_value);
    			t15 = space();
    			button = element("button");
    			i = element("i");
    			t16 = text("\r\n                                    Imprimir");
    			t17 = space();
    			div65 = element("div");
    			div64 = element("div");
    			div26 = element("div");
    			div25 = element("div");
    			div24 = element("div");
    			div23 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			img0 = element("img");
    			t18 = space();
    			address0 = element("address");
    			span0 = element("span");
    			t19 = text(t19_value);
    			t20 = text(",");
    			t21 = space();
    			br1 = element("br");
    			t22 = space();
    			t23 = text(t23_value);
    			t24 = space();
    			br2 = element("br");
    			t25 = space();
    			t26 = text(t26_value);
    			t27 = space();
    			br3 = element("br");
    			t28 = text("\r\n                                            Tel.: ");
    			t29 = text(t29_value);
    			t30 = space();
    			br4 = element("br");
    			t31 = space();
    			t32 = text(t32_value);
    			t33 = space();
    			br5 = element("br");
    			t34 = space();
    			div12 = element("div");
    			div11 = element("div");
    			div11.textContent = "Estudios de laboratorios";
    			t36 = space();
    			hr0 = element("hr");
    			t37 = space();
    			div14 = element("div");
    			div13 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t38 = space();
    			if (if_block1) if_block1.c();
    			t39 = space();
    			div19 = element("div");
    			div15 = element("div");
    			t40 = space();
    			div18 = element("div");
    			h50 = element("h5");
    			t41 = text(t41_value);
    			t42 = space();
    			t43 = text(t43_value);
    			t44 = space();
    			div16 = element("div");
    			t45 = text("Edad: ");
    			t46 = text(t46_value);
    			t47 = text(" aos");
    			t48 = space();
    			div17 = element("div");
    			div17.textContent = `Fecha: ${new Date().toLocaleDateString("es-DO")}`;
    			t51 = space();
    			div20 = element("div");
    			hr1 = element("hr");
    			t52 = space();
    			p1 = element("p");
    			p1.textContent = "Firma del especialista";
    			t54 = space();
    			p2 = element("p");
    			strong0 = element("strong");
    			strong0.textContent = `${user().title}. ${user().name}`;
    			t58 = space();
    			div22 = element("div");
    			hr2 = element("hr");
    			t59 = space();
    			div21 = element("div");
    			div21.textContent = ` nextcom ${new Date().getFullYear()}`;
    			t62 = space();
    			div27 = element("div");
    			t63 = space();
    			div45 = element("div");
    			div44 = element("div");
    			div43 = element("div");
    			div42 = element("div");
    			div29 = element("div");
    			div28 = element("div");
    			img1 = element("img");
    			t64 = space();
    			address1 = element("address");
    			span1 = element("span");
    			t65 = text(t65_value);
    			t66 = text(",");
    			t67 = space();
    			br6 = element("br");
    			t68 = space();
    			t69 = text(t69_value);
    			t70 = space();
    			br7 = element("br");
    			t71 = space();
    			t72 = text(t72_value);
    			t73 = space();
    			br8 = element("br");
    			t74 = text("\r\n                                            Tel.: ");
    			t75 = text(t75_value);
    			t76 = space();
    			br9 = element("br");
    			t77 = space();
    			t78 = text(t78_value);
    			t79 = space();
    			br10 = element("br");
    			t80 = space();
    			div31 = element("div");
    			div30 = element("div");
    			div30.textContent = "Estudios de imagenes";
    			t82 = space();
    			hr3 = element("hr");
    			t83 = space();
    			div33 = element("div");
    			div32 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t84 = space();
    			if (if_block2) if_block2.c();
    			t85 = space();
    			div38 = element("div");
    			div34 = element("div");
    			t86 = space();
    			div37 = element("div");
    			h51 = element("h5");
    			t87 = text(t87_value);
    			t88 = space();
    			t89 = text(t89_value);
    			t90 = space();
    			div35 = element("div");
    			t91 = text("Edad: ");
    			t92 = text(t92_value);
    			t93 = text(" aos");
    			t94 = space();
    			div36 = element("div");
    			div36.textContent = `Fecha: ${new Date().toLocaleDateString("es-DO")}`;
    			t97 = space();
    			div39 = element("div");
    			hr4 = element("hr");
    			t98 = space();
    			p3 = element("p");
    			p3.textContent = "Firma del especialista";
    			t100 = space();
    			p4 = element("p");
    			strong1 = element("strong");
    			strong1.textContent = `${user().title}. ${user().name}`;
    			t104 = space();
    			div41 = element("div");
    			hr5 = element("hr");
    			t105 = space();
    			div40 = element("div");
    			div40.textContent = ` nextcom ${new Date().getFullYear()}`;
    			t108 = space();
    			div46 = element("div");
    			t109 = space();
    			div63 = element("div");
    			div62 = element("div");
    			div61 = element("div");
    			div60 = element("div");
    			div48 = element("div");
    			div47 = element("div");
    			img2 = element("img");
    			t110 = space();
    			address2 = element("address");
    			span2 = element("span");
    			t111 = text(t111_value);
    			t112 = text(",");
    			t113 = space();
    			br11 = element("br");
    			t114 = space();
    			t115 = text(t115_value);
    			t116 = space();
    			br12 = element("br");
    			t117 = space();
    			t118 = text(t118_value);
    			t119 = space();
    			br13 = element("br");
    			t120 = text("\r\n                                            Tel.: ");
    			t121 = text(t121_value);
    			t122 = space();
    			br14 = element("br");
    			t123 = space();
    			t124 = text(t124_value);
    			t125 = space();
    			br15 = element("br");
    			t126 = space();
    			div50 = element("div");
    			div49 = element("div");
    			div49.textContent = "Receta";
    			t128 = space();
    			hr6 = element("hr");
    			t129 = space();
    			div51 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Medicamento";
    			t131 = space();
    			th1 = element("th");
    			th1.textContent = "Cantidad";
    			t133 = space();
    			th2 = element("th");
    			th2.textContent = "Frecuencia";
    			t135 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t136 = space();
    			if (if_block3) if_block3.c();
    			t137 = space();
    			div56 = element("div");
    			div52 = element("div");
    			t138 = space();
    			div55 = element("div");
    			h52 = element("h5");
    			t139 = text(t139_value);
    			t140 = space();
    			t141 = text(t141_value);
    			t142 = space();
    			div53 = element("div");
    			t143 = text("Edad: ");
    			t144 = text(t144_value);
    			t145 = text(" aos");
    			t146 = space();
    			div54 = element("div");
    			div54.textContent = `Fecha: ${new Date().toLocaleDateString("es-DO")}`;
    			t149 = space();
    			div57 = element("div");
    			hr7 = element("hr");
    			t150 = space();
    			p5 = element("p");
    			p5.textContent = "Firma del especialista";
    			t152 = space();
    			p6 = element("p");
    			strong2 = element("strong");
    			strong2.textContent = `${user().title}. ${user().name}`;
    			t156 = space();
    			div59 = element("div");
    			hr8 = element("hr");
    			t157 = space();
    			div58 = element("div");
    			div58.textContent = ` nextcom ${new Date().getFullYear()}`;
    			attr_dev(div0, "class", "avatar-title bg-success rounded-circle mdi mdi-receipt  ");
    			add_location(div0, file$y, 112, 32, 3289);
    			attr_dev(div1, "class", "avatar avatar mr-3");
    			add_location(div1, file$y, 111, 28, 3223);
    			attr_dev(div2, "class", "opacity-75");
    			add_location(div2, file$y, 117, 32, 3525);
    			attr_dev(h4, "class", "m-b-0");
    			add_location(h4, file$y, 118, 32, 3594);
    			add_location(br0, file$y, 120, 63, 3778);
    			attr_dev(p0, "class", "opacity-75");
    			add_location(p0, file$y, 119, 32, 3691);
    			attr_dev(i, "class", "mdi\r\n                                mdi-printer");
    			add_location(i, file$y, 123, 89, 4024);
    			attr_dev(button, "class", "btn btn-white-translucent");
    			attr_dev(button, "id", "printDiv");
    			add_location(button, file$y, 123, 32, 3967);
    			attr_dev(div3, "class", "media-body");
    			add_location(div3, file$y, 116, 28, 3467);
    			attr_dev(div4, "class", "media");
    			add_location(div4, file$y, 110, 24, 3174);
    			attr_dev(div5, "class", "col-md-6 text-white p-b-30");
    			add_location(div5, file$y, 109, 20, 3108);
    			attr_dev(div6, "class", "row p-b-60 p-t-60");
    			add_location(div6, file$y, 107, 16, 3053);
    			attr_dev(div7, "class", "container");
    			add_location(div7, file$y, 106, 12, 3012);
    			attr_dev(div8, "class", "bg-dark m-b-30");
    			add_location(div8, file$y, 105, 8, 2970);
    			if (img0.src !== (img0_src_value = /*logo*/ ctx[5])) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "class", "logo svelte-1c6uu9z");
    			attr_dev(img0, "alt", "");
    			add_location(img0, file$y, 141, 40, 4725);
    			attr_dev(span0, "class", "h4 font-primary");
    			add_location(span0, file$y, 143, 44, 4873);
    			add_location(br1, file$y, 143, 100, 4929);
    			add_location(br2, file$y, 144, 75, 5010);
    			add_location(br3, file$y, 145, 64, 5080);
    			add_location(br4, file$y, 146, 69, 5155);
    			add_location(br5, file$y, 147, 61, 5222);
    			attr_dev(address0, "class", "m-t-10");
    			add_location(address0, file$y, 142, 40, 4803);
    			attr_dev(div9, "class", "col-md-6");
    			add_location(div9, file$y, 140, 36, 4661);
    			attr_dev(div10, "class", "row");
    			add_location(div10, file$y, 139, 32, 4606);
    			add_location(div11, file$y, 154, 36, 5469);
    			attr_dev(div12, "class", "bg-light cabecera svelte-1c6uu9z");
    			add_location(div12, file$y, 153, 32, 5400);
    			set_style(hr0, "margin", "0");
    			add_location(hr0, file$y, 156, 32, 5578);
    			attr_dev(div13, "class", "row mt-3 mb-3 contenedor-estudios svelte-1c6uu9z");
    			add_location(div13, file$y, 158, 35, 5691);
    			attr_dev(div14, "class", "col-12");
    			add_location(div14, file$y, 157, 32, 5634);
    			attr_dev(div15, "class", "col-md-6");
    			add_location(div15, file$y, 175, 36, 6670);
    			attr_dev(h50, "class", "font-primary");
    			add_location(h50, file$y, 179, 40, 6859);
    			attr_dev(div16, "class", "");
    			add_location(div16, file$y, 180, 40, 6970);
    			attr_dev(div17, "class", "");
    			add_location(div17, file$y, 181, 40, 7083);
    			attr_dev(div18, "class", "col-md-6 text-right my-auto");
    			add_location(div18, file$y, 178, 36, 6776);
    			attr_dev(div19, "class", "row");
    			add_location(div19, file$y, 174, 32, 6615);
    			add_location(hr1, file$y, 185, 36, 7325);
    			add_location(p1, file$y, 186, 36, 7367);
    			add_location(strong0, file$y, 187, 39, 7437);
    			add_location(p2, file$y, 187, 36, 7434);
    			attr_dev(div20, "class", "firma svelte-1c6uu9z");
    			add_location(div20, file$y, 184, 32, 7268);
    			add_location(hr2, file$y, 191, 36, 7628);
    			attr_dev(div21, "class", "text-center opacity-75");
    			add_location(div21, file$y, 192, 36, 7670);
    			attr_dev(div22, "class", "p-t-10 p-b-20");
    			add_location(div22, file$y, 189, 32, 7561);
    			attr_dev(div23, "class", "card-body");
    			add_location(div23, file$y, 138, 28, 4549);
    			attr_dev(div24, "class", "card");
    			add_location(div24, file$y, 137, 24, 4501);
    			attr_dev(div25, "class", "col-md-12 m-b-40");
    			add_location(div25, file$y, 136, 20, 4445);
    			attr_dev(div26, "class", "row");
    			add_location(div26, file$y, 135, 16, 4406);
    			attr_dev(div27, "class", "saltopagina svelte-1c6uu9z");
    			add_location(div27, file$y, 201, 16, 8008);
    			if (img1.src !== (img1_src_value = /*logo*/ ctx[5])) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "class", "logo svelte-1c6uu9z");
    			attr_dev(img1, "alt", "");
    			add_location(img1, file$y, 209, 40, 8378);
    			attr_dev(span1, "class", "h4 font-primary");
    			add_location(span1, file$y, 211, 44, 8526);
    			add_location(br6, file$y, 211, 100, 8582);
    			add_location(br7, file$y, 212, 75, 8663);
    			add_location(br8, file$y, 213, 64, 8733);
    			add_location(br9, file$y, 214, 69, 8808);
    			add_location(br10, file$y, 215, 61, 8875);
    			attr_dev(address1, "class", "m-t-10");
    			add_location(address1, file$y, 210, 40, 8456);
    			attr_dev(div28, "class", "col-md-6");
    			add_location(div28, file$y, 208, 36, 8314);
    			attr_dev(div29, "class", "row");
    			add_location(div29, file$y, 207, 32, 8259);
    			add_location(div30, file$y, 222, 36, 9122);
    			attr_dev(div31, "class", "bg-light cabecera svelte-1c6uu9z");
    			add_location(div31, file$y, 221, 32, 9053);
    			set_style(hr3, "margin", "0");
    			add_location(hr3, file$y, 224, 32, 9227);
    			attr_dev(div32, "class", "row mt-3 mb-3 contenedor-estudios svelte-1c6uu9z");
    			add_location(div32, file$y, 226, 35, 9340);
    			attr_dev(div33, "class", "col-12");
    			add_location(div33, file$y, 225, 32, 9283);
    			attr_dev(div34, "class", "col-md-6");
    			add_location(div34, file$y, 243, 36, 10319);
    			attr_dev(h51, "class", "font-primary");
    			add_location(h51, file$y, 247, 40, 10508);
    			attr_dev(div35, "class", "");
    			add_location(div35, file$y, 248, 40, 10619);
    			attr_dev(div36, "class", "");
    			add_location(div36, file$y, 249, 40, 10732);
    			attr_dev(div37, "class", "col-md-6 text-right my-auto");
    			add_location(div37, file$y, 246, 36, 10425);
    			attr_dev(div38, "class", "row");
    			add_location(div38, file$y, 242, 32, 10264);
    			add_location(hr4, file$y, 253, 36, 10974);
    			add_location(p3, file$y, 254, 36, 11016);
    			add_location(strong1, file$y, 255, 39, 11086);
    			add_location(p4, file$y, 255, 36, 11083);
    			attr_dev(div39, "class", "firma svelte-1c6uu9z");
    			add_location(div39, file$y, 252, 32, 10917);
    			add_location(hr5, file$y, 259, 36, 11277);
    			attr_dev(div40, "class", "text-center opacity-75");
    			add_location(div40, file$y, 260, 36, 11319);
    			attr_dev(div41, "class", "p-t-10 p-b-20");
    			add_location(div41, file$y, 257, 32, 11210);
    			attr_dev(div42, "class", "card-body");
    			add_location(div42, file$y, 206, 28, 8202);
    			attr_dev(div43, "class", "card");
    			add_location(div43, file$y, 205, 24, 8154);
    			attr_dev(div44, "class", "col-md-12 m-b-40");
    			add_location(div44, file$y, 204, 20, 8098);
    			attr_dev(div45, "class", "row");
    			add_location(div45, file$y, 203, 16, 8059);
    			attr_dev(div46, "class", "saltopagina svelte-1c6uu9z");
    			add_location(div46, file$y, 269, 16, 11657);
    			if (img2.src !== (img2_src_value = /*logo*/ ctx[5])) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "class", "logo svelte-1c6uu9z");
    			attr_dev(img2, "alt", "");
    			add_location(img2, file$y, 277, 40, 12027);
    			attr_dev(span2, "class", "h4 font-primary");
    			add_location(span2, file$y, 279, 44, 12175);
    			add_location(br11, file$y, 279, 100, 12231);
    			add_location(br12, file$y, 280, 75, 12312);
    			add_location(br13, file$y, 281, 64, 12382);
    			add_location(br14, file$y, 282, 69, 12457);
    			add_location(br15, file$y, 283, 61, 12524);
    			attr_dev(address2, "class", "m-t-10");
    			add_location(address2, file$y, 278, 40, 12105);
    			attr_dev(div47, "class", "col-md-6");
    			add_location(div47, file$y, 276, 36, 11963);
    			attr_dev(div48, "class", "row");
    			add_location(div48, file$y, 275, 32, 11908);
    			add_location(div49, file$y, 290, 36, 12771);
    			attr_dev(div50, "class", "bg-light cabecera svelte-1c6uu9z");
    			add_location(div50, file$y, 289, 32, 12702);
    			set_style(hr6, "margin", "0");
    			add_location(hr6, file$y, 292, 32, 12862);
    			attr_dev(th0, "class", "");
    			add_location(th0, file$y, 297, 44, 13156);
    			attr_dev(th1, "class", "text-center");
    			add_location(th1, file$y, 298, 44, 13231);
    			attr_dev(th2, "class", "text-center");
    			add_location(th2, file$y, 299, 44, 13314);
    			add_location(tr, file$y, 296, 40, 13106);
    			add_location(thead, file$y, 295, 40, 13057);
    			add_location(tbody, file$y, 302, 40, 13492);
    			attr_dev(table, "class", "table m-t-50");
    			add_location(table, file$y, 294, 36, 12987);
    			attr_dev(div51, "class", "table-responsive ");
    			add_location(div51, file$y, 293, 32, 12918);
    			attr_dev(div52, "class", "col-md-6");
    			add_location(div52, file$y, 325, 36, 14952);
    			attr_dev(h52, "class", "font-primary");
    			add_location(h52, file$y, 329, 40, 15141);
    			attr_dev(div53, "class", "");
    			add_location(div53, file$y, 330, 40, 15252);
    			attr_dev(div54, "class", "");
    			add_location(div54, file$y, 331, 40, 15365);
    			attr_dev(div55, "class", "col-md-6 text-right my-auto");
    			add_location(div55, file$y, 328, 36, 15058);
    			attr_dev(div56, "class", "row");
    			add_location(div56, file$y, 324, 32, 14897);
    			add_location(hr7, file$y, 335, 36, 15607);
    			add_location(p5, file$y, 336, 36, 15649);
    			add_location(strong2, file$y, 337, 39, 15719);
    			add_location(p6, file$y, 337, 36, 15716);
    			attr_dev(div57, "class", "firma svelte-1c6uu9z");
    			add_location(div57, file$y, 334, 32, 15550);
    			add_location(hr8, file$y, 341, 36, 15910);
    			attr_dev(div58, "class", "text-center opacity-75");
    			add_location(div58, file$y, 342, 36, 15952);
    			attr_dev(div59, "class", "p-t-10 p-b-20");
    			add_location(div59, file$y, 339, 32, 15843);
    			attr_dev(div60, "class", "card-body");
    			add_location(div60, file$y, 274, 28, 11851);
    			attr_dev(div61, "class", "card");
    			add_location(div61, file$y, 273, 24, 11803);
    			attr_dev(div62, "class", "col-md-12 m-b-40");
    			add_location(div62, file$y, 272, 20, 11747);
    			attr_dev(div63, "class", "row");
    			add_location(div63, file$y, 271, 16, 11708);
    			attr_dev(div64, "class", "container");
    			attr_dev(div64, "id", "printableArea");
    			add_location(div64, file$y, 134, 12, 4346);
    			attr_dev(div65, "class", "pull-up");
    			add_location(div65, file$y, 133, 8, 4311);
    			attr_dev(section, "class", "admin-content ");
    			add_location(section, file$y, 104, 4, 2928);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$y, 99, 2, 2801);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t2);
    			append_dev(main, section);
    			append_dev(section, div8);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div3, t5);
    			append_dev(div3, h4);
    			append_dev(h4, t6);
    			append_dev(h4, t7);
    			append_dev(h4, t8);
    			append_dev(div3, t9);
    			append_dev(div3, p0);
    			append_dev(p0, t10);
    			append_dev(p0, t11);
    			append_dev(p0, t12);
    			append_dev(p0, br0);
    			append_dev(p0, t13);
    			append_dev(p0, t14);
    			append_dev(div3, t15);
    			append_dev(div3, button);
    			append_dev(button, i);
    			append_dev(button, t16);
    			append_dev(section, t17);
    			append_dev(section, div65);
    			append_dev(div65, div64);
    			append_dev(div64, div26);
    			append_dev(div26, div25);
    			append_dev(div25, div24);
    			append_dev(div24, div23);
    			append_dev(div23, div10);
    			append_dev(div10, div9);
    			append_dev(div9, img0);
    			append_dev(div9, t18);
    			append_dev(div9, address0);
    			append_dev(address0, span0);
    			append_dev(span0, t19);
    			append_dev(span0, t20);
    			append_dev(address0, t21);
    			append_dev(address0, br1);
    			append_dev(address0, t22);
    			append_dev(address0, t23);
    			append_dev(address0, t24);
    			append_dev(address0, br2);
    			append_dev(address0, t25);
    			append_dev(address0, t26);
    			append_dev(address0, t27);
    			append_dev(address0, br3);
    			append_dev(address0, t28);
    			append_dev(address0, t29);
    			append_dev(address0, t30);
    			append_dev(address0, br4);
    			append_dev(address0, t31);
    			append_dev(address0, t32);
    			append_dev(address0, t33);
    			append_dev(address0, br5);
    			append_dev(div23, t34);
    			append_dev(div23, div12);
    			append_dev(div12, div11);
    			append_dev(div23, t36);
    			append_dev(div23, hr0);
    			append_dev(div23, t37);
    			append_dev(div23, div14);
    			append_dev(div14, div13);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div13, null);
    			}

    			append_dev(div23, t38);
    			if (if_block1) if_block1.m(div23, null);
    			append_dev(div23, t39);
    			append_dev(div23, div19);
    			append_dev(div19, div15);
    			append_dev(div19, t40);
    			append_dev(div19, div18);
    			append_dev(div18, h50);
    			append_dev(h50, t41);
    			append_dev(h50, t42);
    			append_dev(h50, t43);
    			append_dev(div18, t44);
    			append_dev(div18, div16);
    			append_dev(div16, t45);
    			append_dev(div16, t46);
    			append_dev(div16, t47);
    			append_dev(div18, t48);
    			append_dev(div18, div17);
    			append_dev(div23, t51);
    			append_dev(div23, div20);
    			append_dev(div20, hr1);
    			append_dev(div20, t52);
    			append_dev(div20, p1);
    			append_dev(div20, t54);
    			append_dev(div20, p2);
    			append_dev(p2, strong0);
    			append_dev(div23, t58);
    			append_dev(div23, div22);
    			append_dev(div22, hr2);
    			append_dev(div22, t59);
    			append_dev(div22, div21);
    			append_dev(div64, t62);
    			append_dev(div64, div27);
    			append_dev(div64, t63);
    			append_dev(div64, div45);
    			append_dev(div45, div44);
    			append_dev(div44, div43);
    			append_dev(div43, div42);
    			append_dev(div42, div29);
    			append_dev(div29, div28);
    			append_dev(div28, img1);
    			append_dev(div28, t64);
    			append_dev(div28, address1);
    			append_dev(address1, span1);
    			append_dev(span1, t65);
    			append_dev(span1, t66);
    			append_dev(address1, t67);
    			append_dev(address1, br6);
    			append_dev(address1, t68);
    			append_dev(address1, t69);
    			append_dev(address1, t70);
    			append_dev(address1, br7);
    			append_dev(address1, t71);
    			append_dev(address1, t72);
    			append_dev(address1, t73);
    			append_dev(address1, br8);
    			append_dev(address1, t74);
    			append_dev(address1, t75);
    			append_dev(address1, t76);
    			append_dev(address1, br9);
    			append_dev(address1, t77);
    			append_dev(address1, t78);
    			append_dev(address1, t79);
    			append_dev(address1, br10);
    			append_dev(div42, t80);
    			append_dev(div42, div31);
    			append_dev(div31, div30);
    			append_dev(div42, t82);
    			append_dev(div42, hr3);
    			append_dev(div42, t83);
    			append_dev(div42, div33);
    			append_dev(div33, div32);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div32, null);
    			}

    			append_dev(div42, t84);
    			if (if_block2) if_block2.m(div42, null);
    			append_dev(div42, t85);
    			append_dev(div42, div38);
    			append_dev(div38, div34);
    			append_dev(div38, t86);
    			append_dev(div38, div37);
    			append_dev(div37, h51);
    			append_dev(h51, t87);
    			append_dev(h51, t88);
    			append_dev(h51, t89);
    			append_dev(div37, t90);
    			append_dev(div37, div35);
    			append_dev(div35, t91);
    			append_dev(div35, t92);
    			append_dev(div35, t93);
    			append_dev(div37, t94);
    			append_dev(div37, div36);
    			append_dev(div42, t97);
    			append_dev(div42, div39);
    			append_dev(div39, hr4);
    			append_dev(div39, t98);
    			append_dev(div39, p3);
    			append_dev(div39, t100);
    			append_dev(div39, p4);
    			append_dev(p4, strong1);
    			append_dev(div42, t104);
    			append_dev(div42, div41);
    			append_dev(div41, hr5);
    			append_dev(div41, t105);
    			append_dev(div41, div40);
    			append_dev(div64, t108);
    			append_dev(div64, div46);
    			append_dev(div64, t109);
    			append_dev(div64, div63);
    			append_dev(div63, div62);
    			append_dev(div62, div61);
    			append_dev(div61, div60);
    			append_dev(div60, div48);
    			append_dev(div48, div47);
    			append_dev(div47, img2);
    			append_dev(div47, t110);
    			append_dev(div47, address2);
    			append_dev(address2, span2);
    			append_dev(span2, t111);
    			append_dev(span2, t112);
    			append_dev(address2, t113);
    			append_dev(address2, br11);
    			append_dev(address2, t114);
    			append_dev(address2, t115);
    			append_dev(address2, t116);
    			append_dev(address2, br12);
    			append_dev(address2, t117);
    			append_dev(address2, t118);
    			append_dev(address2, t119);
    			append_dev(address2, br13);
    			append_dev(address2, t120);
    			append_dev(address2, t121);
    			append_dev(address2, t122);
    			append_dev(address2, br14);
    			append_dev(address2, t123);
    			append_dev(address2, t124);
    			append_dev(address2, t125);
    			append_dev(address2, br15);
    			append_dev(div60, t126);
    			append_dev(div60, div50);
    			append_dev(div50, div49);
    			append_dev(div60, t128);
    			append_dev(div60, hr6);
    			append_dev(div60, t129);
    			append_dev(div60, div51);
    			append_dev(div51, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t131);
    			append_dev(tr, th1);
    			append_dev(tr, t133);
    			append_dev(tr, th2);
    			append_dev(table, t135);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(div60, t136);
    			if (if_block3) if_block3.m(div60, null);
    			append_dev(div60, t137);
    			append_dev(div60, div56);
    			append_dev(div56, div52);
    			append_dev(div56, t138);
    			append_dev(div56, div55);
    			append_dev(div55, h52);
    			append_dev(h52, t139);
    			append_dev(h52, t140);
    			append_dev(h52, t141);
    			append_dev(div55, t142);
    			append_dev(div55, div53);
    			append_dev(div53, t143);
    			append_dev(div53, t144);
    			append_dev(div53, t145);
    			append_dev(div55, t146);
    			append_dev(div55, div54);
    			append_dev(div60, t149);
    			append_dev(div60, div57);
    			append_dev(div57, hr7);
    			append_dev(div57, t150);
    			append_dev(div57, p5);
    			append_dev(div57, t152);
    			append_dev(div57, p6);
    			append_dev(p6, strong2);
    			append_dev(div60, t156);
    			append_dev(div60, div59);
    			append_dev(div59, hr8);
    			append_dev(div59, t157);
    			append_dev(div59, div58);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*paciente*/ 1) && t6_value !== (t6_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*paciente*/ 1) && t8_value !== (t8_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t8, t8_value);
    			if ((!current || dirty & /*historia*/ 2) && t11_value !== (t11_value = /*historia*/ ctx[1].id + "")) set_data_dev(t11, t11_value);
    			if ((!current || dirty & /*historia*/ 2) && t14_value !== (t14_value = new Date(/*historia*/ ctx[1].createdAt).toLocaleDateString("es-DO") + "")) set_data_dev(t14, t14_value);

    			if (!current || dirty & /*logo*/ 32 && img0.src !== (img0_src_value = /*logo*/ ctx[5])) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if ((!current || dirty & /*empresa*/ 4) && t19_value !== (t19_value = /*empresa*/ ctx[2].nombre + "")) set_data_dev(t19, t19_value);
    			if ((!current || dirty & /*empresa*/ 4) && t23_value !== (t23_value = (/*empresa*/ ctx[2].especialidades || "") + "")) set_data_dev(t23, t23_value);
    			if ((!current || dirty & /*empresa*/ 4) && t26_value !== (t26_value = /*empresa*/ ctx[2].direccion + "")) set_data_dev(t26, t26_value);
    			if ((!current || dirty & /*empresa*/ 4) && t29_value !== (t29_value = /*empresa*/ ctx[2].telefono + "")) set_data_dev(t29, t29_value);
    			if ((!current || dirty & /*empresa*/ 4) && t32_value !== (t32_value = /*empresa*/ ctx[2].correo + "")) set_data_dev(t32, t32_value);

    			if (dirty & /*estudios*/ 8) {
    				each_value_2 = /*estudios*/ ctx[3];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$4(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2$4(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(div13, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (/*historia*/ ctx[1].instrucciones) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$4(ctx);
    					if_block1.c();
    					if_block1.m(div23, t39);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if ((!current || dirty & /*paciente*/ 1) && t41_value !== (t41_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t41, t41_value);
    			if ((!current || dirty & /*paciente*/ 1) && t43_value !== (t43_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t43, t43_value);
    			if ((!current || dirty & /*paciente*/ 1) && t46_value !== (t46_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "")) set_data_dev(t46, t46_value);

    			if (!current || dirty & /*logo*/ 32 && img1.src !== (img1_src_value = /*logo*/ ctx[5])) {
    				attr_dev(img1, "src", img1_src_value);
    			}

    			if ((!current || dirty & /*empresa*/ 4) && t65_value !== (t65_value = /*empresa*/ ctx[2].nombre + "")) set_data_dev(t65, t65_value);
    			if ((!current || dirty & /*empresa*/ 4) && t69_value !== (t69_value = (/*empresa*/ ctx[2].especialidades || "") + "")) set_data_dev(t69, t69_value);
    			if ((!current || dirty & /*empresa*/ 4) && t72_value !== (t72_value = /*empresa*/ ctx[2].direccion + "")) set_data_dev(t72, t72_value);
    			if ((!current || dirty & /*empresa*/ 4) && t75_value !== (t75_value = /*empresa*/ ctx[2].telefono + "")) set_data_dev(t75, t75_value);
    			if ((!current || dirty & /*empresa*/ 4) && t78_value !== (t78_value = /*empresa*/ ctx[2].correo + "")) set_data_dev(t78, t78_value);

    			if (dirty & /*estudios*/ 8) {
    				each_value_1 = /*estudios*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$5(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div32, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (/*historia*/ ctx[1].instrucciones) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1$d(ctx);
    					if_block2.c();
    					if_block2.m(div42, t85);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if ((!current || dirty & /*paciente*/ 1) && t87_value !== (t87_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t87, t87_value);
    			if ((!current || dirty & /*paciente*/ 1) && t89_value !== (t89_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t89, t89_value);
    			if ((!current || dirty & /*paciente*/ 1) && t92_value !== (t92_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "")) set_data_dev(t92, t92_value);

    			if (!current || dirty & /*logo*/ 32 && img2.src !== (img2_src_value = /*logo*/ ctx[5])) {
    				attr_dev(img2, "src", img2_src_value);
    			}

    			if ((!current || dirty & /*empresa*/ 4) && t111_value !== (t111_value = /*empresa*/ ctx[2].nombre + "")) set_data_dev(t111, t111_value);
    			if ((!current || dirty & /*empresa*/ 4) && t115_value !== (t115_value = (/*empresa*/ ctx[2].especialidades || "") + "")) set_data_dev(t115, t115_value);
    			if ((!current || dirty & /*empresa*/ 4) && t118_value !== (t118_value = /*empresa*/ ctx[2].direccion + "")) set_data_dev(t118, t118_value);
    			if ((!current || dirty & /*empresa*/ 4) && t121_value !== (t121_value = /*empresa*/ ctx[2].telefono + "")) set_data_dev(t121, t121_value);
    			if ((!current || dirty & /*empresa*/ 4) && t124_value !== (t124_value = /*empresa*/ ctx[2].correo + "")) set_data_dev(t124, t124_value);

    			if (dirty & /*medicamentos*/ 16) {
    				each_value = /*medicamentos*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*historia*/ ctx[1].instrucciones) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block$l(ctx);
    					if_block3.c();
    					if_block3.m(div60, t137);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if ((!current || dirty & /*paciente*/ 1) && t139_value !== (t139_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t139, t139_value);
    			if ((!current || dirty & /*paciente*/ 1) && t141_value !== (t141_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t141, t141_value);
    			if ((!current || dirty & /*paciente*/ 1) && t144_value !== (t144_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "")) set_data_dev(t144, t144_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks_2, detaching);
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks_1, detaching);
    			if (if_block2) if_block2.d();
    			destroy_each(each_blocks, detaching);
    			if (if_block3) if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ImprimirRecetas", slots, []);
    	let { params } = $$props;
    	let errorServer = false;
    	let paciente = {};
    	let historia = {};
    	let empresa = {};
    	let estudios = [];
    	let medicamentos = [];
    	let logo = "";

    	const cargarImagenEmpresa = (idConsultorio, idImagen) => {
    		const config = {
    			method: "get",
    			url: `${url}/imagenes/${idConsultorio}/${idImagen}`,
    			responseType: "blob",
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(5, logo = URL.createObjectURL(res.data));
    			console.log(logo);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarPaciente = () => {
    		const config = {
    			method: "get",
    			url: `${url}/pacientes/${params.idPaciente}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(0, paciente = res.data);
    			console.log(paciente);
    		});
    	};

    	const cargarHistoria = () => {
    		const config = {
    			method: "get",
    			url: `${url}/historias/${params.idHistoria}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(1, historia = res.data);
    			$$invalidate(3, estudios = res.data.estudios);
    			$$invalidate(4, medicamentos = res.data.medicamentos);
    			console.log(historia);
    		});
    	};

    	const cargarEmpresa = () => {
    		const config = {
    			method: "get",
    			url: `${url}/empresas/${user().empresa}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(2, empresa = res.data);
    			cargarImagenEmpresa(empresa.id, empresa.logo);
    			console.log(empresa);
    		});
    	};

    	onMount(() => {
    		jQuery("html, body").animate({ scrollTop: 0 }, "slow");
    		cargarPaciente();
    		cargarHistoria();
    		cargarEmpresa();

    		window.onafterprint = event => {
    			location.reload();
    		};
    	});

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$i.warn(`<ImprimirRecetas> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(7, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		onMount,
    		calcularEdad,
    		url,
    		user,
    		Header,
    		Aside,
    		ErrorConexion,
    		params,
    		errorServer,
    		paciente,
    		historia,
    		empresa,
    		estudios,
    		medicamentos,
    		logo,
    		cargarImagenEmpresa,
    		cargarPaciente,
    		cargarHistoria,
    		cargarEmpresa
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(7, params = $$props.params);
    		if ("errorServer" in $$props) $$invalidate(6, errorServer = $$props.errorServer);
    		if ("paciente" in $$props) $$invalidate(0, paciente = $$props.paciente);
    		if ("historia" in $$props) $$invalidate(1, historia = $$props.historia);
    		if ("empresa" in $$props) $$invalidate(2, empresa = $$props.empresa);
    		if ("estudios" in $$props) $$invalidate(3, estudios = $$props.estudios);
    		if ("medicamentos" in $$props) $$invalidate(4, medicamentos = $$props.medicamentos);
    		if ("logo" in $$props) $$invalidate(5, logo = $$props.logo);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [paciente, historia, empresa, estudios, medicamentos, logo, errorServer, params];
    }

    class ImprimirRecetas extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { params: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImprimirRecetas",
    			options,
    			id: create_fragment$A.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*params*/ ctx[7] === undefined && !("params" in props)) {
    			console_1$i.warn("<ImprimirRecetas> was created without expected prop 'params'");
    		}
    	}

    	get params() {
    		throw new Error("<ImprimirRecetas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<ImprimirRecetas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\componentes\Modals\ModalAgregarHorario.svelte generated by Svelte v3.29.0 */

    const { console: console_1$j } = globals;
    const file$z = "src\\componentes\\Modals\\ModalAgregarHorario.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (119:20) {#if cargando}
    function create_if_block_1$e(ctx) {
    	let div;
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loading.$$.fragment);
    			attr_dev(div, "class", "cargando");
    			add_location(div, file$z, 119, 24, 3654);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loading, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(119:20) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    // (154:32) {#each tandas as tanda}
    function create_each_block$f(ctx) {
    	let option;
    	let t_value = /*tanda*/ ctx[5].descripcion + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*tanda*/ ctx[5].id;
    			option.value = option.__value;
    			add_location(option, file$z, 154, 36, 5466);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tandas*/ 1 && t_value !== (t_value = /*tanda*/ ctx[5].descripcion + "")) set_data_dev(t, t_value);

    			if (dirty & /*tandas*/ 1 && option_value_value !== (option_value_value = /*tanda*/ ctx[5].id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(154:32) {#each tandas as tanda}",
    		ctx
    	});

    	return block;
    }

    // (167:20) {#if msgError}
    function create_if_block$m(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*msgError*/ ctx[1]);
    			attr_dev(div, "class", "alert alert-danger");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$z, 167, 24, 6104);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*msgError*/ 2) set_data_dev(t, /*msgError*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(167:20) {#if msgError}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let form;
    	let div14;
    	let div13;
    	let div12;
    	let div0;
    	let h5;
    	let t1;
    	let button0;
    	let span;
    	let t3;
    	let div5;
    	let t4;
    	let div4;
    	let div1;
    	let label0;
    	let t6;
    	let select0;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let option6;
    	let option7;
    	let t15;
    	let div2;
    	let label1;
    	let t17;
    	let select1;
    	let option8;
    	let t19;
    	let div3;
    	let label2;
    	let t21;
    	let input;
    	let t22;
    	let t23;
    	let br;
    	let t24;
    	let div11;
    	let div10;
    	let div7;
    	let a;
    	let h30;
    	let t25;
    	let div6;
    	let t27;
    	let div9;
    	let button1;
    	let h31;
    	let t28;
    	let div8;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*cargando*/ ctx[2] && create_if_block_1$e(ctx);
    	let each_value = /*tandas*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	let if_block1 = /*msgError*/ ctx[1] && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			form = element("form");
    			div14 = element("div");
    			div13 = element("div");
    			div12 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Creando horarios";
    			t1 = space();
    			button0 = element("button");
    			span = element("span");
    			span.textContent = "";
    			t3 = space();
    			div5 = element("div");
    			if (if_block0) if_block0.c();
    			t4 = space();
    			div4 = element("div");
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Dia";
    			t6 = space();
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "- seleccionar dia -\r\n                                ";
    			option1 = element("option");
    			option1.textContent = "Lunes";
    			option2 = element("option");
    			option2.textContent = "Martes";
    			option3 = element("option");
    			option3.textContent = "Miercoles";
    			option4 = element("option");
    			option4.textContent = "Jueves";
    			option5 = element("option");
    			option5.textContent = "Viernes";
    			option6 = element("option");
    			option6.textContent = "Sabado";
    			option7 = element("option");
    			option7.textContent = "Domingo";
    			t15 = space();
    			div2 = element("div");
    			label1 = element("label");
    			label1.textContent = "Tanda";
    			t17 = space();
    			select1 = element("select");
    			option8 = element("option");
    			option8.textContent = "- seleccionar tanda -\r\n                                ";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t19 = space();
    			div3 = element("div");
    			label2 = element("label");
    			label2.textContent = "Cupo (Cantidad de personas por tanda)";
    			t21 = space();
    			input = element("input");
    			t22 = space();
    			if (if_block1) if_block1.c();
    			t23 = space();
    			br = element("br");
    			t24 = space();
    			div11 = element("div");
    			div10 = element("div");
    			div7 = element("div");
    			a = element("a");
    			h30 = element("h3");
    			t25 = space();
    			div6 = element("div");
    			div6.textContent = "Cerrar";
    			t27 = space();
    			div9 = element("div");
    			button1 = element("button");
    			h31 = element("h3");
    			t28 = space();
    			div8 = element("div");
    			div8.textContent = "Crear";
    			attr_dev(h5, "class", "modal-title");
    			attr_dev(h5, "id", "modalInterconsulta");
    			add_location(h5, file$z, 105, 20, 3099);
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$z, 114, 24, 3462);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$z, 108, 20, 3238);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$z, 104, 16, 3051);
    			attr_dev(label0, "for", "");
    			attr_dev(label0, "class", "text-primary");
    			add_location(label0, file$z, 125, 28, 3909);
    			option0.__value = "";
    			option0.value = option0.__value;
    			add_location(option0, file$z, 131, 32, 4203);
    			option1.__value = "0";
    			option1.value = option1.__value;
    			add_location(option1, file$z, 134, 32, 4354);
    			option2.__value = "1";
    			option2.value = option2.__value;
    			add_location(option2, file$z, 135, 32, 4420);
    			option3.__value = "2";
    			option3.value = option3.__value;
    			add_location(option3, file$z, 136, 32, 4487);
    			option4.__value = "3";
    			option4.value = option4.__value;
    			add_location(option4, file$z, 137, 32, 4557);
    			option5.__value = "4";
    			option5.value = option5.__value;
    			add_location(option5, file$z, 138, 32, 4624);
    			option6.__value = "5";
    			option6.value = option6.__value;
    			add_location(option6, file$z, 139, 32, 4692);
    			option7.__value = "6";
    			option7.value = option7.__value;
    			add_location(option7, file$z, 140, 32, 4759);
    			attr_dev(select0, "class", "form-control");
    			select0.required = true;
    			if (/*dia*/ ctx[4] === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[7].call(select0));
    			add_location(select0, file$z, 126, 28, 3985);
    			attr_dev(div1, "class", "form-group col-md-12");
    			add_location(div1, file$z, 124, 24, 3845);
    			attr_dev(label1, "for", "");
    			attr_dev(label1, "class", "text-primary");
    			add_location(label1, file$z, 144, 28, 4954);
    			option8.__value = "";
    			option8.value = option8.__value;
    			add_location(option8, file$z, 150, 32, 5252);
    			attr_dev(select1, "class", "form-control");
    			select1.required = true;
    			if (/*tanda*/ ctx[5] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[8].call(select1));
    			add_location(select1, file$z, 145, 28, 5032);
    			attr_dev(div2, "class", "form-group col-md-12");
    			add_location(div2, file$z, 143, 24, 4890);
    			attr_dev(label2, "for", "");
    			attr_dev(label2, "class", "text-primary");
    			add_location(label2, file$z, 161, 28, 5801);
    			attr_dev(input, "type", "number");
    			attr_dev(input, "class", "form-control");
    			input.required = true;
    			add_location(input, file$z, 162, 28, 5911);
    			attr_dev(div3, "class", "form-group col-md-12");
    			add_location(div3, file$z, 160, 24, 5737);
    			attr_dev(div4, "class", "form-row");
    			add_location(div4, file$z, 123, 20, 3797);
    			add_location(br, file$z, 171, 20, 6270);
    			attr_dev(div5, "class", "modal-body");
    			add_location(div5, file$z, 117, 16, 3568);
    			attr_dev(h30, "class", "mdi mdi-close-outline");
    			add_location(h30, file$z, 182, 32, 6768);
    			attr_dev(div6, "class", "text-overline");
    			add_location(div6, file$z, 183, 32, 6838);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "text-danger");
    			attr_dev(a, "data-dismiss", "modal");
    			add_location(a, file$z, 176, 28, 6475);
    			attr_dev(div7, "class", "col");
    			add_location(div7, file$z, 175, 24, 6428);
    			attr_dev(h31, "class", "mdi mdi-send");
    			add_location(h31, file$z, 192, 32, 7305);
    			attr_dev(div8, "class", "text-overline");
    			add_location(div8, file$z, 193, 32, 7366);
    			attr_dev(button1, "class", "text-success");
    			set_style(button1, "border", "none");
    			set_style(button1, "background-color", "transparent");
    			add_location(button1, file$z, 187, 28, 7016);
    			attr_dev(div9, "class", "col");
    			add_location(div9, file$z, 186, 24, 6969);
    			attr_dev(div10, "class", "row text-center p-b-10");
    			add_location(div10, file$z, 174, 20, 6366);
    			attr_dev(div11, "class", "modal-footer");
    			add_location(div11, file$z, 173, 16, 6318);
    			attr_dev(div12, "class", "modal-content");
    			add_location(div12, file$z, 103, 12, 3006);
    			attr_dev(div13, "class", "modal-dialog");
    			attr_dev(div13, "role", "document");
    			add_location(div13, file$z, 102, 8, 2950);
    			attr_dev(div14, "class", "modal fade modal-slide-right");
    			attr_dev(div14, "id", "modalAgregarHorario");
    			attr_dev(div14, "tabindex", "-1");
    			attr_dev(div14, "role", "dialog");
    			attr_dev(div14, "aria-labelledby", "modalInterconsulta");
    			set_style(div14, "display", "none");
    			set_style(div14, "padding-right", "16px");
    			attr_dev(div14, "aria-modal", "true");
    			add_location(div14, file$z, 93, 4, 2677);
    			attr_dev(form, "class", "col-md-12");
    			add_location(form, file$z, 92, 0, 2599);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div14);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div0);
    			append_dev(div0, h5);
    			append_dev(div0, t1);
    			append_dev(div0, button0);
    			append_dev(button0, span);
    			append_dev(div12, t3);
    			append_dev(div12, div5);
    			if (if_block0) if_block0.m(div5, null);
    			append_dev(div5, t4);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, label0);
    			append_dev(div1, t6);
    			append_dev(div1, select0);
    			append_dev(select0, option0);
    			append_dev(select0, option1);
    			append_dev(select0, option2);
    			append_dev(select0, option3);
    			append_dev(select0, option4);
    			append_dev(select0, option5);
    			append_dev(select0, option6);
    			append_dev(select0, option7);
    			select_option(select0, /*dia*/ ctx[4]);
    			append_dev(div4, t15);
    			append_dev(div4, div2);
    			append_dev(div2, label1);
    			append_dev(div2, t17);
    			append_dev(div2, select1);
    			append_dev(select1, option8);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			select_option(select1, /*tanda*/ ctx[5]);
    			append_dev(div4, t19);
    			append_dev(div4, div3);
    			append_dev(div3, label2);
    			append_dev(div3, t21);
    			append_dev(div3, input);
    			set_input_value(input, /*cupo*/ ctx[3]);
    			append_dev(div5, t22);
    			if (if_block1) if_block1.m(div5, null);
    			append_dev(div5, t23);
    			append_dev(div5, br);
    			append_dev(div12, t24);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, div7);
    			append_dev(div7, a);
    			append_dev(a, h30);
    			append_dev(a, t25);
    			append_dev(a, div6);
    			append_dev(div10, t27);
    			append_dev(div10, div9);
    			append_dev(div9, button1);
    			append_dev(button1, h31);
    			append_dev(button1, t28);
    			append_dev(button1, div8);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[7]),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[8]),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[9]),
    					listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[10]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*cargando*/ ctx[2]) {
    				if (if_block0) {
    					if (dirty & /*cargando*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$e(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div5, t4);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*dia*/ 16) {
    				select_option(select0, /*dia*/ ctx[4]);
    			}

    			if (dirty & /*tandas*/ 1) {
    				each_value = /*tandas*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*tanda, tandas*/ 33) {
    				select_option(select1, /*tanda*/ ctx[5]);
    			}

    			if (dirty & /*cupo*/ 8 && to_number(input.value) !== /*cupo*/ ctx[3]) {
    				set_input_value(input, /*cupo*/ ctx[3]);
    			}

    			if (/*msgError*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$m(ctx);
    					if_block1.c();
    					if_block1.m(div5, t23);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks, detaching);
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ModalAgregarHorario", slots, []);
    	const dispatch = createEventDispatcher();

    	const Toast = Swal.mixin({
    		toast: true,
    		position: "top-end",
    		showConfirmButton: false,
    		timer: 3000,
    		timerProgressBar: true,
    		didOpen: toast => {
    			toast.addEventListener("mouseenter", Swal.stopTimer);
    			toast.addEventListener("mouseleave", Swal.resumeTimer);
    		}
    	});

    	let tandas = [];
    	let msgError = "";
    	let cargando = false;
    	let cupo = "";
    	let tanda = "";
    	let dia = "";

    	const crearHorario = () => {
    		$$invalidate(2, cargando = true);
    		$$invalidate(1, msgError = "");
    		const data = { dia, cantidadCitas: cupo, tanda };

    		const config = {
    			method: "post",
    			url: `${url}/horarioscitas`,
    			data,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(2, cargando = false);

    			if (res.status === 200) {
    				dispatch("cargarHorariosCitas");

    				Toast.fire({
    					icon: "success",
    					title: "Se ha agregado el horario"
    				});
    			}
    		}).catch(err => {
    			$$invalidate(2, cargando = false);

    			if (err.response.data !== undefined) {
    				if (err.response.data.err === 303) {
    					$$invalidate(1, msgError = err.response.data.msg);
    					console.log(err.response.data.msg);
    				}

    				if (err.response.data.err === 310) {
    					$$invalidate(1, msgError = err.response.data.msg);
    					console.log(err.response.data.msg);
    				}
    			}
    		});
    	};

    	const cargarTandas = () => {
    		const config = {
    			method: "get",
    			url: `${url}/tandas`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(0, tandas = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	onMount(() => {
    		cargarTandas();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$j.warn(`<ModalAgregarHorario> was created with unknown prop '${key}'`);
    	});

    	function select0_change_handler() {
    		dia = select_value(this);
    		$$invalidate(4, dia);
    	}

    	function select1_change_handler() {
    		tanda = select_value(this);
    		$$invalidate(5, tanda);
    		$$invalidate(0, tandas);
    	}

    	function input_input_handler() {
    		cupo = to_number(this.value);
    		$$invalidate(3, cupo);
    	}

    	const submit_handler = () => crearHorario();

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		createEventDispatcher,
    		onMount,
    		url,
    		Loading,
    		dispatch,
    		Toast,
    		tandas,
    		msgError,
    		cargando,
    		cupo,
    		tanda,
    		dia,
    		crearHorario,
    		cargarTandas
    	});

    	$$self.$inject_state = $$props => {
    		if ("tandas" in $$props) $$invalidate(0, tandas = $$props.tandas);
    		if ("msgError" in $$props) $$invalidate(1, msgError = $$props.msgError);
    		if ("cargando" in $$props) $$invalidate(2, cargando = $$props.cargando);
    		if ("cupo" in $$props) $$invalidate(3, cupo = $$props.cupo);
    		if ("tanda" in $$props) $$invalidate(5, tanda = $$props.tanda);
    		if ("dia" in $$props) $$invalidate(4, dia = $$props.dia);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		tandas,
    		msgError,
    		cargando,
    		cupo,
    		dia,
    		tanda,
    		crearHorario,
    		select0_change_handler,
    		select1_change_handler,
    		input_input_handler,
    		submit_handler
    	];
    }

    class ModalAgregarHorario extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalAgregarHorario",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* src\Pages\Empresa\Detalle.svelte generated by Svelte v3.29.0 */

    const { console: console_1$k } = globals;
    const file$A = "src\\Pages\\Empresa\\Detalle.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	return child_ctx;
    }

    // (213:4) {#if serverConexion}
    function create_if_block_1$f(ctx) {
    	let noconexion;
    	let current;
    	noconexion = new NoConexion({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(noconexion.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(noconexion, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(noconexion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(noconexion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(noconexion, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(213:4) {#if serverConexion}",
    		ctx
    	});

    	return block;
    }

    // (216:4) {#if cargando}
    function create_if_block$n(ctx) {
    	let div;
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loading.$$.fragment);
    			attr_dev(div, "class", "cargando");
    			add_location(div, file$A, 216, 8, 6761);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loading, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(216:4) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    // (527:64) {#each horarios as horario}
    function create_each_block$g(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*dia*/ ctx[5][/*horario*/ ctx[26].dia] + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = (/*horario*/ ctx[26].tanda === "M" ? "Maana" : "Tarde") + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*horario*/ ctx[26].cantidadCitas + "";
    	let t4;
    	let t5;
    	let t6;
    	let td3;
    	let button;
    	let i;
    	let t7;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[19](/*horario*/ ctx[26], ...args);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text(t4_value);
    			t5 = text(" personas");
    			t6 = space();
    			td3 = element("td");
    			button = element("button");
    			i = element("i");
    			t7 = space();
    			add_location(td0, file$A, 528, 73, 27765);
    			add_location(td1, file$A, 529, 73, 27867);
    			add_location(td2, file$A, 530, 73, 27995);
    			attr_dev(i, "class", "mdi mdi-trash-can-outline");
    			add_location(i, file$A, 536, 81, 28663);
    			attr_dev(button, "title", "Eliminar");
    			attr_dev(button, "class", "btn btn-outline-danger btn-sm");
    			add_location(button, file$A, 532, 77, 28213);
    			attr_dev(td3, "class", "text-right");
    			add_location(td3, file$A, 531, 73, 28111);
    			add_location(tr, file$A, 527, 69, 27686);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(td2, t5);
    			append_dev(tr, t6);
    			append_dev(tr, td3);
    			append_dev(td3, button);
    			append_dev(button, i);
    			append_dev(tr, t7);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", prevent_default(click_handler), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*horarios*/ 16 && t0_value !== (t0_value = /*dia*/ ctx[5][/*horario*/ ctx[26].dia] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*horarios*/ 16 && t2_value !== (t2_value = (/*horario*/ ctx[26].tanda === "M" ? "Maana" : "Tarde") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*horarios*/ 16 && t4_value !== (t4_value = /*horario*/ ctx[26].cantidadCitas + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(527:64) {#each horarios as horario}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let t2;
    	let t3;
    	let section;
    	let button0;
    	let i0;
    	let t4;
    	let div47;
    	let div46;
    	let div45;
    	let div0;
    	let h5;
    	let i1;
    	let t5;
    	let t6;
    	let div19;
    	let div18;
    	let div1;
    	let h4;
    	let t8;
    	let div17;
    	let div16;
    	let div3;
    	let img;
    	let img_src_value;
    	let t9;
    	let div2;
    	let label0;
    	let i2;
    	let t10;
    	let t11;
    	let input0;
    	let t12;
    	let div15;
    	let div14;
    	let div5;
    	let div4;
    	let label1;
    	let t14;
    	let input1;
    	let t15;
    	let div7;
    	let div6;
    	let label2;
    	let t17;
    	let input2;
    	let t18;
    	let div9;
    	let div8;
    	let label3;
    	let t20;
    	let input3;
    	let t21;
    	let div11;
    	let div10;
    	let label4;
    	let t23;
    	let input4;
    	let t24;
    	let div13;
    	let div12;
    	let label5;
    	let t26;
    	let input5;
    	let t27;
    	let div44;
    	let div43;
    	let div21;
    	let div20;
    	let strong;
    	let t29;
    	let div42;
    	let div41;
    	let div23;
    	let div22;
    	let a0;
    	let i3;
    	let t30;
    	let t31;
    	let a1;
    	let i4;
    	let t32;
    	let t33;
    	let div40;
    	let div39;
    	let div33;
    	let div32;
    	let div25;
    	let div24;
    	let label6;
    	let input6;
    	let t34;
    	let span0;
    	let t35;
    	let span1;
    	let t37;
    	let div27;
    	let div26;
    	let label7;
    	let input7;
    	let t38;
    	let span2;
    	let t39;
    	let span3;
    	let t41;
    	let div29;
    	let div28;
    	let label8;
    	let input8;
    	let t42;
    	let span4;
    	let t43;
    	let span5;
    	let t45;
    	let div31;
    	let div30;
    	let label9;
    	let input9;
    	let t46;
    	let span6;
    	let t47;
    	let span7;
    	let t49;
    	let div38;
    	let div37;
    	let div35;
    	let div34;
    	let button1;
    	let i5;
    	let t50;
    	let t51;
    	let div36;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t53;
    	let th1;
    	let t55;
    	let th2;
    	let t57;
    	let th3;
    	let t58;
    	let tbody;
    	let t59;
    	let br0;
    	let br1;
    	let t60;
    	let modalagregarhorario;
    	let current;
    	let mounted;
    	let dispose;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });
    	let if_block0 = /*serverConexion*/ ctx[0] && create_if_block_1$f(ctx);
    	let if_block1 = /*cargando*/ ctx[3] && create_if_block$n(ctx);
    	let each_value = /*horarios*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	modalagregarhorario = new ModalAgregarHorario({ $$inline: true });
    	modalagregarhorario.$on("cargarHorariosCitas", /*cargarHorariosCitas*/ ctx[7]);

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			section = element("section");
    			button0 = element("button");
    			i0 = element("i");
    			t4 = space();
    			div47 = element("div");
    			div46 = element("div");
    			div45 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			i1 = element("i");
    			t5 = text(" Consultorio");
    			t6 = space();
    			div19 = element("div");
    			div18 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Informacin";
    			t8 = space();
    			div17 = element("div");
    			div16 = element("div");
    			div3 = element("div");
    			img = element("img");
    			t9 = space();
    			div2 = element("div");
    			label0 = element("label");
    			i2 = element("i");
    			t10 = text(" Cambiar\r\n                                                imagen");
    			t11 = space();
    			input0 = element("input");
    			t12 = space();
    			div15 = element("div");
    			div14 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			label1 = element("label");
    			label1.textContent = "Nombre consultorio";
    			t14 = space();
    			input1 = element("input");
    			t15 = space();
    			div7 = element("div");
    			div6 = element("div");
    			label2 = element("label");
    			label2.textContent = "Especialidades";
    			t17 = space();
    			input2 = element("input");
    			t18 = space();
    			div9 = element("div");
    			div8 = element("div");
    			label3 = element("label");
    			label3.textContent = "Telefono";
    			t20 = space();
    			input3 = element("input");
    			t21 = space();
    			div11 = element("div");
    			div10 = element("div");
    			label4 = element("label");
    			label4.textContent = "Correo";
    			t23 = space();
    			input4 = element("input");
    			t24 = space();
    			div13 = element("div");
    			div12 = element("div");
    			label5 = element("label");
    			label5.textContent = "Direccion";
    			t26 = space();
    			input5 = element("input");
    			t27 = space();
    			div44 = element("div");
    			div43 = element("div");
    			div21 = element("div");
    			div20 = element("div");
    			strong = element("strong");
    			strong.textContent = "Configurcin";
    			t29 = space();
    			div42 = element("div");
    			div41 = element("div");
    			div23 = element("div");
    			div22 = element("div");
    			a0 = element("a");
    			i3 = element("i");
    			t30 = text(" Horarios de citas");
    			t31 = space();
    			a1 = element("a");
    			i4 = element("i");
    			t32 = text(" Historia Clinica");
    			t33 = space();
    			div40 = element("div");
    			div39 = element("div");
    			div33 = element("div");
    			div32 = element("div");
    			div25 = element("div");
    			div24 = element("div");
    			label6 = element("label");
    			input6 = element("input");
    			t34 = space();
    			span0 = element("span");
    			t35 = space();
    			span1 = element("span");
    			span1.textContent = "Historia\r\n                                                                    Ginecologica";
    			t37 = space();
    			div27 = element("div");
    			div26 = element("div");
    			label7 = element("label");
    			input7 = element("input");
    			t38 = space();
    			span2 = element("span");
    			t39 = space();
    			span3 = element("span");
    			span3.textContent = "Signos\r\n                                                                    Vitales";
    			t41 = space();
    			div29 = element("div");
    			div28 = element("div");
    			label8 = element("label");
    			input8 = element("input");
    			t42 = space();
    			span4 = element("span");
    			t43 = space();
    			span5 = element("span");
    			span5.textContent = "Otros\r\n                                                                    Parametros";
    			t45 = space();
    			div31 = element("div");
    			div30 = element("div");
    			label9 = element("label");
    			input9 = element("input");
    			t46 = space();
    			span6 = element("span");
    			t47 = space();
    			span7 = element("span");
    			span7.textContent = "Exploracin\r\n                                                                    Fisica";
    			t49 = space();
    			div38 = element("div");
    			div37 = element("div");
    			div35 = element("div");
    			div34 = element("div");
    			button1 = element("button");
    			i5 = element("i");
    			t50 = text(" AGREGAR HORARIO");
    			t51 = space();
    			div36 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Dia";
    			t53 = space();
    			th1 = element("th");
    			th1.textContent = "Tanda";
    			t55 = space();
    			th2 = element("th");
    			th2.textContent = "Cupos";
    			t57 = space();
    			th3 = element("th");
    			t58 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t59 = space();
    			br0 = element("br");
    			br1 = element("br");
    			t60 = space();
    			create_component(modalagregarhorario.$$.fragment);
    			attr_dev(i0, "class", "mdi mdi-content-save");
    			add_location(i0, file$A, 227, 12, 7138);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "btn m-b-15 ml-2 mr-2 btn-lg btn-rounded-circle btn-success");
    			set_style(button0, "position", "fixed");
    			set_style(button0, "bottom", "30px");
    			set_style(button0, "right", "30px");
    			set_style(button0, "z-index", "1000");
    			add_location(button0, file$A, 221, 8, 6882);
    			attr_dev(i1, "class", "mdi mdi-medical-bag");
    			add_location(i1, file$A, 233, 28, 7373);
    			add_location(h5, file$A, 233, 24, 7369);
    			attr_dev(div0, "class", "col-12 m-b-20 m-t-20");
    			add_location(div0, file$A, 232, 20, 7309);
    			attr_dev(h4, "class", "card-title");
    			add_location(h4, file$A, 238, 32, 7633);
    			attr_dev(div1, "class", "card-header");
    			add_location(div1, file$A, 237, 28, 7574);
    			if (img.src !== (img_src_value = /*logo*/ ctx[2])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "logo-emp svelte-1dl05vs");
    			attr_dev(img, "alt", "logo empresa");
    			add_location(img, file$A, 243, 40, 7921);
    			attr_dev(i2, "class", "mdi mdi-refresh");
    			add_location(i2, file$A, 253, 48, 8529);
    			attr_dev(label0, "class", "btn btn-primary btn-sm");
    			attr_dev(label0, "for", "inpSubirImagen");
    			add_location(label0, file$A, 249, 44, 8276);
    			set_style(input0, "display", "none");
    			attr_dev(input0, "type", "file");
    			attr_dev(input0, "id", "inpSubirImagen");
    			attr_dev(input0, "accept", "image/png, image/jpeg");
    			add_location(input0, file$A, 256, 44, 8722);
    			attr_dev(div2, "class", "col-12 text-center mt-2");
    			add_location(div2, file$A, 248, 40, 8193);
    			attr_dev(div3, "class", "col-lg-3");
    			add_location(div3, file$A, 242, 36, 7857);
    			attr_dev(label1, "for", "");
    			add_location(label1, file$A, 269, 52, 9548);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "form-control");
    			add_location(input1, file$A, 272, 52, 9754);
    			attr_dev(div4, "class", "form-group");
    			add_location(div4, file$A, 268, 48, 9470);
    			attr_dev(div5, "class", "col-lg-12");
    			add_location(div5, file$A, 267, 44, 9397);
    			attr_dev(label2, "for", "");
    			add_location(label2, file$A, 281, 52, 10353);
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "class", "form-control");
    			add_location(input2, file$A, 284, 52, 10555);
    			attr_dev(div6, "class", "form-group");
    			add_location(div6, file$A, 280, 48, 10275);
    			attr_dev(div7, "class", "col-lg-12");
    			add_location(div7, file$A, 279, 44, 10202);
    			attr_dev(label3, "for", "");
    			add_location(label3, file$A, 293, 52, 11161);
    			attr_dev(input3, "type", "tel");
    			attr_dev(input3, "class", "form-control");
    			add_location(input3, file$A, 296, 52, 11357);
    			attr_dev(div8, "class", "form-group");
    			add_location(div8, file$A, 292, 48, 11083);
    			attr_dev(div9, "class", "col-lg-6");
    			add_location(div9, file$A, 291, 44, 11011);
    			attr_dev(label4, "for", "");
    			add_location(label4, file$A, 305, 52, 11956);
    			attr_dev(input4, "type", "email");
    			attr_dev(input4, "class", "form-control");
    			add_location(input4, file$A, 306, 52, 12038);
    			attr_dev(div10, "class", "form-group");
    			add_location(div10, file$A, 304, 48, 11878);
    			attr_dev(div11, "class", "col-lg-6");
    			add_location(div11, file$A, 303, 44, 11806);
    			attr_dev(label5, "for", "");
    			add_location(label5, file$A, 315, 52, 12638);
    			attr_dev(input5, "type", "text");
    			attr_dev(input5, "class", "form-control");
    			add_location(input5, file$A, 318, 52, 12835);
    			attr_dev(div12, "class", "form-group");
    			add_location(div12, file$A, 314, 48, 12560);
    			attr_dev(div13, "class", "col-lg-12");
    			add_location(div13, file$A, 313, 44, 12487);
    			attr_dev(div14, "class", "row");
    			add_location(div14, file$A, 266, 40, 9334);
    			attr_dev(div15, "class", "col-lg-9");
    			add_location(div15, file$A, 265, 36, 9270);
    			attr_dev(div16, "class", "row");
    			add_location(div16, file$A, 241, 32, 7802);
    			attr_dev(div17, "class", "card-body");
    			add_location(div17, file$A, 240, 28, 7745);
    			attr_dev(div18, "class", "card m-b-30");
    			add_location(div18, file$A, 236, 24, 7519);
    			attr_dev(div19, "class", "col-12");
    			add_location(div19, file$A, 235, 20, 7473);
    			add_location(strong, file$A, 335, 36, 13715);
    			attr_dev(div20, "class", "card-title");
    			add_location(div20, file$A, 334, 32, 13653);
    			attr_dev(div21, "class", "card-header");
    			add_location(div21, file$A, 333, 28, 13594);
    			attr_dev(i3, "class", "mdi mdi-calendar-plus");
    			add_location(i3, file$A, 355, 49, 14950);
    			attr_dev(a0, "class", "nav-link active");
    			attr_dev(a0, "id", "v-pills-profile-tab");
    			attr_dev(a0, "data-toggle", "pill");
    			attr_dev(a0, "href", "#v-pills-profile");
    			attr_dev(a0, "role", "tab");
    			attr_dev(a0, "aria-controls", "v-pills-profile");
    			attr_dev(a0, "aria-selected", "false");
    			add_location(a0, file$A, 347, 44, 14397);
    			attr_dev(i4, "class", "mdi mdi-square-edit-outline");
    			add_location(i4, file$A, 367, 49, 15737);
    			attr_dev(a1, "class", "nav-link");
    			attr_dev(a1, "id", "v-pills-home-tab");
    			attr_dev(a1, "data-toggle", "pill");
    			attr_dev(a1, "href", "#v-pills-home");
    			attr_dev(a1, "role", "tab");
    			attr_dev(a1, "aria-controls", "v-pills-home");
    			attr_dev(a1, "aria-selected", "true");
    			add_location(a1, file$A, 359, 44, 15201);
    			attr_dev(div22, "class", "nav flex-column nav-pills");
    			attr_dev(div22, "id", "v-pills-tab");
    			attr_dev(div22, "role", "tablist");
    			attr_dev(div22, "aria-orientation", "vertical");
    			add_location(div22, file$A, 341, 40, 14030);
    			attr_dev(div23, "class", "col-3");
    			add_location(div23, file$A, 340, 36, 13969);
    			attr_dev(input6, "type", "checkbox");
    			attr_dev(input6, "name", "option");
    			input6.__value = "1";
    			input6.value = input6.__value;
    			attr_dev(input6, "class", "cstm-switch-input");
    			add_location(input6, file$A, 410, 64, 18520);
    			attr_dev(span0, "class", "cstm-switch-indicator bg-success ");
    			add_location(span0, file$A, 417, 64, 19115);
    			attr_dev(span1, "class", "cstm-switch-description");
    			add_location(span1, file$A, 420, 64, 19365);
    			attr_dev(label6, "class", "cstm-switch");
    			add_location(label6, file$A, 407, 60, 18300);
    			attr_dev(div24, "class", " m-b-10");
    			add_location(div24, file$A, 406, 56, 18217);
    			attr_dev(div25, "class", "col-12");
    			add_location(div25, file$A, 405, 52, 18139);
    			attr_dev(input7, "type", "checkbox");
    			attr_dev(input7, "name", "option");
    			input7.__value = "1";
    			input7.value = input7.__value;
    			attr_dev(input7, "class", "cstm-switch-input");
    			add_location(input7, file$A, 433, 64, 20334);
    			attr_dev(span2, "class", "cstm-switch-indicator bg-success ");
    			add_location(span2, file$A, 440, 64, 20922);
    			attr_dev(span3, "class", "cstm-switch-description");
    			add_location(span3, file$A, 443, 64, 21172);
    			attr_dev(label7, "class", "cstm-switch");
    			add_location(label7, file$A, 430, 60, 20114);
    			attr_dev(div26, "class", " m-b-10");
    			add_location(div26, file$A, 429, 56, 20031);
    			attr_dev(div27, "class", "col-12");
    			add_location(div27, file$A, 428, 52, 19953);
    			attr_dev(input8, "type", "checkbox");
    			attr_dev(input8, "name", "option");
    			input8.__value = "1";
    			input8.value = input8.__value;
    			attr_dev(input8, "class", "cstm-switch-input");
    			add_location(input8, file$A, 456, 64, 22134);
    			attr_dev(span4, "class", "cstm-switch-indicator bg-success ");
    			add_location(span4, file$A, 463, 64, 22724);
    			attr_dev(span5, "class", "cstm-switch-description");
    			add_location(span5, file$A, 466, 64, 22974);
    			attr_dev(label8, "class", "cstm-switch");
    			add_location(label8, file$A, 453, 60, 21914);
    			attr_dev(div28, "class", " m-b-10");
    			add_location(div28, file$A, 452, 56, 21831);
    			attr_dev(div29, "class", "col-12");
    			add_location(div29, file$A, 451, 52, 21753);
    			attr_dev(input9, "type", "checkbox");
    			attr_dev(input9, "name", "option");
    			input9.__value = "1";
    			input9.value = input9.__value;
    			attr_dev(input9, "class", "cstm-switch-input");
    			add_location(input9, file$A, 479, 64, 23938);
    			attr_dev(span6, "class", "cstm-switch-indicator bg-success ");
    			add_location(span6, file$A, 486, 64, 24530);
    			attr_dev(span7, "class", "cstm-switch-description");
    			add_location(span7, file$A, 489, 64, 24780);
    			attr_dev(label9, "class", "cstm-switch");
    			add_location(label9, file$A, 476, 60, 23718);
    			attr_dev(div30, "class", " m-b-10");
    			add_location(div30, file$A, 475, 56, 23635);
    			attr_dev(div31, "class", "col-12");
    			add_location(div31, file$A, 474, 52, 23557);
    			attr_dev(div32, "class", "row");
    			add_location(div32, file$A, 404, 48, 18068);
    			attr_dev(div33, "class", "tab-pane fade");
    			attr_dev(div33, "id", "v-pills-home");
    			attr_dev(div33, "role", "tabpanel");
    			attr_dev(div33, "aria-labelledby", "v-pills-home-tab");
    			add_location(div33, file$A, 398, 44, 17680);
    			attr_dev(i5, "class", "mdi mdi-plus");
    			add_location(i5, file$A, 512, 61, 26492);
    			attr_dev(button1, "class", "btn btn-outline-primary btn-sm mb-2");
    			attr_dev(button1, "data-toggle", "modal");
    			attr_dev(button1, "data-target", "#modalAgregarHorario");
    			add_location(button1, file$A, 508, 60, 26128);
    			attr_dev(div34, "class", "col-12 text-right");
    			add_location(div34, file$A, 507, 56, 26035);
    			attr_dev(div35, "class", "row");
    			add_location(div35, file$A, 506, 52, 25960);
    			add_location(th0, file$A, 519, 68, 27053);
    			add_location(th1, file$A, 520, 68, 27135);
    			add_location(th2, file$A, 521, 68, 27219);
    			add_location(th3, file$A, 522, 68, 27303);
    			add_location(tr, file$A, 518, 64, 26979);
    			add_location(thead, file$A, 517, 60, 26906);
    			add_location(tbody, file$A, 525, 60, 27515);
    			attr_dev(table, "class", "table table-hover");
    			add_location(table, file$A, 516, 56, 26811);
    			attr_dev(div36, "class", "table-responsive");
    			add_location(div36, file$A, 515, 52, 26723);
    			attr_dev(div37, "class", "col-lg-12 mt-3");
    			add_location(div37, file$A, 505, 48, 25878);
    			attr_dev(div38, "class", "tab-pane fade show active");
    			attr_dev(div38, "id", "v-pills-profile");
    			attr_dev(div38, "role", "tabpanel");
    			attr_dev(div38, "aria-labelledby", "v-pills-profile-tab");
    			add_location(div38, file$A, 499, 44, 25472);
    			attr_dev(div39, "class", "tab-content");
    			attr_dev(div39, "id", "v-pills-tabContent");
    			add_location(div39, file$A, 394, 40, 17453);
    			attr_dev(div40, "class", "col-9");
    			add_location(div40, file$A, 393, 36, 17392);
    			attr_dev(div41, "class", "row");
    			add_location(div41, file$A, 339, 32, 13914);
    			attr_dev(div42, "class", "card-body");
    			add_location(div42, file$A, 338, 28, 13857);
    			attr_dev(div43, "class", "card m-b-30");
    			add_location(div43, file$A, 332, 24, 13539);
    			attr_dev(div44, "class", "col-lg-12");
    			add_location(div44, file$A, 331, 20, 13490);
    			attr_dev(div45, "class", "row");
    			add_location(div45, file$A, 231, 16, 7270);
    			attr_dev(div46, "class", "col-12");
    			add_location(div46, file$A, 230, 12, 7232);
    			attr_dev(div47, "class", "p-2");
    			add_location(div47, file$A, 229, 8, 7201);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$A, 220, 4, 6841);
    			add_location(br0, file$A, 601, 14, 32978);
    			add_location(br1, file$A, 601, 18, 32982);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$A, 210, 0, 6629);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t2);
    			if (if_block1) if_block1.m(main, null);
    			append_dev(main, t3);
    			append_dev(main, section);
    			append_dev(section, button0);
    			append_dev(button0, i0);
    			append_dev(section, t4);
    			append_dev(section, div47);
    			append_dev(div47, div46);
    			append_dev(div46, div45);
    			append_dev(div45, div0);
    			append_dev(div0, h5);
    			append_dev(h5, i1);
    			append_dev(h5, t5);
    			append_dev(div45, t6);
    			append_dev(div45, div19);
    			append_dev(div19, div18);
    			append_dev(div18, div1);
    			append_dev(div1, h4);
    			append_dev(div18, t8);
    			append_dev(div18, div17);
    			append_dev(div17, div16);
    			append_dev(div16, div3);
    			append_dev(div3, img);
    			append_dev(div3, t9);
    			append_dev(div3, div2);
    			append_dev(div2, label0);
    			append_dev(label0, i2);
    			append_dev(label0, t10);
    			append_dev(div2, t11);
    			append_dev(div2, input0);
    			append_dev(div16, t12);
    			append_dev(div16, div15);
    			append_dev(div15, div14);
    			append_dev(div14, div5);
    			append_dev(div5, div4);
    			append_dev(div4, label1);
    			append_dev(div4, t14);
    			append_dev(div4, input1);
    			set_input_value(input1, /*empresa*/ ctx[1].nombre);
    			append_dev(div14, t15);
    			append_dev(div14, div7);
    			append_dev(div7, div6);
    			append_dev(div6, label2);
    			append_dev(div6, t17);
    			append_dev(div6, input2);
    			set_input_value(input2, /*empresa*/ ctx[1].especialidades);
    			append_dev(div14, t18);
    			append_dev(div14, div9);
    			append_dev(div9, div8);
    			append_dev(div8, label3);
    			append_dev(div8, t20);
    			append_dev(div8, input3);
    			set_input_value(input3, /*empresa*/ ctx[1].telefono);
    			append_dev(div14, t21);
    			append_dev(div14, div11);
    			append_dev(div11, div10);
    			append_dev(div10, label4);
    			append_dev(div10, t23);
    			append_dev(div10, input4);
    			set_input_value(input4, /*empresa*/ ctx[1].correo);
    			append_dev(div14, t24);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, label5);
    			append_dev(div12, t26);
    			append_dev(div12, input5);
    			set_input_value(input5, /*empresa*/ ctx[1].direccion);
    			append_dev(div45, t27);
    			append_dev(div45, div44);
    			append_dev(div44, div43);
    			append_dev(div43, div21);
    			append_dev(div21, div20);
    			append_dev(div20, strong);
    			append_dev(div43, t29);
    			append_dev(div43, div42);
    			append_dev(div42, div41);
    			append_dev(div41, div23);
    			append_dev(div23, div22);
    			append_dev(div22, a0);
    			append_dev(a0, i3);
    			append_dev(a0, t30);
    			append_dev(div22, t31);
    			append_dev(div22, a1);
    			append_dev(a1, i4);
    			append_dev(a1, t32);
    			append_dev(div41, t33);
    			append_dev(div41, div40);
    			append_dev(div40, div39);
    			append_dev(div39, div33);
    			append_dev(div33, div32);
    			append_dev(div32, div25);
    			append_dev(div25, div24);
    			append_dev(div24, label6);
    			append_dev(label6, input6);
    			input6.checked = /*empresa*/ ctx[1].historiaGinecologica;
    			append_dev(label6, t34);
    			append_dev(label6, span0);
    			append_dev(label6, t35);
    			append_dev(label6, span1);
    			append_dev(div32, t37);
    			append_dev(div32, div27);
    			append_dev(div27, div26);
    			append_dev(div26, label7);
    			append_dev(label7, input7);
    			input7.checked = /*empresa*/ ctx[1].signosVitales;
    			append_dev(label7, t38);
    			append_dev(label7, span2);
    			append_dev(label7, t39);
    			append_dev(label7, span3);
    			append_dev(div32, t41);
    			append_dev(div32, div29);
    			append_dev(div29, div28);
    			append_dev(div28, label8);
    			append_dev(label8, input8);
    			input8.checked = /*empresa*/ ctx[1].otrosParametros;
    			append_dev(label8, t42);
    			append_dev(label8, span4);
    			append_dev(label8, t43);
    			append_dev(label8, span5);
    			append_dev(div32, t45);
    			append_dev(div32, div31);
    			append_dev(div31, div30);
    			append_dev(div30, label9);
    			append_dev(label9, input9);
    			input9.checked = /*empresa*/ ctx[1].exploracionFisica;
    			append_dev(label9, t46);
    			append_dev(label9, span6);
    			append_dev(label9, t47);
    			append_dev(label9, span7);
    			append_dev(div39, t49);
    			append_dev(div39, div38);
    			append_dev(div38, div37);
    			append_dev(div37, div35);
    			append_dev(div35, div34);
    			append_dev(div34, button1);
    			append_dev(button1, i5);
    			append_dev(button1, t50);
    			append_dev(div37, t51);
    			append_dev(div37, div36);
    			append_dev(div36, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t53);
    			append_dev(tr, th1);
    			append_dev(tr, t55);
    			append_dev(tr, th2);
    			append_dev(tr, t57);
    			append_dev(tr, th3);
    			append_dev(table, t58);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(section, t59);
    			append_dev(main, br0);
    			append_dev(main, br1);
    			insert_dev(target, t60, anchor);
    			mount_component(modalagregarhorario, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*editarEmpresa*/ ctx[9], false, false, false),
    					listen_dev(input0, "change", /*cambiarImagenEmpresa*/ ctx[8], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[10]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[11]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[12]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[13]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[14]),
    					listen_dev(input6, "change", /*input6_change_handler*/ ctx[15]),
    					listen_dev(input7, "change", /*input7_change_handler*/ ctx[16]),
    					listen_dev(input8, "change", /*input8_change_handler*/ ctx[17]),
    					listen_dev(input9, "change", /*input9_change_handler*/ ctx[18])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*serverConexion*/ ctx[0]) {
    				if (if_block0) {
    					if (dirty & /*serverConexion*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$f(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(main, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*cargando*/ ctx[3]) {
    				if (if_block1) {
    					if (dirty & /*cargando*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$n(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(main, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*logo*/ 4 && img.src !== (img_src_value = /*logo*/ ctx[2])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*empresa*/ 2 && input1.value !== /*empresa*/ ctx[1].nombre) {
    				set_input_value(input1, /*empresa*/ ctx[1].nombre);
    			}

    			if (dirty & /*empresa*/ 2 && input2.value !== /*empresa*/ ctx[1].especialidades) {
    				set_input_value(input2, /*empresa*/ ctx[1].especialidades);
    			}

    			if (dirty & /*empresa*/ 2) {
    				set_input_value(input3, /*empresa*/ ctx[1].telefono);
    			}

    			if (dirty & /*empresa*/ 2 && input4.value !== /*empresa*/ ctx[1].correo) {
    				set_input_value(input4, /*empresa*/ ctx[1].correo);
    			}

    			if (dirty & /*empresa*/ 2 && input5.value !== /*empresa*/ ctx[1].direccion) {
    				set_input_value(input5, /*empresa*/ ctx[1].direccion);
    			}

    			if (dirty & /*empresa*/ 2) {
    				input6.checked = /*empresa*/ ctx[1].historiaGinecologica;
    			}

    			if (dirty & /*empresa*/ 2) {
    				input7.checked = /*empresa*/ ctx[1].signosVitales;
    			}

    			if (dirty & /*empresa*/ 2) {
    				input8.checked = /*empresa*/ ctx[1].otrosParametros;
    			}

    			if (dirty & /*empresa*/ 2) {
    				input9.checked = /*empresa*/ ctx[1].exploracionFisica;
    			}

    			if (dirty & /*eliminarHorario, horarios, dia*/ 112) {
    				each_value = /*horarios*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(modalagregarhorario.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(modalagregarhorario.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t60);
    			destroy_component(modalagregarhorario, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Detalle", slots, []);

    	const Toast = Swal.mixin({
    		toast: true,
    		position: "top-end",
    		showConfirmButton: false,
    		timer: 3000,
    		timerProgressBar: true,
    		didOpen: toast => {
    			toast.addEventListener("mouseenter", Swal.stopTimer);
    			toast.addEventListener("mouseleave", Swal.resumeTimer);
    		}
    	});

    	let errorServer = false;
    	let serverConexion = false;
    	let msgError = "";
    	let empresa = {};
    	let logo = "";
    	let avatar;
    	let cargando = false;

    	const dia = {
    		0: "Lunes",
    		1: "Martes",
    		2: "Miercoles",
    		3: "Jueves",
    		4: "Viernes",
    		5: "Sabado",
    		6: "Domingo"
    	};

    	let horarios = [];

    	const eliminarHorario = idHorario => {
    		const config = {
    			method: "delete",
    			url: `${url}/horarioscitas/${idHorario}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		Swal.fire({
    			title: "Estas seguro?",
    			text: "El horario se va a eliminar definitivamente, pero puedes volver a agregarlo con los cambios que desees!",
    			icon: "warning",
    			showCancelButton: true,
    			confirmButtonColor: "#3085d6",
    			cancelButtonColor: "#d33",
    			confirmButtonText: "Si, Eliminar!",
    			cancelButtonText: "Cancelar"
    		}).then(result => {
    			if (result.isConfirmed) {
    				axios$1(config).then(res => {
    					if (res.status === 200) {
    						Toast.fire({
    							icon: "success",
    							title: "Se ha eliminado el horario"
    						});

    						cargarHorariosCitas();
    					}
    				}).catch(err => {
    					console.error(err);
    				});
    			}
    		});
    	};

    	const cargarHorariosCitas = () => {
    		const config = {
    			method: "get",
    			url: `${url}/horarioscitas`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(4, horarios = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cambiarImagenEmpresa = e => {
    		let image = e.target.files[0];
    		const form = new FormData();
    		form.append("logo", image);

    		const config = {
    			method: "put",
    			url: `${url}/empresas/${user().empresa}/imagen`,
    			data: form,
    			headers: {
    				"Content-Type": "multipart/form-data",
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			if (res.status === 200) {
    				Toast.fire({
    					icon: "success",
    					title: "Se ha cambiado la imagen correctamente"
    				});

    				cargarEmpresa();
    			}
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const editarEmpresa = () => {
    		const data = {
    			nombre: empresa.nombre,
    			especialidades: empresa.especialidades,
    			telefono: empresa.telefono,
    			correo: empresa.correo,
    			direccion: empresa.direccion,
    			historiaGinecologica: empresa.historiaGinecologica,
    			signosVitales: empresa.signosVitales,
    			otrosParametros: empresa.otrosParametros,
    			exploracionFisica: empresa.exploracionFisica
    		};

    		const config = {
    			method: "put",
    			url: `${url}/empresas/${user().empresa}`,
    			data,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			if (res.status === 200) {
    				Toast.fire({
    					icon: "success",
    					title: "Empresa actualizada"
    				});

    				cargarEmpresa();
    			}
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarImagenEmpresa = (idConsultorio, idImagen) => {
    		const config = {
    			method: "get",
    			url: `${url}/imagenes/${idConsultorio}/${idImagen}`,
    			responseType: "blob",
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			return $$invalidate(2, logo = URL.createObjectURL(res.data));
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarEmpresa = () => {
    		$$invalidate(3, cargando = true);

    		const config = {
    			method: "get",
    			url: `${url}/empresas/${user().empresa}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(3, cargando = false);

    			if (res.status === 200) {
    				$$invalidate(1, empresa = res.data);
    				cargarImagenEmpresa(empresa.id, empresa.logo);
    			} else {
    				$$invalidate(0, serverConexion = true);
    			}
    		}).catch(err => {
    			$$invalidate(3, cargando = false);
    			$$invalidate(0, serverConexion = true);
    			console.error(err);
    		});
    	};

    	onMount(() => {
    		cargarEmpresa();
    		cargarHorariosCitas();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$k.warn(`<Detalle> was created with unknown prop '${key}'`);
    	});

    	function input1_input_handler() {
    		empresa.nombre = this.value;
    		$$invalidate(1, empresa);
    	}

    	function input2_input_handler() {
    		empresa.especialidades = this.value;
    		$$invalidate(1, empresa);
    	}

    	function input3_input_handler() {
    		empresa.telefono = this.value;
    		$$invalidate(1, empresa);
    	}

    	function input4_input_handler() {
    		empresa.correo = this.value;
    		$$invalidate(1, empresa);
    	}

    	function input5_input_handler() {
    		empresa.direccion = this.value;
    		$$invalidate(1, empresa);
    	}

    	function input6_change_handler() {
    		empresa.historiaGinecologica = this.checked;
    		$$invalidate(1, empresa);
    	}

    	function input7_change_handler() {
    		empresa.signosVitales = this.checked;
    		$$invalidate(1, empresa);
    	}

    	function input8_change_handler() {
    		empresa.otrosParametros = this.checked;
    		$$invalidate(1, empresa);
    	}

    	function input9_change_handler() {
    		empresa.exploracionFisica = this.checked;
    		$$invalidate(1, empresa);
    	}

    	const click_handler = horario => eliminarHorario(horario.id);

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		onMount,
    		url,
    		user,
    		Header,
    		Aside,
    		ErrorConexion,
    		NoConexion,
    		Loading,
    		ModalAgregarHorario,
    		Toast,
    		errorServer,
    		serverConexion,
    		msgError,
    		empresa,
    		logo,
    		avatar,
    		cargando,
    		dia,
    		horarios,
    		eliminarHorario,
    		cargarHorariosCitas,
    		cambiarImagenEmpresa,
    		editarEmpresa,
    		cargarImagenEmpresa,
    		cargarEmpresa
    	});

    	$$self.$inject_state = $$props => {
    		if ("errorServer" in $$props) errorServer = $$props.errorServer;
    		if ("serverConexion" in $$props) $$invalidate(0, serverConexion = $$props.serverConexion);
    		if ("msgError" in $$props) msgError = $$props.msgError;
    		if ("empresa" in $$props) $$invalidate(1, empresa = $$props.empresa);
    		if ("logo" in $$props) $$invalidate(2, logo = $$props.logo);
    		if ("avatar" in $$props) avatar = $$props.avatar;
    		if ("cargando" in $$props) $$invalidate(3, cargando = $$props.cargando);
    		if ("horarios" in $$props) $$invalidate(4, horarios = $$props.horarios);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		serverConexion,
    		empresa,
    		logo,
    		cargando,
    		horarios,
    		dia,
    		eliminarHorario,
    		cargarHorariosCitas,
    		cambiarImagenEmpresa,
    		editarEmpresa,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input5_input_handler,
    		input6_change_handler,
    		input7_change_handler,
    		input8_change_handler,
    		input9_change_handler,
    		click_handler
    	];
    }

    class Detalle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Detalle",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    var n$1,l,u,t$1,r$1,o$1,f,e$1={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function h(n){var l=n.parentNode;l&&l.removeChild(n);}function v(l,u,i){var t,r,o,f={};for(o in u)"key"==o?t=u[o]:"ref"==o?r=u[o]:f[o]=u[o];if(arguments.length>2&&(f.children=arguments.length>3?n$1.call(arguments,2):i),"function"==typeof l&&null!=l.defaultProps)for(o in l.defaultProps)void 0===f[o]&&(f[o]=l.defaultProps[o]);return y(l,f,t,r,null)}function y(n,i,t,r,o){var f={type:n,props:i,key:t,ref:r,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==o?++u:o};return null==o&&null!=l.vnode&&l.vnode(f),f}function p(){return {current:null}}function d(n){return n.children}function _(n,l){this.props=n,this.context=l;}function k(n,l){if(null==l)return n.__?k(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?k(n):null}function b(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return b(n)}}function m(n){(!n.__d&&(n.__d=!0)&&t$1.push(n)&&!g.__r++||o$1!==l.debounceRendering)&&((o$1=l.debounceRendering)||r$1)(g);}function g(){for(var n;g.__r=t$1.length;)n=t$1.sort(function(n,l){return n.__v.__b-l.__v.__b}),t$1=[],n.some(function(n){var l,u,i,t,r,o;n.__d&&(r=(t=(l=n).__v).__e,(o=l.__P)&&(u=[],(i=a({},t)).__v=t.__v+1,j(o,t,i,l.__n,void 0!==o.ownerSVGElement,null!=t.__h?[r]:null,u,null==r?k(t):r,t.__h),z(u,t),t.__e!=r&&b(t)));});}function w(n,l,u,i,t,r,o,f,s,a){var h,v,p,_,b,m,g,w=i&&i.__k||c,A=w.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(_=u.__k[h]=null==(_=l[h])||"boolean"==typeof _?null:"string"==typeof _||"number"==typeof _||"bigint"==typeof _?y(null,_,null,null,_):Array.isArray(_)?y(d,{children:_},null,null,null):_.__b>0?y(_.type,_.props,_.key,null,_.__v):_)){if(_.__=u,_.__b=u.__b+1,null===(p=w[h])||p&&_.key==p.key&&_.type===p.type)w[h]=void 0;else for(v=0;v<A;v++){if((p=w[v])&&_.key==p.key&&_.type===p.type){w[v]=void 0;break}p=null;}j(n,_,p=p||e$1,t,r,o,f,s,a),b=_.__e,(v=_.ref)&&p.ref!=v&&(g||(g=[]),p.ref&&g.push(p.ref,null,_),g.push(v,_.__c||b,_)),null!=b?(null==m&&(m=b),"function"==typeof _.type&&_.__k===p.__k?_.__d=s=x(_,s,n):s=P(n,_,p,w,b,s),"function"==typeof u.type&&(u.__d=s)):s&&p.__e==s&&s.parentNode!=n&&(s=k(p));}for(u.__e=m,h=A;h--;)null!=w[h]&&("function"==typeof u.type&&null!=w[h].__e&&w[h].__e==u.__d&&(u.__d=k(i,h+1)),N(w[h],w[h]));if(g)for(h=0;h<g.length;h++)M(g[h],g[++h],g[++h]);}function x(n,l,u){for(var i,t=n.__k,r=0;t&&r<t.length;r++)(i=t[r])&&(i.__=n,l="function"==typeof i.type?x(i,l,u):P(u,i,i,t,i.__e,l));return l}function A(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){A(n,l);}):l.push(n)),l}function P(n,l,u,i,t,r){var o,f,e;if(void 0!==l.__d)o=l.__d,l.__d=void 0;else if(null==u||t!=r||null==t.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(t),o=null;else {for(f=r,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,r),o=r;}return void 0!==o?o:t.nextSibling}function C(n,l,u,i,t){var r;for(r in u)"children"===r||"key"===r||r in l||H(n,r,null,u[r],i);for(r in l)t&&"function"!=typeof l[r]||"children"===r||"key"===r||"value"===r||"checked"===r||u[r]===l[r]||H(n,r,l[r],u[r],i);}function $(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||s.test(l)?u:u+"px";}function H(n,l,u,i,t){var r;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||$(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||$(n.style,l,u[l]);}else if("o"===l[0]&&"n"===l[1])r=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?i||n.addEventListener(l,r?T:I,r):n.removeEventListener(l,r?T:I,r);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink[H:h]/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null!=u&&(!1!==u||"a"===l[0]&&"r"===l[1])?n.setAttribute(l,u):n.removeAttribute(l));}}function I(n){this.l[n.type+!1](l.event?l.event(n):n);}function T(n){this.l[n.type+!0](l.event?l.event(n):n);}function j(n,u,i,t,r,o,f,e,c){var s,h,v,y,p,k,b,m,g,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,o=[e]),(s=l.__b)&&s(u);try{n:if("function"==typeof P){if(m=u.props,g=(s=P.contextType)&&t[s.__c],x=s?g?g.props.value:s.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:("prototype"in P&&P.prototype.render?u.__c=h=new P(m,x):(u.__c=h=new _(m,x),h.constructor=P,h.render=O),g&&g.sub(h),h.props=m,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=a({},h.__s)),a(h.__s,P.getDerivedStateFromProps(m,h.__s))),y=h.props,p=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else {if(null==P.getDerivedStateFromProps&&m!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,x)||u.__v===i.__v){h.props=m,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u);}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,p,k);});}h.context=x,h.props=m,h.state=h.__s,(s=l.__r)&&s(u),h.__d=!1,h.__v=u,h.__P=n,s=h.render(h.props,h.state,h.context),h.state=h.__s,null!=h.getChildContext&&(t=a(a({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,p)),A=null!=s&&s.type===d&&null==s.key?s.props.children:s,w(n,Array.isArray(A)?A:[A],u,i,t,r,o,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1;}else null==o&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L(i.__e,u,i,t,r,o,f,c);(s=l.diffed)&&s(u);}catch(n){u.__v=null,(c||null!=o)&&(u.__e=e,u.__h=!!c,o[o.indexOf(e)]=null),l.__e(n,u,i);}}function z(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u);});}catch(n){l.__e(n,u.__v);}});}function L(l,u,i,t,r,o,f,c){var s,a,v,y=i.props,p=u.props,d=u.type,_=0;if("svg"===d&&(r=!0),null!=o)for(;_<o.length;_++)if((s=o[_])&&(s===l||(d?s.localName==d:3==s.nodeType))){l=s,o[_]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=r?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,p.is&&p),o=null,c=!1;}if(null===d)y===p||c&&l.data===p||(l.data=p);else {if(o=o&&n$1.call(l.childNodes),a=(y=i.props||e$1).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=o)for(y={},_=0;_<l.attributes.length;_++)y[l.attributes[_].name]=l.attributes[_].value;(v||a)&&(v&&(a&&v.__html==a.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||""));}if(C(l,p,y,r,c),v)u.__k=[];else if(_=u.props.children,w(l,Array.isArray(_)?_:[_],u,i,t,r&&"foreignObject"!==d,o,f,o?o[0]:i.__k&&k(i,0),c),null!=o)for(_=o.length;_--;)null!=o[_]&&h(o[_]);c||("value"in p&&void 0!==(_=p.value)&&(_!==l.value||"progress"===d&&!_)&&H(l,"value",_,y.value,!1),"checked"in p&&void 0!==(_=p.checked)&&_!==l.checked&&H(l,"checked",_,y.checked,!1));}return l}function M(n,u,i){try{"function"==typeof n?n(u):n.current=u;}catch(n){l.__e(n,i);}}function N(n,u,i){var t,r;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount();}catch(n){l.__e(n,u);}t.base=t.__P=null;}if(t=n.__k)for(r=0;r<t.length;r++)t[r]&&N(t[r],u,"function"!=typeof n.type);i||null==n.__e||h(n.__e),n.__e=n.__d=void 0;}function O(n,l,u){return this.constructor(n,u)}function S(u,i,t){var r,o,f;l.__&&l.__(u,i),o=(r="function"==typeof t)?null:t&&t.__k||i.__k,f=[],j(i,u=(!r&&t||i).__k=v(d,null,[u]),o||e$1,e$1,void 0!==i.ownerSVGElement,!r&&t?[t]:o?null:i.firstChild?n$1.call(i.childNodes):null,f,!r&&t?t:o?o.__e:i.firstChild,r),z(f,u);}function D(n,l){var u={__c:l="__cC"+f++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(m);},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n);};}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n$1=c.slice,l={__e:function(n,l){for(var u,i,t;l=l.__;)if((u=l.__c)&&!u.__)try{if((i=u.constructor)&&null!=i.getDerivedStateFromError&&(u.setState(i.getDerivedStateFromError(n)),t=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),t=u.__d),t)return u.__E=u}catch(l){n=l;}throw n}},u=0,_.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=a({},this.state),"function"==typeof n&&(n=n(a({},u),this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),m(this));},_.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),m(this));},_.prototype.render=d,t$1=[],r$1="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,g.__r=0,f=0;

    var t$2,u$1,r$2,i$1=[],c$1=l.__b,f$1=l.__r,e$2=l.diffed,a$1=l.__c,v$1=l.unmount;function x$1(){i$1.forEach(function(t){if(t.__P)try{t.__H.__h.forEach(g$1),t.__H.__h.forEach(j$1),t.__H.__h=[];}catch(u){t.__H.__h=[],l.__e(u,t.__v);}}),i$1=[];}l.__b=function(n){u$1=null,c$1&&c$1(n);},l.__r=function(n){f$1&&f$1(n),t$2=0;var r=(u$1=n.__c).__H;r&&(r.__h.forEach(g$1),r.__h.forEach(j$1),r.__h=[]);},l.diffed=function(t){e$2&&e$2(t);var o=t.__c;o&&o.__H&&o.__H.__h.length&&(1!==i$1.push(o)&&r$2===l.requestAnimationFrame||((r$2=l.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),b$1&&cancelAnimationFrame(t),setTimeout(n);},r=setTimeout(u,100);b$1&&(t=requestAnimationFrame(u));})(x$1)),u$1=null;},l.__c=function(t,u){u.some(function(t){try{t.__h.forEach(g$1),t.__h=t.__h.filter(function(n){return !n.__||j$1(n)});}catch(r){u.some(function(n){n.__h&&(n.__h=[]);}),u=[],l.__e(r,t.__v);}}),a$1&&a$1(t,u);},l.unmount=function(t){v$1&&v$1(t);var u=t.__c;if(u&&u.__H)try{u.__H.__.forEach(g$1);}catch(t){l.__e(t,u.__v);}};var b$1="function"==typeof requestAnimationFrame;function g$1(n){var t=u$1;"function"==typeof n.__c&&n.__c(),u$1=t;}function j$1(n){var t=u$1;n.__c=n.__(),u$1=t;}

    function S$1(n,t){for(var e in t)n[e]=t[e];return n}function C$1(n,t){for(var e in n)if("__source"!==e&&!(e in t))return !0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return !0;return !1}function E(n){this.props=n;}(E.prototype=new _).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return C$1(this.props,n)||C$1(this.state,t)};var w$1=l.__b;l.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),w$1&&w$1(n);};var A$1=l.__e;l.__e=function(n,t,e){if(n.then)for(var r,u=t;u=u.__;)if((r=u.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t);A$1(n,t,e);};var O$1=l.unmount;function L$1(){this.__u=0,this.t=null,this.__b=null;}function U(n){var t=n.__.__c;return t&&t.__e&&t.__e(n)}function M$1(){this.u=null,this.o=null;}l.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),O$1&&O$1(n);},(L$1.prototype=new _).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=U(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l());};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__e){var n=r.state.__e;r.__v.__k[0]=function n(t,e,r){return t&&(t.__v=null,t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)}),t.__c&&t.__c.__P===e&&(t.__e&&r.insertBefore(t.__e,t.__d),t.__c.__e=!0,t.__c.__P=r)),t}(n,n.__c.__P,n.__c.__O);}var t;for(r.setState({__e:r.__b=null});t=r.t.pop();)t.forceUpdate();}},c=!0===t.__h;r.__u++||c||r.setState({__e:r.__b=r.__v.__k[0]}),n.then(i,i);},L$1.prototype.componentWillUnmount=function(){this.t=[];},L$1.prototype.render=function(n,t){if(this.__b){if(this.__v.__k){var e=document.createElement("div"),r=this.__v.__k[0].__c;this.__v.__k[0]=function n(t,e,r){return t&&(t.__c&&t.__c.__H&&(t.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c();}),t.__c.__H=null),null!=(t=S$1({},t)).__c&&(t.__c.__P===r&&(t.__c.__P=e),t.__c=null),t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)})),t}(this.__b,e,r.__O=r.__P);}this.__b=null;}var u=t.__e&&v(d,null,n.fallback);return u&&(u.__h=null),[v(d,null,t.__e?null:n.children),u]};var T$1=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2];}};function D$1(n){return this.getChildContext=function(){return n.context},n.children}function I$1(n){var t=this,e=n.i;t.componentWillUnmount=function(){S(null,t.l),t.l=null,t.i=null;},t.i&&t.i!==e&&t.componentWillUnmount(),n.__v?(t.l||(t.i=e,t.l={nodeType:1,parentNode:e,childNodes:[],appendChild:function(n){this.childNodes.push(n),t.i.appendChild(n);},insertBefore:function(n,e){this.childNodes.push(n),t.i.appendChild(n);},removeChild:function(n){this.childNodes.splice(this.childNodes.indexOf(n)>>>1,1),t.i.removeChild(n);}}),S(v(D$1,{context:t.context},n.__v),t.l)):t.l&&t.componentWillUnmount();}function W(n,t){return v(I$1,{__v:n,i:t})}(M$1.prototype=new _).__e=function(n){var t=this,e=U(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),T$1(t,n,r)):u();};e?e(o):o();}},M$1.prototype.render=function(n){this.u=null,this.o=new Map;var t=A(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},M$1.prototype.componentDidUpdate=M$1.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){T$1(n,e,t);});};var j$2="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,P$1=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,V="undefined"!=typeof document,z$1=function(n){return ("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};_.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(_.prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t});}});});var Z=l.event;function Y(){}function $$1(){return this.cancelBubble}function q(){return this.defaultPrevented}l.event=function(n){return Z&&(n=Z(n)),n.persist=Y,n.isPropagationStopped=$$1,n.isDefaultPrevented=q,n.nativeEvent=n};var G,J={configurable:!0,get:function(){return this.class}},K=l.vnode;l.vnode=function(n){var t=n.type,e=n.props,r=e;if("string"==typeof t){var u=-1===t.indexOf("-");for(var o in r={},e){var i=e[o];V&&"children"===o&&"noscript"===t||"value"===o&&"defaultValue"in e&&null==i||("defaultValue"===o&&"value"in e&&null==e.value?o="value":"download"===o&&!0===i?i="":/ondoubleclick/i.test(o)?o="ondblclick":/^onchange(textarea|input)/i.test(o+t)&&!z$1(e.type)?o="oninput":/^on(Ani|Tra|Tou|BeforeInp)/.test(o)?o=o.toLowerCase():u&&P$1.test(o)?o=o.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===i&&(i=void 0),r[o]=i);}"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=A(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value);})),"select"==t&&null!=r.defaultValue&&(r.value=A(e.children).forEach(function(n){n.props.selected=r.multiple?-1!=r.defaultValue.indexOf(n.props.value):r.defaultValue==n.props.value;})),n.props=r;}t&&e.class!=e.className&&(J.enumerable="className"in e,null!=e.className&&(r.class=e.className),Object.defineProperty(r,"className",J)),n.$$typeof=j$2,K&&K(n);};var Q=l.__r;l.__r=function(n){Q&&Q(n),G=n.__c;};

    var globalObj = typeof globalThis !== 'undefined' ? globalThis : window; // // TODO: streamline when killing IE11 support
    if (globalObj.FullCalendarVDom) {
        console.warn('FullCalendar VDOM already loaded');
    }
    else {
        globalObj.FullCalendarVDom = {
            Component: _,
            createElement: v,
            render: S,
            createRef: p,
            Fragment: d,
            createContext: createContext,
            createPortal: W,
            flushToDom: flushToDom,
            unmountComponentAtNode: unmountComponentAtNode,
        };
    }
    // HACKS...
    // TODO: lock version
    // TODO: link gh issues
    function flushToDom() {
        var oldDebounceRendering = l.debounceRendering; // orig
        var callbackQ = [];
        function execCallbackSync(callback) {
            callbackQ.push(callback);
        }
        l.debounceRendering = execCallbackSync;
        S(v(FakeComponent, {}), document.createElement('div'));
        while (callbackQ.length) {
            callbackQ.shift()();
        }
        l.debounceRendering = oldDebounceRendering;
    }
    var FakeComponent = /** @class */ (function (_super) {
        __extends(FakeComponent, _super);
        function FakeComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FakeComponent.prototype.render = function () { return v('div', {}); };
        FakeComponent.prototype.componentDidMount = function () { this.setState({}); };
        return FakeComponent;
    }(_));
    function createContext(defaultValue) {
        var ContextType = D(defaultValue);
        var origProvider = ContextType.Provider;
        ContextType.Provider = function () {
            var _this = this;
            var isNew = !this.getChildContext;
            var children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params
            if (isNew) {
                var subs_1 = [];
                this.shouldComponentUpdate = function (_props) {
                    if (_this.props.value !== _props.value) {
                        subs_1.forEach(function (c) {
                            c.context = _props.value;
                            c.forceUpdate();
                        });
                    }
                };
                this.sub = function (c) {
                    subs_1.push(c);
                    var old = c.componentWillUnmount;
                    c.componentWillUnmount = function () {
                        subs_1.splice(subs_1.indexOf(c), 1);
                        old && old.call(c);
                    };
                };
            }
            return children;
        };
        return ContextType;
    }
    function unmountComponentAtNode(node) {
        S(null, node);
    }

    var vdom = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    function styleInject(css, ref) {
      if ( ref === void 0 ) ref = {};
      var insertAt = ref.insertAt;

      if (!css || typeof document === 'undefined') { return; }

      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';

      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css_248z = "\n/* classes attached to <body> */\n/* TODO: make fc-event selector work when calender in shadow DOM */\n.fc-not-allowed,\n.fc-not-allowed .fc-event { /* override events' custom cursors */\n  cursor: not-allowed;\n}\n\n/* TODO: not attached to body. attached to specific els. move */\n.fc-unselectable {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  -webkit-touch-callout: none;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n.fc {\n  /* layout of immediate children */\n  display: flex;\n  flex-direction: column;\n\n  font-size: 1em\n}\n.fc,\n  .fc *,\n  .fc *:before,\n  .fc *:after {\n    box-sizing: border-box;\n  }\n.fc table {\n    border-collapse: collapse;\n    border-spacing: 0;\n    font-size: 1em; /* normalize cross-browser */\n  }\n.fc th {\n    text-align: center;\n  }\n.fc th,\n  .fc td {\n    vertical-align: top;\n    padding: 0;\n  }\n.fc a[data-navlink] {\n    cursor: pointer;\n  }\n.fc a[data-navlink]:hover {\n    text-decoration: underline;\n  }\n.fc-direction-ltr {\n  direction: ltr;\n  text-align: left;\n}\n.fc-direction-rtl {\n  direction: rtl;\n  text-align: right;\n}\n.fc-theme-standard td,\n  .fc-theme-standard th {\n    border: 1px solid #ddd;\n    border: 1px solid var(--fc-border-color, #ddd);\n  }\n/* for FF, which doesn't expand a 100% div within a table cell. use absolute positioning */\n/* inner-wrappers are responsible for being absolute */\n/* TODO: best place for this? */\n.fc-liquid-hack td,\n  .fc-liquid-hack th {\n    position: relative;\n  }\n\n@font-face {\n  font-family: 'fcicons';\n  src: url(\"data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\") format('truetype');\n  font-weight: normal;\n  font-style: normal;\n}\n\n.fc-icon {\n  /* added for fc */\n  display: inline-block;\n  width: 1em;\n  height: 1em;\n  text-align: center;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n\n  /* use !important to prevent issues with browser extensions that change fonts */\n  font-family: 'fcicons' !important;\n  speak: none;\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1;\n\n  /* Better Font Rendering =========== */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.fc-icon-chevron-left:before {\n  content: \"\\e900\";\n}\n\n.fc-icon-chevron-right:before {\n  content: \"\\e901\";\n}\n\n.fc-icon-chevrons-left:before {\n  content: \"\\e902\";\n}\n\n.fc-icon-chevrons-right:before {\n  content: \"\\e903\";\n}\n\n.fc-icon-minus-square:before {\n  content: \"\\e904\";\n}\n\n.fc-icon-plus-square:before {\n  content: \"\\e905\";\n}\n\n.fc-icon-x:before {\n  content: \"\\e906\";\n}\n/*\nLots taken from Flatly (MIT): https://bootswatch.com/4/flatly/bootstrap.css\n\nThese styles only apply when the standard-theme is activated.\nWhen it's NOT activated, the fc-button classes won't even be in the DOM.\n*/\n.fc {\n\n  /* reset */\n\n}\n.fc .fc-button {\n    border-radius: 0;\n    overflow: visible;\n    text-transform: none;\n    margin: 0;\n    font-family: inherit;\n    font-size: inherit;\n    line-height: inherit;\n  }\n.fc .fc-button:focus {\n    outline: 1px dotted;\n    outline: 5px auto -webkit-focus-ring-color;\n  }\n.fc .fc-button {\n    -webkit-appearance: button;\n  }\n.fc .fc-button:not(:disabled) {\n    cursor: pointer;\n  }\n.fc .fc-button::-moz-focus-inner {\n    padding: 0;\n    border-style: none;\n  }\n.fc {\n\n  /* theme */\n\n}\n.fc .fc-button {\n    display: inline-block;\n    font-weight: 400;\n    text-align: center;\n    vertical-align: middle;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    background-color: transparent;\n    border: 1px solid transparent;\n    padding: 0.4em 0.65em;\n    font-size: 1em;\n    line-height: 1.5;\n    border-radius: 0.25em;\n  }\n.fc .fc-button:hover {\n    text-decoration: none;\n  }\n.fc .fc-button:focus {\n    outline: 0;\n    box-shadow: 0 0 0 0.2rem rgba(44, 62, 80, 0.25);\n  }\n.fc .fc-button:disabled {\n    opacity: 0.65;\n  }\n.fc {\n\n  /* \"primary\" coloring */\n\n}\n.fc .fc-button-primary {\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #2C3E50;\n    background-color: var(--fc-button-bg-color, #2C3E50);\n    border-color: #2C3E50;\n    border-color: var(--fc-button-border-color, #2C3E50);\n  }\n.fc .fc-button-primary:hover {\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #1e2b37;\n    background-color: var(--fc-button-hover-bg-color, #1e2b37);\n    border-color: #1a252f;\n    border-color: var(--fc-button-hover-border-color, #1a252f);\n  }\n.fc .fc-button-primary:disabled { /* not DRY */\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #2C3E50;\n    background-color: var(--fc-button-bg-color, #2C3E50);\n    border-color: #2C3E50;\n    border-color: var(--fc-button-border-color, #2C3E50); /* overrides :hover */\n  }\n.fc .fc-button-primary:focus {\n    box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\n  }\n.fc .fc-button-primary:not(:disabled):active,\n  .fc .fc-button-primary:not(:disabled).fc-button-active {\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #1a252f;\n    background-color: var(--fc-button-active-bg-color, #1a252f);\n    border-color: #151e27;\n    border-color: var(--fc-button-active-border-color, #151e27);\n  }\n.fc .fc-button-primary:not(:disabled):active:focus,\n  .fc .fc-button-primary:not(:disabled).fc-button-active:focus {\n    box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\n  }\n.fc {\n\n  /* icons within buttons */\n\n}\n.fc .fc-button .fc-icon {\n    vertical-align: middle;\n    font-size: 1.5em; /* bump up the size (but don't make it bigger than line-height of button, which is 1.5em also) */\n  }\n.fc .fc-button-group {\n    position: relative;\n    display: inline-flex;\n    vertical-align: middle;\n  }\n.fc .fc-button-group > .fc-button {\n    position: relative;\n    flex: 1 1 auto;\n  }\n.fc .fc-button-group > .fc-button:hover {\n    z-index: 1;\n  }\n.fc .fc-button-group > .fc-button:focus,\n  .fc .fc-button-group > .fc-button:active,\n  .fc .fc-button-group > .fc-button.fc-button-active {\n    z-index: 1;\n  }\n.fc-direction-ltr .fc-button-group > .fc-button:not(:first-child) {\n    margin-left: -1px;\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n.fc-direction-ltr .fc-button-group > .fc-button:not(:last-child) {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n.fc-direction-rtl .fc-button-group > .fc-button:not(:first-child) {\n    margin-right: -1px;\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n.fc-direction-rtl .fc-button-group > .fc-button:not(:last-child) {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n.fc .fc-toolbar {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n.fc .fc-toolbar.fc-header-toolbar {\n    margin-bottom: 1.5em;\n  }\n.fc .fc-toolbar.fc-footer-toolbar {\n    margin-top: 1.5em;\n  }\n.fc .fc-toolbar-title {\n    font-size: 1.75em;\n    margin: 0;\n  }\n.fc-direction-ltr .fc-toolbar > * > :not(:first-child) {\n    margin-left: .75em; /* space between */\n  }\n.fc-direction-rtl .fc-toolbar > * > :not(:first-child) {\n    margin-right: .75em; /* space between */\n  }\n.fc-direction-rtl .fc-toolbar-ltr { /* when the toolbar-chunk positioning system is explicitly left-to-right */\n    flex-direction: row-reverse;\n  }\n.fc .fc-scroller {\n    -webkit-overflow-scrolling: touch;\n    position: relative; /* for abs-positioned elements within */\n  }\n.fc .fc-scroller-liquid {\n    height: 100%;\n  }\n.fc .fc-scroller-liquid-absolute {\n    position: absolute;\n    top: 0;\n    right: 0;\n    left: 0;\n    bottom: 0;\n  }\n.fc .fc-scroller-harness {\n    position: relative;\n    overflow: hidden;\n    direction: ltr;\n      /* hack for chrome computing the scroller's right/left wrong for rtl. undone below... */\n      /* TODO: demonstrate in codepen */\n  }\n.fc .fc-scroller-harness-liquid {\n    height: 100%;\n  }\n.fc-direction-rtl .fc-scroller-harness > .fc-scroller { /* undo above hack */\n    direction: rtl;\n  }\n.fc-theme-standard .fc-scrollgrid {\n    border: 1px solid #ddd;\n    border: 1px solid var(--fc-border-color, #ddd); /* bootstrap does this. match */\n  }\n.fc .fc-scrollgrid,\n    .fc .fc-scrollgrid table { /* all tables (self included) */\n      width: 100%; /* because tables don't normally do this */\n      table-layout: fixed;\n    }\n.fc .fc-scrollgrid table { /* inner tables */\n      border-top-style: hidden;\n      border-left-style: hidden;\n      border-right-style: hidden;\n    }\n.fc .fc-scrollgrid {\n\n    border-collapse: separate;\n    border-right-width: 0;\n    border-bottom-width: 0;\n\n  }\n.fc .fc-scrollgrid-liquid {\n    height: 100%;\n  }\n.fc .fc-scrollgrid-section { /* a <tr> */\n    height: 1px /* better than 0, for firefox */\n\n  }\n.fc .fc-scrollgrid-section > td {\n      height: 1px; /* needs a height so inner div within grow. better than 0, for firefox */\n    }\n.fc .fc-scrollgrid-section table {\n      height: 1px;\n        /* for most browsers, if a height isn't set on the table, can't do liquid-height within cells */\n        /* serves as a min-height. harmless */\n    }\n.fc .fc-scrollgrid-section-liquid > td {\n      height: 100%; /* better than `auto`, for firefox */\n    }\n.fc .fc-scrollgrid-section > * {\n    border-top-width: 0;\n    border-left-width: 0;\n  }\n.fc .fc-scrollgrid-section-header > *,\n  .fc .fc-scrollgrid-section-footer > * {\n    border-bottom-width: 0;\n  }\n.fc .fc-scrollgrid-section-body table,\n  .fc .fc-scrollgrid-section-footer table {\n    border-bottom-style: hidden; /* head keeps its bottom border tho */\n  }\n.fc {\n\n  /* stickiness */\n\n}\n.fc .fc-scrollgrid-section-sticky > * {\n    background: #fff;\n    background: var(--fc-page-bg-color, #fff);\n    position: sticky;\n    z-index: 3; /* TODO: var */\n    /* TODO: box-shadow when sticking */\n  }\n.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky > * {\n    top: 0; /* because border-sharing causes a gap at the top */\n      /* TODO: give safari -1. has bug */\n  }\n.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky > * {\n    bottom: 0; /* known bug: bottom-stickiness doesn't work in safari */\n  }\n.fc .fc-scrollgrid-sticky-shim { /* for horizontal scrollbar */\n    height: 1px; /* needs height to create scrollbars */\n    margin-bottom: -1px;\n  }\n.fc-sticky { /* no .fc wrap because used as child of body */\n  position: sticky;\n}\n.fc .fc-view-harness {\n    flex-grow: 1; /* because this harness is WITHIN the .fc's flexbox */\n    position: relative;\n  }\n.fc {\n\n  /* when the harness controls the height, make the view liquid */\n\n}\n.fc .fc-view-harness-active > .fc-view {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n.fc .fc-col-header-cell-cushion {\n    display: inline-block; /* x-browser for when sticky (when multi-tier header) */\n    padding: 2px 4px;\n  }\n.fc .fc-bg-event,\n  .fc .fc-non-business,\n  .fc .fc-highlight {\n    /* will always have a harness with position:relative/absolute, so absolutely expand */\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n  }\n.fc .fc-non-business {\n    background: rgba(215, 215, 215, 0.3);\n    background: var(--fc-non-business-color, rgba(215, 215, 215, 0.3));\n  }\n.fc .fc-bg-event {\n    background: rgb(143, 223, 130);\n    background: var(--fc-bg-event-color, rgb(143, 223, 130));\n    opacity: 0.3;\n    opacity: var(--fc-bg-event-opacity, 0.3)\n  }\n.fc .fc-bg-event .fc-event-title {\n      margin: .5em;\n      font-size: .85em;\n      font-size: var(--fc-small-font-size, .85em);\n      font-style: italic;\n    }\n.fc .fc-highlight {\n    background: rgba(188, 232, 241, 0.3);\n    background: var(--fc-highlight-color, rgba(188, 232, 241, 0.3));\n  }\n.fc .fc-cell-shaded,\n  .fc .fc-day-disabled {\n    background: rgba(208, 208, 208, 0.3);\n    background: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n  }\n/* link resets */\n/* ---------------------------------------------------------------------------------------------------- */\na.fc-event,\na.fc-event:hover {\n  text-decoration: none;\n}\n/* cursor */\n.fc-event[href],\n.fc-event.fc-event-draggable {\n  cursor: pointer;\n}\n/* event text content */\n/* ---------------------------------------------------------------------------------------------------- */\n.fc-event .fc-event-main {\n    position: relative;\n    z-index: 2;\n  }\n/* dragging */\n/* ---------------------------------------------------------------------------------------------------- */\n.fc-event-dragging:not(.fc-event-selected) { /* MOUSE */\n    opacity: 0.75;\n  }\n.fc-event-dragging.fc-event-selected { /* TOUCH */\n    box-shadow: 0 2px 7px rgba(0, 0, 0, 0.3);\n  }\n/* resizing */\n/* ---------------------------------------------------------------------------------------------------- */\n/* (subclasses should hone positioning for touch and non-touch) */\n.fc-event .fc-event-resizer {\n    display: none;\n    position: absolute;\n    z-index: 4;\n  }\n.fc-event:hover, /* MOUSE */\n.fc-event-selected { /* TOUCH */\n\n}\n.fc-event:hover .fc-event-resizer, .fc-event-selected .fc-event-resizer {\n    display: block;\n  }\n.fc-event-selected .fc-event-resizer {\n    border-radius: 4px;\n    border-radius: calc(var(--fc-event-resizer-dot-total-width, 8px) / 2);\n    border-width: 1px;\n    border-width: var(--fc-event-resizer-dot-border-width, 1px);\n    width: 8px;\n    width: var(--fc-event-resizer-dot-total-width, 8px);\n    height: 8px;\n    height: var(--fc-event-resizer-dot-total-width, 8px);\n    border-style: solid;\n    border-color: inherit;\n    background: #fff;\n    background: var(--fc-page-bg-color, #fff)\n\n    /* expand hit area */\n\n  }\n.fc-event-selected .fc-event-resizer:before {\n      content: '';\n      position: absolute;\n      top: -20px;\n      left: -20px;\n      right: -20px;\n      bottom: -20px;\n    }\n/* selecting (always TOUCH) */\n/* OR, focused by tab-index */\n/* (TODO: maybe not the best focus-styling for .fc-daygrid-dot-event) */\n/* ---------------------------------------------------------------------------------------------------- */\n.fc-event-selected,\n.fc-event:focus {\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2)\n\n  /* expand hit area (subclasses should expand) */\n\n}\n.fc-event-selected:before, .fc-event:focus:before {\n    content: \"\";\n    position: absolute;\n    z-index: 3;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n  }\n.fc-event-selected,\n.fc-event:focus {\n\n  /* dimmer effect */\n\n}\n.fc-event-selected:after, .fc-event:focus:after {\n    content: \"\";\n    background: rgba(0, 0, 0, 0.25);\n    background: var(--fc-event-selected-overlay-color, rgba(0, 0, 0, 0.25));\n    position: absolute;\n    z-index: 1;\n\n    /* assume there's a border on all sides. overcome it. */\n    /* sometimes there's NOT a border, in which case the dimmer will go over */\n    /* an adjacent border, which looks fine. */\n    top: -1px;\n    left: -1px;\n    right: -1px;\n    bottom: -1px;\n  }\n/*\nA HORIZONTAL event\n*/\n.fc-h-event { /* allowed to be top-level */\n  display: block;\n  border: 1px solid #3788d8;\n  border: 1px solid var(--fc-event-border-color, #3788d8);\n  background-color: #3788d8;\n  background-color: var(--fc-event-bg-color, #3788d8)\n\n}\n.fc-h-event .fc-event-main {\n    color: #fff;\n    color: var(--fc-event-text-color, #fff);\n  }\n.fc-h-event .fc-event-main-frame {\n    display: flex; /* for make fc-event-title-container expand */\n  }\n.fc-h-event .fc-event-time {\n    max-width: 100%; /* clip overflow on this element */\n    overflow: hidden;\n  }\n.fc-h-event .fc-event-title-container { /* serves as a container for the sticky cushion */\n    flex-grow: 1;\n    flex-shrink: 1;\n    min-width: 0; /* important for allowing to shrink all the way */\n  }\n.fc-h-event .fc-event-title {\n    display: inline-block; /* need this to be sticky cross-browser */\n    vertical-align: top; /* for not messing up line-height */\n    left: 0;  /* for sticky */\n    right: 0; /* for sticky */\n    max-width: 100%; /* clip overflow on this element */\n    overflow: hidden;\n  }\n.fc-h-event.fc-event-selected:before {\n    /* expand hit area */\n    top: -10px;\n    bottom: -10px;\n  }\n/* adjust border and border-radius (if there is any) for non-start/end */\n.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),\n.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-left-width: 0;\n}\n.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),\n.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-right-width: 0;\n}\n/* resizers */\n.fc-h-event:not(.fc-event-selected) .fc-event-resizer {\n  top: 0;\n  bottom: 0;\n  width: 8px;\n  width: var(--fc-event-resizer-thickness, 8px);\n}\n.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,\n.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end {\n  cursor: w-resize;\n  left: -4px;\n  left: calc(-0.5 * var(--fc-event-resizer-thickness, 8px));\n}\n.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,\n.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start {\n  cursor: e-resize;\n  right: -4px;\n  right: calc(-0.5 * var(--fc-event-resizer-thickness, 8px));\n}\n/* resizers for TOUCH */\n.fc-h-event.fc-event-selected .fc-event-resizer {\n  top: 50%;\n  margin-top: -4px;\n  margin-top: calc(-0.5 * var(--fc-event-resizer-dot-total-width, 8px));\n}\n.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,\n.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end {\n  left: -4px;\n  left: calc(-0.5 * var(--fc-event-resizer-dot-total-width, 8px));\n}\n.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,\n.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start {\n  right: -4px;\n  right: calc(-0.5 * var(--fc-event-resizer-dot-total-width, 8px));\n}\n.fc .fc-popover {\n    position: absolute;\n    z-index: 9999;\n    box-shadow: 0 2px 6px rgba(0,0,0,.15);\n  }\n.fc .fc-popover-header {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    padding: 3px 4px;\n  }\n.fc .fc-popover-title {\n    margin: 0 2px;\n  }\n.fc .fc-popover-close {\n    cursor: pointer;\n    opacity: 0.65;\n    font-size: 1.1em;\n  }\n.fc-theme-standard .fc-popover {\n    border: 1px solid #ddd;\n    border: 1px solid var(--fc-border-color, #ddd);\n    background: #fff;\n    background: var(--fc-page-bg-color, #fff);\n  }\n.fc-theme-standard .fc-popover-header {\n    background: rgba(208, 208, 208, 0.3);\n    background: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n  }\n";
    styleInject(css_248z);

    /// <reference types="@fullcalendar/core-preact" />
    if (typeof FullCalendarVDom === 'undefined') {
        throw new Error('Please import the top-level fullcalendar lib before attempting to import a plugin.');
    }
    var Component = FullCalendarVDom.Component;
    var createElement = FullCalendarVDom.createElement;
    var render = FullCalendarVDom.render;
    var createRef = FullCalendarVDom.createRef;
    var Fragment = FullCalendarVDom.Fragment;
    var createContext$1 = FullCalendarVDom.createContext;
    var createPortal = FullCalendarVDom.createPortal;
    var flushToDom$1 = FullCalendarVDom.flushToDom;
    var unmountComponentAtNode$1 = FullCalendarVDom.unmountComponentAtNode;

    /*!
    FullCalendar v5.10.1
    Docs & License: https://fullcalendar.io/
    (c) 2021 Adam Shaw
    */

    // no public types yet. when there are, export from:
    // import {} from './api-type-deps'
    var EventSourceApi = /** @class */ (function () {
        function EventSourceApi(context, internalEventSource) {
            this.context = context;
            this.internalEventSource = internalEventSource;
        }
        EventSourceApi.prototype.remove = function () {
            this.context.dispatch({
                type: 'REMOVE_EVENT_SOURCE',
                sourceId: this.internalEventSource.sourceId,
            });
        };
        EventSourceApi.prototype.refetch = function () {
            this.context.dispatch({
                type: 'FETCH_EVENT_SOURCES',
                sourceIds: [this.internalEventSource.sourceId],
                isRefetch: true,
            });
        };
        Object.defineProperty(EventSourceApi.prototype, "id", {
            get: function () {
                return this.internalEventSource.publicId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventSourceApi.prototype, "url", {
            get: function () {
                return this.internalEventSource.meta.url;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventSourceApi.prototype, "format", {
            get: function () {
                return this.internalEventSource.meta.format; // TODO: bad. not guaranteed
            },
            enumerable: false,
            configurable: true
        });
        return EventSourceApi;
    }());

    function removeElement(el) {
        if (el.parentNode) {
            el.parentNode.removeChild(el);
        }
    }
    // Querying
    // ----------------------------------------------------------------------------------------------------------------
    function elementClosest(el, selector) {
        if (el.closest) {
            return el.closest(selector);
            // really bad fallback for IE
            // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
        }
        if (!document.documentElement.contains(el)) {
            return null;
        }
        do {
            if (elementMatches(el, selector)) {
                return el;
            }
            el = (el.parentElement || el.parentNode);
        } while (el !== null && el.nodeType === 1);
        return null;
    }
    function elementMatches(el, selector) {
        var method = el.matches || el.matchesSelector || el.msMatchesSelector;
        return method.call(el, selector);
    }
    // accepts multiple subject els
    // returns a real array. good for methods like forEach
    // TODO: accept the document
    function findElements(container, selector) {
        var containers = container instanceof HTMLElement ? [container] : container;
        var allMatches = [];
        for (var i = 0; i < containers.length; i += 1) {
            var matches = containers[i].querySelectorAll(selector);
            for (var j = 0; j < matches.length; j += 1) {
                allMatches.push(matches[j]);
            }
        }
        return allMatches;
    }
    // Style
    // ----------------------------------------------------------------------------------------------------------------
    var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
    function applyStyle(el, props) {
        for (var propName in props) {
            applyStyleProp(el, propName, props[propName]);
        }
    }
    function applyStyleProp(el, name, val) {
        if (val == null) {
            el.style[name] = '';
        }
        else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {
            el.style[name] = val + "px";
        }
        else {
            el.style[name] = val;
        }
    }
    // Event Handling
    // ----------------------------------------------------------------------------------------------------------------
    // if intercepting bubbled events at the document/window/body level,
    // and want to see originating element (the 'target'), use this util instead
    // of `ev.target` because it goes within web-component boundaries.
    function getEventTargetViaRoot(ev) {
        var _a, _b;
        return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
    }
    // Shadow DOM consuderations
    // ----------------------------------------------------------------------------------------------------------------
    function getElRoot(el) {
        return el.getRootNode ? el.getRootNode() : document;
    }
    // Unique ID for DOM attribute
    var guid$1 = 0;
    function getUniqueDomId() {
        guid$1 += 1;
        return 'fc-dom-' + guid$1;
    }

    // Stops a mouse/touch event from doing it's native browser action
    function preventDefault(ev) {
        ev.preventDefault();
    }
    // Event Delegation
    // ----------------------------------------------------------------------------------------------------------------
    function buildDelegationHandler(selector, handler) {
        return function (ev) {
            var matchedChild = elementClosest(ev.target, selector);
            if (matchedChild) {
                handler.call(matchedChild, ev, matchedChild);
            }
        };
    }
    function listenBySelector(container, eventType, selector, handler) {
        var attachedHandler = buildDelegationHandler(selector, handler);
        container.addEventListener(eventType, attachedHandler);
        return function () {
            container.removeEventListener(eventType, attachedHandler);
        };
    }
    function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
        var currentMatchedChild;
        return listenBySelector(container, 'mouseover', selector, function (mouseOverEv, matchedChild) {
            if (matchedChild !== currentMatchedChild) {
                currentMatchedChild = matchedChild;
                onMouseEnter(mouseOverEv, matchedChild);
                var realOnMouseLeave_1 = function (mouseLeaveEv) {
                    currentMatchedChild = null;
                    onMouseLeave(mouseLeaveEv, matchedChild);
                    matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);
                };
                // listen to the next mouseleave, and then unattach
                matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);
            }
        });
    }
    // Animation
    // ----------------------------------------------------------------------------------------------------------------
    var transitionEventNames = [
        'webkitTransitionEnd',
        'otransitionend',
        'oTransitionEnd',
        'msTransitionEnd',
        'transitionend',
    ];
    // triggered only when the next single subsequent transition finishes
    function whenTransitionDone(el, callback) {
        var realCallback = function (ev) {
            callback(ev);
            transitionEventNames.forEach(function (eventName) {
                el.removeEventListener(eventName, realCallback);
            });
        };
        transitionEventNames.forEach(function (eventName) {
            el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes
        });
    }
    // ARIA workarounds
    // ----------------------------------------------------------------------------------------------------------------
    function createAriaClickAttrs(handler) {
        return __assign({ onClick: handler }, createAriaKeyboardAttrs(handler));
    }
    function createAriaKeyboardAttrs(handler) {
        return {
            tabIndex: 0,
            onKeyDown: function (ev) {
                if (ev.key === 'Enter' || ev.key === ' ') {
                    handler(ev);
                    ev.preventDefault(); // if space, don't scroll down page
                }
            },
        };
    }

    var guidNumber = 0;
    function guid() {
        guidNumber += 1;
        return String(guidNumber);
    }
    /* FullCalendar-specific DOM Utilities
    ----------------------------------------------------------------------------------------------------------------------*/
    // Make the mouse cursor express that an event is not allowed in the current area
    function disableCursor() {
        document.body.classList.add('fc-not-allowed');
    }
    // Returns the mouse cursor to its original look
    function enableCursor() {
        document.body.classList.remove('fc-not-allowed');
    }
    /* Selection
    ----------------------------------------------------------------------------------------------------------------------*/
    function preventSelection(el) {
        el.classList.add('fc-unselectable');
        el.addEventListener('selectstart', preventDefault);
    }
    function allowSelection(el) {
        el.classList.remove('fc-unselectable');
        el.removeEventListener('selectstart', preventDefault);
    }
    /* Context Menu
    ----------------------------------------------------------------------------------------------------------------------*/
    function preventContextMenu(el) {
        el.addEventListener('contextmenu', preventDefault);
    }
    function allowContextMenu(el) {
        el.removeEventListener('contextmenu', preventDefault);
    }
    function parseFieldSpecs(input) {
        var specs = [];
        var tokens = [];
        var i;
        var token;
        if (typeof input === 'string') {
            tokens = input.split(/\s*,\s*/);
        }
        else if (typeof input === 'function') {
            tokens = [input];
        }
        else if (Array.isArray(input)) {
            tokens = input;
        }
        for (i = 0; i < tokens.length; i += 1) {
            token = tokens[i];
            if (typeof token === 'string') {
                specs.push(token.charAt(0) === '-' ?
                    { field: token.substring(1), order: -1 } :
                    { field: token, order: 1 });
            }
            else if (typeof token === 'function') {
                specs.push({ func: token });
            }
        }
        return specs;
    }
    function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
        var i;
        var cmp;
        for (i = 0; i < fieldSpecs.length; i += 1) {
            cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);
            if (cmp) {
                return cmp;
            }
        }
        return 0;
    }
    function compareByFieldSpec(obj0, obj1, fieldSpec) {
        if (fieldSpec.func) {
            return fieldSpec.func(obj0, obj1);
        }
        return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field])
            * (fieldSpec.order || 1);
    }
    function flexibleCompare(a, b) {
        if (!a && !b) {
            return 0;
        }
        if (b == null) {
            return -1;
        }
        if (a == null) {
            return 1;
        }
        if (typeof a === 'string' || typeof b === 'string') {
            return String(a).localeCompare(String(b));
        }
        return a - b;
    }
    /* String Utilities
    ----------------------------------------------------------------------------------------------------------------------*/
    function padStart(val, len) {
        var s = String(val);
        return '000'.substr(0, len - s.length) + s;
    }
    function formatWithOrdinals(formatter, args, fallbackText) {
        if (typeof formatter === 'function') {
            return formatter.apply(void 0, args);
        }
        if (typeof formatter === 'string') { // non-blank string
            return args.reduce(function (str, arg, index) { return (str.replace('$' + index, arg || '')); }, formatter);
        }
        return fallbackText;
    }
    /* Number Utilities
    ----------------------------------------------------------------------------------------------------------------------*/
    function compareNumbers(a, b) {
        return a - b;
    }
    function isInt(n) {
        return n % 1 === 0;
    }
    /* FC-specific DOM dimension stuff
    ----------------------------------------------------------------------------------------------------------------------*/
    function computeSmallestCellWidth(cellEl) {
        var allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');
        var contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');
        if (!allWidthEl) {
            throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const
        }
        if (!contentWidthEl) {
            throw new Error('needs fc-scrollgrid-shrink-cushion className');
        }
        return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border
            contentWidthEl.getBoundingClientRect().width;
    }

    var DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
    // Adding
    function addWeeks(m, n) {
        var a = dateToUtcArray(m);
        a[2] += n * 7;
        return arrayToUtcDate(a);
    }
    function addDays(m, n) {
        var a = dateToUtcArray(m);
        a[2] += n;
        return arrayToUtcDate(a);
    }
    function addMs(m, n) {
        var a = dateToUtcArray(m);
        a[6] += n;
        return arrayToUtcDate(a);
    }
    // Diffing (all return floats)
    // TODO: why not use ranges?
    function diffWeeks(m0, m1) {
        return diffDays(m0, m1) / 7;
    }
    function diffDays(m0, m1) {
        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);
    }
    function diffHours(m0, m1) {
        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);
    }
    function diffMinutes(m0, m1) {
        return (m1.valueOf() - m0.valueOf()) / (1000 * 60);
    }
    function diffSeconds(m0, m1) {
        return (m1.valueOf() - m0.valueOf()) / 1000;
    }
    function diffDayAndTime(m0, m1) {
        var m0day = startOfDay$1(m0);
        var m1day = startOfDay$1(m1);
        return {
            years: 0,
            months: 0,
            days: Math.round(diffDays(m0day, m1day)),
            milliseconds: (m1.valueOf() - m1day.valueOf()) - (m0.valueOf() - m0day.valueOf()),
        };
    }
    // Diffing Whole Units
    function diffWholeWeeks(m0, m1) {
        var d = diffWholeDays(m0, m1);
        if (d !== null && d % 7 === 0) {
            return d / 7;
        }
        return null;
    }
    function diffWholeDays(m0, m1) {
        if (timeAsMs(m0) === timeAsMs(m1)) {
            return Math.round(diffDays(m0, m1));
        }
        return null;
    }
    // Start-Of
    function startOfDay$1(m) {
        return arrayToUtcDate([
            m.getUTCFullYear(),
            m.getUTCMonth(),
            m.getUTCDate(),
        ]);
    }
    function startOfHour(m) {
        return arrayToUtcDate([
            m.getUTCFullYear(),
            m.getUTCMonth(),
            m.getUTCDate(),
            m.getUTCHours(),
        ]);
    }
    function startOfMinute(m) {
        return arrayToUtcDate([
            m.getUTCFullYear(),
            m.getUTCMonth(),
            m.getUTCDate(),
            m.getUTCHours(),
            m.getUTCMinutes(),
        ]);
    }
    function startOfSecond(m) {
        return arrayToUtcDate([
            m.getUTCFullYear(),
            m.getUTCMonth(),
            m.getUTCDate(),
            m.getUTCHours(),
            m.getUTCMinutes(),
            m.getUTCSeconds(),
        ]);
    }
    // Week Computation
    function weekOfYear(marker, dow, doy) {
        var y = marker.getUTCFullYear();
        var w = weekOfGivenYear(marker, y, dow, doy);
        if (w < 1) {
            return weekOfGivenYear(marker, y - 1, dow, doy);
        }
        var nextW = weekOfGivenYear(marker, y + 1, dow, doy);
        if (nextW >= 1) {
            return Math.min(w, nextW);
        }
        return w;
    }
    function weekOfGivenYear(marker, year, dow, doy) {
        var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
        var dayStart = startOfDay$1(marker);
        var days = Math.round(diffDays(firstWeekStart, dayStart));
        return Math.floor(days / 7) + 1; // zero-indexed
    }
    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        var fwd = 7 + dow - doy;
        // first-week day local weekday -- which local weekday is fwd
        var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
    }
    // Array Conversion
    function dateToLocalArray(date) {
        return [
            date.getFullYear(),
            date.getMonth(),
            date.getDate(),
            date.getHours(),
            date.getMinutes(),
            date.getSeconds(),
            date.getMilliseconds(),
        ];
    }
    function arrayToLocalDate(a) {
        return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month
        a[3] || 0, a[4] || 0, a[5] || 0);
    }
    function dateToUtcArray(date) {
        return [
            date.getUTCFullYear(),
            date.getUTCMonth(),
            date.getUTCDate(),
            date.getUTCHours(),
            date.getUTCMinutes(),
            date.getUTCSeconds(),
            date.getUTCMilliseconds(),
        ];
    }
    function arrayToUtcDate(a) {
        // according to web standards (and Safari), a month index is required.
        // massage if only given a year.
        if (a.length === 1) {
            a = a.concat([0]);
        }
        return new Date(Date.UTC.apply(Date, a));
    }
    // Other Utils
    function isValidDate(m) {
        return !isNaN(m.valueOf());
    }
    function timeAsMs(m) {
        return m.getUTCHours() * 1000 * 60 * 60 +
            m.getUTCMinutes() * 1000 * 60 +
            m.getUTCSeconds() * 1000 +
            m.getUTCMilliseconds();
    }

    function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
        return {
            instanceId: guid(),
            defId: defId,
            range: range,
            forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
            forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo,
        };
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty;
    // Merges an array of objects into a single object.
    // The second argument allows for an array of property names who's object values will be merged together.
    function mergeProps(propObjs, complexPropsMap) {
        var dest = {};
        if (complexPropsMap) {
            for (var name_1 in complexPropsMap) {
                var complexObjs = [];
                // collect the trailing object values, stopping when a non-object is discovered
                for (var i = propObjs.length - 1; i >= 0; i -= 1) {
                    var val = propObjs[i][name_1];
                    if (typeof val === 'object' && val) { // non-null object
                        complexObjs.unshift(val);
                    }
                    else if (val !== undefined) {
                        dest[name_1] = val; // if there were no objects, this value will be used
                        break;
                    }
                }
                // if the trailing values were objects, use the merged value
                if (complexObjs.length) {
                    dest[name_1] = mergeProps(complexObjs);
                }
            }
        }
        // copy values into the destination, going from last to first
        for (var i = propObjs.length - 1; i >= 0; i -= 1) {
            var props = propObjs[i];
            for (var name_2 in props) {
                if (!(name_2 in dest)) { // if already assigned by previous props or complex props, don't reassign
                    dest[name_2] = props[name_2];
                }
            }
        }
        return dest;
    }
    function filterHash(hash, func) {
        var filtered = {};
        for (var key in hash) {
            if (func(hash[key], key)) {
                filtered[key] = hash[key];
            }
        }
        return filtered;
    }
    function mapHash(hash, func) {
        var newHash = {};
        for (var key in hash) {
            newHash[key] = func(hash[key], key);
        }
        return newHash;
    }
    function arrayToHash(a) {
        var hash = {};
        for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
            var item = a_1[_i];
            hash[item] = true;
        }
        return hash;
    }
    function hashValuesToArray(obj) {
        var a = [];
        for (var key in obj) {
            a.push(obj[key]);
        }
        return a;
    }
    function isPropsEqual(obj0, obj1) {
        if (obj0 === obj1) {
            return true;
        }
        for (var key in obj0) {
            if (hasOwnProperty.call(obj0, key)) {
                if (!(key in obj1)) {
                    return false;
                }
            }
        }
        for (var key in obj1) {
            if (hasOwnProperty.call(obj1, key)) {
                if (obj0[key] !== obj1[key]) {
                    return false;
                }
            }
        }
        return true;
    }
    function getUnequalProps(obj0, obj1) {
        var keys = [];
        for (var key in obj0) {
            if (hasOwnProperty.call(obj0, key)) {
                if (!(key in obj1)) {
                    keys.push(key);
                }
            }
        }
        for (var key in obj1) {
            if (hasOwnProperty.call(obj1, key)) {
                if (obj0[key] !== obj1[key]) {
                    keys.push(key);
                }
            }
        }
        return keys;
    }
    function compareObjs(oldProps, newProps, equalityFuncs) {
        if (equalityFuncs === void 0) { equalityFuncs = {}; }
        if (oldProps === newProps) {
            return true;
        }
        for (var key in newProps) {
            if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;
            else {
                return false;
            }
        }
        // check for props that were omitted in the new
        for (var key in oldProps) {
            if (!(key in newProps)) {
                return false;
            }
        }
        return true;
    }
    /*
    assumed "true" equality for handler names like "onReceiveSomething"
    */
    function isObjValsEqual(val0, val1, comparator) {
        if (val0 === val1 || comparator === true) {
            return true;
        }
        if (comparator) {
            return comparator(val0, val1);
        }
        return false;
    }
    function collectFromHash(hash, startIndex, endIndex, step) {
        if (startIndex === void 0) { startIndex = 0; }
        if (step === void 0) { step = 1; }
        var res = [];
        if (endIndex == null) {
            endIndex = Object.keys(hash).length;
        }
        for (var i = startIndex; i < endIndex; i += step) {
            var val = hash[i];
            if (val !== undefined) { // will disregard undefined for sparse arrays
                res.push(val);
            }
        }
        return res;
    }

    function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
        for (var i = 0; i < recurringTypes.length; i += 1) {
            var parsed = recurringTypes[i].parse(refined, dateEnv);
            if (parsed) {
                var allDay = refined.allDay;
                if (allDay == null) {
                    allDay = defaultAllDay;
                    if (allDay == null) {
                        allDay = parsed.allDayGuess;
                        if (allDay == null) {
                            allDay = false;
                        }
                    }
                }
                return {
                    allDay: allDay,
                    duration: parsed.duration,
                    typeData: parsed.typeData,
                    typeId: i,
                };
            }
        }
        return null;
    }
    function expandRecurring(eventStore, framingRange, context) {
        var dateEnv = context.dateEnv, pluginHooks = context.pluginHooks, options = context.options;
        var defs = eventStore.defs, instances = eventStore.instances;
        // remove existing recurring instances
        // TODO: bad. always expand events as a second step
        instances = filterHash(instances, function (instance) { return !defs[instance.defId].recurringDef; });
        for (var defId in defs) {
            var def = defs[defId];
            if (def.recurringDef) {
                var duration = def.recurringDef.duration;
                if (!duration) {
                    duration = def.allDay ?
                        options.defaultAllDayEventDuration :
                        options.defaultTimedEventDuration;
                }
                var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);
                for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {
                    var start = starts_1[_i];
                    var instance = createEventInstance(defId, {
                        start: start,
                        end: dateEnv.add(start, duration),
                    });
                    instances[instance.instanceId] = instance;
                }
            }
        }
        return { defs: defs, instances: instances };
    }
    /*
    Event MUST have a recurringDef
    */
    function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
        var typeDef = recurringTypes[eventDef.recurringDef.typeId];
        var markers = typeDef.expand(eventDef.recurringDef.typeData, {
            start: dateEnv.subtract(framingRange.start, duration),
            end: framingRange.end,
        }, dateEnv);
        // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to
        if (eventDef.allDay) {
            markers = markers.map(startOfDay$1);
        }
        return markers;
    }
    var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
    // Parsing and Creation
    function createDuration(input, unit) {
        var _a;
        if (typeof input === 'string') {
            return parseString(input);
        }
        if (typeof input === 'object' && input) { // non-null object
            return parseObject(input);
        }
        if (typeof input === 'number') {
            return parseObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));
        }
        return null;
    }
    function parseString(s) {
        var m = PARSE_RE.exec(s);
        if (m) {
            var sign = m[1] ? -1 : 1;
            return {
                years: 0,
                months: 0,
                days: sign * (m[2] ? parseInt(m[2], 10) : 0),
                milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours
                    (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes
                    (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds
                    (m[6] ? parseInt(m[6], 10) : 0) // ms
                ),
            };
        }
        return null;
    }
    function parseObject(obj) {
        var duration = {
            years: obj.years || obj.year || 0,
            months: obj.months || obj.month || 0,
            days: obj.days || obj.day || 0,
            milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours
                (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes
                (obj.seconds || obj.second || 0) * 1000 + // seconds
                (obj.milliseconds || obj.millisecond || obj.ms || 0), // ms
        };
        var weeks = obj.weeks || obj.week;
        if (weeks) {
            duration.days += weeks * 7;
            duration.specifiedWeeks = true;
        }
        return duration;
    }
    // Equality
    function durationsEqual(d0, d1) {
        return d0.years === d1.years &&
            d0.months === d1.months &&
            d0.days === d1.days &&
            d0.milliseconds === d1.milliseconds;
    }
    function subtractDurations(d1, d0) {
        return {
            years: d1.years - d0.years,
            months: d1.months - d0.months,
            days: d1.days - d0.days,
            milliseconds: d1.milliseconds - d0.milliseconds,
        };
    }
    // Conversions
    // "Rough" because they are based on average-case Gregorian months/years
    function asRoughYears(dur) {
        return asRoughDays(dur) / 365;
    }
    function asRoughMonths(dur) {
        return asRoughDays(dur) / 30;
    }
    function asRoughDays(dur) {
        return asRoughMs(dur) / 864e5;
    }
    function asRoughMs(dur) {
        return dur.years * (365 * 864e5) +
            dur.months * (30 * 864e5) +
            dur.days * 864e5 +
            dur.milliseconds;
    }
    function greatestDurationDenominator(dur) {
        var ms = dur.milliseconds;
        if (ms) {
            if (ms % 1000 !== 0) {
                return { unit: 'millisecond', value: ms };
            }
            if (ms % (1000 * 60) !== 0) {
                return { unit: 'second', value: ms / 1000 };
            }
            if (ms % (1000 * 60 * 60) !== 0) {
                return { unit: 'minute', value: ms / (1000 * 60) };
            }
            if (ms) {
                return { unit: 'hour', value: ms / (1000 * 60 * 60) };
            }
        }
        if (dur.days) {
            if (dur.specifiedWeeks && dur.days % 7 === 0) {
                return { unit: 'week', value: dur.days / 7 };
            }
            return { unit: 'day', value: dur.days };
        }
        if (dur.months) {
            return { unit: 'month', value: dur.months };
        }
        if (dur.years) {
            return { unit: 'year', value: dur.years };
        }
        return { unit: 'millisecond', value: 0 };
    }

    // timeZoneOffset is in minutes
    function buildIsoString(marker, timeZoneOffset, stripZeroTime) {
        if (stripZeroTime === void 0) { stripZeroTime = false; }
        var s = marker.toISOString();
        s = s.replace('.000', '');
        if (stripZeroTime) {
            s = s.replace('T00:00:00Z', '');
        }
        if (s.length > 10) { // time part wasn't stripped, can add timezone info
            if (timeZoneOffset == null) {
                s = s.replace('Z', '');
            }
            else if (timeZoneOffset !== 0) {
                s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));
            }
            // otherwise, its UTC-0 and we want to keep the Z
        }
        return s;
    }
    // formats the date, but with no time part
    // TODO: somehow merge with buildIsoString and stripZeroTime
    // TODO: rename. omit "string"
    function formatDayString(marker) {
        return marker.toISOString().replace(/T.*$/, '');
    }
    function formatTimeZoneOffset(minutes, doIso) {
        if (doIso === void 0) { doIso = false; }
        var sign = minutes < 0 ? '-' : '+';
        var abs = Math.abs(minutes);
        var hours = Math.floor(abs / 60);
        var mins = Math.round(abs % 60);
        if (doIso) {
            return sign + padStart(hours, 2) + ":" + padStart(mins, 2);
        }
        return "GMT" + sign + hours + (mins ? ":" + padStart(mins, 2) : '');
    }
    function isArraysEqual(a0, a1, equalityFunc) {
        if (a0 === a1) {
            return true;
        }
        var len = a0.length;
        var i;
        if (len !== a1.length) { // not array? or not same length?
            return false;
        }
        for (i = 0; i < len; i += 1) {
            if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {
                return false;
            }
        }
        return true;
    }

    function memoize(workerFunc, resEquality, teardownFunc) {
        var currentArgs;
        var currentRes;
        return function () {
            var newArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newArgs[_i] = arguments[_i];
            }
            if (!currentArgs) {
                currentRes = workerFunc.apply(this, newArgs);
            }
            else if (!isArraysEqual(currentArgs, newArgs)) {
                if (teardownFunc) {
                    teardownFunc(currentRes);
                }
                var res = workerFunc.apply(this, newArgs);
                if (!resEquality || !resEquality(res, currentRes)) {
                    currentRes = res;
                }
            }
            currentArgs = newArgs;
            return currentRes;
        };
    }
    function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
        var _this = this;
        var currentArg;
        var currentRes;
        return function (newArg) {
            if (!currentArg) {
                currentRes = workerFunc.call(_this, newArg);
            }
            else if (!isPropsEqual(currentArg, newArg)) {
                if (teardownFunc) {
                    teardownFunc(currentRes);
                }
                var res = workerFunc.call(_this, newArg);
                if (!resEquality || !resEquality(res, currentRes)) {
                    currentRes = res;
                }
            }
            currentArg = newArg;
            return currentRes;
        };
    }

    var EXTENDED_SETTINGS_AND_SEVERITIES = {
        week: 3,
        separator: 0,
        omitZeroMinute: 0,
        meridiem: 0,
        omitCommas: 0,
    };
    var STANDARD_DATE_PROP_SEVERITIES = {
        timeZoneName: 7,
        era: 6,
        year: 5,
        month: 4,
        day: 2,
        weekday: 2,
        hour: 1,
        minute: 1,
        second: 1,
    };
    var MERIDIEM_RE = /\s*([ap])\.?m\.?/i; // eats up leading spaces too
    var COMMA_RE = /,/g; // we need re for globalness
    var MULTI_SPACE_RE = /\s+/g;
    var LTR_RE = /\u200e/g; // control character
    var UTC_RE = /UTC|GMT/;
    var NativeFormatter = /** @class */ (function () {
        function NativeFormatter(formatSettings) {
            var standardDateProps = {};
            var extendedSettings = {};
            var severity = 0;
            for (var name_1 in formatSettings) {
                if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {
                    extendedSettings[name_1] = formatSettings[name_1];
                    severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);
                }
                else {
                    standardDateProps[name_1] = formatSettings[name_1];
                    if (name_1 in STANDARD_DATE_PROP_SEVERITIES) { // TODO: what about hour12? no severity
                        severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);
                    }
                }
            }
            this.standardDateProps = standardDateProps;
            this.extendedSettings = extendedSettings;
            this.severity = severity;
            this.buildFormattingFunc = memoize(buildFormattingFunc);
        }
        NativeFormatter.prototype.format = function (date, context) {
            return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
        };
        NativeFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {
            var _a = this, standardDateProps = _a.standardDateProps, extendedSettings = _a.extendedSettings;
            var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);
            if (!diffSeverity) {
                return this.format(start, context);
            }
            var biggestUnitForPartial = diffSeverity;
            if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time
                (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') &&
                (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') &&
                (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {
                biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time
            }
            var full0 = this.format(start, context);
            var full1 = this.format(end, context);
            if (full0 === full1) {
                return full0;
            }
            var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
            var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
            var partial0 = partialFormattingFunc(start);
            var partial1 = partialFormattingFunc(end);
            var insertion = findCommonInsertion(full0, partial0, full1, partial1);
            var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';
            if (insertion) {
                return insertion.before + partial0 + separator + partial1 + insertion.after;
            }
            return full0 + separator + full1;
        };
        NativeFormatter.prototype.getLargestUnit = function () {
            switch (this.severity) {
                case 7:
                case 6:
                case 5:
                    return 'year';
                case 4:
                    return 'month';
                case 3:
                    return 'week';
                case 2:
                    return 'day';
                default:
                    return 'time'; // really?
            }
        };
        return NativeFormatter;
    }());
    function buildFormattingFunc(standardDateProps, extendedSettings, context) {
        var standardDatePropCnt = Object.keys(standardDateProps).length;
        if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {
            return function (date) { return (formatTimeZoneOffset(date.timeZoneOffset)); };
        }
        if (standardDatePropCnt === 0 && extendedSettings.week) {
            return function (date) { return (formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week)); };
        }
        return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
    }
    function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
        standardDateProps = __assign({}, standardDateProps); // copy
        extendedSettings = __assign({}, extendedSettings); // copy
        sanitizeSettings(standardDateProps, extendedSettings);
        standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers
        var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
        var zeroFormat; // needed?
        if (extendedSettings.omitZeroMinute) {
            var zeroProps = __assign({}, standardDateProps);
            delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings
            zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
        }
        return function (date) {
            var marker = date.marker;
            var format;
            if (zeroFormat && !marker.getUTCMinutes()) {
                format = zeroFormat;
            }
            else {
                format = normalFormat;
            }
            var s = format.format(marker);
            return postProcess(s, date, standardDateProps, extendedSettings, context);
        };
    }
    function sanitizeSettings(standardDateProps, extendedSettings) {
        // deal with a browser inconsistency where formatting the timezone
        // requires that the hour/minute be present.
        if (standardDateProps.timeZoneName) {
            if (!standardDateProps.hour) {
                standardDateProps.hour = '2-digit';
            }
            if (!standardDateProps.minute) {
                standardDateProps.minute = '2-digit';
            }
        }
        // only support short timezone names
        if (standardDateProps.timeZoneName === 'long') {
            standardDateProps.timeZoneName = 'short';
        }
        // if requesting to display seconds, MUST display minutes
        if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
            delete extendedSettings.omitZeroMinute;
        }
    }
    function postProcess(s, date, standardDateProps, extendedSettings, context) {
        s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes
        if (standardDateProps.timeZoneName === 'short') {
            s = injectTzoStr(s, (context.timeZone === 'UTC' || date.timeZoneOffset == null) ?
                'UTC' : // important to normalize for IE, which does "GMT"
                formatTimeZoneOffset(date.timeZoneOffset));
        }
        if (extendedSettings.omitCommas) {
            s = s.replace(COMMA_RE, '').trim();
        }
        if (extendedSettings.omitZeroMinute) {
            s = s.replace(':00', ''); // zeroFormat doesn't always achieve this
        }
        // ^ do anything that might create adjacent spaces before this point,
        // because MERIDIEM_RE likes to eat up loading spaces
        if (extendedSettings.meridiem === false) {
            s = s.replace(MERIDIEM_RE, '').trim();
        }
        else if (extendedSettings.meridiem === 'narrow') { // a/p
            s = s.replace(MERIDIEM_RE, function (m0, m1) { return m1.toLocaleLowerCase(); });
        }
        else if (extendedSettings.meridiem === 'short') { // am/pm
            s = s.replace(MERIDIEM_RE, function (m0, m1) { return m1.toLocaleLowerCase() + "m"; });
        }
        else if (extendedSettings.meridiem === 'lowercase') { // other meridiem transformers already converted to lowercase
            s = s.replace(MERIDIEM_RE, function (m0) { return m0.toLocaleLowerCase(); });
        }
        s = s.replace(MULTI_SPACE_RE, ' ');
        s = s.trim();
        return s;
    }
    function injectTzoStr(s, tzoStr) {
        var replaced = false;
        s = s.replace(UTC_RE, function () {
            replaced = true;
            return tzoStr;
        });
        // IE11 doesn't include UTC/GMT in the original string, so append to end
        if (!replaced) {
            s += " " + tzoStr;
        }
        return s;
    }
    function formatWeekNumber(num, weekText, weekTextLong, locale, display) {
        var parts = [];
        if (display === 'long') {
            parts.push(weekTextLong);
        }
        else if (display === 'short' || display === 'narrow') {
            parts.push(weekText);
        }
        if (display === 'long' || display === 'short') {
            parts.push(' ');
        }
        parts.push(locale.simpleNumberFormat.format(num));
        if (locale.options.direction === 'rtl') { // TODO: use control characters instead?
            parts.reverse();
        }
        return parts.join('');
    }
    // Range Formatting Utils
    // 0 = exactly the same
    // 1 = different by time
    // and bigger
    function computeMarkerDiffSeverity(d0, d1, ca) {
        if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
            return 5;
        }
        if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
            return 4;
        }
        if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
            return 2;
        }
        if (timeAsMs(d0) !== timeAsMs(d1)) {
            return 1;
        }
        return 0;
    }
    function computePartialFormattingOptions(options, biggestUnit) {
        var partialOptions = {};
        for (var name_2 in options) {
            if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
                STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {
                partialOptions[name_2] = options[name_2];
            }
        }
        return partialOptions;
    }
    function findCommonInsertion(full0, partial0, full1, partial1) {
        var i0 = 0;
        while (i0 < full0.length) {
            var found0 = full0.indexOf(partial0, i0);
            if (found0 === -1) {
                break;
            }
            var before0 = full0.substr(0, found0);
            i0 = found0 + partial0.length;
            var after0 = full0.substr(i0);
            var i1 = 0;
            while (i1 < full1.length) {
                var found1 = full1.indexOf(partial1, i1);
                if (found1 === -1) {
                    break;
                }
                var before1 = full1.substr(0, found1);
                i1 = found1 + partial1.length;
                var after1 = full1.substr(i1);
                if (before0 === before1 && after0 === after1) {
                    return {
                        before: before0,
                        after: after0,
                    };
                }
            }
        }
        return null;
    }

    function expandZonedMarker(dateInfo, calendarSystem) {
        var a = calendarSystem.markerToArray(dateInfo.marker);
        return {
            marker: dateInfo.marker,
            timeZoneOffset: dateInfo.timeZoneOffset,
            array: a,
            year: a[0],
            month: a[1],
            day: a[2],
            hour: a[3],
            minute: a[4],
            second: a[5],
            millisecond: a[6],
        };
    }

    function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {
        var startInfo = expandZonedMarker(start, context.calendarSystem);
        var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
        return {
            date: startInfo,
            start: startInfo,
            end: endInfo,
            timeZone: context.timeZone,
            localeCodes: context.locale.codes,
            defaultSeparator: betterDefaultSeparator || context.defaultSeparator,
        };
    }

    /*
    TODO: fix the terminology of "formatter" vs "formatting func"
    */
    /*
    At the time of instantiation, this object does not know which cmd-formatting system it will use.
    It receives this at the time of formatting, as a setting.
    */
    var CmdFormatter = /** @class */ (function () {
        function CmdFormatter(cmdStr) {
            this.cmdStr = cmdStr;
        }
        CmdFormatter.prototype.format = function (date, context, betterDefaultSeparator) {
            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
        };
        CmdFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {
            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
        };
        return CmdFormatter;
    }());

    var FuncFormatter = /** @class */ (function () {
        function FuncFormatter(func) {
            this.func = func;
        }
        FuncFormatter.prototype.format = function (date, context, betterDefaultSeparator) {
            return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
        };
        FuncFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {
            return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
        };
        return FuncFormatter;
    }());

    function createFormatter(input) {
        if (typeof input === 'object' && input) { // non-null object
            return new NativeFormatter(input);
        }
        if (typeof input === 'string') {
            return new CmdFormatter(input);
        }
        if (typeof input === 'function') {
            return new FuncFormatter(input);
        }
        return null;
    }

    // base options
    // ------------
    var BASE_OPTION_REFINERS = {
        navLinkDayClick: identity$1,
        navLinkWeekClick: identity$1,
        duration: createDuration,
        bootstrapFontAwesome: identity$1,
        buttonIcons: identity$1,
        customButtons: identity$1,
        defaultAllDayEventDuration: createDuration,
        defaultTimedEventDuration: createDuration,
        nextDayThreshold: createDuration,
        scrollTime: createDuration,
        scrollTimeReset: Boolean,
        slotMinTime: createDuration,
        slotMaxTime: createDuration,
        dayPopoverFormat: createFormatter,
        slotDuration: createDuration,
        snapDuration: createDuration,
        headerToolbar: identity$1,
        footerToolbar: identity$1,
        defaultRangeSeparator: String,
        titleRangeSeparator: String,
        forceEventDuration: Boolean,
        dayHeaders: Boolean,
        dayHeaderFormat: createFormatter,
        dayHeaderClassNames: identity$1,
        dayHeaderContent: identity$1,
        dayHeaderDidMount: identity$1,
        dayHeaderWillUnmount: identity$1,
        dayCellClassNames: identity$1,
        dayCellContent: identity$1,
        dayCellDidMount: identity$1,
        dayCellWillUnmount: identity$1,
        initialView: String,
        aspectRatio: Number,
        weekends: Boolean,
        weekNumberCalculation: identity$1,
        weekNumbers: Boolean,
        weekNumberClassNames: identity$1,
        weekNumberContent: identity$1,
        weekNumberDidMount: identity$1,
        weekNumberWillUnmount: identity$1,
        editable: Boolean,
        viewClassNames: identity$1,
        viewDidMount: identity$1,
        viewWillUnmount: identity$1,
        nowIndicator: Boolean,
        nowIndicatorClassNames: identity$1,
        nowIndicatorContent: identity$1,
        nowIndicatorDidMount: identity$1,
        nowIndicatorWillUnmount: identity$1,
        showNonCurrentDates: Boolean,
        lazyFetching: Boolean,
        startParam: String,
        endParam: String,
        timeZoneParam: String,
        timeZone: String,
        locales: identity$1,
        locale: identity$1,
        themeSystem: String,
        dragRevertDuration: Number,
        dragScroll: Boolean,
        allDayMaintainDuration: Boolean,
        unselectAuto: Boolean,
        dropAccept: identity$1,
        eventOrder: parseFieldSpecs,
        eventOrderStrict: Boolean,
        handleWindowResize: Boolean,
        windowResizeDelay: Number,
        longPressDelay: Number,
        eventDragMinDistance: Number,
        expandRows: Boolean,
        height: identity$1,
        contentHeight: identity$1,
        direction: String,
        weekNumberFormat: createFormatter,
        eventResizableFromStart: Boolean,
        displayEventTime: Boolean,
        displayEventEnd: Boolean,
        weekText: String,
        weekTextLong: String,
        progressiveEventRendering: Boolean,
        businessHours: identity$1,
        initialDate: identity$1,
        now: identity$1,
        eventDataTransform: identity$1,
        stickyHeaderDates: identity$1,
        stickyFooterScrollbar: identity$1,
        viewHeight: identity$1,
        defaultAllDay: Boolean,
        eventSourceFailure: identity$1,
        eventSourceSuccess: identity$1,
        eventDisplay: String,
        eventStartEditable: Boolean,
        eventDurationEditable: Boolean,
        eventOverlap: identity$1,
        eventConstraint: identity$1,
        eventAllow: identity$1,
        eventBackgroundColor: String,
        eventBorderColor: String,
        eventTextColor: String,
        eventColor: String,
        eventClassNames: identity$1,
        eventContent: identity$1,
        eventDidMount: identity$1,
        eventWillUnmount: identity$1,
        selectConstraint: identity$1,
        selectOverlap: identity$1,
        selectAllow: identity$1,
        droppable: Boolean,
        unselectCancel: String,
        slotLabelFormat: identity$1,
        slotLaneClassNames: identity$1,
        slotLaneContent: identity$1,
        slotLaneDidMount: identity$1,
        slotLaneWillUnmount: identity$1,
        slotLabelClassNames: identity$1,
        slotLabelContent: identity$1,
        slotLabelDidMount: identity$1,
        slotLabelWillUnmount: identity$1,
        dayMaxEvents: identity$1,
        dayMaxEventRows: identity$1,
        dayMinWidth: Number,
        slotLabelInterval: createDuration,
        allDayText: String,
        allDayClassNames: identity$1,
        allDayContent: identity$1,
        allDayDidMount: identity$1,
        allDayWillUnmount: identity$1,
        slotMinWidth: Number,
        navLinks: Boolean,
        eventTimeFormat: createFormatter,
        rerenderDelay: Number,
        moreLinkText: identity$1,
        moreLinkHint: identity$1,
        selectMinDistance: Number,
        selectable: Boolean,
        selectLongPressDelay: Number,
        eventLongPressDelay: Number,
        selectMirror: Boolean,
        eventMaxStack: Number,
        eventMinHeight: Number,
        eventMinWidth: Number,
        eventShortHeight: Number,
        slotEventOverlap: Boolean,
        plugins: identity$1,
        firstDay: Number,
        dayCount: Number,
        dateAlignment: String,
        dateIncrement: createDuration,
        hiddenDays: identity$1,
        monthMode: Boolean,
        fixedWeekCount: Boolean,
        validRange: identity$1,
        visibleRange: identity$1,
        titleFormat: identity$1,
        eventInteractive: Boolean,
        // only used by list-view, but languages define the value, so we need it in base options
        noEventsText: String,
        viewHint: identity$1,
        navLinkHint: identity$1,
        closeHint: String,
        timeHint: String,
        eventHint: String,
        moreLinkClick: identity$1,
        moreLinkClassNames: identity$1,
        moreLinkContent: identity$1,
        moreLinkDidMount: identity$1,
        moreLinkWillUnmount: identity$1,
    };
    // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.
    // raw values.
    var BASE_OPTION_DEFAULTS = {
        eventDisplay: 'auto',
        defaultRangeSeparator: ' - ',
        titleRangeSeparator: ' \u2013 ',
        defaultTimedEventDuration: '01:00:00',
        defaultAllDayEventDuration: { day: 1 },
        forceEventDuration: false,
        nextDayThreshold: '00:00:00',
        dayHeaders: true,
        initialView: '',
        aspectRatio: 1.35,
        headerToolbar: {
            start: 'title',
            center: '',
            end: 'today prev,next',
        },
        weekends: true,
        weekNumbers: false,
        weekNumberCalculation: 'local',
        editable: false,
        nowIndicator: false,
        scrollTime: '06:00:00',
        scrollTimeReset: true,
        slotMinTime: '00:00:00',
        slotMaxTime: '24:00:00',
        showNonCurrentDates: true,
        lazyFetching: true,
        startParam: 'start',
        endParam: 'end',
        timeZoneParam: 'timeZone',
        timeZone: 'local',
        locales: [],
        locale: '',
        themeSystem: 'standard',
        dragRevertDuration: 500,
        dragScroll: true,
        allDayMaintainDuration: false,
        unselectAuto: true,
        dropAccept: '*',
        eventOrder: 'start,-duration,allDay,title',
        dayPopoverFormat: { month: 'long', day: 'numeric', year: 'numeric' },
        handleWindowResize: true,
        windowResizeDelay: 100,
        longPressDelay: 1000,
        eventDragMinDistance: 5,
        expandRows: false,
        navLinks: false,
        selectable: false,
        eventMinHeight: 15,
        eventMinWidth: 30,
        eventShortHeight: 30,
    };
    // calendar listeners
    // ------------------
    var CALENDAR_LISTENER_REFINERS = {
        datesSet: identity$1,
        eventsSet: identity$1,
        eventAdd: identity$1,
        eventChange: identity$1,
        eventRemove: identity$1,
        windowResize: identity$1,
        eventClick: identity$1,
        eventMouseEnter: identity$1,
        eventMouseLeave: identity$1,
        select: identity$1,
        unselect: identity$1,
        loading: identity$1,
        // internal
        _unmount: identity$1,
        _beforeprint: identity$1,
        _afterprint: identity$1,
        _noEventDrop: identity$1,
        _noEventResize: identity$1,
        _resize: identity$1,
        _scrollRequest: identity$1,
    };
    // calendar-specific options
    // -------------------------
    var CALENDAR_OPTION_REFINERS = {
        buttonText: identity$1,
        buttonHints: identity$1,
        views: identity$1,
        plugins: identity$1,
        initialEvents: identity$1,
        events: identity$1,
        eventSources: identity$1,
    };
    var COMPLEX_OPTION_COMPARATORS = {
        headerToolbar: isBoolComplexEqual,
        footerToolbar: isBoolComplexEqual,
        buttonText: isBoolComplexEqual,
        buttonHints: isBoolComplexEqual,
        buttonIcons: isBoolComplexEqual,
    };
    function isBoolComplexEqual(a, b) {
        if (typeof a === 'object' && typeof b === 'object' && a && b) { // both non-null objects
            return isPropsEqual(a, b);
        }
        return a === b;
    }
    // view-specific options
    // ---------------------
    var VIEW_OPTION_REFINERS = {
        type: String,
        component: identity$1,
        buttonText: String,
        buttonTextKey: String,
        dateProfileGeneratorClass: identity$1,
        usesMinMaxTime: Boolean,
        classNames: identity$1,
        content: identity$1,
        didMount: identity$1,
        willUnmount: identity$1,
    };
    // util funcs
    // ----------------------------------------------------------------------------------------------------
    function mergeRawOptions(optionSets) {
        return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
    }
    function refineProps(input, refiners) {
        var refined = {};
        var extra = {};
        for (var propName in refiners) {
            if (propName in input) {
                refined[propName] = refiners[propName](input[propName]);
            }
        }
        for (var propName in input) {
            if (!(propName in refiners)) {
                extra[propName] = input[propName];
            }
        }
        return { refined: refined, extra: extra };
    }
    function identity$1(raw) {
        return raw;
    }

    function parseEvents(rawEvents, eventSource, context, allowOpenRange) {
        var eventStore = createEmptyEventStore();
        var eventRefiners = buildEventRefiners(context);
        for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {
            var rawEvent = rawEvents_1[_i];
            var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);
            if (tuple) {
                eventTupleToStore(tuple, eventStore);
            }
        }
        return eventStore;
    }
    function eventTupleToStore(tuple, eventStore) {
        if (eventStore === void 0) { eventStore = createEmptyEventStore(); }
        eventStore.defs[tuple.def.defId] = tuple.def;
        if (tuple.instance) {
            eventStore.instances[tuple.instance.instanceId] = tuple.instance;
        }
        return eventStore;
    }
    // retrieves events that have the same groupId as the instance specified by `instanceId`
    // or they are the same as the instance.
    // why might instanceId not be in the store? an event from another calendar?
    function getRelevantEvents(eventStore, instanceId) {
        var instance = eventStore.instances[instanceId];
        if (instance) {
            var def_1 = eventStore.defs[instance.defId];
            // get events/instances with same group
            var newStore = filterEventStoreDefs(eventStore, function (lookDef) { return isEventDefsGrouped(def_1, lookDef); });
            // add the original
            // TODO: wish we could use eventTupleToStore or something like it
            newStore.defs[def_1.defId] = def_1;
            newStore.instances[instance.instanceId] = instance;
            return newStore;
        }
        return createEmptyEventStore();
    }
    function isEventDefsGrouped(def0, def1) {
        return Boolean(def0.groupId && def0.groupId === def1.groupId);
    }
    function createEmptyEventStore() {
        return { defs: {}, instances: {} };
    }
    function mergeEventStores(store0, store1) {
        return {
            defs: __assign(__assign({}, store0.defs), store1.defs),
            instances: __assign(__assign({}, store0.instances), store1.instances),
        };
    }
    function filterEventStoreDefs(eventStore, filterFunc) {
        var defs = filterHash(eventStore.defs, filterFunc);
        var instances = filterHash(eventStore.instances, function (instance) { return (defs[instance.defId] // still exists?
        ); });
        return { defs: defs, instances: instances };
    }
    function excludeSubEventStore(master, sub) {
        var defs = master.defs, instances = master.instances;
        var filteredDefs = {};
        var filteredInstances = {};
        for (var defId in defs) {
            if (!sub.defs[defId]) { // not explicitly excluded
                filteredDefs[defId] = defs[defId];
            }
        }
        for (var instanceId in instances) {
            if (!sub.instances[instanceId] && // not explicitly excluded
                filteredDefs[instances[instanceId].defId] // def wasn't filtered away
            ) {
                filteredInstances[instanceId] = instances[instanceId];
            }
        }
        return {
            defs: filteredDefs,
            instances: filteredInstances,
        };
    }

    function normalizeConstraint(input, context) {
        if (Array.isArray(input)) {
            return parseEvents(input, null, context, true); // allowOpenRange=true
        }
        if (typeof input === 'object' && input) { // non-null object
            return parseEvents([input], null, context, true); // allowOpenRange=true
        }
        if (input != null) {
            return String(input);
        }
        return null;
    }

    function parseClassNames(raw) {
        if (Array.isArray(raw)) {
            return raw;
        }
        if (typeof raw === 'string') {
            return raw.split(/\s+/);
        }
        return [];
    }

    // TODO: better called "EventSettings" or "EventConfig"
    // TODO: move this file into structs
    // TODO: separate constraint/overlap/allow, because selection uses only that, not other props
    var EVENT_UI_REFINERS = {
        display: String,
        editable: Boolean,
        startEditable: Boolean,
        durationEditable: Boolean,
        constraint: identity$1,
        overlap: identity$1,
        allow: identity$1,
        className: parseClassNames,
        classNames: parseClassNames,
        color: String,
        backgroundColor: String,
        borderColor: String,
        textColor: String,
    };
    var EMPTY_EVENT_UI = {
        display: null,
        startEditable: null,
        durationEditable: null,
        constraints: [],
        overlap: null,
        allows: [],
        backgroundColor: '',
        borderColor: '',
        textColor: '',
        classNames: [],
    };
    function createEventUi(refined, context) {
        var constraint = normalizeConstraint(refined.constraint, context);
        return {
            display: refined.display || null,
            startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
            durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
            constraints: constraint != null ? [constraint] : [],
            overlap: refined.overlap != null ? refined.overlap : null,
            allows: refined.allow != null ? [refined.allow] : [],
            backgroundColor: refined.backgroundColor || refined.color || '',
            borderColor: refined.borderColor || refined.color || '',
            textColor: refined.textColor || '',
            classNames: (refined.className || []).concat(refined.classNames || []), // join singular and plural
        };
    }
    // TODO: prevent against problems with <2 args!
    function combineEventUis(uis) {
        return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
    }
    function combineTwoEventUis(item0, item1) {
        return {
            display: item1.display != null ? item1.display : item0.display,
            startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
            durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
            constraints: item0.constraints.concat(item1.constraints),
            overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,
            allows: item0.allows.concat(item1.allows),
            backgroundColor: item1.backgroundColor || item0.backgroundColor,
            borderColor: item1.borderColor || item0.borderColor,
            textColor: item1.textColor || item0.textColor,
            classNames: item0.classNames.concat(item1.classNames),
        };
    }

    var EVENT_NON_DATE_REFINERS = {
        id: String,
        groupId: String,
        title: String,
        url: String,
        interactive: Boolean,
    };
    var EVENT_DATE_REFINERS = {
        start: identity$1,
        end: identity$1,
        date: identity$1,
        allDay: Boolean,
    };
    var EVENT_REFINERS = __assign(__assign(__assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity$1 });
    function parseEvent(raw, eventSource, context, allowOpenRange, refiners) {
        if (refiners === void 0) { refiners = buildEventRefiners(context); }
        var _a = refineEventDef(raw, context, refiners), refined = _a.refined, extra = _a.extra;
        var defaultAllDay = computeIsDefaultAllDay(eventSource, context);
        var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);
        if (recurringRes) {
            var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context);
            def.recurringDef = {
                typeId: recurringRes.typeId,
                typeData: recurringRes.typeData,
                duration: recurringRes.duration,
            };
            return { def: def, instance: null };
        }
        var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);
        if (singleRes) {
            var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context);
            var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
            return { def: def, instance: instance };
        }
        return null;
    }
    function refineEventDef(raw, context, refiners) {
        if (refiners === void 0) { refiners = buildEventRefiners(context); }
        return refineProps(raw, refiners);
    }
    function buildEventRefiners(context) {
        return __assign(__assign(__assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
    }
    /*
    Will NOT populate extendedProps with the leftover properties.
    Will NOT populate date-related props.
    */
    function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {
        var def = {
            title: refined.title || '',
            groupId: refined.groupId || '',
            publicId: refined.id || '',
            url: refined.url || '',
            recurringDef: null,
            defId: guid(),
            sourceId: sourceId,
            allDay: allDay,
            hasEnd: hasEnd,
            interactive: refined.interactive,
            ui: createEventUi(refined, context),
            extendedProps: __assign(__assign({}, (refined.extendedProps || {})), extra),
        };
        for (var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++) {
            var memberAdder = _a[_i];
            __assign(def, memberAdder(refined));
        }
        // help out EventApi from having user modify props
        Object.freeze(def.ui.classNames);
        Object.freeze(def.extendedProps);
        return def;
    }
    function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
        var allDay = refined.allDay;
        var startMeta;
        var startMarker = null;
        var hasEnd = false;
        var endMeta;
        var endMarker = null;
        var startInput = refined.start != null ? refined.start : refined.date;
        startMeta = context.dateEnv.createMarkerMeta(startInput);
        if (startMeta) {
            startMarker = startMeta.marker;
        }
        else if (!allowOpenRange) {
            return null;
        }
        if (refined.end != null) {
            endMeta = context.dateEnv.createMarkerMeta(refined.end);
        }
        if (allDay == null) {
            if (defaultAllDay != null) {
                allDay = defaultAllDay;
            }
            else {
                // fall back to the date props LAST
                allDay = (!startMeta || startMeta.isTimeUnspecified) &&
                    (!endMeta || endMeta.isTimeUnspecified);
            }
        }
        if (allDay && startMarker) {
            startMarker = startOfDay$1(startMarker);
        }
        if (endMeta) {
            endMarker = endMeta.marker;
            if (allDay) {
                endMarker = startOfDay$1(endMarker);
            }
            if (startMarker && endMarker <= startMarker) {
                endMarker = null;
            }
        }
        if (endMarker) {
            hasEnd = true;
        }
        else if (!allowOpenRange) {
            hasEnd = context.options.forceEventDuration || false;
            endMarker = context.dateEnv.add(startMarker, allDay ?
                context.options.defaultAllDayEventDuration :
                context.options.defaultTimedEventDuration);
        }
        return {
            allDay: allDay,
            hasEnd: hasEnd,
            range: { start: startMarker, end: endMarker },
            forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
            forcedEndTzo: endMeta ? endMeta.forcedTzo : null,
        };
    }
    function computeIsDefaultAllDay(eventSource, context) {
        var res = null;
        if (eventSource) {
            res = eventSource.defaultAllDay;
        }
        if (res == null) {
            res = context.options.defaultAllDay;
        }
        return res;
    }

    /* Date stuff that doesn't belong in datelib core
    ----------------------------------------------------------------------------------------------------------------------*/
    // given a timed range, computes an all-day range that has the same exact duration,
    // but whose start time is aligned with the start of the day.
    function computeAlignedDayRange(timedRange) {
        var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
        var start = startOfDay$1(timedRange.start);
        var end = addDays(start, dayCnt);
        return { start: start, end: end };
    }
    // given a timed range, computes an all-day range based on how for the end date bleeds into the next day
    // TODO: give nextDayThreshold a default arg
    function computeVisibleDayRange(timedRange, nextDayThreshold) {
        if (nextDayThreshold === void 0) { nextDayThreshold = createDuration(0); }
        var startDay = null;
        var endDay = null;
        if (timedRange.end) {
            endDay = startOfDay$1(timedRange.end);
            var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`
            // If the end time is actually inclusively part of the next day and is equal to or
            // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
            // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
            if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
                endDay = addDays(endDay, 1);
            }
        }
        if (timedRange.start) {
            startDay = startOfDay$1(timedRange.start); // the beginning of the day the range starts
            // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.
            if (endDay && endDay <= startDay) {
                endDay = addDays(startDay, 1);
            }
        }
        return { start: startDay, end: endDay };
    }
    function diffDates(date0, date1, dateEnv, largeUnit) {
        if (largeUnit === 'year') {
            return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');
        }
        if (largeUnit === 'month') {
            return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');
        }
        return diffDayAndTime(date0, date1); // returns a duration
    }

    function parseRange(input, dateEnv) {
        var start = null;
        var end = null;
        if (input.start) {
            start = dateEnv.createMarker(input.start);
        }
        if (input.end) {
            end = dateEnv.createMarker(input.end);
        }
        if (!start && !end) {
            return null;
        }
        if (start && end && end < start) {
            return null;
        }
        return { start: start, end: end };
    }
    // SIDE-EFFECT: will mutate ranges.
    // Will return a new array result.
    function invertRanges(ranges, constraintRange) {
        var invertedRanges = [];
        var start = constraintRange.start; // the end of the previous range. the start of the new range
        var i;
        var dateRange;
        // ranges need to be in order. required for our date-walking algorithm
        ranges.sort(compareRanges);
        for (i = 0; i < ranges.length; i += 1) {
            dateRange = ranges[i];
            // add the span of time before the event (if there is any)
            if (dateRange.start > start) { // compare millisecond time (skip any ambig logic)
                invertedRanges.push({ start: start, end: dateRange.start });
            }
            if (dateRange.end > start) {
                start = dateRange.end;
            }
        }
        // add the span of time after the last event (if there is any)
        if (start < constraintRange.end) { // compare millisecond time (skip any ambig logic)
            invertedRanges.push({ start: start, end: constraintRange.end });
        }
        return invertedRanges;
    }
    function compareRanges(range0, range1) {
        return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first
    }
    function intersectRanges(range0, range1) {
        var start = range0.start, end = range0.end;
        var newRange = null;
        if (range1.start !== null) {
            if (start === null) {
                start = range1.start;
            }
            else {
                start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
            }
        }
        if (range1.end != null) {
            if (end === null) {
                end = range1.end;
            }
            else {
                end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
            }
        }
        if (start === null || end === null || start < end) {
            newRange = { start: start, end: end };
        }
        return newRange;
    }
    function rangesEqual(range0, range1) {
        return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) &&
            (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
    }
    function rangesIntersect(range0, range1) {
        return (range0.end === null || range1.start === null || range0.end > range1.start) &&
            (range0.start === null || range1.end === null || range0.start < range1.end);
    }
    function rangeContainsRange(outerRange, innerRange) {
        return (outerRange.start === null || (innerRange.start !== null && innerRange.start >= outerRange.start)) &&
            (outerRange.end === null || (innerRange.end !== null && innerRange.end <= outerRange.end));
    }
    function rangeContainsMarker(range, date) {
        return (range.start === null || date >= range.start) &&
            (range.end === null || date < range.end);
    }
    // If the given date is not within the given range, move it inside.
    // (If it's past the end, make it one millisecond before the end).
    function constrainMarkerToRange(date, range) {
        if (range.start != null && date < range.start) {
            return range.start;
        }
        if (range.end != null && date >= range.end) {
            return new Date(range.end.valueOf() - 1);
        }
        return date;
    }

    /*
    Specifying nextDayThreshold signals that all-day ranges should be sliced.
    */
    function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
        var inverseBgByGroupId = {};
        var inverseBgByDefId = {};
        var defByGroupId = {};
        var bgRanges = [];
        var fgRanges = [];
        var eventUis = compileEventUis(eventStore.defs, eventUiBases);
        for (var defId in eventStore.defs) {
            var def = eventStore.defs[defId];
            var ui = eventUis[def.defId];
            if (ui.display === 'inverse-background') {
                if (def.groupId) {
                    inverseBgByGroupId[def.groupId] = [];
                    if (!defByGroupId[def.groupId]) {
                        defByGroupId[def.groupId] = def;
                    }
                }
                else {
                    inverseBgByDefId[defId] = [];
                }
            }
        }
        for (var instanceId in eventStore.instances) {
            var instance = eventStore.instances[instanceId];
            var def = eventStore.defs[instance.defId];
            var ui = eventUis[def.defId];
            var origRange = instance.range;
            var normalRange = (!def.allDay && nextDayThreshold) ?
                computeVisibleDayRange(origRange, nextDayThreshold) :
                origRange;
            var slicedRange = intersectRanges(normalRange, framingRange);
            if (slicedRange) {
                if (ui.display === 'inverse-background') {
                    if (def.groupId) {
                        inverseBgByGroupId[def.groupId].push(slicedRange);
                    }
                    else {
                        inverseBgByDefId[instance.defId].push(slicedRange);
                    }
                }
                else if (ui.display !== 'none') {
                    (ui.display === 'background' ? bgRanges : fgRanges).push({
                        def: def,
                        ui: ui,
                        instance: instance,
                        range: slicedRange,
                        isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
                        isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf(),
                    });
                }
            }
        }
        for (var groupId in inverseBgByGroupId) { // BY GROUP
            var ranges = inverseBgByGroupId[groupId];
            var invertedRanges = invertRanges(ranges, framingRange);
            for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {
                var invertedRange = invertedRanges_1[_i];
                var def = defByGroupId[groupId];
                var ui = eventUis[def.defId];
                bgRanges.push({
                    def: def,
                    ui: ui,
                    instance: null,
                    range: invertedRange,
                    isStart: false,
                    isEnd: false,
                });
            }
        }
        for (var defId in inverseBgByDefId) {
            var ranges = inverseBgByDefId[defId];
            var invertedRanges = invertRanges(ranges, framingRange);
            for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {
                var invertedRange = invertedRanges_2[_a];
                bgRanges.push({
                    def: eventStore.defs[defId],
                    ui: eventUis[defId],
                    instance: null,
                    range: invertedRange,
                    isStart: false,
                    isEnd: false,
                });
            }
        }
        return { bg: bgRanges, fg: fgRanges };
    }
    function setElSeg(el, seg) {
        el.fcSeg = seg;
    }
    function getElSeg(el) {
        return el.fcSeg ||
            el.parentNode.fcSeg || // for the harness
            null;
    }
    // event ui computation
    function compileEventUis(eventDefs, eventUiBases) {
        return mapHash(eventDefs, function (eventDef) { return compileEventUi(eventDef, eventUiBases); });
    }
    function compileEventUi(eventDef, eventUiBases) {
        var uis = [];
        if (eventUiBases['']) {
            uis.push(eventUiBases['']);
        }
        if (eventUiBases[eventDef.defId]) {
            uis.push(eventUiBases[eventDef.defId]);
        }
        uis.push(eventDef.ui);
        return combineEventUis(uis);
    }
    function sortEventSegs(segs, eventOrderSpecs) {
        var objs = segs.map(buildSegCompareObj);
        objs.sort(function (obj0, obj1) { return compareByFieldSpecs(obj0, obj1, eventOrderSpecs); });
        return objs.map(function (c) { return c._seg; });
    }
    // returns a object with all primitive props that can be compared
    function buildSegCompareObj(seg) {
        var eventRange = seg.eventRange;
        var eventDef = eventRange.def;
        var range = eventRange.instance ? eventRange.instance.range : eventRange.range;
        var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events
        var end = range.end ? range.end.valueOf() : 0; // "
        return __assign(__assign(__assign({}, eventDef.extendedProps), eventDef), { id: eventDef.publicId, start: start,
            end: end, duration: end - start, allDay: Number(eventDef.allDay), _seg: seg });
    }
    function computeSegDraggable(seg, context) {
        var pluginHooks = context.pluginHooks;
        var transformers = pluginHooks.isDraggableTransformers;
        var _a = seg.eventRange, def = _a.def, ui = _a.ui;
        var val = ui.startEditable;
        for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
            var transformer = transformers_1[_i];
            val = transformer(val, def, ui, context);
        }
        return val;
    }
    function computeSegStartResizable(seg, context) {
        return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
    }
    function computeSegEndResizable(seg, context) {
        return seg.isEnd && seg.eventRange.ui.durationEditable;
    }
    function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, // defaults to true
    defaultDisplayEventEnd, // defaults to true
    startOverride, endOverride) {
        var dateEnv = context.dateEnv, options = context.options;
        var displayEventTime = options.displayEventTime, displayEventEnd = options.displayEventEnd;
        var eventDef = seg.eventRange.def;
        var eventInstance = seg.eventRange.instance;
        if (displayEventTime == null) {
            displayEventTime = defaultDisplayEventTime !== false;
        }
        if (displayEventEnd == null) {
            displayEventEnd = defaultDisplayEventEnd !== false;
        }
        var wholeEventStart = eventInstance.range.start;
        var wholeEventEnd = eventInstance.range.end;
        var segStart = startOverride || seg.start || seg.eventRange.range.start;
        var segEnd = endOverride || seg.end || seg.eventRange.range.end;
        var isStartDay = startOfDay$1(wholeEventStart).valueOf() === startOfDay$1(segStart).valueOf();
        var isEndDay = startOfDay$1(addMs(wholeEventEnd, -1)).valueOf() === startOfDay$1(addMs(segEnd, -1)).valueOf();
        if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
            segStart = isStartDay ? wholeEventStart : segStart;
            segEnd = isEndDay ? wholeEventEnd : segEnd;
            if (displayEventEnd && eventDef.hasEnd) {
                return dateEnv.formatRange(segStart, segEnd, timeFormat, {
                    forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
                    forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo,
                });
            }
            return dateEnv.format(segStart, timeFormat, {
                forcedTzo: startOverride ? null : eventInstance.forcedStartTzo, // nooooo, same
            });
        }
        return '';
    }
    function getSegMeta(seg, todayRange, nowDate) {
        var segRange = seg.eventRange.range;
        return {
            isPast: segRange.end < (nowDate || todayRange.start),
            isFuture: segRange.start >= (nowDate || todayRange.end),
            isToday: todayRange && rangeContainsMarker(todayRange, segRange.start),
        };
    }
    function getEventClassNames(props) {
        var classNames = ['fc-event'];
        if (props.isMirror) {
            classNames.push('fc-event-mirror');
        }
        if (props.isDraggable) {
            classNames.push('fc-event-draggable');
        }
        if (props.isStartResizable || props.isEndResizable) {
            classNames.push('fc-event-resizable');
        }
        if (props.isDragging) {
            classNames.push('fc-event-dragging');
        }
        if (props.isResizing) {
            classNames.push('fc-event-resizing');
        }
        if (props.isSelected) {
            classNames.push('fc-event-selected');
        }
        if (props.isStart) {
            classNames.push('fc-event-start');
        }
        if (props.isEnd) {
            classNames.push('fc-event-end');
        }
        if (props.isPast) {
            classNames.push('fc-event-past');
        }
        if (props.isToday) {
            classNames.push('fc-event-today');
        }
        if (props.isFuture) {
            classNames.push('fc-event-future');
        }
        return classNames;
    }
    function buildEventRangeKey(eventRange) {
        return eventRange.instance
            ? eventRange.instance.instanceId
            : eventRange.def.defId + ":" + eventRange.range.start.toISOString();
        // inverse-background events don't have specific instances. TODO: better solution
    }
    function getSegAnchorAttrs(seg, context) {
        var _a = seg.eventRange, def = _a.def, instance = _a.instance;
        var url = def.url;
        if (url) {
            return { href: url };
        }
        var emitter = context.emitter, options = context.options;
        var eventInteractive = options.eventInteractive;
        if (eventInteractive == null) {
            eventInteractive = def.interactive;
            if (eventInteractive == null) {
                eventInteractive = Boolean(emitter.hasHandlers('eventClick'));
            }
        }
        // mock what happens in EventClicking
        if (eventInteractive) {
            // only attach keyboard-related handlers because click handler is already done in EventClicking
            return createAriaKeyboardAttrs(function (ev) {
                emitter.trigger('eventClick', {
                    el: ev.target,
                    event: new EventApi(context, def, instance),
                    jsEvent: ev,
                    view: context.viewApi,
                });
            });
        }
        return {};
    }

    var STANDARD_PROPS = {
        start: identity$1,
        end: identity$1,
        allDay: Boolean,
    };
    function parseDateSpan(raw, dateEnv, defaultDuration) {
        var span = parseOpenDateSpan(raw, dateEnv);
        var range = span.range;
        if (!range.start) {
            return null;
        }
        if (!range.end) {
            if (defaultDuration == null) {
                return null;
            }
            range.end = dateEnv.add(range.start, defaultDuration);
        }
        return span;
    }
    /*
    TODO: somehow combine with parseRange?
    Will return null if the start/end props were present but parsed invalidly.
    */
    function parseOpenDateSpan(raw, dateEnv) {
        var _a = refineProps(raw, STANDARD_PROPS), standardProps = _a.refined, extra = _a.extra;
        var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
        var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
        var allDay = standardProps.allDay;
        if (allDay == null) {
            allDay = (startMeta && startMeta.isTimeUnspecified) &&
                (!endMeta || endMeta.isTimeUnspecified);
        }
        return __assign({ range: {
                start: startMeta ? startMeta.marker : null,
                end: endMeta ? endMeta.marker : null,
            }, allDay: allDay }, extra);
    }
    function isDateSpansEqual(span0, span1) {
        return rangesEqual(span0.range, span1.range) &&
            span0.allDay === span1.allDay &&
            isSpanPropsEqual(span0, span1);
    }
    // the NON-DATE-RELATED props
    function isSpanPropsEqual(span0, span1) {
        for (var propName in span1) {
            if (propName !== 'range' && propName !== 'allDay') {
                if (span0[propName] !== span1[propName]) {
                    return false;
                }
            }
        }
        // are there any props that span0 has that span1 DOESN'T have?
        // both have range/allDay, so no need to special-case.
        for (var propName in span0) {
            if (!(propName in span1)) {
                return false;
            }
        }
        return true;
    }
    function buildDateSpanApi(span, dateEnv) {
        return __assign(__assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });
    }
    function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {
        return __assign(__assign({}, buildRangeApi(range, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });
    }
    function buildRangeApi(range, dateEnv, omitTime) {
        return {
            start: dateEnv.toDate(range.start),
            end: dateEnv.toDate(range.end),
            startStr: dateEnv.formatIso(range.start, { omitTime: omitTime }),
            endStr: dateEnv.formatIso(range.end, { omitTime: omitTime }),
        };
    }
    function fabricateEventRange(dateSpan, eventUiBases, context) {
        var res = refineEventDef({ editable: false }, context);
        var def = parseEventDef(res.refined, res.extra, '', // sourceId
        dateSpan.allDay, true, // hasEnd
        context);
        return {
            def: def,
            ui: compileEventUi(def, eventUiBases),
            instance: createEventInstance(def.defId, dateSpan.range),
            range: dateSpan.range,
            isStart: true,
            isEnd: true,
        };
    }

    function triggerDateSelect(selection, pev, context) {
        context.emitter.trigger('select', __assign(__assign({}, buildDateSpanApiWithContext(selection, context)), { jsEvent: pev ? pev.origEvent : null, view: context.viewApi || context.calendarApi.view }));
    }
    function triggerDateUnselect(pev, context) {
        context.emitter.trigger('unselect', {
            jsEvent: pev ? pev.origEvent : null,
            view: context.viewApi || context.calendarApi.view,
        });
    }
    function buildDateSpanApiWithContext(dateSpan, context) {
        var props = {};
        for (var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++) {
            var transform = _a[_i];
            __assign(props, transform(dateSpan, context));
        }
        __assign(props, buildDateSpanApi(dateSpan, context.dateEnv));
        return props;
    }
    // Given an event's allDay status and start date, return what its fallback end date should be.
    // TODO: rename to computeDefaultEventEnd
    function getDefaultEventEnd(allDay, marker, context) {
        var dateEnv = context.dateEnv, options = context.options;
        var end = marker;
        if (allDay) {
            end = startOfDay$1(end);
            end = dateEnv.add(end, options.defaultAllDayEventDuration);
        }
        else {
            end = dateEnv.add(end, options.defaultTimedEventDuration);
        }
        return end;
    }

    // applies the mutation to ALL defs/instances within the event store
    function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
        var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
        var dest = createEmptyEventStore();
        for (var defId in eventStore.defs) {
            var def = eventStore.defs[defId];
            dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
        }
        for (var instanceId in eventStore.instances) {
            var instance = eventStore.instances[instanceId];
            var def = dest.defs[instance.defId]; // important to grab the newly modified def
            dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
        }
        return dest;
    }
    function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
        var standardProps = mutation.standardProps || {};
        // if hasEnd has not been specified, guess a good value based on deltas.
        // if duration will change, there's no way the default duration will persist,
        // and thus, we need to mark the event as having a real end
        if (standardProps.hasEnd == null &&
            eventConfig.durationEditable &&
            (mutation.startDelta || mutation.endDelta)) {
            standardProps.hasEnd = true; // TODO: is this mutation okay?
        }
        var copy = __assign(__assign(__assign({}, eventDef), standardProps), { ui: __assign(__assign({}, eventDef.ui), standardProps.ui) });
        if (mutation.extendedProps) {
            copy.extendedProps = __assign(__assign({}, copy.extendedProps), mutation.extendedProps);
        }
        for (var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++) {
            var applier = _a[_i];
            applier(copy, mutation, context);
        }
        if (!copy.hasEnd && context.options.forceEventDuration) {
            copy.hasEnd = true;
        }
        return copy;
    }
    function applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef
    eventConfig, mutation, context) {
        var dateEnv = context.dateEnv;
        var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
        var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
        var copy = __assign({}, eventInstance);
        if (forceAllDay) {
            copy.range = computeAlignedDayRange(copy.range);
        }
        if (mutation.datesDelta && eventConfig.startEditable) {
            copy.range = {
                start: dateEnv.add(copy.range.start, mutation.datesDelta),
                end: dateEnv.add(copy.range.end, mutation.datesDelta),
            };
        }
        if (mutation.startDelta && eventConfig.durationEditable) {
            copy.range = {
                start: dateEnv.add(copy.range.start, mutation.startDelta),
                end: copy.range.end,
            };
        }
        if (mutation.endDelta && eventConfig.durationEditable) {
            copy.range = {
                start: copy.range.start,
                end: dateEnv.add(copy.range.end, mutation.endDelta),
            };
        }
        if (clearEnd) {
            copy.range = {
                start: copy.range.start,
                end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context),
            };
        }
        // in case event was all-day but the supplied deltas were not
        // better util for this?
        if (eventDef.allDay) {
            copy.range = {
                start: startOfDay$1(copy.range.start),
                end: startOfDay$1(copy.range.end),
            };
        }
        // handle invalid durations
        if (copy.range.end < copy.range.start) {
            copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
        }
        return copy;
    }

    // no public types yet. when there are, export from:
    // import {} from './api-type-deps'
    var ViewApi = /** @class */ (function () {
        function ViewApi(type, getCurrentData, dateEnv) {
            this.type = type;
            this.getCurrentData = getCurrentData;
            this.dateEnv = dateEnv;
        }
        Object.defineProperty(ViewApi.prototype, "calendar", {
            get: function () {
                return this.getCurrentData().calendarApi;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ViewApi.prototype, "title", {
            get: function () {
                return this.getCurrentData().viewTitle;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ViewApi.prototype, "activeStart", {
            get: function () {
                return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ViewApi.prototype, "activeEnd", {
            get: function () {
                return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ViewApi.prototype, "currentStart", {
            get: function () {
                return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ViewApi.prototype, "currentEnd", {
            get: function () {
                return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
            },
            enumerable: false,
            configurable: true
        });
        ViewApi.prototype.getOption = function (name) {
            return this.getCurrentData().options[name]; // are the view-specific options
        };
        return ViewApi;
    }());

    var EVENT_SOURCE_REFINERS = {
        id: String,
        defaultAllDay: Boolean,
        url: String,
        format: String,
        events: identity$1,
        eventDataTransform: identity$1,
        // for any network-related sources
        success: identity$1,
        failure: identity$1,
    };
    function parseEventSource(raw, context, refiners) {
        if (refiners === void 0) { refiners = buildEventSourceRefiners(context); }
        var rawObj;
        if (typeof raw === 'string') {
            rawObj = { url: raw };
        }
        else if (typeof raw === 'function' || Array.isArray(raw)) {
            rawObj = { events: raw };
        }
        else if (typeof raw === 'object' && raw) { // not null
            rawObj = raw;
        }
        if (rawObj) {
            var _a = refineProps(rawObj, refiners), refined = _a.refined, extra = _a.extra;
            var metaRes = buildEventSourceMeta(refined, context);
            if (metaRes) {
                return {
                    _raw: raw,
                    isFetching: false,
                    latestFetchId: '',
                    fetchRange: null,
                    defaultAllDay: refined.defaultAllDay,
                    eventDataTransform: refined.eventDataTransform,
                    success: refined.success,
                    failure: refined.failure,
                    publicId: refined.id || '',
                    sourceId: guid(),
                    sourceDefId: metaRes.sourceDefId,
                    meta: metaRes.meta,
                    ui: createEventUi(refined, context),
                    extendedProps: extra,
                };
            }
        }
        return null;
    }
    function buildEventSourceRefiners(context) {
        return __assign(__assign(__assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);
    }
    function buildEventSourceMeta(raw, context) {
        var defs = context.pluginHooks.eventSourceDefs;
        for (var i = defs.length - 1; i >= 0; i -= 1) { // later-added plugins take precedence
            var def = defs[i];
            var meta = def.parseMeta(raw);
            if (meta) {
                return { sourceDefId: i, meta: meta };
            }
        }
        return null;
    }

    function reduceCurrentDate(currentDate, action) {
        switch (action.type) {
            case 'CHANGE_DATE':
                return action.dateMarker;
            default:
                return currentDate;
        }
    }
    function getInitialDate(options, dateEnv) {
        var initialDateInput = options.initialDate;
        // compute the initial ambig-timezone date
        if (initialDateInput != null) {
            return dateEnv.createMarker(initialDateInput);
        }
        return getNow(options.now, dateEnv); // getNow already returns unzoned
    }
    function getNow(nowInput, dateEnv) {
        if (typeof nowInput === 'function') {
            nowInput = nowInput();
        }
        if (nowInput == null) {
            return dateEnv.createNowMarker();
        }
        return dateEnv.createMarker(nowInput);
    }

    var CalendarApi = /** @class */ (function () {
        function CalendarApi() {
        }
        CalendarApi.prototype.getCurrentData = function () {
            return this.currentDataManager.getCurrentData();
        };
        CalendarApi.prototype.dispatch = function (action) {
            return this.currentDataManager.dispatch(action);
        };
        Object.defineProperty(CalendarApi.prototype, "view", {
            get: function () { return this.getCurrentData().viewApi; } // for public API
            ,
            enumerable: false,
            configurable: true
        });
        CalendarApi.prototype.batchRendering = function (callback) {
            callback();
        };
        CalendarApi.prototype.updateSize = function () {
            this.trigger('_resize', true);
        };
        // Options
        // -----------------------------------------------------------------------------------------------------------------
        CalendarApi.prototype.setOption = function (name, val) {
            this.dispatch({
                type: 'SET_OPTION',
                optionName: name,
                rawOptionValue: val,
            });
        };
        CalendarApi.prototype.getOption = function (name) {
            return this.currentDataManager.currentCalendarOptionsInput[name];
        };
        CalendarApi.prototype.getAvailableLocaleCodes = function () {
            return Object.keys(this.getCurrentData().availableRawLocales);
        };
        // Trigger
        // -----------------------------------------------------------------------------------------------------------------
        CalendarApi.prototype.on = function (handlerName, handler) {
            var currentDataManager = this.currentDataManager;
            if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
                currentDataManager.emitter.on(handlerName, handler);
            }
            else {
                console.warn("Unknown listener name '" + handlerName + "'");
            }
        };
        CalendarApi.prototype.off = function (handlerName, handler) {
            this.currentDataManager.emitter.off(handlerName, handler);
        };
        // not meant for public use
        CalendarApi.prototype.trigger = function (handlerName) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            (_a = this.currentDataManager.emitter).trigger.apply(_a, __spreadArray([handlerName], args));
        };
        // View
        // -----------------------------------------------------------------------------------------------------------------
        CalendarApi.prototype.changeView = function (viewType, dateOrRange) {
            var _this = this;
            this.batchRendering(function () {
                _this.unselect();
                if (dateOrRange) {
                    if (dateOrRange.start && dateOrRange.end) { // a range
                        _this.dispatch({
                            type: 'CHANGE_VIEW_TYPE',
                            viewType: viewType,
                        });
                        _this.dispatch({
                            type: 'SET_OPTION',
                            optionName: 'visibleRange',
                            rawOptionValue: dateOrRange,
                        });
                    }
                    else {
                        var dateEnv = _this.getCurrentData().dateEnv;
                        _this.dispatch({
                            type: 'CHANGE_VIEW_TYPE',
                            viewType: viewType,
                            dateMarker: dateEnv.createMarker(dateOrRange),
                        });
                    }
                }
                else {
                    _this.dispatch({
                        type: 'CHANGE_VIEW_TYPE',
                        viewType: viewType,
                    });
                }
            });
        };
        // Forces navigation to a view for the given date.
        // `viewType` can be a specific view name or a generic one like "week" or "day".
        // needs to change
        CalendarApi.prototype.zoomTo = function (dateMarker, viewType) {
            var state = this.getCurrentData();
            var spec;
            viewType = viewType || 'day'; // day is default zoom
            spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
            this.unselect();
            if (spec) {
                this.dispatch({
                    type: 'CHANGE_VIEW_TYPE',
                    viewType: spec.type,
                    dateMarker: dateMarker,
                });
            }
            else {
                this.dispatch({
                    type: 'CHANGE_DATE',
                    dateMarker: dateMarker,
                });
            }
        };
        // Given a duration singular unit, like "week" or "day", finds a matching view spec.
        // Preference is given to views that have corresponding buttons.
        CalendarApi.prototype.getUnitViewSpec = function (unit) {
            var _a = this.getCurrentData(), viewSpecs = _a.viewSpecs, toolbarConfig = _a.toolbarConfig;
            var viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
            var i;
            var spec;
            for (var viewType in viewSpecs) {
                viewTypes.push(viewType);
            }
            for (i = 0; i < viewTypes.length; i += 1) {
                spec = viewSpecs[viewTypes[i]];
                if (spec) {
                    if (spec.singleUnit === unit) {
                        return spec;
                    }
                }
            }
            return null;
        };
        // Current Date
        // -----------------------------------------------------------------------------------------------------------------
        CalendarApi.prototype.prev = function () {
            this.unselect();
            this.dispatch({ type: 'PREV' });
        };
        CalendarApi.prototype.next = function () {
            this.unselect();
            this.dispatch({ type: 'NEXT' });
        };
        CalendarApi.prototype.prevYear = function () {
            var state = this.getCurrentData();
            this.unselect();
            this.dispatch({
                type: 'CHANGE_DATE',
                dateMarker: state.dateEnv.addYears(state.currentDate, -1),
            });
        };
        CalendarApi.prototype.nextYear = function () {
            var state = this.getCurrentData();
            this.unselect();
            this.dispatch({
                type: 'CHANGE_DATE',
                dateMarker: state.dateEnv.addYears(state.currentDate, 1),
            });
        };
        CalendarApi.prototype.today = function () {
            var state = this.getCurrentData();
            this.unselect();
            this.dispatch({
                type: 'CHANGE_DATE',
                dateMarker: getNow(state.calendarOptions.now, state.dateEnv),
            });
        };
        CalendarApi.prototype.gotoDate = function (zonedDateInput) {
            var state = this.getCurrentData();
            this.unselect();
            this.dispatch({
                type: 'CHANGE_DATE',
                dateMarker: state.dateEnv.createMarker(zonedDateInput),
            });
        };
        CalendarApi.prototype.incrementDate = function (deltaInput) {
            var state = this.getCurrentData();
            var delta = createDuration(deltaInput);
            if (delta) { // else, warn about invalid input?
                this.unselect();
                this.dispatch({
                    type: 'CHANGE_DATE',
                    dateMarker: state.dateEnv.add(state.currentDate, delta),
                });
            }
        };
        // for external API
        CalendarApi.prototype.getDate = function () {
            var state = this.getCurrentData();
            return state.dateEnv.toDate(state.currentDate);
        };
        // Date Formatting Utils
        // -----------------------------------------------------------------------------------------------------------------
        CalendarApi.prototype.formatDate = function (d, formatter) {
            var dateEnv = this.getCurrentData().dateEnv;
            return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));
        };
        // `settings` is for formatter AND isEndExclusive
        CalendarApi.prototype.formatRange = function (d0, d1, settings) {
            var dateEnv = this.getCurrentData().dateEnv;
            return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
        };
        CalendarApi.prototype.formatIso = function (d, omitTime) {
            var dateEnv = this.getCurrentData().dateEnv;
            return dateEnv.formatIso(dateEnv.createMarker(d), { omitTime: omitTime });
        };
        // Date Selection / Event Selection / DayClick
        // -----------------------------------------------------------------------------------------------------------------
        // this public method receives start/end dates in any format, with any timezone
        // NOTE: args were changed from v3
        CalendarApi.prototype.select = function (dateOrObj, endDate) {
            var selectionInput;
            if (endDate == null) {
                if (dateOrObj.start != null) {
                    selectionInput = dateOrObj;
                }
                else {
                    selectionInput = {
                        start: dateOrObj,
                        end: null,
                    };
                }
            }
            else {
                selectionInput = {
                    start: dateOrObj,
                    end: endDate,
                };
            }
            var state = this.getCurrentData();
            var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({ days: 1 }));
            if (selection) { // throw parse error otherwise?
                this.dispatch({ type: 'SELECT_DATES', selection: selection });
                triggerDateSelect(selection, null, state);
            }
        };
        // public method
        CalendarApi.prototype.unselect = function (pev) {
            var state = this.getCurrentData();
            if (state.dateSelection) {
                this.dispatch({ type: 'UNSELECT_DATES' });
                triggerDateUnselect(pev, state);
            }
        };
        // Public Events API
        // -----------------------------------------------------------------------------------------------------------------
        CalendarApi.prototype.addEvent = function (eventInput, sourceInput) {
            if (eventInput instanceof EventApi) {
                var def = eventInput._def;
                var instance = eventInput._instance;
                var currentData = this.getCurrentData();
                // not already present? don't want to add an old snapshot
                if (!currentData.eventStore.defs[def.defId]) {
                    this.dispatch({
                        type: 'ADD_EVENTS',
                        eventStore: eventTupleToStore({ def: def, instance: instance }), // TODO: better util for two args?
                    });
                    this.triggerEventAdd(eventInput);
                }
                return eventInput;
            }
            var state = this.getCurrentData();
            var eventSource;
            if (sourceInput instanceof EventSourceApi) {
                eventSource = sourceInput.internalEventSource;
            }
            else if (typeof sourceInput === 'boolean') {
                if (sourceInput) { // true. part of the first event source
                    eventSource = hashValuesToArray(state.eventSources)[0];
                }
            }
            else if (sourceInput != null) { // an ID. accepts a number too
                var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function
                if (!sourceApi) {
                    console.warn("Could not find an event source with ID \"" + sourceInput + "\""); // TODO: test
                    return null;
                }
                eventSource = sourceApi.internalEventSource;
            }
            var tuple = parseEvent(eventInput, eventSource, state, false);
            if (tuple) {
                var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
                this.dispatch({
                    type: 'ADD_EVENTS',
                    eventStore: eventTupleToStore(tuple),
                });
                this.triggerEventAdd(newEventApi);
                return newEventApi;
            }
            return null;
        };
        CalendarApi.prototype.triggerEventAdd = function (eventApi) {
            var _this = this;
            var emitter = this.getCurrentData().emitter;
            emitter.trigger('eventAdd', {
                event: eventApi,
                relatedEvents: [],
                revert: function () {
                    _this.dispatch({
                        type: 'REMOVE_EVENTS',
                        eventStore: eventApiToStore(eventApi),
                    });
                },
            });
        };
        // TODO: optimize
        CalendarApi.prototype.getEventById = function (id) {
            var state = this.getCurrentData();
            var _a = state.eventStore, defs = _a.defs, instances = _a.instances;
            id = String(id);
            for (var defId in defs) {
                var def = defs[defId];
                if (def.publicId === id) {
                    if (def.recurringDef) {
                        return new EventApi(state, def, null);
                    }
                    for (var instanceId in instances) {
                        var instance = instances[instanceId];
                        if (instance.defId === def.defId) {
                            return new EventApi(state, def, instance);
                        }
                    }
                }
            }
            return null;
        };
        CalendarApi.prototype.getEvents = function () {
            var currentData = this.getCurrentData();
            return buildEventApis(currentData.eventStore, currentData);
        };
        CalendarApi.prototype.removeAllEvents = function () {
            this.dispatch({ type: 'REMOVE_ALL_EVENTS' });
        };
        // Public Event Sources API
        // -----------------------------------------------------------------------------------------------------------------
        CalendarApi.prototype.getEventSources = function () {
            var state = this.getCurrentData();
            var sourceHash = state.eventSources;
            var sourceApis = [];
            for (var internalId in sourceHash) {
                sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));
            }
            return sourceApis;
        };
        CalendarApi.prototype.getEventSourceById = function (id) {
            var state = this.getCurrentData();
            var sourceHash = state.eventSources;
            id = String(id);
            for (var sourceId in sourceHash) {
                if (sourceHash[sourceId].publicId === id) {
                    return new EventSourceApi(state, sourceHash[sourceId]);
                }
            }
            return null;
        };
        CalendarApi.prototype.addEventSource = function (sourceInput) {
            var state = this.getCurrentData();
            if (sourceInput instanceof EventSourceApi) {
                // not already present? don't want to add an old snapshot
                if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
                    this.dispatch({
                        type: 'ADD_EVENT_SOURCES',
                        sources: [sourceInput.internalEventSource],
                    });
                }
                return sourceInput;
            }
            var eventSource = parseEventSource(sourceInput, state);
            if (eventSource) { // TODO: error otherwise?
                this.dispatch({ type: 'ADD_EVENT_SOURCES', sources: [eventSource] });
                return new EventSourceApi(state, eventSource);
            }
            return null;
        };
        CalendarApi.prototype.removeAllEventSources = function () {
            this.dispatch({ type: 'REMOVE_ALL_EVENT_SOURCES' });
        };
        CalendarApi.prototype.refetchEvents = function () {
            this.dispatch({ type: 'FETCH_EVENT_SOURCES', isRefetch: true });
        };
        // Scroll
        // -----------------------------------------------------------------------------------------------------------------
        CalendarApi.prototype.scrollToTime = function (timeInput) {
            var time = createDuration(timeInput);
            if (time) {
                this.trigger('_scrollRequest', { time: time });
            }
        };
        return CalendarApi;
    }());

    var EventApi = /** @class */ (function () {
        // instance will be null if expressing a recurring event that has no current instances,
        // OR if trying to validate an incoming external event that has no dates assigned
        function EventApi(context, def, instance) {
            this._context = context;
            this._def = def;
            this._instance = instance || null;
        }
        /*
        TODO: make event struct more responsible for this
        */
        EventApi.prototype.setProp = function (name, val) {
            var _a, _b;
            if (name in EVENT_DATE_REFINERS) {
                console.warn('Could not set date-related prop \'name\'. Use one of the date-related methods instead.');
                // TODO: make proper aliasing system?
            }
            else if (name === 'id') {
                val = EVENT_NON_DATE_REFINERS[name](val);
                this.mutate({
                    standardProps: { publicId: val }, // hardcoded internal name
                });
            }
            else if (name in EVENT_NON_DATE_REFINERS) {
                val = EVENT_NON_DATE_REFINERS[name](val);
                this.mutate({
                    standardProps: (_a = {}, _a[name] = val, _a),
                });
            }
            else if (name in EVENT_UI_REFINERS) {
                var ui = EVENT_UI_REFINERS[name](val);
                if (name === 'color') {
                    ui = { backgroundColor: val, borderColor: val };
                }
                else if (name === 'editable') {
                    ui = { startEditable: val, durationEditable: val };
                }
                else {
                    ui = (_b = {}, _b[name] = val, _b);
                }
                this.mutate({
                    standardProps: { ui: ui },
                });
            }
            else {
                console.warn("Could not set prop '" + name + "'. Use setExtendedProp instead.");
            }
        };
        EventApi.prototype.setExtendedProp = function (name, val) {
            var _a;
            this.mutate({
                extendedProps: (_a = {}, _a[name] = val, _a),
            });
        };
        EventApi.prototype.setStart = function (startInput, options) {
            if (options === void 0) { options = {}; }
            var dateEnv = this._context.dateEnv;
            var start = dateEnv.createMarker(startInput);
            if (start && this._instance) { // TODO: warning if parsed bad
                var instanceRange = this._instance.range;
                var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?
                if (options.maintainDuration) {
                    this.mutate({ datesDelta: startDelta });
                }
                else {
                    this.mutate({ startDelta: startDelta });
                }
            }
        };
        EventApi.prototype.setEnd = function (endInput, options) {
            if (options === void 0) { options = {}; }
            var dateEnv = this._context.dateEnv;
            var end;
            if (endInput != null) {
                end = dateEnv.createMarker(endInput);
                if (!end) {
                    return; // TODO: warning if parsed bad
                }
            }
            if (this._instance) {
                if (end) {
                    var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
                    this.mutate({ endDelta: endDelta });
                }
                else {
                    this.mutate({ standardProps: { hasEnd: false } });
                }
            }
        };
        EventApi.prototype.setDates = function (startInput, endInput, options) {
            if (options === void 0) { options = {}; }
            var dateEnv = this._context.dateEnv;
            var standardProps = { allDay: options.allDay };
            var start = dateEnv.createMarker(startInput);
            var end;
            if (!start) {
                return; // TODO: warning if parsed bad
            }
            if (endInput != null) {
                end = dateEnv.createMarker(endInput);
                if (!end) { // TODO: warning if parsed bad
                    return;
                }
            }
            if (this._instance) {
                var instanceRange = this._instance.range;
                // when computing the diff for an event being converted to all-day,
                // compute diff off of the all-day values the way event-mutation does.
                if (options.allDay === true) {
                    instanceRange = computeAlignedDayRange(instanceRange);
                }
                var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
                if (end) {
                    var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
                    if (durationsEqual(startDelta, endDelta)) {
                        this.mutate({ datesDelta: startDelta, standardProps: standardProps });
                    }
                    else {
                        this.mutate({ startDelta: startDelta, endDelta: endDelta, standardProps: standardProps });
                    }
                }
                else { // means "clear the end"
                    standardProps.hasEnd = false;
                    this.mutate({ datesDelta: startDelta, standardProps: standardProps });
                }
            }
        };
        EventApi.prototype.moveStart = function (deltaInput) {
            var delta = createDuration(deltaInput);
            if (delta) { // TODO: warning if parsed bad
                this.mutate({ startDelta: delta });
            }
        };
        EventApi.prototype.moveEnd = function (deltaInput) {
            var delta = createDuration(deltaInput);
            if (delta) { // TODO: warning if parsed bad
                this.mutate({ endDelta: delta });
            }
        };
        EventApi.prototype.moveDates = function (deltaInput) {
            var delta = createDuration(deltaInput);
            if (delta) { // TODO: warning if parsed bad
                this.mutate({ datesDelta: delta });
            }
        };
        EventApi.prototype.setAllDay = function (allDay, options) {
            if (options === void 0) { options = {}; }
            var standardProps = { allDay: allDay };
            var maintainDuration = options.maintainDuration;
            if (maintainDuration == null) {
                maintainDuration = this._context.options.allDayMaintainDuration;
            }
            if (this._def.allDay !== allDay) {
                standardProps.hasEnd = maintainDuration;
            }
            this.mutate({ standardProps: standardProps });
        };
        EventApi.prototype.formatRange = function (formatInput) {
            var dateEnv = this._context.dateEnv;
            var instance = this._instance;
            var formatter = createFormatter(formatInput);
            if (this._def.hasEnd) {
                return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
                    forcedStartTzo: instance.forcedStartTzo,
                    forcedEndTzo: instance.forcedEndTzo,
                });
            }
            return dateEnv.format(instance.range.start, formatter, {
                forcedTzo: instance.forcedStartTzo,
            });
        };
        EventApi.prototype.mutate = function (mutation) {
            var instance = this._instance;
            if (instance) {
                var def = this._def;
                var context_1 = this._context;
                var eventStore_1 = context_1.getCurrentData().eventStore;
                var relevantEvents = getRelevantEvents(eventStore_1, instance.instanceId);
                var eventConfigBase = {
                    '': {
                        display: '',
                        startEditable: true,
                        durationEditable: true,
                        constraints: [],
                        overlap: null,
                        allows: [],
                        backgroundColor: '',
                        borderColor: '',
                        textColor: '',
                        classNames: [],
                    },
                };
                relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context_1);
                var oldEvent = new EventApi(context_1, def, instance); // snapshot
                this._def = relevantEvents.defs[def.defId];
                this._instance = relevantEvents.instances[instance.instanceId];
                context_1.dispatch({
                    type: 'MERGE_EVENTS',
                    eventStore: relevantEvents,
                });
                context_1.emitter.trigger('eventChange', {
                    oldEvent: oldEvent,
                    event: this,
                    relatedEvents: buildEventApis(relevantEvents, context_1, instance),
                    revert: function () {
                        context_1.dispatch({
                            type: 'RESET_EVENTS',
                            eventStore: eventStore_1,
                        });
                    },
                });
            }
        };
        EventApi.prototype.remove = function () {
            var context = this._context;
            var asStore = eventApiToStore(this);
            context.dispatch({
                type: 'REMOVE_EVENTS',
                eventStore: asStore,
            });
            context.emitter.trigger('eventRemove', {
                event: this,
                relatedEvents: [],
                revert: function () {
                    context.dispatch({
                        type: 'MERGE_EVENTS',
                        eventStore: asStore,
                    });
                },
            });
        };
        Object.defineProperty(EventApi.prototype, "source", {
            get: function () {
                var sourceId = this._def.sourceId;
                if (sourceId) {
                    return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "start", {
            get: function () {
                return this._instance ?
                    this._context.dateEnv.toDate(this._instance.range.start) :
                    null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "end", {
            get: function () {
                return (this._instance && this._def.hasEnd) ?
                    this._context.dateEnv.toDate(this._instance.range.end) :
                    null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "startStr", {
            get: function () {
                var instance = this._instance;
                if (instance) {
                    return this._context.dateEnv.formatIso(instance.range.start, {
                        omitTime: this._def.allDay,
                        forcedTzo: instance.forcedStartTzo,
                    });
                }
                return '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "endStr", {
            get: function () {
                var instance = this._instance;
                if (instance && this._def.hasEnd) {
                    return this._context.dateEnv.formatIso(instance.range.end, {
                        omitTime: this._def.allDay,
                        forcedTzo: instance.forcedEndTzo,
                    });
                }
                return '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "id", {
            // computable props that all access the def
            // TODO: find a TypeScript-compatible way to do this at scale
            get: function () { return this._def.publicId; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "groupId", {
            get: function () { return this._def.groupId; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "allDay", {
            get: function () { return this._def.allDay; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "title", {
            get: function () { return this._def.title; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "url", {
            get: function () { return this._def.url; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "display", {
            get: function () { return this._def.ui.display || 'auto'; } // bad. just normalize the type earlier
            ,
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "startEditable", {
            get: function () { return this._def.ui.startEditable; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "durationEditable", {
            get: function () { return this._def.ui.durationEditable; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "constraint", {
            get: function () { return this._def.ui.constraints[0] || null; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "overlap", {
            get: function () { return this._def.ui.overlap; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "allow", {
            get: function () { return this._def.ui.allows[0] || null; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "backgroundColor", {
            get: function () { return this._def.ui.backgroundColor; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "borderColor", {
            get: function () { return this._def.ui.borderColor; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "textColor", {
            get: function () { return this._def.ui.textColor; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "classNames", {
            // NOTE: user can't modify these because Object.freeze was called in event-def parsing
            get: function () { return this._def.ui.classNames; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EventApi.prototype, "extendedProps", {
            get: function () { return this._def.extendedProps; },
            enumerable: false,
            configurable: true
        });
        EventApi.prototype.toPlainObject = function (settings) {
            if (settings === void 0) { settings = {}; }
            var def = this._def;
            var ui = def.ui;
            var _a = this, startStr = _a.startStr, endStr = _a.endStr;
            var res = {};
            if (def.title) {
                res.title = def.title;
            }
            if (startStr) {
                res.start = startStr;
            }
            if (endStr) {
                res.end = endStr;
            }
            if (def.publicId) {
                res.id = def.publicId;
            }
            if (def.groupId) {
                res.groupId = def.groupId;
            }
            if (def.url) {
                res.url = def.url;
            }
            if (ui.display && ui.display !== 'auto') {
                res.display = ui.display;
            }
            // TODO: what about recurring-event properties???
            // TODO: include startEditable/durationEditable/constraint/overlap/allow
            if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
                res.color = ui.backgroundColor;
            }
            else {
                if (ui.backgroundColor) {
                    res.backgroundColor = ui.backgroundColor;
                }
                if (ui.borderColor) {
                    res.borderColor = ui.borderColor;
                }
            }
            if (ui.textColor) {
                res.textColor = ui.textColor;
            }
            if (ui.classNames.length) {
                res.classNames = ui.classNames;
            }
            if (Object.keys(def.extendedProps).length) {
                if (settings.collapseExtendedProps) {
                    __assign(res, def.extendedProps);
                }
                else {
                    res.extendedProps = def.extendedProps;
                }
            }
            return res;
        };
        EventApi.prototype.toJSON = function () {
            return this.toPlainObject();
        };
        return EventApi;
    }());
    function eventApiToStore(eventApi) {
        var _a, _b;
        var def = eventApi._def;
        var instance = eventApi._instance;
        return {
            defs: (_a = {}, _a[def.defId] = def, _a),
            instances: instance
                ? (_b = {}, _b[instance.instanceId] = instance, _b) : {},
        };
    }
    function buildEventApis(eventStore, context, excludeInstance) {
        var defs = eventStore.defs, instances = eventStore.instances;
        var eventApis = [];
        var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';
        for (var id in instances) {
            var instance = instances[id];
            var def = defs[instance.defId];
            if (instance.instanceId !== excludeInstanceId) {
                eventApis.push(new EventApi(context, def, instance));
            }
        }
        return eventApis;
    }

    var calendarSystemClassMap = {};
    function registerCalendarSystem(name, theClass) {
        calendarSystemClassMap[name] = theClass;
    }
    function createCalendarSystem(name) {
        return new calendarSystemClassMap[name]();
    }
    var GregorianCalendarSystem = /** @class */ (function () {
        function GregorianCalendarSystem() {
        }
        GregorianCalendarSystem.prototype.getMarkerYear = function (d) {
            return d.getUTCFullYear();
        };
        GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {
            return d.getUTCMonth();
        };
        GregorianCalendarSystem.prototype.getMarkerDay = function (d) {
            return d.getUTCDate();
        };
        GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {
            return arrayToUtcDate(arr);
        };
        GregorianCalendarSystem.prototype.markerToArray = function (marker) {
            return dateToUtcArray(marker);
        };
        return GregorianCalendarSystem;
    }());
    registerCalendarSystem('gregory', GregorianCalendarSystem);

    var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
    function parse(str) {
        var m = ISO_RE.exec(str);
        if (m) {
            var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number("0." + m[12]) * 1000 : 0));
            if (isValidDate(marker)) {
                var timeZoneOffset = null;
                if (m[13]) {
                    timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 +
                        Number(m[18] || 0));
                }
                return {
                    marker: marker,
                    isTimeUnspecified: !m[6],
                    timeZoneOffset: timeZoneOffset,
                };
            }
        }
        return null;
    }

    var DateEnv = /** @class */ (function () {
        function DateEnv(settings) {
            var timeZone = this.timeZone = settings.timeZone;
            var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';
            if (settings.namedTimeZoneImpl && isNamedTimeZone) {
                this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
            }
            this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
            this.calendarSystem = createCalendarSystem(settings.calendarSystem);
            this.locale = settings.locale;
            this.weekDow = settings.locale.week.dow;
            this.weekDoy = settings.locale.week.doy;
            if (settings.weekNumberCalculation === 'ISO') {
                this.weekDow = 1;
                this.weekDoy = 4;
            }
            if (typeof settings.firstDay === 'number') {
                this.weekDow = settings.firstDay;
            }
            if (typeof settings.weekNumberCalculation === 'function') {
                this.weekNumberFunc = settings.weekNumberCalculation;
            }
            this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
            this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
            this.cmdFormatter = settings.cmdFormatter;
            this.defaultSeparator = settings.defaultSeparator;
        }
        // Creating / Parsing
        DateEnv.prototype.createMarker = function (input) {
            var meta = this.createMarkerMeta(input);
            if (meta === null) {
                return null;
            }
            return meta.marker;
        };
        DateEnv.prototype.createNowMarker = function () {
            if (this.canComputeOffset) {
                return this.timestampToMarker(new Date().valueOf());
            }
            // if we can't compute the current date val for a timezone,
            // better to give the current local date vals than UTC
            return arrayToUtcDate(dateToLocalArray(new Date()));
        };
        DateEnv.prototype.createMarkerMeta = function (input) {
            if (typeof input === 'string') {
                return this.parse(input);
            }
            var marker = null;
            if (typeof input === 'number') {
                marker = this.timestampToMarker(input);
            }
            else if (input instanceof Date) {
                input = input.valueOf();
                if (!isNaN(input)) {
                    marker = this.timestampToMarker(input);
                }
            }
            else if (Array.isArray(input)) {
                marker = arrayToUtcDate(input);
            }
            if (marker === null || !isValidDate(marker)) {
                return null;
            }
            return { marker: marker, isTimeUnspecified: false, forcedTzo: null };
        };
        DateEnv.prototype.parse = function (s) {
            var parts = parse(s);
            if (parts === null) {
                return null;
            }
            var marker = parts.marker;
            var forcedTzo = null;
            if (parts.timeZoneOffset !== null) {
                if (this.canComputeOffset) {
                    marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);
                }
                else {
                    forcedTzo = parts.timeZoneOffset;
                }
            }
            return { marker: marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo: forcedTzo };
        };
        // Accessors
        DateEnv.prototype.getYear = function (marker) {
            return this.calendarSystem.getMarkerYear(marker);
        };
        DateEnv.prototype.getMonth = function (marker) {
            return this.calendarSystem.getMarkerMonth(marker);
        };
        // Adding / Subtracting
        DateEnv.prototype.add = function (marker, dur) {
            var a = this.calendarSystem.markerToArray(marker);
            a[0] += dur.years;
            a[1] += dur.months;
            a[2] += dur.days;
            a[6] += dur.milliseconds;
            return this.calendarSystem.arrayToMarker(a);
        };
        DateEnv.prototype.subtract = function (marker, dur) {
            var a = this.calendarSystem.markerToArray(marker);
            a[0] -= dur.years;
            a[1] -= dur.months;
            a[2] -= dur.days;
            a[6] -= dur.milliseconds;
            return this.calendarSystem.arrayToMarker(a);
        };
        DateEnv.prototype.addYears = function (marker, n) {
            var a = this.calendarSystem.markerToArray(marker);
            a[0] += n;
            return this.calendarSystem.arrayToMarker(a);
        };
        DateEnv.prototype.addMonths = function (marker, n) {
            var a = this.calendarSystem.markerToArray(marker);
            a[1] += n;
            return this.calendarSystem.arrayToMarker(a);
        };
        // Diffing Whole Units
        DateEnv.prototype.diffWholeYears = function (m0, m1) {
            var calendarSystem = this.calendarSystem;
            if (timeAsMs(m0) === timeAsMs(m1) &&
                calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) &&
                calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
                return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
            }
            return null;
        };
        DateEnv.prototype.diffWholeMonths = function (m0, m1) {
            var calendarSystem = this.calendarSystem;
            if (timeAsMs(m0) === timeAsMs(m1) &&
                calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
                return (calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0)) +
                    (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
            }
            return null;
        };
        // Range / Duration
        DateEnv.prototype.greatestWholeUnit = function (m0, m1) {
            var n = this.diffWholeYears(m0, m1);
            if (n !== null) {
                return { unit: 'year', value: n };
            }
            n = this.diffWholeMonths(m0, m1);
            if (n !== null) {
                return { unit: 'month', value: n };
            }
            n = diffWholeWeeks(m0, m1);
            if (n !== null) {
                return { unit: 'week', value: n };
            }
            n = diffWholeDays(m0, m1);
            if (n !== null) {
                return { unit: 'day', value: n };
            }
            n = diffHours(m0, m1);
            if (isInt(n)) {
                return { unit: 'hour', value: n };
            }
            n = diffMinutes(m0, m1);
            if (isInt(n)) {
                return { unit: 'minute', value: n };
            }
            n = diffSeconds(m0, m1);
            if (isInt(n)) {
                return { unit: 'second', value: n };
            }
            return { unit: 'millisecond', value: m1.valueOf() - m0.valueOf() };
        };
        DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {
            // TODO: can use greatestWholeUnit
            var diff;
            if (d.years) {
                diff = this.diffWholeYears(m0, m1);
                if (diff !== null) {
                    return diff / asRoughYears(d);
                }
            }
            if (d.months) {
                diff = this.diffWholeMonths(m0, m1);
                if (diff !== null) {
                    return diff / asRoughMonths(d);
                }
            }
            if (d.days) {
                diff = diffWholeDays(m0, m1);
                if (diff !== null) {
                    return diff / asRoughDays(d);
                }
            }
            return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);
        };
        // Start-Of
        // these DON'T return zoned-dates. only UTC start-of dates
        DateEnv.prototype.startOf = function (m, unit) {
            if (unit === 'year') {
                return this.startOfYear(m);
            }
            if (unit === 'month') {
                return this.startOfMonth(m);
            }
            if (unit === 'week') {
                return this.startOfWeek(m);
            }
            if (unit === 'day') {
                return startOfDay$1(m);
            }
            if (unit === 'hour') {
                return startOfHour(m);
            }
            if (unit === 'minute') {
                return startOfMinute(m);
            }
            if (unit === 'second') {
                return startOfSecond(m);
            }
            return null;
        };
        DateEnv.prototype.startOfYear = function (m) {
            return this.calendarSystem.arrayToMarker([
                this.calendarSystem.getMarkerYear(m),
            ]);
        };
        DateEnv.prototype.startOfMonth = function (m) {
            return this.calendarSystem.arrayToMarker([
                this.calendarSystem.getMarkerYear(m),
                this.calendarSystem.getMarkerMonth(m),
            ]);
        };
        DateEnv.prototype.startOfWeek = function (m) {
            return this.calendarSystem.arrayToMarker([
                this.calendarSystem.getMarkerYear(m),
                this.calendarSystem.getMarkerMonth(m),
                m.getUTCDate() - ((m.getUTCDay() - this.weekDow + 7) % 7),
            ]);
        };
        // Week Number
        DateEnv.prototype.computeWeekNumber = function (marker) {
            if (this.weekNumberFunc) {
                return this.weekNumberFunc(this.toDate(marker));
            }
            return weekOfYear(marker, this.weekDow, this.weekDoy);
        };
        // TODO: choke on timeZoneName: long
        DateEnv.prototype.format = function (marker, formatter, dateOptions) {
            if (dateOptions === void 0) { dateOptions = {}; }
            return formatter.format({
                marker: marker,
                timeZoneOffset: dateOptions.forcedTzo != null ?
                    dateOptions.forcedTzo :
                    this.offsetForMarker(marker),
            }, this);
        };
        DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {
            if (dateOptions === void 0) { dateOptions = {}; }
            if (dateOptions.isEndExclusive) {
                end = addMs(end, -1);
            }
            return formatter.formatRange({
                marker: start,
                timeZoneOffset: dateOptions.forcedStartTzo != null ?
                    dateOptions.forcedStartTzo :
                    this.offsetForMarker(start),
            }, {
                marker: end,
                timeZoneOffset: dateOptions.forcedEndTzo != null ?
                    dateOptions.forcedEndTzo :
                    this.offsetForMarker(end),
            }, this, dateOptions.defaultSeparator);
        };
        /*
        DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
        might as well use buildIsoString or some other util directly
        */
        DateEnv.prototype.formatIso = function (marker, extraOptions) {
            if (extraOptions === void 0) { extraOptions = {}; }
            var timeZoneOffset = null;
            if (!extraOptions.omitTimeZoneOffset) {
                if (extraOptions.forcedTzo != null) {
                    timeZoneOffset = extraOptions.forcedTzo;
                }
                else {
                    timeZoneOffset = this.offsetForMarker(marker);
                }
            }
            return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
        };
        // TimeZone
        DateEnv.prototype.timestampToMarker = function (ms) {
            if (this.timeZone === 'local') {
                return arrayToUtcDate(dateToLocalArray(new Date(ms)));
            }
            if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {
                return new Date(ms);
            }
            return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
        };
        DateEnv.prototype.offsetForMarker = function (m) {
            if (this.timeZone === 'local') {
                return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert "inverse" offset to "normal" offset
            }
            if (this.timeZone === 'UTC') {
                return 0;
            }
            if (this.namedTimeZoneImpl) {
                return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));
            }
            return null;
        };
        // Conversion
        DateEnv.prototype.toDate = function (m, forcedTzo) {
            if (this.timeZone === 'local') {
                return arrayToLocalDate(dateToUtcArray(m));
            }
            if (this.timeZone === 'UTC') {
                return new Date(m.valueOf()); // make sure it's a copy
            }
            if (!this.namedTimeZoneImpl) {
                return new Date(m.valueOf() - (forcedTzo || 0));
            }
            return new Date(m.valueOf() -
                this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);
        };
        return DateEnv;
    }());

    var globalLocales = [];

    var MINIMAL_RAW_EN_LOCALE = {
        code: 'en',
        week: {
            dow: 0,
            doy: 4, // 4 days need to be within the year to be considered the first week
        },
        direction: 'ltr',
        buttonText: {
            prev: 'prev',
            next: 'next',
            prevYear: 'prev year',
            nextYear: 'next year',
            year: 'year',
            today: 'today',
            month: 'month',
            week: 'week',
            day: 'day',
            list: 'list',
        },
        weekText: 'W',
        weekTextLong: 'Week',
        closeHint: 'Close',
        timeHint: 'Time',
        eventHint: 'Event',
        allDayText: 'all-day',
        moreLinkText: 'more',
        noEventsText: 'No events to display',
    };
    var RAW_EN_LOCALE = __assign(__assign({}, MINIMAL_RAW_EN_LOCALE), { 
        // Includes things we don't want other locales to inherit,
        // things that derive from other translatable strings.
        buttonHints: {
            prev: 'Previous $0',
            next: 'Next $0',
            today: function (buttonText, unit) {
                return (unit === 'day')
                    ? 'Today'
                    : "This " + buttonText;
            },
        }, viewHint: '$0 view', navLinkHint: 'Go to $0', moreLinkHint: function (eventCnt) {
            return "Show " + eventCnt + " more event" + (eventCnt === 1 ? '' : 's');
        } });
    function organizeRawLocales(explicitRawLocales) {
        var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';
        var allRawLocales = globalLocales.concat(explicitRawLocales);
        var rawLocaleMap = {
            en: RAW_EN_LOCALE,
        };
        for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {
            var rawLocale = allRawLocales_1[_i];
            rawLocaleMap[rawLocale.code] = rawLocale;
        }
        return {
            map: rawLocaleMap,
            defaultCode: defaultCode,
        };
    }
    function buildLocale(inputSingular, available) {
        if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {
            return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
        }
        return queryLocale(inputSingular, available);
    }
    function queryLocale(codeArg, available) {
        var codes = [].concat(codeArg || []); // will convert to array
        var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
        return parseLocale(codeArg, codes, raw);
    }
    function queryRawLocale(codes, available) {
        for (var i = 0; i < codes.length; i += 1) {
            var parts = codes[i].toLocaleLowerCase().split('-');
            for (var j = parts.length; j > 0; j -= 1) {
                var simpleId = parts.slice(0, j).join('-');
                if (available[simpleId]) {
                    return available[simpleId];
                }
            }
        }
        return null;
    }
    function parseLocale(codeArg, codes, raw) {
        var merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ['buttonText']);
        delete merged.code; // don't want this part of the options
        var week = merged.week;
        delete merged.week;
        return {
            codeArg: codeArg,
            codes: codes,
            week: week,
            simpleNumberFormat: new Intl.NumberFormat(codeArg),
            options: merged,
        };
    }

    var DEF_DEFAULTS = {
        startTime: '09:00',
        endTime: '17:00',
        daysOfWeek: [1, 2, 3, 4, 5],
        display: 'inverse-background',
        classNames: 'fc-non-business',
        groupId: '_businessHours', // so multiple defs get grouped
    };
    /*
    TODO: pass around as EventDefHash!!!
    */
    function parseBusinessHours(input, context) {
        return parseEvents(refineInputs(input), null, context);
    }
    function refineInputs(input) {
        var rawDefs;
        if (input === true) {
            rawDefs = [{}]; // will get DEF_DEFAULTS verbatim
        }
        else if (Array.isArray(input)) {
            // if specifying an array, every sub-definition NEEDS a day-of-week
            rawDefs = input.filter(function (rawDef) { return rawDef.daysOfWeek; });
        }
        else if (typeof input === 'object' && input) { // non-null object
            rawDefs = [input];
        }
        else { // is probably false
            rawDefs = [];
        }
        rawDefs = rawDefs.map(function (rawDef) { return (__assign(__assign({}, DEF_DEFAULTS), rawDef)); });
        return rawDefs;
    }

    function pointInsideRect(point, rect) {
        return point.left >= rect.left &&
            point.left < rect.right &&
            point.top >= rect.top &&
            point.top < rect.bottom;
    }
    // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
    function intersectRects(rect1, rect2) {
        var res = {
            left: Math.max(rect1.left, rect2.left),
            right: Math.min(rect1.right, rect2.right),
            top: Math.max(rect1.top, rect2.top),
            bottom: Math.min(rect1.bottom, rect2.bottom),
        };
        if (res.left < res.right && res.top < res.bottom) {
            return res;
        }
        return false;
    }
    // Returns a new point that will have been moved to reside within the given rectangle
    function constrainPoint(point, rect) {
        return {
            left: Math.min(Math.max(point.left, rect.left), rect.right),
            top: Math.min(Math.max(point.top, rect.top), rect.bottom),
        };
    }
    // Returns a point that is the center of the given rectangle
    function getRectCenter(rect) {
        return {
            left: (rect.left + rect.right) / 2,
            top: (rect.top + rect.bottom) / 2,
        };
    }
    // Subtracts point2's coordinates from point1's coordinates, returning a delta
    function diffPoints(point1, point2) {
        return {
            left: point1.left - point2.left,
            top: point1.top - point2.top,
        };
    }

    var canVGrowWithinCell;
    function getCanVGrowWithinCell() {
        if (canVGrowWithinCell == null) {
            canVGrowWithinCell = computeCanVGrowWithinCell();
        }
        return canVGrowWithinCell;
    }
    function computeCanVGrowWithinCell() {
        // for SSR, because this function is call immediately at top-level
        // TODO: just make this logic execute top-level, immediately, instead of doing lazily
        if (typeof document === 'undefined') {
            return true;
        }
        var el = document.createElement('div');
        el.style.position = 'absolute';
        el.style.top = '0px';
        el.style.left = '0px';
        el.innerHTML = '<table><tr><td><div></div></td></tr></table>';
        el.querySelector('table').style.height = '100px';
        el.querySelector('div').style.height = '100%';
        document.body.appendChild(el);
        var div = el.querySelector('div');
        var possible = div.offsetHeight > 0;
        document.body.removeChild(el);
        return possible;
    }

    function getDateMeta(date, todayRange, nowDate, dateProfile) {
        return {
            dow: date.getUTCDay(),
            isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),
            isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
            isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
            isPast: Boolean(nowDate ? (date < nowDate) : todayRange ? (date < todayRange.start) : false),
            isFuture: Boolean(nowDate ? (date > nowDate) : todayRange ? (date >= todayRange.end) : false),
        };
    }
    function getDayClassNames(meta, theme) {
        var classNames = [
            'fc-day',
            "fc-day-" + DAY_IDS[meta.dow],
        ];
        if (meta.isDisabled) {
            classNames.push('fc-day-disabled');
        }
        else {
            if (meta.isToday) {
                classNames.push('fc-day-today');
                classNames.push(theme.getClass('today'));
            }
            if (meta.isPast) {
                classNames.push('fc-day-past');
            }
            if (meta.isFuture) {
                classNames.push('fc-day-future');
            }
            if (meta.isOther) {
                classNames.push('fc-day-other');
            }
        }
        return classNames;
    }

    var DAY_FORMAT = createFormatter({ year: 'numeric', month: 'long', day: 'numeric' });
    var WEEK_FORMAT = createFormatter({ week: 'long' });
    function buildNavLinkAttrs(context, dateMarker, viewType, isTabbable) {
        if (viewType === void 0) { viewType = 'day'; }
        if (isTabbable === void 0) { isTabbable = true; }
        var dateEnv = context.dateEnv, options = context.options, calendarApi = context.calendarApi;
        var dateStr = dateEnv.format(dateMarker, viewType === 'week' ? WEEK_FORMAT : DAY_FORMAT);
        if (options.navLinks) {
            var zonedDate = dateEnv.toDate(dateMarker);
            var handleInteraction = function (ev) {
                var customAction = viewType === 'day' ? options.navLinkDayClick :
                    viewType === 'week' ? options.navLinkWeekClick : null;
                if (typeof customAction === 'function') {
                    customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
                }
                else {
                    if (typeof customAction === 'string') {
                        viewType = customAction;
                    }
                    calendarApi.zoomTo(dateMarker, viewType);
                }
            };
            return __assign({ title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr), 'data-navlink': '' }, (isTabbable
                ? createAriaClickAttrs(handleInteraction)
                : { onClick: handleInteraction }));
        }
        return { 'aria-label': dateStr };
    }

    var _isRtlScrollbarOnLeft = null;
    function getIsRtlScrollbarOnLeft() {
        if (_isRtlScrollbarOnLeft === null) {
            _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
        }
        return _isRtlScrollbarOnLeft;
    }
    function computeIsRtlScrollbarOnLeft() {
        var outerEl = document.createElement('div');
        applyStyle(outerEl, {
            position: 'absolute',
            top: -1000,
            left: 0,
            border: 0,
            padding: 0,
            overflow: 'scroll',
            direction: 'rtl',
        });
        outerEl.innerHTML = '<div></div>';
        document.body.appendChild(outerEl);
        var innerEl = outerEl.firstChild;
        var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
        removeElement(outerEl);
        return res;
    }

    var _scrollbarWidths;
    function getScrollbarWidths() {
        if (!_scrollbarWidths) {
            _scrollbarWidths = computeScrollbarWidths();
        }
        return _scrollbarWidths;
    }
    function computeScrollbarWidths() {
        var el = document.createElement('div');
        el.style.overflow = 'scroll';
        el.style.position = 'absolute';
        el.style.top = '-9999px';
        el.style.left = '-9999px';
        document.body.appendChild(el);
        var res = computeScrollbarWidthsForEl(el);
        document.body.removeChild(el);
        return res;
    }
    // WARNING: will include border
    function computeScrollbarWidthsForEl(el) {
        return {
            x: el.offsetHeight - el.clientHeight,
            y: el.offsetWidth - el.clientWidth,
        };
    }

    function computeEdges(el, getPadding) {
        if (getPadding === void 0) { getPadding = false; }
        var computedStyle = window.getComputedStyle(el);
        var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
        var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
        var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
        var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
        var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!
        var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
        var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
        var res = {
            borderLeft: borderLeft,
            borderRight: borderRight,
            borderTop: borderTop,
            borderBottom: borderBottom,
            scrollbarBottom: scrollbarBottom,
            scrollbarLeft: 0,
            scrollbarRight: 0,
        };
        if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') { // is the scrollbar on the left side?
            res.scrollbarLeft = scrollbarLeftRight;
        }
        else {
            res.scrollbarRight = scrollbarLeftRight;
        }
        if (getPadding) {
            res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
            res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
            res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
            res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
        }
        return res;
    }
    function computeInnerRect(el, goWithinPadding, doFromWindowViewport) {
        if (goWithinPadding === void 0) { goWithinPadding = false; }
        var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
        var edges = computeEdges(el, goWithinPadding);
        var res = {
            left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
            right: outerRect.right - edges.borderRight - edges.scrollbarRight,
            top: outerRect.top + edges.borderTop,
            bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom,
        };
        if (goWithinPadding) {
            res.left += edges.paddingLeft;
            res.right -= edges.paddingRight;
            res.top += edges.paddingTop;
            res.bottom -= edges.paddingBottom;
        }
        return res;
    }
    function computeRect(el) {
        var rect = el.getBoundingClientRect();
        return {
            left: rect.left + window.pageXOffset,
            top: rect.top + window.pageYOffset,
            right: rect.right + window.pageXOffset,
            bottom: rect.bottom + window.pageYOffset,
        };
    }
    function computeClippedClientRect(el) {
        var clippingParents = getClippingParents(el);
        var rect = el.getBoundingClientRect();
        for (var _i = 0, clippingParents_1 = clippingParents; _i < clippingParents_1.length; _i++) {
            var clippingParent = clippingParents_1[_i];
            var intersection = intersectRects(rect, clippingParent.getBoundingClientRect());
            if (intersection) {
                rect = intersection;
            }
            else {
                return null;
            }
        }
        return rect;
    }
    // does not return window
    function getClippingParents(el) {
        var parents = [];
        while (el instanceof HTMLElement) { // will stop when gets to document or null
            var computedStyle = window.getComputedStyle(el);
            if (computedStyle.position === 'fixed') {
                break;
            }
            if ((/(auto|scroll)/).test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
                parents.push(el);
            }
            el = el.parentNode;
        }
        return parents;
    }

    // given a function that resolves a result asynchronously.
    // the function can either call passed-in success and failure callbacks,
    // or it can return a promise.
    // if you need to pass additional params to func, bind them first.
    function unpromisify(func, success, failure) {
        // guard against success/failure callbacks being called more than once
        // and guard against a promise AND callback being used together.
        var isResolved = false;
        var wrappedSuccess = function () {
            if (!isResolved) {
                isResolved = true;
                success.apply(this, arguments); // eslint-disable-line prefer-rest-params
            }
        };
        var wrappedFailure = function () {
            if (!isResolved) {
                isResolved = true;
                if (failure) {
                    failure.apply(this, arguments); // eslint-disable-line prefer-rest-params
                }
            }
        };
        var res = func(wrappedSuccess, wrappedFailure);
        if (res && typeof res.then === 'function') {
            res.then(wrappedSuccess, wrappedFailure);
        }
    }

    var Emitter = /** @class */ (function () {
        function Emitter() {
            this.handlers = {};
            this.thisContext = null;
        }
        Emitter.prototype.setThisContext = function (thisContext) {
            this.thisContext = thisContext;
        };
        Emitter.prototype.setOptions = function (options) {
            this.options = options;
        };
        Emitter.prototype.on = function (type, handler) {
            addToHash(this.handlers, type, handler);
        };
        Emitter.prototype.off = function (type, handler) {
            removeFromHash(this.handlers, type, handler);
        };
        Emitter.prototype.trigger = function (type) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var attachedHandlers = this.handlers[type] || [];
            var optionHandler = this.options && this.options[type];
            var handlers = [].concat(optionHandler || [], attachedHandlers);
            for (var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++) {
                var handler = handlers_1[_a];
                handler.apply(this.thisContext, args);
            }
        };
        Emitter.prototype.hasHandlers = function (type) {
            return Boolean((this.handlers[type] && this.handlers[type].length) ||
                (this.options && this.options[type]));
        };
        return Emitter;
    }());
    function addToHash(hash, type, handler) {
        (hash[type] || (hash[type] = []))
            .push(handler);
    }
    function removeFromHash(hash, type, handler) {
        if (handler) {
            if (hash[type]) {
                hash[type] = hash[type].filter(function (func) { return func !== handler; });
            }
        }
        else {
            delete hash[type]; // remove all handler funcs for this type
        }
    }

    /*
    Records offset information for a set of elements, relative to an origin element.
    Can record the left/right OR the top/bottom OR both.
    Provides methods for querying the cache by position.
    */
    var PositionCache = /** @class */ (function () {
        function PositionCache(originEl, els, isHorizontal, isVertical) {
            this.els = els;
            var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left
            if (isHorizontal) {
                this.buildElHorizontals(originClientRect.left);
            }
            if (isVertical) {
                this.buildElVerticals(originClientRect.top);
            }
        }
        // Populates the left/right internal coordinate arrays
        PositionCache.prototype.buildElHorizontals = function (originClientLeft) {
            var lefts = [];
            var rights = [];
            for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
                var el = _a[_i];
                var rect = el.getBoundingClientRect();
                lefts.push(rect.left - originClientLeft);
                rights.push(rect.right - originClientLeft);
            }
            this.lefts = lefts;
            this.rights = rights;
        };
        // Populates the top/bottom internal coordinate arrays
        PositionCache.prototype.buildElVerticals = function (originClientTop) {
            var tops = [];
            var bottoms = [];
            for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
                var el = _a[_i];
                var rect = el.getBoundingClientRect();
                tops.push(rect.top - originClientTop);
                bottoms.push(rect.bottom - originClientTop);
            }
            this.tops = tops;
            this.bottoms = bottoms;
        };
        // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
        // If no intersection is made, returns undefined.
        PositionCache.prototype.leftToIndex = function (leftPosition) {
            var _a = this, lefts = _a.lefts, rights = _a.rights;
            var len = lefts.length;
            var i;
            for (i = 0; i < len; i += 1) {
                if (leftPosition >= lefts[i] && leftPosition < rights[i]) {
                    return i;
                }
            }
            return undefined; // TODO: better
        };
        // Given a top offset (from document top), returns the index of the el that it vertically intersects.
        // If no intersection is made, returns undefined.
        PositionCache.prototype.topToIndex = function (topPosition) {
            var _a = this, tops = _a.tops, bottoms = _a.bottoms;
            var len = tops.length;
            var i;
            for (i = 0; i < len; i += 1) {
                if (topPosition >= tops[i] && topPosition < bottoms[i]) {
                    return i;
                }
            }
            return undefined; // TODO: better
        };
        // Gets the width of the element at the given index
        PositionCache.prototype.getWidth = function (leftIndex) {
            return this.rights[leftIndex] - this.lefts[leftIndex];
        };
        // Gets the height of the element at the given index
        PositionCache.prototype.getHeight = function (topIndex) {
            return this.bottoms[topIndex] - this.tops[topIndex];
        };
        return PositionCache;
    }());

    /* eslint max-classes-per-file: "off" */
    /*
    An object for getting/setting scroll-related information for an element.
    Internally, this is done very differently for window versus DOM element,
    so this object serves as a common interface.
    */
    var ScrollController = /** @class */ (function () {
        function ScrollController() {
        }
        ScrollController.prototype.getMaxScrollTop = function () {
            return this.getScrollHeight() - this.getClientHeight();
        };
        ScrollController.prototype.getMaxScrollLeft = function () {
            return this.getScrollWidth() - this.getClientWidth();
        };
        ScrollController.prototype.canScrollVertically = function () {
            return this.getMaxScrollTop() > 0;
        };
        ScrollController.prototype.canScrollHorizontally = function () {
            return this.getMaxScrollLeft() > 0;
        };
        ScrollController.prototype.canScrollUp = function () {
            return this.getScrollTop() > 0;
        };
        ScrollController.prototype.canScrollDown = function () {
            return this.getScrollTop() < this.getMaxScrollTop();
        };
        ScrollController.prototype.canScrollLeft = function () {
            return this.getScrollLeft() > 0;
        };
        ScrollController.prototype.canScrollRight = function () {
            return this.getScrollLeft() < this.getMaxScrollLeft();
        };
        return ScrollController;
    }());
    var ElementScrollController = /** @class */ (function (_super) {
        __extends(ElementScrollController, _super);
        function ElementScrollController(el) {
            var _this = _super.call(this) || this;
            _this.el = el;
            return _this;
        }
        ElementScrollController.prototype.getScrollTop = function () {
            return this.el.scrollTop;
        };
        ElementScrollController.prototype.getScrollLeft = function () {
            return this.el.scrollLeft;
        };
        ElementScrollController.prototype.setScrollTop = function (top) {
            this.el.scrollTop = top;
        };
        ElementScrollController.prototype.setScrollLeft = function (left) {
            this.el.scrollLeft = left;
        };
        ElementScrollController.prototype.getScrollWidth = function () {
            return this.el.scrollWidth;
        };
        ElementScrollController.prototype.getScrollHeight = function () {
            return this.el.scrollHeight;
        };
        ElementScrollController.prototype.getClientHeight = function () {
            return this.el.clientHeight;
        };
        ElementScrollController.prototype.getClientWidth = function () {
            return this.el.clientWidth;
        };
        return ElementScrollController;
    }(ScrollController));
    var WindowScrollController = /** @class */ (function (_super) {
        __extends(WindowScrollController, _super);
        function WindowScrollController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WindowScrollController.prototype.getScrollTop = function () {
            return window.pageYOffset;
        };
        WindowScrollController.prototype.getScrollLeft = function () {
            return window.pageXOffset;
        };
        WindowScrollController.prototype.setScrollTop = function (n) {
            window.scroll(window.pageXOffset, n);
        };
        WindowScrollController.prototype.setScrollLeft = function (n) {
            window.scroll(n, window.pageYOffset);
        };
        WindowScrollController.prototype.getScrollWidth = function () {
            return document.documentElement.scrollWidth;
        };
        WindowScrollController.prototype.getScrollHeight = function () {
            return document.documentElement.scrollHeight;
        };
        WindowScrollController.prototype.getClientHeight = function () {
            return document.documentElement.clientHeight;
        };
        WindowScrollController.prototype.getClientWidth = function () {
            return document.documentElement.clientWidth;
        };
        return WindowScrollController;
    }(ScrollController));

    var Theme = /** @class */ (function () {
        function Theme(calendarOptions) {
            if (this.iconOverrideOption) {
                this.setIconOverride(calendarOptions[this.iconOverrideOption]);
            }
        }
        Theme.prototype.setIconOverride = function (iconOverrideHash) {
            var iconClassesCopy;
            var buttonName;
            if (typeof iconOverrideHash === 'object' && iconOverrideHash) { // non-null object
                iconClassesCopy = __assign({}, this.iconClasses);
                for (buttonName in iconOverrideHash) {
                    iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
                }
                this.iconClasses = iconClassesCopy;
            }
            else if (iconOverrideHash === false) {
                this.iconClasses = {};
            }
        };
        Theme.prototype.applyIconOverridePrefix = function (className) {
            var prefix = this.iconOverridePrefix;
            if (prefix && className.indexOf(prefix) !== 0) { // if not already present
                className = prefix + className;
            }
            return className;
        };
        Theme.prototype.getClass = function (key) {
            return this.classes[key] || '';
        };
        Theme.prototype.getIconClass = function (buttonName, isRtl) {
            var className;
            if (isRtl && this.rtlIconClasses) {
                className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
            }
            else {
                className = this.iconClasses[buttonName];
            }
            if (className) {
                return this.baseIconClass + " " + className;
            }
            return '';
        };
        Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {
            var className;
            if (this.iconOverrideCustomButtonOption) {
                className = customButtonProps[this.iconOverrideCustomButtonOption];
                if (className) {
                    return this.baseIconClass + " " + this.applyIconOverridePrefix(className);
                }
            }
            return '';
        };
        return Theme;
    }());
    Theme.prototype.classes = {};
    Theme.prototype.iconClasses = {};
    Theme.prototype.baseIconClass = '';
    Theme.prototype.iconOverridePrefix = '';

    var ScrollResponder = /** @class */ (function () {
        function ScrollResponder(execFunc, emitter, scrollTime, scrollTimeReset) {
            var _this = this;
            this.execFunc = execFunc;
            this.emitter = emitter;
            this.scrollTime = scrollTime;
            this.scrollTimeReset = scrollTimeReset;
            this.handleScrollRequest = function (request) {
                _this.queuedRequest = __assign({}, _this.queuedRequest || {}, request);
                _this.drain();
            };
            emitter.on('_scrollRequest', this.handleScrollRequest);
            this.fireInitialScroll();
        }
        ScrollResponder.prototype.detach = function () {
            this.emitter.off('_scrollRequest', this.handleScrollRequest);
        };
        ScrollResponder.prototype.update = function (isDatesNew) {
            if (isDatesNew && this.scrollTimeReset) {
                this.fireInitialScroll(); // will drain
            }
            else {
                this.drain();
            }
        };
        ScrollResponder.prototype.fireInitialScroll = function () {
            this.handleScrollRequest({
                time: this.scrollTime,
            });
        };
        ScrollResponder.prototype.drain = function () {
            if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
                this.queuedRequest = null;
            }
        };
        return ScrollResponder;
    }());

    var ViewContextType = createContext$1({}); // for Components
    function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
        return {
            dateEnv: dateEnv,
            options: viewOptions,
            pluginHooks: pluginHooks,
            emitter: emitter,
            dispatch: dispatch,
            getCurrentData: getCurrentData,
            calendarApi: calendarApi,
            viewSpec: viewSpec,
            viewApi: viewApi,
            dateProfileGenerator: dateProfileGenerator,
            theme: theme,
            isRtl: viewOptions.direction === 'rtl',
            addResizeHandler: function (handler) {
                emitter.on('_resize', handler);
            },
            removeResizeHandler: function (handler) {
                emitter.off('_resize', handler);
            },
            createScrollResponder: function (execFunc) {
                return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
            },
            registerInteractiveComponent: registerInteractiveComponent,
            unregisterInteractiveComponent: unregisterInteractiveComponent,
        };
    }

    /* eslint max-classes-per-file: off */
    var PureComponent = /** @class */ (function (_super) {
        __extends(PureComponent, _super);
        function PureComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PureComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {
            if (this.debug) {
                // eslint-disable-next-line no-console
                console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));
            }
            return !compareObjs(this.props, nextProps, this.propEquality) ||
                !compareObjs(this.state, nextState, this.stateEquality);
        };
        PureComponent.addPropsEquality = addPropsEquality;
        PureComponent.addStateEquality = addStateEquality;
        PureComponent.contextType = ViewContextType;
        return PureComponent;
    }(Component));
    PureComponent.prototype.propEquality = {};
    PureComponent.prototype.stateEquality = {};
    var BaseComponent = /** @class */ (function (_super) {
        __extends(BaseComponent, _super);
        function BaseComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BaseComponent.contextType = ViewContextType;
        return BaseComponent;
    }(PureComponent));
    function addPropsEquality(propEquality) {
        var hash = Object.create(this.prototype.propEquality);
        __assign(hash, propEquality);
        this.prototype.propEquality = hash;
    }
    function addStateEquality(stateEquality) {
        var hash = Object.create(this.prototype.stateEquality);
        __assign(hash, stateEquality);
        this.prototype.stateEquality = hash;
    }
    // use other one
    function setRef(ref, current) {
        if (typeof ref === 'function') {
            ref(current);
        }
        else if (ref) {
            // see https://github.com/facebook/react/issues/13029
            ref.current = current;
        }
    }

    /*
    an INTERACTABLE date component

    PURPOSES:
    - hook up to fg, fill, and mirror renderers
    - interface for dragging and hits
    */
    var DateComponent = /** @class */ (function (_super) {
        __extends(DateComponent, _super);
        function DateComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.uid = guid();
            return _this;
        }
        // Hit System
        // -----------------------------------------------------------------------------------------------------------------
        DateComponent.prototype.prepareHits = function () {
        };
        DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
            return null; // this should be abstract
        };
        // Pointer Interaction Utils
        // -----------------------------------------------------------------------------------------------------------------
        DateComponent.prototype.isValidSegDownEl = function (el) {
            return !this.props.eventDrag && // HACK
                !this.props.eventResize && // HACK
                !elementClosest(el, '.fc-event-mirror');
        };
        DateComponent.prototype.isValidDateDownEl = function (el) {
            return !elementClosest(el, '.fc-event:not(.fc-bg-event)') &&
                !elementClosest(el, '.fc-more-link') && // a "more.." link
                !elementClosest(el, 'a[data-navlink]') && // a clickable nav link
                !elementClosest(el, '.fc-popover'); // hack
        };
        return DateComponent;
    }(BaseComponent));

    // TODO: easier way to add new hooks? need to update a million things
    function createPlugin(input) {
        return {
            id: guid(),
            deps: input.deps || [],
            reducers: input.reducers || [],
            isLoadingFuncs: input.isLoadingFuncs || [],
            contextInit: [].concat(input.contextInit || []),
            eventRefiners: input.eventRefiners || {},
            eventDefMemberAdders: input.eventDefMemberAdders || [],
            eventSourceRefiners: input.eventSourceRefiners || {},
            isDraggableTransformers: input.isDraggableTransformers || [],
            eventDragMutationMassagers: input.eventDragMutationMassagers || [],
            eventDefMutationAppliers: input.eventDefMutationAppliers || [],
            dateSelectionTransformers: input.dateSelectionTransformers || [],
            datePointTransforms: input.datePointTransforms || [],
            dateSpanTransforms: input.dateSpanTransforms || [],
            views: input.views || {},
            viewPropsTransformers: input.viewPropsTransformers || [],
            isPropsValid: input.isPropsValid || null,
            externalDefTransforms: input.externalDefTransforms || [],
            viewContainerAppends: input.viewContainerAppends || [],
            eventDropTransformers: input.eventDropTransformers || [],
            componentInteractions: input.componentInteractions || [],
            calendarInteractions: input.calendarInteractions || [],
            themeClasses: input.themeClasses || {},
            eventSourceDefs: input.eventSourceDefs || [],
            cmdFormatter: input.cmdFormatter,
            recurringTypes: input.recurringTypes || [],
            namedTimeZonedImpl: input.namedTimeZonedImpl,
            initialView: input.initialView || '',
            elementDraggingImpl: input.elementDraggingImpl,
            optionChangeHandlers: input.optionChangeHandlers || {},
            scrollGridImpl: input.scrollGridImpl || null,
            contentTypeHandlers: input.contentTypeHandlers || {},
            listenerRefiners: input.listenerRefiners || {},
            optionRefiners: input.optionRefiners || {},
            propSetHandlers: input.propSetHandlers || {},
        };
    }
    function buildPluginHooks(pluginDefs, globalDefs) {
        var isAdded = {};
        var hooks = {
            reducers: [],
            isLoadingFuncs: [],
            contextInit: [],
            eventRefiners: {},
            eventDefMemberAdders: [],
            eventSourceRefiners: {},
            isDraggableTransformers: [],
            eventDragMutationMassagers: [],
            eventDefMutationAppliers: [],
            dateSelectionTransformers: [],
            datePointTransforms: [],
            dateSpanTransforms: [],
            views: {},
            viewPropsTransformers: [],
            isPropsValid: null,
            externalDefTransforms: [],
            viewContainerAppends: [],
            eventDropTransformers: [],
            componentInteractions: [],
            calendarInteractions: [],
            themeClasses: {},
            eventSourceDefs: [],
            cmdFormatter: null,
            recurringTypes: [],
            namedTimeZonedImpl: null,
            initialView: '',
            elementDraggingImpl: null,
            optionChangeHandlers: {},
            scrollGridImpl: null,
            contentTypeHandlers: {},
            listenerRefiners: {},
            optionRefiners: {},
            propSetHandlers: {},
        };
        function addDefs(defs) {
            for (var _i = 0, defs_1 = defs; _i < defs_1.length; _i++) {
                var def = defs_1[_i];
                if (!isAdded[def.id]) {
                    isAdded[def.id] = true;
                    addDefs(def.deps);
                    hooks = combineHooks(hooks, def);
                }
            }
        }
        if (pluginDefs) {
            addDefs(pluginDefs);
        }
        addDefs(globalDefs);
        return hooks;
    }
    function buildBuildPluginHooks() {
        var currentOverrideDefs = [];
        var currentGlobalDefs = [];
        var currentHooks;
        return function (overrideDefs, globalDefs) {
            if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
                currentHooks = buildPluginHooks(overrideDefs, globalDefs);
            }
            currentOverrideDefs = overrideDefs;
            currentGlobalDefs = globalDefs;
            return currentHooks;
        };
    }
    function combineHooks(hooks0, hooks1) {
        return {
            reducers: hooks0.reducers.concat(hooks1.reducers),
            isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
            contextInit: hooks0.contextInit.concat(hooks1.contextInit),
            eventRefiners: __assign(__assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
            eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
            eventSourceRefiners: __assign(__assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
            isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
            eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
            eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
            dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
            datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
            dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
            views: __assign(__assign({}, hooks0.views), hooks1.views),
            viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
            isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
            externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
            viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
            eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
            calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
            componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
            themeClasses: __assign(__assign({}, hooks0.themeClasses), hooks1.themeClasses),
            eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
            cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
            recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
            namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
            initialView: hooks0.initialView || hooks1.initialView,
            elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
            optionChangeHandlers: __assign(__assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
            scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
            contentTypeHandlers: __assign(__assign({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),
            listenerRefiners: __assign(__assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
            optionRefiners: __assign(__assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
            propSetHandlers: __assign(__assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers),
        };
    }

    var StandardTheme = /** @class */ (function (_super) {
        __extends(StandardTheme, _super);
        function StandardTheme() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return StandardTheme;
    }(Theme));
    StandardTheme.prototype.classes = {
        root: 'fc-theme-standard',
        tableCellShaded: 'fc-cell-shaded',
        buttonGroup: 'fc-button-group',
        button: 'fc-button fc-button-primary',
        buttonActive: 'fc-button-active',
    };
    StandardTheme.prototype.baseIconClass = 'fc-icon';
    StandardTheme.prototype.iconClasses = {
        close: 'fc-icon-x',
        prev: 'fc-icon-chevron-left',
        next: 'fc-icon-chevron-right',
        prevYear: 'fc-icon-chevrons-left',
        nextYear: 'fc-icon-chevrons-right',
    };
    StandardTheme.prototype.rtlIconClasses = {
        prev: 'fc-icon-chevron-right',
        next: 'fc-icon-chevron-left',
        prevYear: 'fc-icon-chevrons-right',
        nextYear: 'fc-icon-chevrons-left',
    };
    StandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly
    StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
    StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';

    function compileViewDefs(defaultConfigs, overrideConfigs) {
        var hash = {};
        var viewType;
        for (viewType in defaultConfigs) {
            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
        }
        for (viewType in overrideConfigs) {
            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
        }
        return hash;
    }
    function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
        if (hash[viewType]) {
            return hash[viewType];
        }
        var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
        if (viewDef) {
            hash[viewType] = viewDef;
        }
        return viewDef;
    }
    function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
        var defaultConfig = defaultConfigs[viewType];
        var overrideConfig = overrideConfigs[viewType];
        var queryProp = function (name) { return ((defaultConfig && defaultConfig[name] !== null) ? defaultConfig[name] :
            ((overrideConfig && overrideConfig[name] !== null) ? overrideConfig[name] : null)); };
        var theComponent = queryProp('component');
        var superType = queryProp('superType');
        var superDef = null;
        if (superType) {
            if (superType === viewType) {
                throw new Error('Can\'t have a custom view type that references itself');
            }
            superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
        }
        if (!theComponent && superDef) {
            theComponent = superDef.component;
        }
        if (!theComponent) {
            return null; // don't throw a warning, might be settings for a single-unit view
        }
        return {
            type: viewType,
            component: theComponent,
            defaults: __assign(__assign({}, (superDef ? superDef.defaults : {})), (defaultConfig ? defaultConfig.rawOptions : {})),
            overrides: __assign(__assign({}, (superDef ? superDef.overrides : {})), (overrideConfig ? overrideConfig.rawOptions : {})),
        };
    }

    /* eslint max-classes-per-file: off */
    // NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???
    var RenderHook = /** @class */ (function (_super) {
        __extends(RenderHook, _super);
        function RenderHook() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.rootElRef = createRef();
            _this.handleRootEl = function (el) {
                setRef(_this.rootElRef, el);
                if (_this.props.elRef) {
                    setRef(_this.props.elRef, el);
                }
            };
            return _this;
        }
        RenderHook.prototype.render = function () {
            var _this = this;
            var props = this.props;
            var hookProps = props.hookProps;
            return (createElement(MountHook, { hookProps: hookProps, didMount: props.didMount, willUnmount: props.willUnmount, elRef: this.handleRootEl }, function (rootElRef) { return (createElement(ContentHook, { hookProps: hookProps, content: props.content, defaultContent: props.defaultContent, backupElRef: _this.rootElRef }, function (innerElRef, innerContent) { return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent); })); }));
        };
        return RenderHook;
    }(BaseComponent));
    // TODO: rename to be about function, not default. use in above type
    // for forcing rerender of components that use the ContentHook
    var CustomContentRenderContext = createContext$1(0);
    function ContentHook(props) {
        return (createElement(CustomContentRenderContext.Consumer, null, function (renderId) { return (createElement(ContentHookInner, __assign({ renderId: renderId }, props))); }));
    }
    var ContentHookInner = /** @class */ (function (_super) {
        __extends(ContentHookInner, _super);
        function ContentHookInner() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.innerElRef = createRef();
            return _this;
        }
        ContentHookInner.prototype.render = function () {
            return this.props.children(this.innerElRef, this.renderInnerContent());
        };
        ContentHookInner.prototype.componentDidMount = function () {
            this.updateCustomContent();
        };
        ContentHookInner.prototype.componentDidUpdate = function () {
            this.updateCustomContent();
        };
        ContentHookInner.prototype.componentWillUnmount = function () {
            if (this.customContentInfo && this.customContentInfo.destroy) {
                this.customContentInfo.destroy();
            }
        };
        ContentHookInner.prototype.renderInnerContent = function () {
            var customContentInfo = this.customContentInfo; // only populated if using non-[p]react node(s)
            var innerContent = this.getInnerContent();
            var meta = this.getContentMeta(innerContent);
            // initial run, or content-type changing? (from vue -> react for example)
            if (!customContentInfo || customContentInfo.contentKey !== meta.contentKey) {
                // clearing old value
                if (customContentInfo) {
                    if (customContentInfo.destroy) {
                        customContentInfo.destroy();
                    }
                    customContentInfo = this.customContentInfo = null;
                }
                // assigning new value
                if (meta.contentKey) {
                    customContentInfo = this.customContentInfo = __assign({ contentKey: meta.contentKey, contentVal: innerContent[meta.contentKey] }, meta.buildLifecycleFuncs());
                }
                // updating
            }
            else if (customContentInfo) {
                customContentInfo.contentVal = innerContent[meta.contentKey];
            }
            return customContentInfo
                ? [] // signal that something was specified
                : innerContent; // assume a [p]react vdom node. use it
        };
        ContentHookInner.prototype.getInnerContent = function () {
            var props = this.props;
            var innerContent = normalizeContent(props.content, props.hookProps);
            if (innerContent === undefined) { // use the default
                innerContent = normalizeContent(props.defaultContent, props.hookProps);
            }
            return innerContent == null ? null : innerContent; // convert undefined to null (better for React)
        };
        ContentHookInner.prototype.getContentMeta = function (innerContent) {
            var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;
            var contentKey = '';
            var buildLifecycleFuncs = null;
            if (innerContent) { // allowed to be null, for convenience to caller
                for (var searchKey in contentTypeHandlers) {
                    if (innerContent[searchKey] !== undefined) {
                        contentKey = searchKey;
                        buildLifecycleFuncs = contentTypeHandlers[searchKey];
                        break;
                    }
                }
            }
            return { contentKey: contentKey, buildLifecycleFuncs: buildLifecycleFuncs };
        };
        ContentHookInner.prototype.updateCustomContent = function () {
            if (this.customContentInfo) { // for non-[p]react
                this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, // the element to render into
                this.customContentInfo.contentVal);
            }
        };
        return ContentHookInner;
    }(BaseComponent));
    var MountHook = /** @class */ (function (_super) {
        __extends(MountHook, _super);
        function MountHook() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handleRootEl = function (rootEl) {
                _this.rootEl = rootEl;
                if (_this.props.elRef) {
                    setRef(_this.props.elRef, rootEl);
                }
            };
            return _this;
        }
        MountHook.prototype.render = function () {
            return this.props.children(this.handleRootEl);
        };
        MountHook.prototype.componentDidMount = function () {
            var callback = this.props.didMount;
            if (callback) {
                callback(__assign(__assign({}, this.props.hookProps), { el: this.rootEl }));
            }
        };
        MountHook.prototype.componentWillUnmount = function () {
            var callback = this.props.willUnmount;
            if (callback) {
                callback(__assign(__assign({}, this.props.hookProps), { el: this.rootEl }));
            }
        };
        return MountHook;
    }(BaseComponent));
    function buildClassNameNormalizer() {
        var currentGenerator;
        var currentHookProps;
        var currentClassNames = [];
        return function (generator, hookProps) {
            if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {
                currentGenerator = generator;
                currentHookProps = hookProps;
                currentClassNames = normalizeClassNames(generator, hookProps);
            }
            return currentClassNames;
        };
    }
    function normalizeClassNames(classNames, hookProps) {
        if (typeof classNames === 'function') {
            classNames = classNames(hookProps);
        }
        return parseClassNames(classNames);
    }
    function normalizeContent(input, hookProps) {
        if (typeof input === 'function') {
            return input(hookProps, createElement); // give the function the vdom-creation func
        }
        return input;
    }

    var ViewRoot = /** @class */ (function (_super) {
        __extends(ViewRoot, _super);
        function ViewRoot() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.normalizeClassNames = buildClassNameNormalizer();
            return _this;
        }
        ViewRoot.prototype.render = function () {
            var _a = this, props = _a.props, context = _a.context;
            var options = context.options;
            var hookProps = { view: context.viewApi };
            var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);
            return (createElement(MountHook, { hookProps: hookProps, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount, elRef: props.elRef }, function (rootElRef) { return props.children(rootElRef, ["fc-" + props.viewSpec.type + "-view", 'fc-view'].concat(customClassNames)); }));
        };
        return ViewRoot;
    }(BaseComponent));

    function parseViewConfigs(inputs) {
        return mapHash(inputs, parseViewConfig);
    }
    function parseViewConfig(input) {
        var rawOptions = typeof input === 'function' ?
            { component: input } :
            input;
        var component = rawOptions.component;
        if (rawOptions.content) {
            component = createViewHookComponent(rawOptions);
            // TODO: remove content/classNames/didMount/etc from options?
        }
        return {
            superType: rawOptions.type,
            component: component,
            rawOptions: rawOptions,
        };
    }
    function createViewHookComponent(options) {
        return function (viewProps) { return (createElement(ViewContextType.Consumer, null, function (context) { return (createElement(ViewRoot, { viewSpec: context.viewSpec }, function (viewElRef, viewClassNames) {
            var hookProps = __assign(__assign({}, viewProps), { nextDayThreshold: context.options.nextDayThreshold });
            return (createElement(RenderHook, { hookProps: hookProps, classNames: options.classNames, content: options.content, didMount: options.didMount, willUnmount: options.willUnmount, elRef: viewElRef }, function (rootElRef, customClassNames, innerElRef, innerContent) { return (createElement("div", { className: viewClassNames.concat(customClassNames).join(' '), ref: rootElRef }, innerContent)); }));
        })); })); };
    }

    function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
        var defaultConfigs = parseViewConfigs(defaultInputs);
        var overrideConfigs = parseViewConfigs(optionOverrides.views);
        var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
        return mapHash(viewDefs, function (viewDef) { return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults); });
    }
    function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
        var durationInput = viewDef.overrides.duration ||
            viewDef.defaults.duration ||
            dynamicOptionOverrides.duration ||
            optionOverrides.duration;
        var duration = null;
        var durationUnit = '';
        var singleUnit = '';
        var singleUnitOverrides = {};
        if (durationInput) {
            duration = createDurationCached(durationInput);
            if (duration) { // valid?
                var denom = greatestDurationDenominator(duration);
                durationUnit = denom.unit;
                if (denom.value === 1) {
                    singleUnit = durationUnit;
                    singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
                }
            }
        }
        var queryButtonText = function (optionsSubset) {
            var buttonTextMap = optionsSubset.buttonText || {};
            var buttonTextKey = viewDef.defaults.buttonTextKey;
            if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
                return buttonTextMap[buttonTextKey];
            }
            if (buttonTextMap[viewDef.type] != null) {
                return buttonTextMap[viewDef.type];
            }
            if (buttonTextMap[singleUnit] != null) {
                return buttonTextMap[singleUnit];
            }
            return null;
        };
        var queryButtonTitle = function (optionsSubset) {
            var buttonHints = optionsSubset.buttonHints || {};
            var buttonKey = viewDef.defaults.buttonTextKey; // use same key as text
            if (buttonKey != null && buttonHints[buttonKey] != null) {
                return buttonHints[buttonKey];
            }
            if (buttonHints[viewDef.type] != null) {
                return buttonHints[viewDef.type];
            }
            if (buttonHints[singleUnit] != null) {
                return buttonHints[singleUnit];
            }
            return null;
        };
        return {
            type: viewDef.type,
            component: viewDef.component,
            duration: duration,
            durationUnit: durationUnit,
            singleUnit: singleUnit,
            optionDefaults: viewDef.defaults,
            optionOverrides: __assign(__assign({}, singleUnitOverrides), viewDef.overrides),
            buttonTextOverride: queryButtonText(dynamicOptionOverrides) ||
                queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence
                viewDef.overrides.buttonText,
            buttonTextDefault: queryButtonText(localeDefaults) ||
                viewDef.defaults.buttonText ||
                queryButtonText(BASE_OPTION_DEFAULTS) ||
                viewDef.type,
            // not DRY
            buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) ||
                queryButtonTitle(optionOverrides) ||
                viewDef.overrides.buttonHint,
            buttonTitleDefault: queryButtonTitle(localeDefaults) ||
                viewDef.defaults.buttonHint ||
                queryButtonTitle(BASE_OPTION_DEFAULTS),
            // will eventually fall back to buttonText
        };
    }
    // hack to get memoization working
    var durationInputMap = {};
    function createDurationCached(durationInput) {
        var json = JSON.stringify(durationInput);
        var res = durationInputMap[json];
        if (res === undefined) {
            res = createDuration(durationInput);
            durationInputMap[json] = res;
        }
        return res;
    }

    var DateProfileGenerator = /** @class */ (function () {
        function DateProfileGenerator(props) {
            this.props = props;
            this.nowDate = getNow(props.nowInput, props.dateEnv);
            this.initHiddenDays();
        }
        /* Date Range Computation
        ------------------------------------------------------------------------------------------------------------------*/
        // Builds a structure with info about what the dates/ranges will be for the "prev" view.
        DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate, forceToValid) {
            var dateEnv = this.props.dateEnv;
            var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
            currentDateProfile.dateIncrement);
            return this.build(prevDate, -1, forceToValid);
        };
        // Builds a structure with info about what the dates/ranges will be for the "next" view.
        DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate, forceToValid) {
            var dateEnv = this.props.dateEnv;
            var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
            currentDateProfile.dateIncrement);
            return this.build(nextDate, 1, forceToValid);
        };
        // Builds a structure holding dates/ranges for rendering around the given date.
        // Optional direction param indicates whether the date is being incremented/decremented
        // from its previous value. decremented = -1, incremented = 1 (default).
        DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {
            if (forceToValid === void 0) { forceToValid = true; }
            var props = this.props;
            var validRange;
            var currentInfo;
            var isRangeAllDay;
            var renderRange;
            var activeRange;
            var isValid;
            validRange = this.buildValidRange();
            validRange = this.trimHiddenDays(validRange);
            if (forceToValid) {
                currentDate = constrainMarkerToRange(currentDate, validRange);
            }
            currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
            isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
            renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
            renderRange = this.trimHiddenDays(renderRange);
            activeRange = renderRange;
            if (!props.showNonCurrentDates) {
                activeRange = intersectRanges(activeRange, currentInfo.range);
            }
            activeRange = this.adjustActiveRange(activeRange);
            activeRange = intersectRanges(activeRange, validRange); // might return null
            // it's invalid if the originally requested date is not contained,
            // or if the range is completely outside of the valid range.
            isValid = rangesIntersect(currentInfo.range, validRange);
            return {
                // constraint for where prev/next operations can go and where events can be dragged/resized to.
                // an object with optional start and end properties.
                validRange: validRange,
                // range the view is formally responsible for.
                // for example, a month view might have 1st-31st, excluding padded dates
                currentRange: currentInfo.range,
                // name of largest unit being displayed, like "month" or "week"
                currentRangeUnit: currentInfo.unit,
                isRangeAllDay: isRangeAllDay,
                // dates that display events and accept drag-n-drop
                // will be `null` if no dates accept events
                activeRange: activeRange,
                // date range with a rendered skeleton
                // includes not-active days that need some sort of DOM
                renderRange: renderRange,
                // Duration object that denotes the first visible time of any given day
                slotMinTime: props.slotMinTime,
                // Duration object that denotes the exclusive visible end time of any given day
                slotMaxTime: props.slotMaxTime,
                isValid: isValid,
                // how far the current date will move for a prev/next operation
                dateIncrement: this.buildDateIncrement(currentInfo.duration),
                // pass a fallback (might be null) ^
            };
        };
        // Builds an object with optional start/end properties.
        // Indicates the minimum/maximum dates to display.
        // not responsible for trimming hidden days.
        DateProfileGenerator.prototype.buildValidRange = function () {
            var input = this.props.validRangeInput;
            var simpleInput = typeof input === 'function'
                ? input.call(this.props.calendarApi, this.nowDate)
                : input;
            return this.refineRange(simpleInput) ||
                { start: null, end: null }; // completely open-ended
        };
        // Builds a structure with info about the "current" range, the range that is
        // highlighted as being the current month for example.
        // See build() for a description of `direction`.
        // Guaranteed to have `range` and `unit` properties. `duration` is optional.
        DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {
            var props = this.props;
            var duration = null;
            var unit = null;
            var range = null;
            var dayCount;
            if (props.duration) {
                duration = props.duration;
                unit = props.durationUnit;
                range = this.buildRangeFromDuration(date, direction, duration, unit);
            }
            else if ((dayCount = this.props.dayCount)) {
                unit = 'day';
                range = this.buildRangeFromDayCount(date, direction, dayCount);
            }
            else if ((range = this.buildCustomVisibleRange(date))) {
                unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;
            }
            else {
                duration = this.getFallbackDuration();
                unit = greatestDurationDenominator(duration).unit;
                range = this.buildRangeFromDuration(date, direction, duration, unit);
            }
            return { duration: duration, unit: unit, range: range };
        };
        DateProfileGenerator.prototype.getFallbackDuration = function () {
            return createDuration({ day: 1 });
        };
        // Returns a new activeRange to have time values (un-ambiguate)
        // slotMinTime or slotMaxTime causes the range to expand.
        DateProfileGenerator.prototype.adjustActiveRange = function (range) {
            var _a = this.props, dateEnv = _a.dateEnv, usesMinMaxTime = _a.usesMinMaxTime, slotMinTime = _a.slotMinTime, slotMaxTime = _a.slotMaxTime;
            var start = range.start, end = range.end;
            if (usesMinMaxTime) {
                // expand active range if slotMinTime is negative (why not when positive?)
                if (asRoughDays(slotMinTime) < 0) {
                    start = startOfDay$1(start); // necessary?
                    start = dateEnv.add(start, slotMinTime);
                }
                // expand active range if slotMaxTime is beyond one day (why not when negative?)
                if (asRoughDays(slotMaxTime) > 1) {
                    end = startOfDay$1(end); // necessary?
                    end = addDays(end, -1);
                    end = dateEnv.add(end, slotMaxTime);
                }
            }
            return { start: start, end: end };
        };
        // Builds the "current" range when it is specified as an explicit duration.
        // `unit` is the already-computed greatestDurationDenominator unit of duration.
        DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {
            var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;
            var start;
            var end;
            var res;
            // compute what the alignment should be
            if (!dateAlignment) {
                var dateIncrement = this.props.dateIncrement;
                if (dateIncrement) {
                    // use the smaller of the two units
                    if (asRoughMs(dateIncrement) < asRoughMs(duration)) {
                        dateAlignment = greatestDurationDenominator(dateIncrement).unit;
                    }
                    else {
                        dateAlignment = unit;
                    }
                }
                else {
                    dateAlignment = unit;
                }
            }
            // if the view displays a single day or smaller
            if (asRoughDays(duration) <= 1) {
                if (this.isHiddenDay(start)) {
                    start = this.skipHiddenDays(start, direction);
                    start = startOfDay$1(start);
                }
            }
            function computeRes() {
                start = dateEnv.startOf(date, dateAlignment);
                end = dateEnv.add(start, duration);
                res = { start: start, end: end };
            }
            computeRes();
            // if range is completely enveloped by hidden days, go past the hidden days
            if (!this.trimHiddenDays(res)) {
                date = this.skipHiddenDays(date, direction);
                computeRes();
            }
            return res;
        };
        // Builds the "current" range when a dayCount is specified.
        DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {
            var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;
            var runningCount = 0;
            var start = date;
            var end;
            if (dateAlignment) {
                start = dateEnv.startOf(start, dateAlignment);
            }
            start = startOfDay$1(start);
            start = this.skipHiddenDays(start, direction);
            end = start;
            do {
                end = addDays(end, 1);
                if (!this.isHiddenDay(end)) {
                    runningCount += 1;
                }
            } while (runningCount < dayCount);
            return { start: start, end: end };
        };
        // Builds a normalized range object for the "visible" range,
        // which is a way to define the currentRange and activeRange at the same time.
        DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {
            var props = this.props;
            var input = props.visibleRangeInput;
            var simpleInput = typeof input === 'function'
                ? input.call(props.calendarApi, props.dateEnv.toDate(date))
                : input;
            var range = this.refineRange(simpleInput);
            if (range && (range.start == null || range.end == null)) {
                return null;
            }
            return range;
        };
        // Computes the range that will represent the element/cells for *rendering*,
        // but which may have voided days/times.
        // not responsible for trimming hidden days.
        DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
            return currentRange;
        };
        // Compute the duration value that should be added/substracted to the current date
        // when a prev/next operation happens.
        DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {
            var dateIncrement = this.props.dateIncrement;
            var customAlignment;
            if (dateIncrement) {
                return dateIncrement;
            }
            if ((customAlignment = this.props.dateAlignment)) {
                return createDuration(1, customAlignment);
            }
            if (fallback) {
                return fallback;
            }
            return createDuration({ days: 1 });
        };
        DateProfileGenerator.prototype.refineRange = function (rangeInput) {
            if (rangeInput) {
                var range = parseRange(rangeInput, this.props.dateEnv);
                if (range) {
                    range = computeVisibleDayRange(range);
                }
                return range;
            }
            return null;
        };
        /* Hidden Days
        ------------------------------------------------------------------------------------------------------------------*/
        // Initializes internal variables related to calculating hidden days-of-week
        DateProfileGenerator.prototype.initHiddenDays = function () {
            var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden
            var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
            var dayCnt = 0;
            var i;
            if (this.props.weekends === false) {
                hiddenDays.push(0, 6); // 0=sunday, 6=saturday
            }
            for (i = 0; i < 7; i += 1) {
                if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {
                    dayCnt += 1;
                }
            }
            if (!dayCnt) {
                throw new Error('invalid hiddenDays'); // all days were hidden? bad.
            }
            this.isHiddenDayHash = isHiddenDayHash;
        };
        // Remove days from the beginning and end of the range that are computed as hidden.
        // If the whole range is trimmed off, returns null
        DateProfileGenerator.prototype.trimHiddenDays = function (range) {
            var start = range.start, end = range.end;
            if (start) {
                start = this.skipHiddenDays(start);
            }
            if (end) {
                end = this.skipHiddenDays(end, -1, true);
            }
            if (start == null || end == null || start < end) {
                return { start: start, end: end };
            }
            return null;
        };
        // Is the current day hidden?
        // `day` is a day-of-week index (0-6), or a Date (used for UTC)
        DateProfileGenerator.prototype.isHiddenDay = function (day) {
            if (day instanceof Date) {
                day = day.getUTCDay();
            }
            return this.isHiddenDayHash[day];
        };
        // Incrementing the current day until it is no longer a hidden day, returning a copy.
        // DOES NOT CONSIDER validRange!
        // If the initial value of `date` is not a hidden day, don't do anything.
        // Pass `isExclusive` as `true` if you are dealing with an end date.
        // `inc` defaults to `1` (increment one day forward each time)
        DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {
            if (inc === void 0) { inc = 1; }
            if (isExclusive === void 0) { isExclusive = false; }
            while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
                date = addDays(date, inc);
            }
            return date;
        };
        return DateProfileGenerator;
    }());

    function reduceViewType(viewType, action) {
        switch (action.type) {
            case 'CHANGE_VIEW_TYPE':
                viewType = action.viewType;
        }
        return viewType;
    }

    function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
        var _a;
        switch (action.type) {
            case 'SET_OPTION':
                return __assign(__assign({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));
            default:
                return dynamicOptionOverrides;
        }
    }

    function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
        var dp;
        switch (action.type) {
            case 'CHANGE_VIEW_TYPE':
                return dateProfileGenerator.build(action.dateMarker || currentDate);
            case 'CHANGE_DATE':
                return dateProfileGenerator.build(action.dateMarker);
            case 'PREV':
                dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);
                if (dp.isValid) {
                    return dp;
                }
                break;
            case 'NEXT':
                dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);
                if (dp.isValid) {
                    return dp;
                }
                break;
        }
        return currentDateProfile;
    }

    function initEventSources(calendarOptions, dateProfile, context) {
        var activeRange = dateProfile ? dateProfile.activeRange : null;
        return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
    }
    function reduceEventSources(eventSources, action, dateProfile, context) {
        var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?
        switch (action.type) {
            case 'ADD_EVENT_SOURCES': // already parsed
                return addSources(eventSources, action.sources, activeRange, context);
            case 'REMOVE_EVENT_SOURCE':
                return removeSource(eventSources, action.sourceId);
            case 'PREV': // TODO: how do we track all actions that affect dateProfile :(
            case 'NEXT':
            case 'CHANGE_DATE':
            case 'CHANGE_VIEW_TYPE':
                if (dateProfile) {
                    return fetchDirtySources(eventSources, activeRange, context);
                }
                return eventSources;
            case 'FETCH_EVENT_SOURCES':
                return fetchSourcesByIds(eventSources, action.sourceIds ? // why no type?
                    arrayToHash(action.sourceIds) :
                    excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);
            case 'RECEIVE_EVENTS':
            case 'RECEIVE_EVENT_ERROR':
                return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
            case 'REMOVE_ALL_EVENT_SOURCES':
                return {};
            default:
                return eventSources;
        }
    }
    function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
        var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?
        return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
    }
    function computeEventSourcesLoading(eventSources) {
        for (var sourceId in eventSources) {
            if (eventSources[sourceId].isFetching) {
                return true;
            }
        }
        return false;
    }
    function addSources(eventSourceHash, sources, fetchRange, context) {
        var hash = {};
        for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {
            var source = sources_1[_i];
            hash[source.sourceId] = source;
        }
        if (fetchRange) {
            hash = fetchDirtySources(hash, fetchRange, context);
        }
        return __assign(__assign({}, eventSourceHash), hash);
    }
    function removeSource(eventSourceHash, sourceId) {
        return filterHash(eventSourceHash, function (eventSource) { return eventSource.sourceId !== sourceId; });
    }
    function fetchDirtySources(sourceHash, fetchRange, context) {
        return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) { return isSourceDirty(eventSource, fetchRange, context); }), fetchRange, false, context);
    }
    function isSourceDirty(eventSource, fetchRange, context) {
        if (!doesSourceNeedRange(eventSource, context)) {
            return !eventSource.latestFetchId;
        }
        return !context.options.lazyFetching ||
            !eventSource.fetchRange ||
            eventSource.isFetching || // always cancel outdated in-progress fetches
            fetchRange.start < eventSource.fetchRange.start ||
            fetchRange.end > eventSource.fetchRange.end;
    }
    function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
        var nextSources = {};
        for (var sourceId in prevSources) {
            var source = prevSources[sourceId];
            if (sourceIdHash[sourceId]) {
                nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
            }
            else {
                nextSources[sourceId] = source;
            }
        }
        return nextSources;
    }
    function fetchSource(eventSource, fetchRange, isRefetch, context) {
        var options = context.options, calendarApi = context.calendarApi;
        var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
        var fetchId = guid();
        sourceDef.fetch({
            eventSource: eventSource,
            range: fetchRange,
            isRefetch: isRefetch,
            context: context,
        }, function (res) {
            var rawEvents = res.rawEvents;
            if (options.eventSourceSuccess) {
                rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;
            }
            if (eventSource.success) {
                rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;
            }
            context.dispatch({
                type: 'RECEIVE_EVENTS',
                sourceId: eventSource.sourceId,
                fetchId: fetchId,
                fetchRange: fetchRange,
                rawEvents: rawEvents,
            });
        }, function (error) {
            console.warn(error.message, error);
            if (options.eventSourceFailure) {
                options.eventSourceFailure.call(calendarApi, error);
            }
            if (eventSource.failure) {
                eventSource.failure(error);
            }
            context.dispatch({
                type: 'RECEIVE_EVENT_ERROR',
                sourceId: eventSource.sourceId,
                fetchId: fetchId,
                fetchRange: fetchRange,
                error: error,
            });
        });
        return __assign(__assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });
    }
    function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
        var _a;
        var eventSource = sourceHash[sourceId];
        if (eventSource && // not already removed
            fetchId === eventSource.latestFetchId) {
            return __assign(__assign({}, sourceHash), (_a = {}, _a[sourceId] = __assign(__assign({}, eventSource), { isFetching: false, fetchRange: fetchRange }), _a));
        }
        return sourceHash;
    }
    function excludeStaticSources(eventSources, context) {
        return filterHash(eventSources, function (eventSource) { return doesSourceNeedRange(eventSource, context); });
    }
    function parseInitialSources(rawOptions, context) {
        var refiners = buildEventSourceRefiners(context);
        var rawSources = [].concat(rawOptions.eventSources || []);
        var sources = []; // parsed
        if (rawOptions.initialEvents) {
            rawSources.unshift(rawOptions.initialEvents);
        }
        if (rawOptions.events) {
            rawSources.unshift(rawOptions.events);
        }
        for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {
            var rawSource = rawSources_1[_i];
            var source = parseEventSource(rawSource, context, refiners);
            if (source) {
                sources.push(source);
            }
        }
        return sources;
    }
    function doesSourceNeedRange(eventSource, context) {
        var defs = context.pluginHooks.eventSourceDefs;
        return !defs[eventSource.sourceDefId].ignoreRange;
    }

    function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
        switch (action.type) {
            case 'RECEIVE_EVENTS': // raw
                return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);
            case 'ADD_EVENTS': // already parsed, but not expanded
                return addEvent(eventStore, action.eventStore, // new ones
                dateProfile ? dateProfile.activeRange : null, context);
            case 'RESET_EVENTS':
                return action.eventStore;
            case 'MERGE_EVENTS': // already parsed and expanded
                return mergeEventStores(eventStore, action.eventStore);
            case 'PREV': // TODO: how do we track all actions that affect dateProfile :(
            case 'NEXT':
            case 'CHANGE_DATE':
            case 'CHANGE_VIEW_TYPE':
                if (dateProfile) {
                    return expandRecurring(eventStore, dateProfile.activeRange, context);
                }
                return eventStore;
            case 'REMOVE_EVENTS':
                return excludeSubEventStore(eventStore, action.eventStore);
            case 'REMOVE_EVENT_SOURCE':
                return excludeEventsBySourceId(eventStore, action.sourceId);
            case 'REMOVE_ALL_EVENT_SOURCES':
                return filterEventStoreDefs(eventStore, function (eventDef) { return (!eventDef.sourceId // only keep events with no source id
                ); });
            case 'REMOVE_ALL_EVENTS':
                return createEmptyEventStore();
            default:
                return eventStore;
        }
    }
    function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
        if (eventSource && // not already removed
            fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources
        ) {
            var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);
            if (fetchRange) {
                subset = expandRecurring(subset, fetchRange, context);
            }
            return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
        }
        return eventStore;
    }
    function transformRawEvents(rawEvents, eventSource, context) {
        var calEachTransform = context.options.eventDataTransform;
        var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
        if (sourceEachTransform) {
            rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
        }
        if (calEachTransform) {
            rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
        }
        return rawEvents;
    }
    function transformEachRawEvent(rawEvents, func) {
        var refinedEvents;
        if (!func) {
            refinedEvents = rawEvents;
        }
        else {
            refinedEvents = [];
            for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {
                var rawEvent = rawEvents_1[_i];
                var refinedEvent = func(rawEvent);
                if (refinedEvent) {
                    refinedEvents.push(refinedEvent);
                }
                else if (refinedEvent == null) {
                    refinedEvents.push(rawEvent);
                } // if a different falsy value, do nothing
            }
        }
        return refinedEvents;
    }
    function addEvent(eventStore, subset, expandRange, context) {
        if (expandRange) {
            subset = expandRecurring(subset, expandRange, context);
        }
        return mergeEventStores(eventStore, subset);
    }
    function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
        var defs = eventStore.defs;
        var instances = mapHash(eventStore.instances, function (instance) {
            var def = defs[instance.defId];
            if (def.allDay || def.recurringDef) {
                return instance; // isn't dependent on timezone
            }
            return __assign(__assign({}, instance), { range: {
                    start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
                    end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo)),
                }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });
        });
        return { defs: defs, instances: instances };
    }
    function excludeEventsBySourceId(eventStore, sourceId) {
        return filterEventStoreDefs(eventStore, function (eventDef) { return eventDef.sourceId !== sourceId; });
    }
    // QUESTION: why not just return instances? do a general object-property-exclusion util
    function excludeInstances(eventStore, removals) {
        return {
            defs: eventStore.defs,
            instances: filterHash(eventStore.instances, function (instance) { return !removals[instance.instanceId]; }),
        };
    }

    function reduceDateSelection(currentSelection, action) {
        switch (action.type) {
            case 'UNSELECT_DATES':
                return null;
            case 'SELECT_DATES':
                return action.selection;
            default:
                return currentSelection;
        }
    }

    function reduceSelectedEvent(currentInstanceId, action) {
        switch (action.type) {
            case 'UNSELECT_EVENT':
                return '';
            case 'SELECT_EVENT':
                return action.eventInstanceId;
            default:
                return currentInstanceId;
        }
    }

    function reduceEventDrag(currentDrag, action) {
        var newDrag;
        switch (action.type) {
            case 'UNSET_EVENT_DRAG':
                return null;
            case 'SET_EVENT_DRAG':
                newDrag = action.state;
                return {
                    affectedEvents: newDrag.affectedEvents,
                    mutatedEvents: newDrag.mutatedEvents,
                    isEvent: newDrag.isEvent,
                };
            default:
                return currentDrag;
        }
    }

    function reduceEventResize(currentResize, action) {
        var newResize;
        switch (action.type) {
            case 'UNSET_EVENT_RESIZE':
                return null;
            case 'SET_EVENT_RESIZE':
                newResize = action.state;
                return {
                    affectedEvents: newResize.affectedEvents,
                    mutatedEvents: newResize.mutatedEvents,
                    isEvent: newResize.isEvent,
                };
            default:
                return currentResize;
        }
    }

    function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
        var header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
        var footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
        return { header: header, footer: footer };
    }
    function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
        var sectionWidgets = {};
        var viewsWithButtons = [];
        var hasTitle = false;
        for (var sectionName in sectionStrHash) {
            var sectionStr = sectionStrHash[sectionName];
            var sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
            sectionWidgets[sectionName] = sectionRes.widgets;
            viewsWithButtons.push.apply(viewsWithButtons, sectionRes.viewsWithButtons);
            hasTitle = hasTitle || sectionRes.hasTitle;
        }
        return { sectionWidgets: sectionWidgets, viewsWithButtons: viewsWithButtons, hasTitle: hasTitle };
    }
    /*
    BAD: querying icons and text here. should be done at render time
    */
    function parseSection(sectionStr, calendarOptions, // defaults+overrides, then refined
    calendarOptionOverrides, // overrides only!, unrefined :(
    theme, viewSpecs, calendarApi) {
        var isRtl = calendarOptions.direction === 'rtl';
        var calendarCustomButtons = calendarOptions.customButtons || {};
        var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
        var calendarButtonText = calendarOptions.buttonText || {};
        var calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
        var calendarButtonHints = calendarOptions.buttonHints || {};
        var sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];
        var viewsWithButtons = [];
        var hasTitle = false;
        var widgets = sectionSubstrs.map(function (buttonGroupStr) { return (buttonGroupStr.split(',').map(function (buttonName) {
            if (buttonName === 'title') {
                hasTitle = true;
                return { buttonName: buttonName };
            }
            var customButtonProps;
            var viewSpec;
            var buttonClick;
            var buttonIcon; // only one of these will be set
            var buttonText; // "
            var buttonHint;
            // ^ for the title="" attribute, for accessibility
            if ((customButtonProps = calendarCustomButtons[buttonName])) {
                buttonClick = function (ev) {
                    if (customButtonProps.click) {
                        customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?
                    }
                };
                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||
                    (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||
                    (buttonText = customButtonProps.text);
                buttonHint = customButtonProps.hint || customButtonProps.text;
            }
            else if ((viewSpec = viewSpecs[buttonName])) {
                viewsWithButtons.push(buttonName);
                buttonClick = function () {
                    calendarApi.changeView(buttonName);
                };
                (buttonText = viewSpec.buttonTextOverride) ||
                    (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||
                    (buttonText = viewSpec.buttonTextDefault);
                var textFallback = viewSpec.buttonTextOverride ||
                    viewSpec.buttonTextDefault;
                buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride ||
                    viewSpec.buttonTitleDefault ||
                    calendarOptions.viewHint, [textFallback, buttonName], // view-name = buttonName
                textFallback);
            }
            else if (calendarApi[buttonName]) { // a calendarApi method
                buttonClick = function () {
                    calendarApi[buttonName]();
                };
                (buttonText = calendarButtonTextOverrides[buttonName]) ||
                    (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||
                    (buttonText = calendarButtonText[buttonName]); // everything else is considered default
                if (buttonName === 'prevYear' || buttonName === 'nextYear') {
                    var prevOrNext = buttonName === 'prevYear' ? 'prev' : 'next';
                    buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] ||
                        calendarButtonHints[prevOrNext], [
                        calendarButtonText.year || 'year',
                        'year',
                    ], calendarButtonText[buttonName]);
                }
                else {
                    buttonHint = function (navUnit) { return formatWithOrdinals(calendarButtonHintOverrides[buttonName] ||
                        calendarButtonHints[buttonName], [
                        calendarButtonText[navUnit] || navUnit,
                        navUnit,
                    ], calendarButtonText[buttonName]); };
                }
            }
            return { buttonName: buttonName, buttonClick: buttonClick, buttonIcon: buttonIcon, buttonText: buttonText, buttonHint: buttonHint };
        })); });
        return { widgets: widgets, viewsWithButtons: viewsWithButtons, hasTitle: hasTitle };
    }

    var eventSourceDef$2 = {
        ignoreRange: true,
        parseMeta: function (refined) {
            if (Array.isArray(refined.events)) {
                return refined.events;
            }
            return null;
        },
        fetch: function (arg, success) {
            success({
                rawEvents: arg.eventSource.meta,
            });
        },
    };
    var arrayEventSourcePlugin = createPlugin({
        eventSourceDefs: [eventSourceDef$2],
    });

    var eventSourceDef$1 = {
        parseMeta: function (refined) {
            if (typeof refined.events === 'function') {
                return refined.events;
            }
            return null;
        },
        fetch: function (arg, success, failure) {
            var dateEnv = arg.context.dateEnv;
            var func = arg.eventSource.meta;
            unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function (rawEvents) {
                success({ rawEvents: rawEvents }); // needs an object response
            }, failure);
        },
    };
    var funcEventSourcePlugin = createPlugin({
        eventSourceDefs: [eventSourceDef$1],
    });

    function requestJson(method, url, params, successCallback, failureCallback) {
        method = method.toUpperCase();
        var body = null;
        if (method === 'GET') {
            url = injectQueryStringParams(url, params);
        }
        else {
            body = encodeParams(params);
        }
        var xhr = new XMLHttpRequest();
        xhr.open(method, url, true);
        if (method !== 'GET') {
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        }
        xhr.onload = function () {
            if (xhr.status >= 200 && xhr.status < 400) {
                var parsed = false;
                var res = void 0;
                try {
                    res = JSON.parse(xhr.responseText);
                    parsed = true;
                }
                catch (err) {
                    // will handle parsed=false
                }
                if (parsed) {
                    successCallback(res, xhr);
                }
                else {
                    failureCallback('Failure parsing JSON', xhr);
                }
            }
            else {
                failureCallback('Request failed', xhr);
            }
        };
        xhr.onerror = function () {
            failureCallback('Request failed', xhr);
        };
        xhr.send(body);
    }
    function injectQueryStringParams(url, params) {
        return url +
            (url.indexOf('?') === -1 ? '?' : '&') +
            encodeParams(params);
    }
    function encodeParams(params) {
        var parts = [];
        for (var key in params) {
            parts.push(encodeURIComponent(key) + "=" + encodeURIComponent(params[key]));
        }
        return parts.join('&');
    }

    var JSON_FEED_EVENT_SOURCE_REFINERS = {
        method: String,
        extraParams: identity$1,
        startParam: String,
        endParam: String,
        timeZoneParam: String,
    };

    var eventSourceDef = {
        parseMeta: function (refined) {
            if (refined.url && (refined.format === 'json' || !refined.format)) {
                return {
                    url: refined.url,
                    format: 'json',
                    method: (refined.method || 'GET').toUpperCase(),
                    extraParams: refined.extraParams,
                    startParam: refined.startParam,
                    endParam: refined.endParam,
                    timeZoneParam: refined.timeZoneParam,
                };
            }
            return null;
        },
        fetch: function (arg, success, failure) {
            var meta = arg.eventSource.meta;
            var requestParams = buildRequestParams(meta, arg.range, arg.context);
            requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {
                success({ rawEvents: rawEvents, xhr: xhr });
            }, function (errorMessage, xhr) {
                failure({ message: errorMessage, xhr: xhr });
            });
        },
    };
    var jsonFeedEventSourcePlugin = createPlugin({
        eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
        eventSourceDefs: [eventSourceDef],
    });
    function buildRequestParams(meta, range, context) {
        var dateEnv = context.dateEnv, options = context.options;
        var startParam;
        var endParam;
        var timeZoneParam;
        var customRequestParams;
        var params = {};
        startParam = meta.startParam;
        if (startParam == null) {
            startParam = options.startParam;
        }
        endParam = meta.endParam;
        if (endParam == null) {
            endParam = options.endParam;
        }
        timeZoneParam = meta.timeZoneParam;
        if (timeZoneParam == null) {
            timeZoneParam = options.timeZoneParam;
        }
        // retrieve any outbound GET/POST data from the options
        if (typeof meta.extraParams === 'function') {
            // supplied as a function that returns a key/value object
            customRequestParams = meta.extraParams();
        }
        else {
            // probably supplied as a straight key/value object
            customRequestParams = meta.extraParams || {};
        }
        __assign(params, customRequestParams);
        params[startParam] = dateEnv.formatIso(range.start);
        params[endParam] = dateEnv.formatIso(range.end);
        if (dateEnv.timeZone !== 'local') {
            params[timeZoneParam] = dateEnv.timeZone;
        }
        return params;
    }

    var SIMPLE_RECURRING_REFINERS = {
        daysOfWeek: identity$1,
        startTime: createDuration,
        endTime: createDuration,
        duration: createDuration,
        startRecur: identity$1,
        endRecur: identity$1,
    };

    var recurring = {
        parse: function (refined, dateEnv) {
            if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
                var recurringData = {
                    daysOfWeek: refined.daysOfWeek || null,
                    startTime: refined.startTime || null,
                    endTime: refined.endTime || null,
                    startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
                    endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null,
                };
                var duration = void 0;
                if (refined.duration) {
                    duration = refined.duration;
                }
                if (!duration && refined.startTime && refined.endTime) {
                    duration = subtractDurations(refined.endTime, refined.startTime);
                }
                return {
                    allDayGuess: Boolean(!refined.startTime && !refined.endTime),
                    duration: duration,
                    typeData: recurringData, // doesn't need endTime anymore but oh well
                };
            }
            return null;
        },
        expand: function (typeData, framingRange, dateEnv) {
            var clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });
            if (clippedFramingRange) {
                return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
            }
            return [];
        },
    };
    var simpleRecurringEventsPlugin = createPlugin({
        recurringTypes: [recurring],
        eventRefiners: SIMPLE_RECURRING_REFINERS,
    });
    function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {
        var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
        var dayMarker = startOfDay$1(framingRange.start);
        var endMarker = framingRange.end;
        var instanceStarts = [];
        while (dayMarker < endMarker) {
            var instanceStart 
            // if everyday, or this particular day-of-week
            = void 0;
            // if everyday, or this particular day-of-week
            if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
                if (startTime) {
                    instanceStart = dateEnv.add(dayMarker, startTime);
                }
                else {
                    instanceStart = dayMarker;
                }
                instanceStarts.push(instanceStart);
            }
            dayMarker = addDays(dayMarker, 1);
        }
        return instanceStarts;
    }

    var changeHandlerPlugin = createPlugin({
        optionChangeHandlers: {
            events: function (events, context) {
                handleEventSources([events], context);
            },
            eventSources: handleEventSources,
        },
    });
    /*
    BUG: if `event` was supplied, all previously-given `eventSources` will be wiped out
    */
    function handleEventSources(inputs, context) {
        var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
        var newInputs = [];
        for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
            var input = inputs_1[_i];
            var inputFound = false;
            for (var i = 0; i < unfoundSources.length; i += 1) {
                if (unfoundSources[i]._raw === input) {
                    unfoundSources.splice(i, 1); // delete
                    inputFound = true;
                    break;
                }
            }
            if (!inputFound) {
                newInputs.push(input);
            }
        }
        for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {
            var unfoundSource = unfoundSources_1[_a];
            context.dispatch({
                type: 'REMOVE_EVENT_SOURCE',
                sourceId: unfoundSource.sourceId,
            });
        }
        for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {
            var newInput = newInputs_1[_b];
            context.calendarApi.addEventSource(newInput);
        }
    }

    function handleDateProfile(dateProfile, context) {
        context.emitter.trigger('datesSet', __assign(__assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), { view: context.viewApi }));
    }

    function handleEventStore(eventStore, context) {
        var emitter = context.emitter;
        if (emitter.hasHandlers('eventsSet')) {
            emitter.trigger('eventsSet', buildEventApis(eventStore, context));
        }
    }

    /*
    this array is exposed on the root namespace so that UMD plugins can add to it.
    see the rollup-bundles script.
    */
    var globalPlugins = [
        arrayEventSourcePlugin,
        funcEventSourcePlugin,
        jsonFeedEventSourcePlugin,
        simpleRecurringEventsPlugin,
        changeHandlerPlugin,
        createPlugin({
            isLoadingFuncs: [
                function (state) { return computeEventSourcesLoading(state.eventSources); },
            ],
            contentTypeHandlers: {
                html: buildHtmlRenderer,
                domNodes: buildDomNodeRenderer,
            },
            propSetHandlers: {
                dateProfile: handleDateProfile,
                eventStore: handleEventStore,
            },
        }),
    ];
    function buildHtmlRenderer() {
        var currentEl = null;
        var currentHtml = '';
        function render(el, html) {
            if (el !== currentEl || html !== currentHtml) {
                el.innerHTML = html;
            }
            currentEl = el;
            currentHtml = html;
        }
        function destroy() {
            currentEl.innerHTML = '';
            currentEl = null;
            currentHtml = '';
        }
        return { render: render, destroy: destroy };
    }
    function buildDomNodeRenderer() {
        var currentEl = null;
        var currentDomNodes = [];
        function render(el, domNodes) {
            var newDomNodes = Array.prototype.slice.call(domNodes);
            if (el !== currentEl || !isArraysEqual(currentDomNodes, newDomNodes)) {
                // append first, remove second (for scroll resetting)
                for (var _i = 0, newDomNodes_1 = newDomNodes; _i < newDomNodes_1.length; _i++) {
                    var newNode = newDomNodes_1[_i];
                    el.appendChild(newNode);
                }
                destroy();
            }
            currentEl = el;
            currentDomNodes = newDomNodes;
        }
        function destroy() {
            currentDomNodes.forEach(removeElement);
            currentDomNodes = [];
            currentEl = null;
        }
        return { render: render, destroy: destroy };
    }

    var DelayedRunner = /** @class */ (function () {
        function DelayedRunner(drainedOption) {
            this.drainedOption = drainedOption;
            this.isRunning = false;
            this.isDirty = false;
            this.pauseDepths = {};
            this.timeoutId = 0;
        }
        DelayedRunner.prototype.request = function (delay) {
            this.isDirty = true;
            if (!this.isPaused()) {
                this.clearTimeout();
                if (delay == null) {
                    this.tryDrain();
                }
                else {
                    this.timeoutId = setTimeout(// NOT OPTIMAL! TODO: look at debounce
                    this.tryDrain.bind(this), delay);
                }
            }
        };
        DelayedRunner.prototype.pause = function (scope) {
            if (scope === void 0) { scope = ''; }
            var pauseDepths = this.pauseDepths;
            pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
            this.clearTimeout();
        };
        DelayedRunner.prototype.resume = function (scope, force) {
            if (scope === void 0) { scope = ''; }
            var pauseDepths = this.pauseDepths;
            if (scope in pauseDepths) {
                if (force) {
                    delete pauseDepths[scope];
                }
                else {
                    pauseDepths[scope] -= 1;
                    var depth = pauseDepths[scope];
                    if (depth <= 0) {
                        delete pauseDepths[scope];
                    }
                }
                this.tryDrain();
            }
        };
        DelayedRunner.prototype.isPaused = function () {
            return Object.keys(this.pauseDepths).length;
        };
        DelayedRunner.prototype.tryDrain = function () {
            if (!this.isRunning && !this.isPaused()) {
                this.isRunning = true;
                while (this.isDirty) {
                    this.isDirty = false;
                    this.drained(); // might set isDirty to true again
                }
                this.isRunning = false;
            }
        };
        DelayedRunner.prototype.clear = function () {
            this.clearTimeout();
            this.isDirty = false;
            this.pauseDepths = {};
        };
        DelayedRunner.prototype.clearTimeout = function () {
            if (this.timeoutId) {
                clearTimeout(this.timeoutId);
                this.timeoutId = 0;
            }
        };
        DelayedRunner.prototype.drained = function () {
            if (this.drainedOption) {
                this.drainedOption();
            }
        };
        return DelayedRunner;
    }());

    var TaskRunner = /** @class */ (function () {
        function TaskRunner(runTaskOption, drainedOption) {
            this.runTaskOption = runTaskOption;
            this.drainedOption = drainedOption;
            this.queue = [];
            this.delayedRunner = new DelayedRunner(this.drain.bind(this));
        }
        TaskRunner.prototype.request = function (task, delay) {
            this.queue.push(task);
            this.delayedRunner.request(delay);
        };
        TaskRunner.prototype.pause = function (scope) {
            this.delayedRunner.pause(scope);
        };
        TaskRunner.prototype.resume = function (scope, force) {
            this.delayedRunner.resume(scope, force);
        };
        TaskRunner.prototype.drain = function () {
            var queue = this.queue;
            while (queue.length) {
                var completedTasks = [];
                var task = void 0;
                while ((task = queue.shift())) {
                    this.runTask(task);
                    completedTasks.push(task);
                }
                this.drained(completedTasks);
            } // keep going, in case new tasks were added in the drained handler
        };
        TaskRunner.prototype.runTask = function (task) {
            if (this.runTaskOption) {
                this.runTaskOption(task);
            }
        };
        TaskRunner.prototype.drained = function (completedTasks) {
            if (this.drainedOption) {
                this.drainedOption(completedTasks);
            }
        };
        return TaskRunner;
    }());

    // Computes what the title at the top of the calendarApi should be for this view
    function buildTitle(dateProfile, viewOptions, dateEnv) {
        var range;
        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after
        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
            range = dateProfile.currentRange;
        }
        else { // for day units or smaller, use the actual day range
            range = dateProfile.activeRange;
        }
        return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
            isEndExclusive: dateProfile.isRangeAllDay,
            defaultSeparator: viewOptions.titleRangeSeparator,
        });
    }
    // Generates the format string that should be used to generate the title for the current date range.
    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
    function buildTitleFormat(dateProfile) {
        var currentRangeUnit = dateProfile.currentRangeUnit;
        if (currentRangeUnit === 'year') {
            return { year: 'numeric' };
        }
        if (currentRangeUnit === 'month') {
            return { year: 'numeric', month: 'long' }; // like "September 2014"
        }
        var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
        if (days !== null && days > 1) {
            // multi-day range. shorter, like "Sep 9 - 10 2014"
            return { year: 'numeric', month: 'short', day: 'numeric' };
        }
        // one day. longer, like "September 9 2014"
        return { year: 'numeric', month: 'long', day: 'numeric' };
    }

    // in future refactor, do the redux-style function(state=initial) for initial-state
    // also, whatever is happening in constructor, have it happen in action queue too
    var CalendarDataManager = /** @class */ (function () {
        function CalendarDataManager(props) {
            var _this = this;
            this.computeOptionsData = memoize(this._computeOptionsData);
            this.computeCurrentViewData = memoize(this._computeCurrentViewData);
            this.organizeRawLocales = memoize(organizeRawLocales);
            this.buildLocale = memoize(buildLocale);
            this.buildPluginHooks = buildBuildPluginHooks();
            this.buildDateEnv = memoize(buildDateEnv);
            this.buildTheme = memoize(buildTheme);
            this.parseToolbars = memoize(parseToolbars);
            this.buildViewSpecs = memoize(buildViewSpecs);
            this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
            this.buildViewApi = memoize(buildViewApi);
            this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
            this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
            this.buildEventUiBases = memoize(buildEventUiBases);
            this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
            this.buildTitle = memoize(buildTitle);
            this.emitter = new Emitter();
            this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
            this.currentCalendarOptionsInput = {};
            this.currentCalendarOptionsRefined = {};
            this.currentViewOptionsInput = {};
            this.currentViewOptionsRefined = {};
            this.currentCalendarOptionsRefiners = {};
            this.getCurrentData = function () { return _this.data; };
            this.dispatch = function (action) {
                _this.actionRunner.request(action); // protects against recursive calls to _handleAction
            };
            this.props = props;
            this.actionRunner.pause();
            var dynamicOptionOverrides = {};
            var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
            var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
            var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
            // wire things up
            // TODO: not DRY
            props.calendarApi.currentDataManager = this;
            this.emitter.setThisContext(props.calendarApi);
            this.emitter.setOptions(currentViewData.options);
            var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);
            var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
            if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
                currentDate = dateProfile.currentRange.start;
            }
            var calendarContext = {
                dateEnv: optionsData.dateEnv,
                options: optionsData.calendarOptions,
                pluginHooks: optionsData.pluginHooks,
                calendarApi: props.calendarApi,
                dispatch: this.dispatch,
                emitter: this.emitter,
                getCurrentData: this.getCurrentData,
            };
            // needs to be after setThisContext
            for (var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++) {
                var callback = _a[_i];
                callback(calendarContext);
            }
            // NOT DRY
            var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
            var initialState = {
                dynamicOptionOverrides: dynamicOptionOverrides,
                currentViewType: currentViewType,
                currentDate: currentDate,
                dateProfile: dateProfile,
                businessHours: this.parseContextBusinessHours(calendarContext),
                eventSources: eventSources,
                eventUiBases: {},
                eventStore: createEmptyEventStore(),
                renderableEventStore: createEmptyEventStore(),
                dateSelection: null,
                eventSelection: '',
                eventDrag: null,
                eventResize: null,
                selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig,
            };
            var contextAndState = __assign(__assign({}, calendarContext), initialState);
            for (var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++) {
                var reducer = _c[_b];
                __assign(initialState, reducer(null, null, contextAndState));
            }
            if (computeIsLoading(initialState, calendarContext)) {
                this.emitter.trigger('loading', true); // NOT DRY
            }
            this.state = initialState;
            this.updateData();
            this.actionRunner.resume();
        }
        CalendarDataManager.prototype.resetOptions = function (optionOverrides, append) {
            var props = this.props;
            props.optionOverrides = append
                ? __assign(__assign({}, props.optionOverrides), optionOverrides) : optionOverrides;
            this.actionRunner.request({
                type: 'NOTHING',
            });
        };
        CalendarDataManager.prototype._handleAction = function (action) {
            var _a = this, props = _a.props, state = _a.state, emitter = _a.emitter;
            var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
            var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
            var currentViewType = reduceViewType(state.currentViewType, action);
            var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
            // wire things up
            // TODO: not DRY
            props.calendarApi.currentDataManager = this;
            emitter.setThisContext(props.calendarApi);
            emitter.setOptions(currentViewData.options);
            var calendarContext = {
                dateEnv: optionsData.dateEnv,
                options: optionsData.calendarOptions,
                pluginHooks: optionsData.pluginHooks,
                calendarApi: props.calendarApi,
                dispatch: this.dispatch,
                emitter: emitter,
                getCurrentData: this.getCurrentData,
            };
            var currentDate = state.currentDate, dateProfile = state.dateProfile;
            if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) { // hack
                dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
            }
            currentDate = reduceCurrentDate(currentDate, action);
            dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);
            if (action.type === 'PREV' || // TODO: move this logic into DateProfileGenerator
                action.type === 'NEXT' || // "
                !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
                currentDate = dateProfile.currentRange.start;
            }
            var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
            var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
            var isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading
            var renderableEventStore = (isEventsLoading && !currentViewData.options.progressiveEventRendering) ?
                (state.renderableEventStore || eventStore) : // try from previous state
                eventStore;
            var _b = this.buildViewUiProps(calendarContext), eventUiSingleBase = _b.eventUiSingleBase, selectionConfig = _b.selectionConfig; // will memoize obj
            var eventUiBySource = this.buildEventUiBySource(eventSources);
            var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
            var newState = {
                dynamicOptionOverrides: dynamicOptionOverrides,
                currentViewType: currentViewType,
                currentDate: currentDate,
                dateProfile: dateProfile,
                eventSources: eventSources,
                eventStore: eventStore,
                renderableEventStore: renderableEventStore,
                selectionConfig: selectionConfig,
                eventUiBases: eventUiBases,
                businessHours: this.parseContextBusinessHours(calendarContext),
                dateSelection: reduceDateSelection(state.dateSelection, action),
                eventSelection: reduceSelectedEvent(state.eventSelection, action),
                eventDrag: reduceEventDrag(state.eventDrag, action),
                eventResize: reduceEventResize(state.eventResize, action),
            };
            var contextAndState = __assign(__assign({}, calendarContext), newState);
            for (var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++) {
                var reducer = _c[_i];
                __assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value
            }
            var wasLoading = computeIsLoading(state, calendarContext);
            var isLoading = computeIsLoading(newState, calendarContext);
            // TODO: use propSetHandlers in plugin system
            if (!wasLoading && isLoading) {
                emitter.trigger('loading', true);
            }
            else if (wasLoading && !isLoading) {
                emitter.trigger('loading', false);
            }
            this.state = newState;
            if (props.onAction) {
                props.onAction(action);
            }
        };
        CalendarDataManager.prototype.updateData = function () {
            var _a = this, props = _a.props, state = _a.state;
            var oldData = this.data;
            var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
            var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);
            var data = this.data = __assign(__assign(__assign({ viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);
            var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
            var oldCalendarOptions = oldData && oldData.calendarOptions;
            var newCalendarOptions = optionsData.calendarOptions;
            if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
                if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
                    // hack
                    state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
                    state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
                }
                for (var optionName in changeHandlers) {
                    if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
                        changeHandlers[optionName](newCalendarOptions[optionName], data);
                    }
                }
            }
            if (props.onData) {
                props.onData(data);
            }
        };
        CalendarDataManager.prototype._computeOptionsData = function (optionOverrides, dynamicOptionOverrides, calendarApi) {
            // TODO: blacklist options that are handled by optionChangeHandlers
            var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, pluginHooks = _a.pluginHooks, localeDefaults = _a.localeDefaults, availableLocaleData = _a.availableLocaleData, extra = _a.extra;
            warnUnknownOptions(extra);
            var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
            var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);
            var theme = this.buildTheme(refinedOptions, pluginHooks);
            var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);
            return {
                calendarOptions: refinedOptions,
                pluginHooks: pluginHooks,
                dateEnv: dateEnv,
                viewSpecs: viewSpecs,
                theme: theme,
                toolbarConfig: toolbarConfig,
                localeDefaults: localeDefaults,
                availableRawLocales: availableLocaleData.map,
            };
        };
        // always called from behind a memoizer
        CalendarDataManager.prototype.processRawCalendarOptions = function (optionOverrides, dynamicOptionOverrides) {
            var _a = mergeRawOptions([
                BASE_OPTION_DEFAULTS,
                optionOverrides,
                dynamicOptionOverrides,
            ]), locales = _a.locales, locale = _a.locale;
            var availableLocaleData = this.organizeRawLocales(locales);
            var availableRawLocales = availableLocaleData.map;
            var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
            var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);
            var refiners = this.currentCalendarOptionsRefiners = __assign(__assign(__assign(__assign(__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
            var extra = {};
            var raw = mergeRawOptions([
                BASE_OPTION_DEFAULTS,
                localeDefaults,
                optionOverrides,
                dynamicOptionOverrides,
            ]);
            var refined = {};
            var currentRaw = this.currentCalendarOptionsInput;
            var currentRefined = this.currentCalendarOptionsRefined;
            var anyChanges = false;
            for (var optionName in raw) {
                if (optionName !== 'plugins') { // because plugins is special-cased
                    if (raw[optionName] === currentRaw[optionName] ||
                        (COMPLEX_OPTION_COMPARATORS[optionName] &&
                            (optionName in currentRaw) &&
                            COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName]))) {
                        refined[optionName] = currentRefined[optionName];
                    }
                    else if (refiners[optionName]) {
                        refined[optionName] = refiners[optionName](raw[optionName]);
                        anyChanges = true;
                    }
                    else {
                        extra[optionName] = currentRaw[optionName];
                    }
                }
            }
            if (anyChanges) {
                this.currentCalendarOptionsInput = raw;
                this.currentCalendarOptionsRefined = refined;
            }
            return {
                rawOptions: this.currentCalendarOptionsInput,
                refinedOptions: this.currentCalendarOptionsRefined,
                pluginHooks: pluginHooks,
                availableLocaleData: availableLocaleData,
                localeDefaults: localeDefaults,
                extra: extra,
            };
        };
        CalendarDataManager.prototype._computeCurrentViewData = function (viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
            var viewSpec = optionsData.viewSpecs[viewType];
            if (!viewSpec) {
                throw new Error("viewType \"" + viewType + "\" is not available. Please make sure you've loaded all neccessary plugins");
            }
            var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, extra = _a.extra;
            warnUnknownOptions(extra);
            var dateProfileGenerator = this.buildDateProfileGenerator({
                dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
                duration: viewSpec.duration,
                durationUnit: viewSpec.durationUnit,
                usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
                dateEnv: optionsData.dateEnv,
                calendarApi: this.props.calendarApi,
                slotMinTime: refinedOptions.slotMinTime,
                slotMaxTime: refinedOptions.slotMaxTime,
                showNonCurrentDates: refinedOptions.showNonCurrentDates,
                dayCount: refinedOptions.dayCount,
                dateAlignment: refinedOptions.dateAlignment,
                dateIncrement: refinedOptions.dateIncrement,
                hiddenDays: refinedOptions.hiddenDays,
                weekends: refinedOptions.weekends,
                nowInput: refinedOptions.now,
                validRangeInput: refinedOptions.validRange,
                visibleRangeInput: refinedOptions.visibleRange,
                monthMode: refinedOptions.monthMode,
                fixedWeekCount: refinedOptions.fixedWeekCount,
            });
            var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
            return { viewSpec: viewSpec, options: refinedOptions, dateProfileGenerator: dateProfileGenerator, viewApi: viewApi };
        };
        CalendarDataManager.prototype.processRawViewOptions = function (viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
            var raw = mergeRawOptions([
                BASE_OPTION_DEFAULTS,
                viewSpec.optionDefaults,
                localeDefaults,
                optionOverrides,
                viewSpec.optionOverrides,
                dynamicOptionOverrides,
            ]);
            var refiners = __assign(__assign(__assign(__assign(__assign(__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
            var refined = {};
            var currentRaw = this.currentViewOptionsInput;
            var currentRefined = this.currentViewOptionsRefined;
            var anyChanges = false;
            var extra = {};
            for (var optionName in raw) {
                if (raw[optionName] === currentRaw[optionName]) {
                    refined[optionName] = currentRefined[optionName];
                }
                else {
                    if (raw[optionName] === this.currentCalendarOptionsInput[optionName]) {
                        if (optionName in this.currentCalendarOptionsRefined) { // might be an "extra" prop
                            refined[optionName] = this.currentCalendarOptionsRefined[optionName];
                        }
                    }
                    else if (refiners[optionName]) {
                        refined[optionName] = refiners[optionName](raw[optionName]);
                    }
                    else {
                        extra[optionName] = raw[optionName];
                    }
                    anyChanges = true;
                }
            }
            if (anyChanges) {
                this.currentViewOptionsInput = raw;
                this.currentViewOptionsRefined = refined;
            }
            return {
                rawOptions: this.currentViewOptionsInput,
                refinedOptions: this.currentViewOptionsRefined,
                extra: extra,
            };
        };
        return CalendarDataManager;
    }());
    function buildDateEnv(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
        var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
        return new DateEnv({
            calendarSystem: 'gregory',
            timeZone: timeZone,
            namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
            locale: locale,
            weekNumberCalculation: weekNumberCalculation,
            firstDay: firstDay,
            weekText: weekText,
            cmdFormatter: pluginHooks.cmdFormatter,
            defaultSeparator: defaultSeparator,
        });
    }
    function buildTheme(options, pluginHooks) {
        var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
        return new ThemeClass(options);
    }
    function buildDateProfileGenerator(props) {
        var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
        return new DateProfileGeneratorClass(props);
    }
    function buildViewApi(type, getCurrentData, dateEnv) {
        return new ViewApi(type, getCurrentData, dateEnv);
    }
    function buildEventUiBySource(eventSources) {
        return mapHash(eventSources, function (eventSource) { return eventSource.ui; });
    }
    function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
        var eventUiBases = { '': eventUiSingleBase };
        for (var defId in eventDefs) {
            var def = eventDefs[defId];
            if (def.sourceId && eventUiBySource[def.sourceId]) {
                eventUiBases[defId] = eventUiBySource[def.sourceId];
            }
        }
        return eventUiBases;
    }
    function buildViewUiProps(calendarContext) {
        var options = calendarContext.options;
        return {
            eventUiSingleBase: createEventUi({
                display: options.eventDisplay,
                editable: options.editable,
                startEditable: options.eventStartEditable,
                durationEditable: options.eventDurationEditable,
                constraint: options.eventConstraint,
                overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,
                allow: options.eventAllow,
                backgroundColor: options.eventBackgroundColor,
                borderColor: options.eventBorderColor,
                textColor: options.eventTextColor,
                color: options.eventColor,
                // classNames: options.eventClassNames // render hook will handle this
            }, calendarContext),
            selectionConfig: createEventUi({
                constraint: options.selectConstraint,
                overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,
                allow: options.selectAllow,
            }, calendarContext),
        };
    }
    function computeIsLoading(state, context) {
        for (var _i = 0, _a = context.pluginHooks.isLoadingFuncs; _i < _a.length; _i++) {
            var isLoadingFunc = _a[_i];
            if (isLoadingFunc(state)) {
                return true;
            }
        }
        return false;
    }
    function parseContextBusinessHours(calendarContext) {
        return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
    }
    function warnUnknownOptions(options, viewName) {
        for (var optionName in options) {
            console.warn("Unknown option '" + optionName + "'" +
                (viewName ? " for view '" + viewName + "'" : ''));
        }
    }

    // TODO: move this to react plugin?
    var CalendarDataProvider = /** @class */ (function (_super) {
        __extends(CalendarDataProvider, _super);
        function CalendarDataProvider(props) {
            var _this = _super.call(this, props) || this;
            _this.handleData = function (data) {
                if (!_this.dataManager) { // still within initial run, before assignment in constructor
                    // eslint-disable-next-line react/no-direct-mutation-state
                    _this.state = data; // can't use setState yet
                }
                else {
                    _this.setState(data);
                }
            };
            _this.dataManager = new CalendarDataManager({
                optionOverrides: props.optionOverrides,
                calendarApi: props.calendarApi,
                onData: _this.handleData,
            });
            return _this;
        }
        CalendarDataProvider.prototype.render = function () {
            return this.props.children(this.state);
        };
        CalendarDataProvider.prototype.componentDidUpdate = function (prevProps) {
            var newOptionOverrides = this.props.optionOverrides;
            if (newOptionOverrides !== prevProps.optionOverrides) { // prevent recursive handleData
                this.dataManager.resetOptions(newOptionOverrides);
            }
        };
        return CalendarDataProvider;
    }(Component));

    var SegHierarchy = /** @class */ (function () {
        function SegHierarchy() {
            // settings
            this.strictOrder = false;
            this.allowReslicing = false;
            this.maxCoord = -1; // -1 means no max
            this.maxStackCnt = -1; // -1 means no max
            this.levelCoords = []; // ordered
            this.entriesByLevel = []; // parallel with levelCoords
            this.stackCnts = {}; // TODO: use better technique!?
        }
        SegHierarchy.prototype.addSegs = function (inputs) {
            var hiddenEntries = [];
            for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
                var input = inputs_1[_i];
                this.insertEntry(input, hiddenEntries);
            }
            return hiddenEntries;
        };
        SegHierarchy.prototype.insertEntry = function (entry, hiddenEntries) {
            var insertion = this.findInsertion(entry);
            if (this.isInsertionValid(insertion, entry)) {
                this.insertEntryAt(entry, insertion);
                return 1;
            }
            return this.handleInvalidInsertion(insertion, entry, hiddenEntries);
        };
        SegHierarchy.prototype.isInsertionValid = function (insertion, entry) {
            return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) &&
                (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
        };
        // returns number of new entries inserted
        SegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {
            if (this.allowReslicing && insertion.touchingEntry) {
                return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
            }
            hiddenEntries.push(entry);
            return 0;
        };
        SegHierarchy.prototype.splitEntry = function (entry, barrier, hiddenEntries) {
            var partCnt = 0;
            var splitHiddenEntries = [];
            var entrySpan = entry.span;
            var barrierSpan = barrier.span;
            if (entrySpan.start < barrierSpan.start) {
                partCnt += this.insertEntry({
                    index: entry.index,
                    thickness: entry.thickness,
                    span: { start: entrySpan.start, end: barrierSpan.start },
                }, splitHiddenEntries);
            }
            if (entrySpan.end > barrierSpan.end) {
                partCnt += this.insertEntry({
                    index: entry.index,
                    thickness: entry.thickness,
                    span: { start: barrierSpan.end, end: entrySpan.end },
                }, splitHiddenEntries);
            }
            if (partCnt) {
                hiddenEntries.push.apply(hiddenEntries, __spreadArray([{
                        index: entry.index,
                        thickness: entry.thickness,
                        span: intersectSpans(barrierSpan, entrySpan), // guaranteed to intersect
                    }], splitHiddenEntries));
                return partCnt;
            }
            hiddenEntries.push(entry);
            return 0;
        };
        SegHierarchy.prototype.insertEntryAt = function (entry, insertion) {
            var _a = this, entriesByLevel = _a.entriesByLevel, levelCoords = _a.levelCoords;
            if (insertion.lateral === -1) {
                // create a new level
                insertAt(levelCoords, insertion.level, insertion.levelCoord);
                insertAt(entriesByLevel, insertion.level, [entry]);
            }
            else {
                // insert into existing level
                insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
            }
            this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
        };
        SegHierarchy.prototype.findInsertion = function (newEntry) {
            var _a = this, levelCoords = _a.levelCoords, entriesByLevel = _a.entriesByLevel, strictOrder = _a.strictOrder, stackCnts = _a.stackCnts;
            var levelCnt = levelCoords.length;
            var candidateCoord = 0;
            var touchingLevel = -1;
            var touchingLateral = -1;
            var touchingEntry = null;
            var stackCnt = 0;
            for (var trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {
                var trackingCoord = levelCoords[trackingLevel];
                // if the current level is past the placed entry, we have found a good empty space and can stop.
                // if strictOrder, keep finding more lateral intersections.
                if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {
                    break;
                }
                var trackingEntries = entriesByLevel[trackingLevel];
                var trackingEntry = void 0;
                var searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end
                var lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one
                while ( // loop through entries that horizontally intersect
                (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list
                    trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry
                ) {
                    var trackingEntryBottom = trackingCoord + trackingEntry.thickness;
                    // intersects into the top of the candidate?
                    if (trackingEntryBottom > candidateCoord) {
                        candidateCoord = trackingEntryBottom;
                        touchingEntry = trackingEntry;
                        touchingLevel = trackingLevel;
                        touchingLateral = lateralIndex;
                    }
                    // butts up against top of candidate? (will happen if just intersected as well)
                    if (trackingEntryBottom === candidateCoord) {
                        // accumulate the highest possible stackCnt of the trackingEntries that butt up
                        stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
                    }
                    lateralIndex += 1;
                }
            }
            // the destination level will be after touchingEntry's level. find it
            var destLevel = 0;
            if (touchingEntry) {
                destLevel = touchingLevel + 1;
                while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
                    destLevel += 1;
                }
            }
            // if adding to an existing level, find where to insert
            var destLateral = -1;
            if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
                destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
            }
            return {
                touchingLevel: touchingLevel,
                touchingLateral: touchingLateral,
                touchingEntry: touchingEntry,
                stackCnt: stackCnt,
                levelCoord: candidateCoord,
                level: destLevel,
                lateral: destLateral,
            };
        };
        // sorted by levelCoord (lowest to highest)
        SegHierarchy.prototype.toRects = function () {
            var _a = this, entriesByLevel = _a.entriesByLevel, levelCoords = _a.levelCoords;
            var levelCnt = entriesByLevel.length;
            var rects = [];
            for (var level = 0; level < levelCnt; level += 1) {
                var entries = entriesByLevel[level];
                var levelCoord = levelCoords[level];
                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                    var entry = entries_1[_i];
                    rects.push(__assign(__assign({}, entry), { levelCoord: levelCoord }));
                }
            }
            return rects;
        };
        return SegHierarchy;
    }());
    function getEntrySpanEnd(entry) {
        return entry.span.end;
    }
    function buildEntryKey(entry) {
        return entry.index + ':' + entry.span.start;
    }
    function intersectSpans(span0, span1) {
        var start = Math.max(span0.start, span1.start);
        var end = Math.min(span0.end, span1.end);
        if (start < end) {
            return { start: start, end: end };
        }
        return null;
    }
    // general util
    // ---------------------------------------------------------------------------------------------------------------------
    function insertAt(arr, index, item) {
        arr.splice(index, 0, item);
    }
    function binarySearch(a, searchVal, getItemVal) {
        var startIndex = 0;
        var endIndex = a.length; // exclusive
        if (!endIndex || searchVal < getItemVal(a[startIndex])) { // no items OR before first item
            return [0, 0];
        }
        if (searchVal > getItemVal(a[endIndex - 1])) { // after last item
            return [endIndex, 0];
        }
        while (startIndex < endIndex) {
            var middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
            var middleVal = getItemVal(a[middleIndex]);
            if (searchVal < middleVal) {
                endIndex = middleIndex;
            }
            else if (searchVal > middleVal) {
                startIndex = middleIndex + 1;
            }
            else { // equal!
                return [middleIndex, 1];
            }
        }
        return [startIndex, 0];
    }

    var Interaction = /** @class */ (function () {
        function Interaction(settings) {
            this.component = settings.component;
            this.isHitComboAllowed = settings.isHitComboAllowed || null;
        }
        Interaction.prototype.destroy = function () {
        };
        return Interaction;
    }());
    function parseInteractionSettings(component, input) {
        return {
            component: component,
            el: input.el,
            useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
            isHitComboAllowed: input.isHitComboAllowed || null,
        };
    }
    function interactionSettingsToStore(settings) {
        var _a;
        return _a = {},
            _a[settings.component.uid] = settings,
            _a;
    }
    // global state
    var interactionSettingsStore = {};

    /*
    An abstraction for a dragging interaction originating on an event.
    Does higher-level things than PointerDragger, such as possibly:
    - a "mirror" that moves with the pointer
    - a minimum number of pixels or other criteria for a true drag to begin

    subclasses must emit:
    - pointerdown
    - dragstart
    - dragmove
    - pointerup
    - dragend
    */
    var ElementDragging = /** @class */ (function () {
        function ElementDragging(el, selector) {
            this.emitter = new Emitter();
        }
        ElementDragging.prototype.destroy = function () {
        };
        ElementDragging.prototype.setMirrorIsVisible = function (bool) {
            // optional if subclass doesn't want to support a mirror
        };
        ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {
            // optional if subclass doesn't want to support a mirror
        };
        ElementDragging.prototype.setAutoScrollEnabled = function (bool) {
            // optional
        };
        return ElementDragging;
    }());

    // TODO: get rid of this in favor of options system,
    // tho it's really easy to access this globally rather than pass thru options.
    var config = {};

    var ToolbarSection = /** @class */ (function (_super) {
        __extends(ToolbarSection, _super);
        function ToolbarSection() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ToolbarSection.prototype.render = function () {
            var _this = this;
            var children = this.props.widgetGroups.map(function (widgetGroup) { return _this.renderWidgetGroup(widgetGroup); });
            return createElement.apply(void 0, __spreadArray(['div', { className: 'fc-toolbar-chunk' }], children));
        };
        ToolbarSection.prototype.renderWidgetGroup = function (widgetGroup) {
            var props = this.props;
            var theme = this.context.theme;
            var children = [];
            var isOnlyButtons = true;
            for (var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++) {
                var widget = widgetGroup_1[_i];
                var buttonName = widget.buttonName, buttonClick = widget.buttonClick, buttonText = widget.buttonText, buttonIcon = widget.buttonIcon, buttonHint = widget.buttonHint;
                if (buttonName === 'title') {
                    isOnlyButtons = false;
                    children.push(createElement("h2", { className: "fc-toolbar-title", id: props.titleId }, props.title));
                }
                else {
                    var isPressed = buttonName === props.activeButton;
                    var isDisabled = (!props.isTodayEnabled && buttonName === 'today') ||
                        (!props.isPrevEnabled && buttonName === 'prev') ||
                        (!props.isNextEnabled && buttonName === 'next');
                    var buttonClasses = ["fc-" + buttonName + "-button", theme.getClass('button')];
                    if (isPressed) {
                        buttonClasses.push(theme.getClass('buttonActive'));
                    }
                    children.push(createElement("button", { type: "button", title: typeof buttonHint === 'function' ? buttonHint(props.navUnit) : buttonHint, disabled: isDisabled, "aria-pressed": isPressed, className: buttonClasses.join(' '), onClick: buttonClick }, buttonText || (buttonIcon ? createElement("span", { className: buttonIcon }) : '')));
                }
            }
            if (children.length > 1) {
                var groupClassName = (isOnlyButtons && theme.getClass('buttonGroup')) || '';
                return createElement.apply(void 0, __spreadArray(['div', { className: groupClassName }], children));
            }
            return children[0];
        };
        return ToolbarSection;
    }(BaseComponent));

    var Toolbar = /** @class */ (function (_super) {
        __extends(Toolbar, _super);
        function Toolbar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Toolbar.prototype.render = function () {
            var _a = this.props, model = _a.model, extraClassName = _a.extraClassName;
            var forceLtr = false;
            var startContent;
            var endContent;
            var sectionWidgets = model.sectionWidgets;
            var centerContent = sectionWidgets.center;
            if (sectionWidgets.left) {
                forceLtr = true;
                startContent = sectionWidgets.left;
            }
            else {
                startContent = sectionWidgets.start;
            }
            if (sectionWidgets.right) {
                forceLtr = true;
                endContent = sectionWidgets.right;
            }
            else {
                endContent = sectionWidgets.end;
            }
            var classNames = [
                extraClassName || '',
                'fc-toolbar',
                forceLtr ? 'fc-toolbar-ltr' : '',
            ];
            return (createElement("div", { className: classNames.join(' ') },
                this.renderSection('start', startContent || []),
                this.renderSection('center', centerContent || []),
                this.renderSection('end', endContent || [])));
        };
        Toolbar.prototype.renderSection = function (key, widgetGroups) {
            var props = this.props;
            return (createElement(ToolbarSection, { key: key, widgetGroups: widgetGroups, title: props.title, navUnit: props.navUnit, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled, titleId: props.titleId }));
        };
        return Toolbar;
    }(BaseComponent));

    // TODO: do function component?
    var ViewContainer = /** @class */ (function (_super) {
        __extends(ViewContainer, _super);
        function ViewContainer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = {
                availableWidth: null,
            };
            _this.handleEl = function (el) {
                _this.el = el;
                setRef(_this.props.elRef, el);
                _this.updateAvailableWidth();
            };
            _this.handleResize = function () {
                _this.updateAvailableWidth();
            };
            return _this;
        }
        ViewContainer.prototype.render = function () {
            var _a = this, props = _a.props, state = _a.state;
            var aspectRatio = props.aspectRatio;
            var classNames = [
                'fc-view-harness',
                (aspectRatio || props.liquid || props.height)
                    ? 'fc-view-harness-active' // harness controls the height
                    : 'fc-view-harness-passive', // let the view do the height
            ];
            var height = '';
            var paddingBottom = '';
            if (aspectRatio) {
                if (state.availableWidth !== null) {
                    height = state.availableWidth / aspectRatio;
                }
                else {
                    // while waiting to know availableWidth, we can't set height to *zero*
                    // because will cause lots of unnecessary scrollbars within scrollgrid.
                    // BETTER: don't start rendering ANYTHING yet until we know container width
                    // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)
                    paddingBottom = (1 / aspectRatio) * 100 + "%";
                }
            }
            else {
                height = props.height || '';
            }
            return (createElement("div", { "aria-labelledby": props.labeledById, ref: this.handleEl, className: classNames.join(' '), style: { height: height, paddingBottom: paddingBottom } }, props.children));
        };
        ViewContainer.prototype.componentDidMount = function () {
            this.context.addResizeHandler(this.handleResize);
        };
        ViewContainer.prototype.componentWillUnmount = function () {
            this.context.removeResizeHandler(this.handleResize);
        };
        ViewContainer.prototype.updateAvailableWidth = function () {
            if (this.el && // needed. but why?
                this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth
            ) {
                this.setState({ availableWidth: this.el.offsetWidth });
            }
        };
        return ViewContainer;
    }(BaseComponent));

    /*
    Detects when the user clicks on an event within a DateComponent
    */
    var EventClicking = /** @class */ (function (_super) {
        __extends(EventClicking, _super);
        function EventClicking(settings) {
            var _this = _super.call(this, settings) || this;
            _this.handleSegClick = function (ev, segEl) {
                var component = _this.component;
                var context = component.context;
                var seg = getElSeg(segEl);
                if (seg && // might be the <div> surrounding the more link
                    component.isValidSegDownEl(ev.target)) {
                    // our way to simulate a link click for elements that can't be <a> tags
                    // grab before trigger fired in case trigger trashes DOM thru rerendering
                    var hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');
                    var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';
                    context.emitter.trigger('eventClick', {
                        el: segEl,
                        event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),
                        jsEvent: ev,
                        view: context.viewApi,
                    });
                    if (url && !ev.defaultPrevented) {
                        window.location.href = url;
                    }
                }
            };
            _this.destroy = listenBySelector(settings.el, 'click', '.fc-event', // on both fg and bg events
            _this.handleSegClick);
            return _this;
        }
        return EventClicking;
    }(Interaction));

    /*
    Triggers events and adds/removes core classNames when the user's pointer
    enters/leaves event-elements of a component.
    */
    var EventHovering = /** @class */ (function (_super) {
        __extends(EventHovering, _super);
        function EventHovering(settings) {
            var _this = _super.call(this, settings) || this;
            // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it
            _this.handleEventElRemove = function (el) {
                if (el === _this.currentSegEl) {
                    _this.handleSegLeave(null, _this.currentSegEl);
                }
            };
            _this.handleSegEnter = function (ev, segEl) {
                if (getElSeg(segEl)) { // TODO: better way to make sure not hovering over more+ link or its wrapper
                    _this.currentSegEl = segEl;
                    _this.triggerEvent('eventMouseEnter', ev, segEl);
                }
            };
            _this.handleSegLeave = function (ev, segEl) {
                if (_this.currentSegEl) {
                    _this.currentSegEl = null;
                    _this.triggerEvent('eventMouseLeave', ev, segEl);
                }
            };
            _this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', // on both fg and bg events
            _this.handleSegEnter, _this.handleSegLeave);
            return _this;
        }
        EventHovering.prototype.destroy = function () {
            this.removeHoverListeners();
        };
        EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {
            var component = this.component;
            var context = component.context;
            var seg = getElSeg(segEl);
            if (!ev || component.isValidSegDownEl(ev.target)) {
                context.emitter.trigger(publicEvName, {
                    el: segEl,
                    event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),
                    jsEvent: ev,
                    view: context.viewApi,
                });
            }
        };
        return EventHovering;
    }(Interaction));

    var CalendarContent = /** @class */ (function (_super) {
        __extends(CalendarContent, _super);
        function CalendarContent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.buildViewContext = memoize(buildViewContext);
            _this.buildViewPropTransformers = memoize(buildViewPropTransformers);
            _this.buildToolbarProps = memoize(buildToolbarProps);
            _this.headerRef = createRef();
            _this.footerRef = createRef();
            _this.interactionsStore = {};
            // eslint-disable-next-line
            _this.state = {
                viewLabelId: getUniqueDomId(),
            };
            // Component Registration
            // -----------------------------------------------------------------------------------------------------------------
            _this.registerInteractiveComponent = function (component, settingsInput) {
                var settings = parseInteractionSettings(component, settingsInput);
                var DEFAULT_INTERACTIONS = [
                    EventClicking,
                    EventHovering,
                ];
                var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);
                var interactions = interactionClasses.map(function (TheInteractionClass) { return new TheInteractionClass(settings); });
                _this.interactionsStore[component.uid] = interactions;
                interactionSettingsStore[component.uid] = settings;
            };
            _this.unregisterInteractiveComponent = function (component) {
                for (var _i = 0, _a = _this.interactionsStore[component.uid]; _i < _a.length; _i++) {
                    var listener = _a[_i];
                    listener.destroy();
                }
                delete _this.interactionsStore[component.uid];
                delete interactionSettingsStore[component.uid];
            };
            // Resizing
            // -----------------------------------------------------------------------------------------------------------------
            _this.resizeRunner = new DelayedRunner(function () {
                _this.props.emitter.trigger('_resize', true); // should window resizes be considered "forced" ?
                _this.props.emitter.trigger('windowResize', { view: _this.props.viewApi });
            });
            _this.handleWindowResize = function (ev) {
                var options = _this.props.options;
                if (options.handleWindowResize &&
                    ev.target === window // avoid jqui events
                ) {
                    _this.resizeRunner.request(options.windowResizeDelay);
                }
            };
            return _this;
        }
        /*
        renders INSIDE of an outer div
        */
        CalendarContent.prototype.render = function () {
            var props = this.props;
            var toolbarConfig = props.toolbarConfig, options = props.options;
            var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), // TODO: use NowTimer????
            props.viewTitle);
            var viewVGrow = false;
            var viewHeight = '';
            var viewAspectRatio;
            if (props.isHeightAuto || props.forPrint) {
                viewHeight = '';
            }
            else if (options.height != null) {
                viewVGrow = true;
            }
            else if (options.contentHeight != null) {
                viewHeight = options.contentHeight;
            }
            else {
                viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall
            }
            var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
            var viewLabelId = (toolbarConfig.header && toolbarConfig.header.hasTitle)
                ? this.state.viewLabelId
                : '';
            return (createElement(ViewContextType.Provider, { value: viewContext },
                toolbarConfig.header && (createElement(Toolbar, __assign({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: toolbarConfig.header, titleId: viewLabelId }, toolbarProps))),
                createElement(ViewContainer, { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, labeledById: viewLabelId },
                    this.renderView(props),
                    this.buildAppendContent()),
                toolbarConfig.footer && (createElement(Toolbar, __assign({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: toolbarConfig.footer, titleId: "" }, toolbarProps)))));
        };
        CalendarContent.prototype.componentDidMount = function () {
            var props = this.props;
            this.calendarInteractions = props.pluginHooks.calendarInteractions
                .map(function (CalendarInteractionClass) { return new CalendarInteractionClass(props); });
            window.addEventListener('resize', this.handleWindowResize);
            var propSetHandlers = props.pluginHooks.propSetHandlers;
            for (var propName in propSetHandlers) {
                propSetHandlers[propName](props[propName], props);
            }
        };
        CalendarContent.prototype.componentDidUpdate = function (prevProps) {
            var props = this.props;
            var propSetHandlers = props.pluginHooks.propSetHandlers;
            for (var propName in propSetHandlers) {
                if (props[propName] !== prevProps[propName]) {
                    propSetHandlers[propName](props[propName], props);
                }
            }
        };
        CalendarContent.prototype.componentWillUnmount = function () {
            window.removeEventListener('resize', this.handleWindowResize);
            this.resizeRunner.clear();
            for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {
                var interaction = _a[_i];
                interaction.destroy();
            }
            this.props.emitter.trigger('_unmount');
        };
        CalendarContent.prototype.buildAppendContent = function () {
            var props = this.props;
            var children = props.pluginHooks.viewContainerAppends.map(function (buildAppendContent) { return buildAppendContent(props); });
            return createElement.apply(void 0, __spreadArray([Fragment, {}], children));
        };
        CalendarContent.prototype.renderView = function (props) {
            var pluginHooks = props.pluginHooks;
            var viewSpec = props.viewSpec;
            var viewProps = {
                dateProfile: props.dateProfile,
                businessHours: props.businessHours,
                eventStore: props.renderableEventStore,
                eventUiBases: props.eventUiBases,
                dateSelection: props.dateSelection,
                eventSelection: props.eventSelection,
                eventDrag: props.eventDrag,
                eventResize: props.eventResize,
                isHeightAuto: props.isHeightAuto,
                forPrint: props.forPrint,
            };
            var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);
            for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
                var transformer = transformers_1[_i];
                __assign(viewProps, transformer.transform(viewProps, props));
            }
            var ViewComponent = viewSpec.component;
            return (createElement(ViewComponent, __assign({}, viewProps)));
        };
        return CalendarContent;
    }(PureComponent));
    function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {
        // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid
        var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason
        var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
        var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
        return {
            title: title,
            activeButton: viewSpec.type,
            navUnit: viewSpec.singleUnit,
            isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
            isPrevEnabled: prevInfo.isValid,
            isNextEnabled: nextInfo.isValid,
        };
    }
    // Plugin
    // -----------------------------------------------------------------------------------------------------------------
    function buildViewPropTransformers(theClasses) {
        return theClasses.map(function (TheClass) { return new TheClass(); });
    }

    var CalendarRoot = /** @class */ (function (_super) {
        __extends(CalendarRoot, _super);
        function CalendarRoot() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = {
                forPrint: false,
            };
            _this.handleBeforePrint = function () {
                _this.setState({ forPrint: true });
            };
            _this.handleAfterPrint = function () {
                _this.setState({ forPrint: false });
            };
            return _this;
        }
        CalendarRoot.prototype.render = function () {
            var props = this.props;
            var options = props.options;
            var forPrint = this.state.forPrint;
            var isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';
            var height = (!isHeightAuto && options.height != null) ? options.height : '';
            var classNames = [
                'fc',
                forPrint ? 'fc-media-print' : 'fc-media-screen',
                "fc-direction-" + options.direction,
                props.theme.getClass('root'),
            ];
            if (!getCanVGrowWithinCell()) {
                classNames.push('fc-liquid-hack');
            }
            return props.children(classNames, height, isHeightAuto, forPrint);
        };
        CalendarRoot.prototype.componentDidMount = function () {
            var emitter = this.props.emitter;
            emitter.on('_beforeprint', this.handleBeforePrint);
            emitter.on('_afterprint', this.handleAfterPrint);
        };
        CalendarRoot.prototype.componentWillUnmount = function () {
            var emitter = this.props.emitter;
            emitter.off('_beforeprint', this.handleBeforePrint);
            emitter.off('_afterprint', this.handleAfterPrint);
        };
        return CalendarRoot;
    }(BaseComponent));

    // Computes a default column header formatting string if `colFormat` is not explicitly defined
    function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
        // if more than one week row, or if there are a lot of columns with not much space,
        // put just the day numbers will be in each cell
        if (!datesRepDistinctDays || dayCnt > 10) {
            return createFormatter({ weekday: 'short' }); // "Sat"
        }
        if (dayCnt > 1) {
            return createFormatter({ weekday: 'short', month: 'numeric', day: 'numeric', omitCommas: true }); // "Sat 11/12"
        }
        return createFormatter({ weekday: 'long' }); // "Saturday"
    }

    var CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no
    function renderInner$1(hookProps) {
        return hookProps.text;
    }

    var TableDateCell = /** @class */ (function (_super) {
        __extends(TableDateCell, _super);
        function TableDateCell() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableDateCell.prototype.render = function () {
            var _a = this.context, dateEnv = _a.dateEnv, options = _a.options, theme = _a.theme, viewApi = _a.viewApi;
            var props = this.props;
            var date = props.date, dateProfile = props.dateProfile;
            var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
            var classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
            var text = dateEnv.format(date, props.dayHeaderFormat);
            // if colCnt is 1, we are already in a day-view and don't need a navlink
            var navLinkAttrs = (!dayMeta.isDisabled && props.colCnt > 1)
                ? buildNavLinkAttrs(this.context, date)
                : {};
            var hookProps = __assign(__assign(__assign({ date: dateEnv.toDate(date), view: viewApi }, props.extraHookProps), { text: text }), dayMeta);
            return (createElement(RenderHook, { hookProps: hookProps, classNames: options.dayHeaderClassNames, content: options.dayHeaderContent, defaultContent: renderInner$1, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, function (rootElRef, customClassNames, innerElRef, innerContent) { return (createElement("th", __assign({ ref: rootElRef, role: "columnheader", className: classNames.concat(customClassNames).join(' '), "data-date": !dayMeta.isDisabled ? formatDayString(date) : undefined, colSpan: props.colSpan }, props.extraDataAttrs),
                createElement("div", { className: "fc-scrollgrid-sync-inner" }, !dayMeta.isDisabled && (createElement("a", __assign({ ref: innerElRef, className: [
                        'fc-col-header-cell-cushion',
                        props.isSticky ? 'fc-sticky' : '',
                    ].join(' ') }, navLinkAttrs), innerContent))))); }));
        };
        return TableDateCell;
    }(BaseComponent));

    var WEEKDAY_FORMAT = createFormatter({ weekday: 'long' });
    var TableDowCell = /** @class */ (function (_super) {
        __extends(TableDowCell, _super);
        function TableDowCell() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableDowCell.prototype.render = function () {
            var props = this.props;
            var _a = this.context, dateEnv = _a.dateEnv, theme = _a.theme, viewApi = _a.viewApi, options = _a.options;
            var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT
            var dateMeta = {
                dow: props.dow,
                isDisabled: false,
                isFuture: false,
                isPast: false,
                isToday: false,
                isOther: false,
            };
            var classNames = [CLASS_NAME].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);
            var text = dateEnv.format(date, props.dayHeaderFormat);
            var hookProps = __assign(__assign(__assign(__assign({ // TODO: make this public?
                date: date }, dateMeta), { view: viewApi }), props.extraHookProps), { text: text });
            return (createElement(RenderHook, { hookProps: hookProps, classNames: options.dayHeaderClassNames, content: options.dayHeaderContent, defaultContent: renderInner$1, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, function (rootElRef, customClassNames, innerElRef, innerContent) { return (createElement("th", __assign({ ref: rootElRef, role: "columnheader", className: classNames.concat(customClassNames).join(' '), colSpan: props.colSpan }, props.extraDataAttrs),
                createElement("div", { className: "fc-scrollgrid-sync-inner" },
                    createElement("a", { "aria-label": dateEnv.format(date, WEEKDAY_FORMAT), className: [
                            'fc-col-header-cell-cushion',
                            props.isSticky ? 'fc-sticky' : '',
                        ].join(' '), ref: innerElRef }, innerContent)))); }));
        };
        return TableDowCell;
    }(BaseComponent));

    var NowTimer = /** @class */ (function (_super) {
        __extends(NowTimer, _super);
        function NowTimer(props, context) {
            var _this = _super.call(this, props, context) || this;
            _this.initialNowDate = getNow(context.options.now, context.dateEnv);
            _this.initialNowQueriedMs = new Date().valueOf();
            _this.state = _this.computeTiming().currentState;
            return _this;
        }
        NowTimer.prototype.render = function () {
            var _a = this, props = _a.props, state = _a.state;
            return props.children(state.nowDate, state.todayRange);
        };
        NowTimer.prototype.componentDidMount = function () {
            this.setTimeout();
        };
        NowTimer.prototype.componentDidUpdate = function (prevProps) {
            if (prevProps.unit !== this.props.unit) {
                this.clearTimeout();
                this.setTimeout();
            }
        };
        NowTimer.prototype.componentWillUnmount = function () {
            this.clearTimeout();
        };
        NowTimer.prototype.computeTiming = function () {
            var _a = this, props = _a.props, context = _a.context;
            var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);
            var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);
            var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));
            var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();
            // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)
            // ensure no longer than a day
            waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);
            return {
                currentState: { nowDate: currentUnitStart, todayRange: buildDayRange(currentUnitStart) },
                nextState: { nowDate: nextUnitStart, todayRange: buildDayRange(nextUnitStart) },
                waitMs: waitMs,
            };
        };
        NowTimer.prototype.setTimeout = function () {
            var _this = this;
            var _a = this.computeTiming(), nextState = _a.nextState, waitMs = _a.waitMs;
            this.timeoutId = setTimeout(function () {
                _this.setState(nextState, function () {
                    _this.setTimeout();
                });
            }, waitMs);
        };
        NowTimer.prototype.clearTimeout = function () {
            if (this.timeoutId) {
                clearTimeout(this.timeoutId);
            }
        };
        NowTimer.contextType = ViewContextType;
        return NowTimer;
    }(Component));
    function buildDayRange(date) {
        var start = startOfDay$1(date);
        var end = addDays(start, 1);
        return { start: start, end: end };
    }

    var DayHeader = /** @class */ (function (_super) {
        __extends(DayHeader, _super);
        function DayHeader() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
            return _this;
        }
        DayHeader.prototype.render = function () {
            var context = this.context;
            var _a = this.props, dates = _a.dates, dateProfile = _a.dateProfile, datesRepDistinctDays = _a.datesRepDistinctDays, renderIntro = _a.renderIntro;
            var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
            return (createElement(NowTimer, { unit: "day" }, function (nowDate, todayRange) { return (createElement("tr", { role: "row" },
                renderIntro && renderIntro('day'),
                dates.map(function (date) { return (datesRepDistinctDays ? (createElement(TableDateCell, { key: date.toISOString(), date: date, dateProfile: dateProfile, todayRange: todayRange, colCnt: dates.length, dayHeaderFormat: dayHeaderFormat })) : (createElement(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat: dayHeaderFormat }))); }))); }));
        };
        return DayHeader;
    }(BaseComponent));
    function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
        return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
    }

    var DaySeriesModel = /** @class */ (function () {
        function DaySeriesModel(range, dateProfileGenerator) {
            var date = range.start;
            var end = range.end;
            var indices = [];
            var dates = [];
            var dayIndex = -1;
            while (date < end) { // loop each day from start to end
                if (dateProfileGenerator.isHiddenDay(date)) {
                    indices.push(dayIndex + 0.5); // mark that it's between indices
                }
                else {
                    dayIndex += 1;
                    indices.push(dayIndex);
                    dates.push(date);
                }
                date = addDays(date, 1);
            }
            this.dates = dates;
            this.indices = indices;
            this.cnt = dates.length;
        }
        DaySeriesModel.prototype.sliceRange = function (range) {
            var firstIndex = this.getDateDayIndex(range.start); // inclusive first index
            var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index
            var clippedFirstIndex = Math.max(0, firstIndex);
            var clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
            // deal with in-between indices
            clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell
            clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell
            if (clippedFirstIndex <= clippedLastIndex) {
                return {
                    firstIndex: clippedFirstIndex,
                    lastIndex: clippedLastIndex,
                    isStart: firstIndex === clippedFirstIndex,
                    isEnd: lastIndex === clippedLastIndex,
                };
            }
            return null;
        };
        // Given a date, returns its chronolocial cell-index from the first cell of the grid.
        // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
        // If before the first offset, returns a negative number.
        // If after the last offset, returns an offset past the last cell offset.
        // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
        DaySeriesModel.prototype.getDateDayIndex = function (date) {
            var indices = this.indices;
            var dayOffset = Math.floor(diffDays(this.dates[0], date));
            if (dayOffset < 0) {
                return indices[0] - 1;
            }
            if (dayOffset >= indices.length) {
                return indices[indices.length - 1] + 1;
            }
            return indices[dayOffset];
        };
        return DaySeriesModel;
    }());

    var DayTableModel = /** @class */ (function () {
        function DayTableModel(daySeries, breakOnWeeks) {
            var dates = daySeries.dates;
            var daysPerRow;
            var firstDay;
            var rowCnt;
            if (breakOnWeeks) {
                // count columns until the day-of-week repeats
                firstDay = dates[0].getUTCDay();
                for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {
                    if (dates[daysPerRow].getUTCDay() === firstDay) {
                        break;
                    }
                }
                rowCnt = Math.ceil(dates.length / daysPerRow);
            }
            else {
                rowCnt = 1;
                daysPerRow = dates.length;
            }
            this.rowCnt = rowCnt;
            this.colCnt = daysPerRow;
            this.daySeries = daySeries;
            this.cells = this.buildCells();
            this.headerDates = this.buildHeaderDates();
        }
        DayTableModel.prototype.buildCells = function () {
            var rows = [];
            for (var row = 0; row < this.rowCnt; row += 1) {
                var cells = [];
                for (var col = 0; col < this.colCnt; col += 1) {
                    cells.push(this.buildCell(row, col));
                }
                rows.push(cells);
            }
            return rows;
        };
        DayTableModel.prototype.buildCell = function (row, col) {
            var date = this.daySeries.dates[row * this.colCnt + col];
            return {
                key: date.toISOString(),
                date: date,
            };
        };
        DayTableModel.prototype.buildHeaderDates = function () {
            var dates = [];
            for (var col = 0; col < this.colCnt; col += 1) {
                dates.push(this.cells[0][col].date);
            }
            return dates;
        };
        DayTableModel.prototype.sliceRange = function (range) {
            var colCnt = this.colCnt;
            var seriesSeg = this.daySeries.sliceRange(range);
            var segs = [];
            if (seriesSeg) {
                var firstIndex = seriesSeg.firstIndex, lastIndex = seriesSeg.lastIndex;
                var index = firstIndex;
                while (index <= lastIndex) {
                    var row = Math.floor(index / colCnt);
                    var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
                    segs.push({
                        row: row,
                        firstCol: index % colCnt,
                        lastCol: (nextIndex - 1) % colCnt,
                        isStart: seriesSeg.isStart && index === firstIndex,
                        isEnd: seriesSeg.isEnd && (nextIndex - 1) === lastIndex,
                    });
                    index = nextIndex;
                }
            }
            return segs;
        };
        return DayTableModel;
    }());

    var Slicer = /** @class */ (function () {
        function Slicer() {
            this.sliceBusinessHours = memoize(this._sliceBusinessHours);
            this.sliceDateSelection = memoize(this._sliceDateSpan);
            this.sliceEventStore = memoize(this._sliceEventStore);
            this.sliceEventDrag = memoize(this._sliceInteraction);
            this.sliceEventResize = memoize(this._sliceInteraction);
            this.forceDayIfListItem = false; // hack
        }
        Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, context) {
            var extraArgs = [];
            for (var _i = 4; _i < arguments.length; _i++) {
                extraArgs[_i - 4] = arguments[_i];
            }
            var eventUiBases = props.eventUiBases;
            var eventSegs = this.sliceEventStore.apply(this, __spreadArray([props.eventStore, eventUiBases, dateProfile, nextDayThreshold], extraArgs));
            return {
                dateSelectionSegs: this.sliceDateSelection.apply(this, __spreadArray([props.dateSelection, eventUiBases, context], extraArgs)),
                businessHourSegs: this.sliceBusinessHours.apply(this, __spreadArray([props.businessHours, dateProfile, nextDayThreshold, context], extraArgs)),
                fgEventSegs: eventSegs.fg,
                bgEventSegs: eventSegs.bg,
                eventDrag: this.sliceEventDrag.apply(this, __spreadArray([props.eventDrag, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),
                eventResize: this.sliceEventResize.apply(this, __spreadArray([props.eventResize, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),
                eventSelection: props.eventSelection,
            }; // TODO: give interactionSegs?
        };
        Slicer.prototype.sliceNowDate = function (// does not memoize
        date, context) {
            var extraArgs = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                extraArgs[_i - 2] = arguments[_i];
            }
            return this._sliceDateSpan.apply(this, __spreadArray([{ range: { start: date, end: addMs(date, 1) }, allDay: false },
                {},
                context], extraArgs));
        };
        Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, context) {
            var extraArgs = [];
            for (var _i = 4; _i < arguments.length; _i++) {
                extraArgs[_i - 4] = arguments[_i];
            }
            if (!businessHours) {
                return [];
            }
            return this._sliceEventStore.apply(this, __spreadArray([expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context),
                {},
                dateProfile,
                nextDayThreshold], extraArgs)).bg;
        };
        Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold) {
            var extraArgs = [];
            for (var _i = 4; _i < arguments.length; _i++) {
                extraArgs[_i - 4] = arguments[_i];
            }
            if (eventStore) {
                var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
                return {
                    bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
                    fg: this.sliceEventRanges(rangeRes.fg, extraArgs),
                };
            }
            return { bg: [], fg: [] };
        };
        Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold) {
            var extraArgs = [];
            for (var _i = 4; _i < arguments.length; _i++) {
                extraArgs[_i - 4] = arguments[_i];
            }
            if (!interaction) {
                return null;
            }
            var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
            return {
                segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
                affectedInstances: interaction.affectedEvents.instances,
                isEvent: interaction.isEvent,
            };
        };
        Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, context) {
            var extraArgs = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                extraArgs[_i - 3] = arguments[_i];
            }
            if (!dateSpan) {
                return [];
            }
            var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
            var segs = this.sliceRange.apply(this, __spreadArray([dateSpan.range], extraArgs));
            for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {
                var seg = segs_1[_a];
                seg.eventRange = eventRange;
            }
            return segs;
        };
        /*
        "complete" seg means it has component and eventRange
        */
        Slicer.prototype.sliceEventRanges = function (eventRanges, extraArgs) {
            var segs = [];
            for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {
                var eventRange = eventRanges_1[_i];
                segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));
            }
            return segs;
        };
        /*
        "complete" seg means it has component and eventRange
        */
        Slicer.prototype.sliceEventRange = function (eventRange, extraArgs) {
            var dateRange = eventRange.range;
            // hack to make multi-day events that are being force-displayed as list-items to take up only one day
            if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {
                dateRange = {
                    start: dateRange.start,
                    end: addDays(dateRange.start, 1),
                };
            }
            var segs = this.sliceRange.apply(this, __spreadArray([dateRange], extraArgs));
            for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
                var seg = segs_2[_i];
                seg.eventRange = eventRange;
                seg.isStart = eventRange.isStart && seg.isStart;
                seg.isEnd = eventRange.isEnd && seg.isEnd;
            }
            return segs;
        };
        return Slicer;
    }());
    /*
    for incorporating slotMinTime/slotMaxTime if appropriate
    TODO: should be part of DateProfile!
    TimelineDateProfile already does this btw
    */
    function computeActiveRange(dateProfile, isComponentAllDay) {
        var range = dateProfile.activeRange;
        if (isComponentAllDay) {
            return range;
        }
        return {
            start: addMs(range.start, dateProfile.slotMinTime.milliseconds),
            end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5), // 864e5 = ms in a day
        };
    }

    // high-level segmenting-aware tester functions
    // ------------------------------------------------------------------------------------------------------------------------
    function isInteractionValid(interaction, dateProfile, context) {
        var instances = interaction.mutatedEvents.instances;
        for (var instanceId in instances) {
            if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
                return false;
            }
        }
        return isNewPropsValid({ eventDrag: interaction }, context); // HACK: the eventDrag props is used for ALL interactions
    }
    function isDateSelectionValid(dateSelection, dateProfile, context) {
        if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {
            return false;
        }
        return isNewPropsValid({ dateSelection: dateSelection }, context);
    }
    function isNewPropsValid(newProps, context) {
        var calendarState = context.getCurrentData();
        var props = __assign({ businessHours: calendarState.businessHours, dateSelection: '', eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: '', eventDrag: null, eventResize: null }, newProps);
        return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);
    }
    function isPropsValid(state, context, dateSpanMeta, filterConfig) {
        if (dateSpanMeta === void 0) { dateSpanMeta = {}; }
        if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {
            return false;
        }
        if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {
            return false;
        }
        return true;
    }
    // Moving Event Validation
    // ------------------------------------------------------------------------------------------------------------------------
    function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {
        var currentState = context.getCurrentData();
        var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions
        var subjectEventStore = interaction.mutatedEvents;
        var subjectDefs = subjectEventStore.defs;
        var subjectInstances = subjectEventStore.instances;
        var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ?
            state.eventUiBases :
            { '': currentState.selectionConfig });
        if (filterConfig) {
            subjectConfigs = mapHash(subjectConfigs, filterConfig);
        }
        // exclude the subject events. TODO: exclude defs too?
        var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
        var otherDefs = otherEventStore.defs;
        var otherInstances = otherEventStore.instances;
        var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
        for (var subjectInstanceId in subjectInstances) {
            var subjectInstance = subjectInstances[subjectInstanceId];
            var subjectRange = subjectInstance.range;
            var subjectConfig = subjectConfigs[subjectInstance.defId];
            var subjectDef = subjectDefs[subjectInstance.defId];
            // constraint
            if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {
                return false;
            }
            // overlap
            var eventOverlap = context.options.eventOverlap;
            var eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;
            for (var otherInstanceId in otherInstances) {
                var otherInstance = otherInstances[otherInstanceId];
                // intersect! evaluate
                if (rangesIntersect(subjectRange, otherInstance.range)) {
                    var otherOverlap = otherConfigs[otherInstance.defId].overlap;
                    // consider the other event's overlap. only do this if the subject event is a "real" event
                    if (otherOverlap === false && interaction.isEvent) {
                        return false;
                    }
                    if (subjectConfig.overlap === false) {
                        return false;
                    }
                    if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), // still event
                    new EventApi(context, subjectDef, subjectInstance))) {
                        return false;
                    }
                }
            }
            // allow (a function)
            var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state
            for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {
                var subjectAllow = _a[_i];
                var subjectDateSpan = __assign(__assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });
                var origDef = calendarEventStore.defs[subjectDef.defId];
                var origInstance = calendarEventStore.instances[subjectInstanceId];
                var eventApi = void 0;
                if (origDef) { // was previously in the calendar
                    eventApi = new EventApi(context, origDef, origInstance);
                }
                else { // was an external event
                    eventApi = new EventApi(context, subjectDef); // no instance, because had no dates
                }
                if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {
                    return false;
                }
            }
        }
        return true;
    }
    // Date Selection Validation
    // ------------------------------------------------------------------------------------------------------------------------
    function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {
        var relevantEventStore = state.eventStore;
        var relevantDefs = relevantEventStore.defs;
        var relevantInstances = relevantEventStore.instances;
        var selection = state.dateSelection;
        var selectionRange = selection.range;
        var selectionConfig = context.getCurrentData().selectionConfig;
        if (filterConfig) {
            selectionConfig = filterConfig(selectionConfig);
        }
        // constraint
        if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {
            return false;
        }
        // overlap
        var selectOverlap = context.options.selectOverlap;
        var selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;
        for (var relevantInstanceId in relevantInstances) {
            var relevantInstance = relevantInstances[relevantInstanceId];
            // intersect! evaluate
            if (rangesIntersect(selectionRange, relevantInstance.range)) {
                if (selectionConfig.overlap === false) {
                    return false;
                }
                if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {
                    return false;
                }
            }
        }
        // allow (a function)
        for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {
            var selectionAllow = _a[_i];
            var fullDateSpan = __assign(__assign({}, dateSpanMeta), selection);
            if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {
                return false;
            }
        }
        return true;
    }
    // Constraint Utils
    // ------------------------------------------------------------------------------------------------------------------------
    function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
        for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {
            var constraint = constraints_1[_i];
            if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {
                return false;
            }
        }
        return true;
    }
    function constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours
    otherEventStore, // for if constraint is an even group ID
    businessHoursUnexpanded, // for if constraint is 'businessHours'
    context) {
        if (constraint === 'businessHours') {
            return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));
        }
        if (typeof constraint === 'string') { // an group ID
            return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) { return eventDef.groupId === constraint; }));
        }
        if (typeof constraint === 'object' && constraint) { // non-null object
            return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));
        }
        return []; // if it's false
    }
    // TODO: move to event-store file?
    function eventStoreToRanges(eventStore) {
        var instances = eventStore.instances;
        var ranges = [];
        for (var instanceId in instances) {
            ranges.push(instances[instanceId].range);
        }
        return ranges;
    }
    // TODO: move to geom file?
    function anyRangesContainRange(outerRanges, innerRange) {
        for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {
            var outerRange = outerRanges_1[_i];
            if (rangeContainsRange(outerRange, innerRange)) {
                return true;
            }
        }
        return false;
    }

    var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;
    var Scroller = /** @class */ (function (_super) {
        __extends(Scroller, _super);
        function Scroller() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handleEl = function (el) {
                _this.el = el;
                setRef(_this.props.elRef, el);
            };
            return _this;
        }
        Scroller.prototype.render = function () {
            var props = this.props;
            var liquid = props.liquid, liquidIsAbsolute = props.liquidIsAbsolute;
            var isAbsolute = liquid && liquidIsAbsolute;
            var className = ['fc-scroller'];
            if (liquid) {
                if (liquidIsAbsolute) {
                    className.push('fc-scroller-liquid-absolute');
                }
                else {
                    className.push('fc-scroller-liquid');
                }
            }
            return (createElement("div", { ref: this.handleEl, className: className.join(' '), style: {
                    overflowX: props.overflowX,
                    overflowY: props.overflowY,
                    left: (isAbsolute && -(props.overcomeLeft || 0)) || '',
                    right: (isAbsolute && -(props.overcomeRight || 0)) || '',
                    bottom: (isAbsolute && -(props.overcomeBottom || 0)) || '',
                    marginLeft: (!isAbsolute && -(props.overcomeLeft || 0)) || '',
                    marginRight: (!isAbsolute && -(props.overcomeRight || 0)) || '',
                    marginBottom: (!isAbsolute && -(props.overcomeBottom || 0)) || '',
                    maxHeight: props.maxHeight || '',
                } }, props.children));
        };
        Scroller.prototype.needsXScrolling = function () {
            if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
                return false;
            }
            // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.
            // much more reliable to see if children are taller than the scroller, even tho doesn't account for
            // inner-child margins and absolute positioning
            var el = this.el;
            var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
            var children = el.children;
            for (var i = 0; i < children.length; i += 1) {
                var childEl = children[i];
                if (childEl.getBoundingClientRect().width > realClientWidth) {
                    return true;
                }
            }
            return false;
        };
        Scroller.prototype.needsYScrolling = function () {
            if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
                return false;
            }
            // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.
            // much more reliable to see if children are taller than the scroller, even tho doesn't account for
            // inner-child margins and absolute positioning
            var el = this.el;
            var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
            var children = el.children;
            for (var i = 0; i < children.length; i += 1) {
                var childEl = children[i];
                if (childEl.getBoundingClientRect().height > realClientHeight) {
                    return true;
                }
            }
            return false;
        };
        Scroller.prototype.getXScrollbarWidth = function () {
            if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
                return 0;
            }
            return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?
        };
        Scroller.prototype.getYScrollbarWidth = function () {
            if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
                return 0;
            }
            return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?
        };
        return Scroller;
    }(BaseComponent));

    /*
    TODO: somehow infer OtherArgs from masterCallback?
    TODO: infer RefType from masterCallback if provided
    */
    var RefMap = /** @class */ (function () {
        function RefMap(masterCallback) {
            var _this = this;
            this.masterCallback = masterCallback;
            this.currentMap = {};
            this.depths = {};
            this.callbackMap = {};
            this.handleValue = function (val, key) {
                var _a = _this, depths = _a.depths, currentMap = _a.currentMap;
                var removed = false;
                var added = false;
                if (val !== null) {
                    // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore
                    removed = (key in currentMap);
                    currentMap[key] = val;
                    depths[key] = (depths[key] || 0) + 1;
                    added = true;
                }
                else {
                    depths[key] -= 1;
                    if (!depths[key]) {
                        delete currentMap[key];
                        delete _this.callbackMap[key];
                        removed = true;
                    }
                }
                if (_this.masterCallback) {
                    if (removed) {
                        _this.masterCallback(null, String(key));
                    }
                    if (added) {
                        _this.masterCallback(val, String(key));
                    }
                }
            };
        }
        RefMap.prototype.createRef = function (key) {
            var _this = this;
            var refCallback = this.callbackMap[key];
            if (!refCallback) {
                refCallback = this.callbackMap[key] = function (val) {
                    _this.handleValue(val, String(key));
                };
            }
            return refCallback;
        };
        // TODO: check callers that don't care about order. should use getAll instead
        // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
        // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"
        RefMap.prototype.collect = function (startIndex, endIndex, step) {
            return collectFromHash(this.currentMap, startIndex, endIndex, step);
        };
        RefMap.prototype.getAll = function () {
            return hashValuesToArray(this.currentMap);
        };
        return RefMap;
    }());

    function computeShrinkWidth(chunkEls) {
        var shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');
        var largestWidth = 0;
        for (var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++) {
            var shrinkCell = shrinkCells_1[_i];
            largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
        }
        return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits
    }
    function getSectionHasLiquidHeight(props, sectionConfig) {
        return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)
    }
    function getAllowYScrolling(props, sectionConfig) {
        return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars
            getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars
    }
    // TODO: ONLY use `arg`. force out internal function to use same API
    function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
        var expandRows = arg.expandRows;
        var content = typeof chunkConfig.content === 'function' ?
            chunkConfig.content(arg) :
            createElement('table', {
                role: 'presentation',
                className: [
                    chunkConfig.tableClassName,
                    sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : '',
                ].join(' '),
                style: {
                    minWidth: arg.tableMinWidth,
                    width: arg.clientWidth,
                    height: expandRows ? arg.clientHeight : '', // css `height` on a <table> serves as a min-height
                },
            }, arg.tableColGroupNode, createElement(isHeader ? 'thead' : 'tbody', {
                role: 'presentation',
            }, typeof chunkConfig.rowContent === 'function'
                ? chunkConfig.rowContent(arg)
                : chunkConfig.rowContent));
        return content;
    }
    function isColPropsEqual(cols0, cols1) {
        return isArraysEqual(cols0, cols1, isPropsEqual);
    }
    function renderMicroColGroup(cols, shrinkWidth) {
        var colNodes = [];
        /*
        for ColProps with spans, it would have been great to make a single <col span="">
        HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.
        SOLUTION: making individual <col> elements makes Chrome behave.
        */
        for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {
            var colProps = cols_1[_i];
            var span = colProps.span || 1;
            for (var i = 0; i < span; i += 1) {
                colNodes.push(createElement("col", { style: {
                        width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : (colProps.width || ''),
                        minWidth: colProps.minWidth || '',
                    } }));
            }
        }
        return createElement.apply(void 0, __spreadArray(['colgroup', {}], colNodes));
    }
    function sanitizeShrinkWidth(shrinkWidth) {
        /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth
        4 accounts for 2 2-pixel borders. TODO: better solution? */
        return shrinkWidth == null ? 4 : shrinkWidth;
    }
    function hasShrinkWidth(cols) {
        for (var _i = 0, cols_2 = cols; _i < cols_2.length; _i++) {
            var col = cols_2[_i];
            if (col.width === 'shrink') {
                return true;
            }
        }
        return false;
    }
    function getScrollGridClassNames(liquid, context) {
        var classNames = [
            'fc-scrollgrid',
            context.theme.getClass('table'),
        ];
        if (liquid) {
            classNames.push('fc-scrollgrid-liquid');
        }
        return classNames;
    }
    function getSectionClassNames(sectionConfig, wholeTableVGrow) {
        var classNames = [
            'fc-scrollgrid-section',
            "fc-scrollgrid-section-" + sectionConfig.type,
            sectionConfig.className, // used?
        ];
        if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
            classNames.push('fc-scrollgrid-section-liquid');
        }
        if (sectionConfig.isSticky) {
            classNames.push('fc-scrollgrid-section-sticky');
        }
        return classNames;
    }
    function renderScrollShim(arg) {
        return (createElement("div", { className: "fc-scrollgrid-sticky-shim", style: {
                width: arg.clientWidth,
                minWidth: arg.tableMinWidth,
            } }));
    }
    function getStickyHeaderDates(options) {
        var stickyHeaderDates = options.stickyHeaderDates;
        if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {
            stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';
        }
        return stickyHeaderDates;
    }
    function getStickyFooterScrollbar(options) {
        var stickyFooterScrollbar = options.stickyFooterScrollbar;
        if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {
            stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';
        }
        return stickyFooterScrollbar;
    }

    var SimpleScrollGrid = /** @class */ (function (_super) {
        __extends(SimpleScrollGrid, _super);
        function SimpleScrollGrid() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.processCols = memoize(function (a) { return a; }, isColPropsEqual); // so we get same `cols` props every time
            // yucky to memoize VNodes, but much more efficient for consumers
            _this.renderMicroColGroup = memoize(renderMicroColGroup);
            _this.scrollerRefs = new RefMap();
            _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));
            _this.state = {
                shrinkWidth: null,
                forceYScrollbars: false,
                scrollerClientWidths: {},
                scrollerClientHeights: {},
            };
            // TODO: can do a really simple print-view. dont need to join rows
            _this.handleSizing = function () {
                _this.setState(__assign({ shrinkWidth: _this.computeShrinkWidth() }, _this.computeScrollerDims()));
            };
            return _this;
        }
        SimpleScrollGrid.prototype.render = function () {
            var _a = this, props = _a.props, state = _a.state, context = _a.context;
            var sectionConfigs = props.sections || [];
            var cols = this.processCols(props.cols);
            var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
            var classNames = getScrollGridClassNames(props.liquid, context);
            if (props.collapsibleWidth) {
                classNames.push('fc-scrollgrid-collapsible');
            }
            // TODO: make DRY
            var configCnt = sectionConfigs.length;
            var configI = 0;
            var currentConfig;
            var headSectionNodes = [];
            var bodySectionNodes = [];
            var footSectionNodes = [];
            while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {
                headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
                configI += 1;
            }
            while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {
                bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
                configI += 1;
            }
            while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {
                footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
                configI += 1;
            }
            // firefox bug: when setting height on table and there is a thead or tfoot,
            // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)
            // use getCanVGrowWithinCell as a way to detect table-stupid firefox.
            // if so, use a simpler dom structure, jam everything into a lone tbody.
            var isBuggy = !getCanVGrowWithinCell();
            var roleAttrs = { role: 'rowgroup' };
            return createElement('table', {
                role: 'grid',
                className: classNames.join(' '),
                style: { height: props.height },
            }, Boolean(!isBuggy && headSectionNodes.length) && createElement.apply(void 0, __spreadArray(['thead', roleAttrs], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && createElement.apply(void 0, __spreadArray(['tbody', roleAttrs], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && createElement.apply(void 0, __spreadArray(['tfoot', roleAttrs], footSectionNodes)), isBuggy && createElement.apply(void 0, __spreadArray(__spreadArray(__spreadArray(['tbody', roleAttrs], headSectionNodes), bodySectionNodes), footSectionNodes)));
        };
        SimpleScrollGrid.prototype.renderSection = function (sectionConfig, microColGroupNode, isHeader) {
            if ('outerContent' in sectionConfig) {
                return (createElement(Fragment, { key: sectionConfig.key }, sectionConfig.outerContent));
            }
            return (createElement("tr", { key: sectionConfig.key, role: "presentation", className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ') }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader)));
        };
        SimpleScrollGrid.prototype.renderChunkTd = function (sectionConfig, microColGroupNode, chunkConfig, isHeader) {
            if ('outerContent' in chunkConfig) {
                return chunkConfig.outerContent;
            }
            var props = this.props;
            var _a = this.state, forceYScrollbars = _a.forceYScrollbars, scrollerClientWidths = _a.scrollerClientWidths, scrollerClientHeights = _a.scrollerClientHeights;
            var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?
            var isLiquid = getSectionHasLiquidHeight(props, sectionConfig);
            // for `!props.liquid` - is WHOLE scrollgrid natural height?
            // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars
            var overflowY = !props.liquid ? 'visible' :
                forceYScrollbars ? 'scroll' :
                    !needsYScrolling ? 'hidden' :
                        'auto';
            var sectionKey = sectionConfig.key;
            var content = renderChunkContent(sectionConfig, chunkConfig, {
                tableColGroupNode: microColGroupNode,
                tableMinWidth: '',
                clientWidth: (!props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined) ? scrollerClientWidths[sectionKey] : null,
                clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,
                expandRows: sectionConfig.expandRows,
                syncRowHeights: false,
                rowSyncHeights: [],
                reportRowHeightChange: function () { },
            }, isHeader);
            return createElement(isHeader ? 'th' : 'td', {
                ref: chunkConfig.elRef,
                role: 'presentation',
            }, createElement("div", { className: "fc-scroller-harness" + (isLiquid ? ' fc-scroller-harness-liquid' : '') },
                createElement(Scroller, { ref: this.scrollerRefs.createRef(sectionKey), elRef: this.scrollerElRefs.createRef(sectionKey), overflowY: overflowY, overflowX: !props.liquid ? 'visible' : 'hidden' /* natural height? */, maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute // because its within a harness
                    : true }, content)));
        };
        SimpleScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {
            var section = getSectionByKey(this.props.sections, key);
            if (section) {
                setRef(section.chunk.scrollerElRef, scrollerEl);
            }
        };
        SimpleScrollGrid.prototype.componentDidMount = function () {
            this.handleSizing();
            this.context.addResizeHandler(this.handleSizing);
        };
        SimpleScrollGrid.prototype.componentDidUpdate = function () {
            // TODO: need better solution when state contains non-sizing things
            this.handleSizing();
        };
        SimpleScrollGrid.prototype.componentWillUnmount = function () {
            this.context.removeResizeHandler(this.handleSizing);
        };
        SimpleScrollGrid.prototype.computeShrinkWidth = function () {
            return hasShrinkWidth(this.props.cols)
                ? computeShrinkWidth(this.scrollerElRefs.getAll())
                : 0;
        };
        SimpleScrollGrid.prototype.computeScrollerDims = function () {
            var scrollbarWidth = getScrollbarWidths();
            var _a = this, scrollerRefs = _a.scrollerRefs, scrollerElRefs = _a.scrollerElRefs;
            var forceYScrollbars = false;
            var scrollerClientWidths = {};
            var scrollerClientHeights = {};
            for (var sectionKey in scrollerRefs.currentMap) {
                var scroller = scrollerRefs.currentMap[sectionKey];
                if (scroller && scroller.needsYScrolling()) {
                    forceYScrollbars = true;
                    break;
                }
            }
            for (var _i = 0, _b = this.props.sections; _i < _b.length; _i++) {
                var section = _b[_i];
                var sectionKey = section.key;
                var scrollerEl = scrollerElRefs.currentMap[sectionKey];
                if (scrollerEl) {
                    var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders
                    scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars
                        ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future
                        : 0));
                    scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
                }
            }
            return { forceYScrollbars: forceYScrollbars, scrollerClientWidths: scrollerClientWidths, scrollerClientHeights: scrollerClientHeights };
        };
        return SimpleScrollGrid;
    }(BaseComponent));
    SimpleScrollGrid.addStateEquality({
        scrollerClientWidths: isPropsEqual,
        scrollerClientHeights: isPropsEqual,
    });
    function getSectionByKey(sections, key) {
        for (var _i = 0, sections_1 = sections; _i < sections_1.length; _i++) {
            var section = sections_1[_i];
            if (section.key === key) {
                return section;
            }
        }
        return null;
    }

    var EventRoot = /** @class */ (function (_super) {
        __extends(EventRoot, _super);
        function EventRoot() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.elRef = createRef();
            return _this;
        }
        EventRoot.prototype.render = function () {
            var _a = this, props = _a.props, context = _a.context;
            var options = context.options;
            var seg = props.seg;
            var eventRange = seg.eventRange;
            var ui = eventRange.ui;
            var hookProps = {
                event: new EventApi(context, eventRange.def, eventRange.instance),
                view: context.viewApi,
                timeText: props.timeText,
                textColor: ui.textColor,
                backgroundColor: ui.backgroundColor,
                borderColor: ui.borderColor,
                isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
                isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
                isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
                isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
                isStart: Boolean(seg.isStart),
                isEnd: Boolean(seg.isEnd),
                isPast: Boolean(props.isPast),
                isFuture: Boolean(props.isFuture),
                isToday: Boolean(props.isToday),
                isSelected: Boolean(props.isSelected),
                isDragging: Boolean(props.isDragging),
                isResizing: Boolean(props.isResizing),
            };
            var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);
            return (createElement(RenderHook, { hookProps: hookProps, classNames: options.eventClassNames, content: options.eventContent, defaultContent: props.defaultContent, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount, elRef: this.elRef }, function (rootElRef, customClassNames, innerElRef, innerContent) { return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps); }));
        };
        EventRoot.prototype.componentDidMount = function () {
            setElSeg(this.elRef.current, this.props.seg);
        };
        /*
        need to re-assign seg to the element if seg changes, even if the element is the same
        */
        EventRoot.prototype.componentDidUpdate = function (prevProps) {
            var seg = this.props.seg;
            if (seg !== prevProps.seg) {
                setElSeg(this.elRef.current, seg);
            }
        };
        return EventRoot;
    }(BaseComponent));

    // should not be a purecomponent
    var StandardEvent = /** @class */ (function (_super) {
        __extends(StandardEvent, _super);
        function StandardEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StandardEvent.prototype.render = function () {
            var _a = this, props = _a.props, context = _a.context;
            var seg = props.seg;
            var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;
            var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
            return (createElement(EventRoot, { seg: seg, timeText: timeText, disableDragging: props.disableDragging, disableResizing: props.disableResizing, defaultContent: props.defaultContent || renderInnerContent$1, isDragging: props.isDragging, isResizing: props.isResizing, isDateSelecting: props.isDateSelecting, isSelected: props.isSelected, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) { return (createElement("a", __assign({ className: props.extraClassNames.concat(classNames).join(' '), style: {
                    borderColor: hookProps.borderColor,
                    backgroundColor: hookProps.backgroundColor,
                }, ref: rootElRef }, getSegAnchorAttrs(seg, context)),
                createElement("div", { className: "fc-event-main", ref: innerElRef, style: { color: hookProps.textColor } }, innerContent),
                hookProps.isStartResizable &&
                    createElement("div", { className: "fc-event-resizer fc-event-resizer-start" }),
                hookProps.isEndResizable &&
                    createElement("div", { className: "fc-event-resizer fc-event-resizer-end" }))); }));
        };
        return StandardEvent;
    }(BaseComponent));
    function renderInnerContent$1(innerProps) {
        return (createElement("div", { className: "fc-event-main-frame" },
            innerProps.timeText && (createElement("div", { className: "fc-event-time" }, innerProps.timeText)),
            createElement("div", { className: "fc-event-title-container" },
                createElement("div", { className: "fc-event-title fc-sticky" }, innerProps.event.title || createElement(Fragment, null, "\u00A0")))));
    }

    var DAY_NUM_FORMAT = createFormatter({ day: 'numeric' });
    var DayCellContent = /** @class */ (function (_super) {
        __extends(DayCellContent, _super);
        function DayCellContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DayCellContent.prototype.render = function () {
            var _a = this, props = _a.props, context = _a.context;
            var options = context.options;
            var hookProps = refineDayCellHookProps({
                date: props.date,
                dateProfile: props.dateProfile,
                todayRange: props.todayRange,
                showDayNumber: props.showDayNumber,
                extraProps: props.extraHookProps,
                viewApi: context.viewApi,
                dateEnv: context.dateEnv,
            });
            return (createElement(ContentHook, { hookProps: hookProps, content: options.dayCellContent, defaultContent: props.defaultContent }, props.children));
        };
        return DayCellContent;
    }(BaseComponent));
    function refineDayCellHookProps(raw) {
        var date = raw.date, dateEnv = raw.dateEnv;
        var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);
        return __assign(__assign(__assign({ date: dateEnv.toDate(date), view: raw.viewApi }, dayMeta), { dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : '' }), raw.extraProps);
    }

    var DayCellRoot = /** @class */ (function (_super) {
        __extends(DayCellRoot, _super);
        function DayCellRoot() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);
            _this.normalizeClassNames = buildClassNameNormalizer();
            return _this;
        }
        DayCellRoot.prototype.render = function () {
            var _a = this, props = _a.props, context = _a.context;
            var options = context.options;
            var hookProps = this.refineHookProps({
                date: props.date,
                dateProfile: props.dateProfile,
                todayRange: props.todayRange,
                showDayNumber: props.showDayNumber,
                extraProps: props.extraHookProps,
                viewApi: context.viewApi,
                dateEnv: context.dateEnv,
            });
            var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled
                ? [] // don't use custom classNames if disabled
                : this.normalizeClassNames(options.dayCellClassNames, hookProps));
            var dataAttrs = hookProps.isDisabled ? {} : {
                'data-date': formatDayString(props.date),
            };
            return (createElement(MountHook, { hookProps: hookProps, didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount, elRef: props.elRef }, function (rootElRef) { return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled); }));
        };
        return DayCellRoot;
    }(BaseComponent));

    function renderFill(fillType) {
        return (createElement("div", { className: "fc-" + fillType }));
    }
    var BgEvent = function (props) { return (createElement(EventRoot, { defaultContent: renderInnerContent, seg: props.seg /* uselesss i think */, timeText: "", disableDragging: true, disableResizing: true, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) { return (createElement("div", { ref: rootElRef, className: ['fc-bg-event'].concat(classNames).join(' '), style: {
            backgroundColor: hookProps.backgroundColor,
        } }, innerContent)); })); };
    function renderInnerContent(props) {
        var title = props.event.title;
        return title && (createElement("div", { className: "fc-event-title" }, props.event.title));
    }

    var WeekNumberRoot = function (props) { return (createElement(ViewContextType.Consumer, null, function (context) {
        var dateEnv = context.dateEnv, options = context.options;
        var date = props.date;
        var format = options.weekNumberFormat || props.defaultFormat;
        var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?
        var text = dateEnv.format(date, format);
        var hookProps = { num: num, text: text, date: date };
        return (createElement(RenderHook, { hookProps: hookProps, classNames: options.weekNumberClassNames, content: options.weekNumberContent, defaultContent: renderInner, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount }, props.children));
    })); };
    function renderInner(innerProps) {
        return innerProps.text;
    }

    var PADDING_FROM_VIEWPORT = 10;
    var Popover = /** @class */ (function (_super) {
        __extends(Popover, _super);
        function Popover() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = {
                titleId: getUniqueDomId(),
            };
            _this.handleRootEl = function (el) {
                _this.rootEl = el;
                if (_this.props.elRef) {
                    setRef(_this.props.elRef, el);
                }
            };
            // Triggered when the user clicks *anywhere* in the document, for the autoHide feature
            _this.handleDocumentMouseDown = function (ev) {
                // only hide the popover if the click happened outside the popover
                var target = getEventTargetViaRoot(ev);
                if (!_this.rootEl.contains(target)) {
                    _this.handleCloseClick();
                }
            };
            _this.handleDocumentKeyDown = function (ev) {
                if (ev.key === 'Escape') {
                    _this.handleCloseClick();
                }
            };
            _this.handleCloseClick = function () {
                var onClose = _this.props.onClose;
                if (onClose) {
                    onClose();
                }
            };
            return _this;
        }
        Popover.prototype.render = function () {
            var _a = this.context, theme = _a.theme, options = _a.options;
            var _b = this, props = _b.props, state = _b.state;
            var classNames = [
                'fc-popover',
                theme.getClass('popover'),
            ].concat(props.extraClassNames || []);
            return createPortal(createElement("div", __assign({ id: props.id, className: classNames.join(' '), "aria-labelledby": state.titleId }, props.extraAttrs, { ref: this.handleRootEl }),
                createElement("div", { className: 'fc-popover-header ' + theme.getClass('popoverHeader') },
                    createElement("span", { className: "fc-popover-title", id: state.titleId }, props.title),
                    createElement("span", { className: 'fc-popover-close ' + theme.getIconClass('close'), title: options.closeHint, onClick: this.handleCloseClick })),
                createElement("div", { className: 'fc-popover-body ' + theme.getClass('popoverContent') }, props.children)), props.parentEl);
        };
        Popover.prototype.componentDidMount = function () {
            document.addEventListener('mousedown', this.handleDocumentMouseDown);
            document.addEventListener('keydown', this.handleDocumentKeyDown);
            this.updateSize();
        };
        Popover.prototype.componentWillUnmount = function () {
            document.removeEventListener('mousedown', this.handleDocumentMouseDown);
            document.removeEventListener('keydown', this.handleDocumentKeyDown);
        };
        Popover.prototype.updateSize = function () {
            var isRtl = this.context.isRtl;
            var _a = this.props, alignmentEl = _a.alignmentEl, alignGridTop = _a.alignGridTop;
            var rootEl = this.rootEl;
            var alignmentRect = computeClippedClientRect(alignmentEl);
            if (alignmentRect) {
                var popoverDims = rootEl.getBoundingClientRect();
                // position relative to viewport
                var popoverTop = alignGridTop
                    ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top
                    : alignmentRect.top;
                var popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;
                // constrain
                popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
                popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
                popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
                var origin_1 = rootEl.offsetParent.getBoundingClientRect();
                applyStyle(rootEl, {
                    top: popoverTop - origin_1.top,
                    left: popoverLeft - origin_1.left,
                });
            }
        };
        return Popover;
    }(BaseComponent));

    var MorePopover = /** @class */ (function (_super) {
        __extends(MorePopover, _super);
        function MorePopover() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handleRootEl = function (rootEl) {
                _this.rootEl = rootEl;
                if (rootEl) {
                    _this.context.registerInteractiveComponent(_this, {
                        el: rootEl,
                        useEventCenter: false,
                    });
                }
                else {
                    _this.context.unregisterInteractiveComponent(_this);
                }
            };
            return _this;
        }
        MorePopover.prototype.render = function () {
            var _a = this.context, options = _a.options, dateEnv = _a.dateEnv;
            var props = this.props;
            var startDate = props.startDate, todayRange = props.todayRange, dateProfile = props.dateProfile;
            var title = dateEnv.format(startDate, options.dayPopoverFormat);
            return (createElement(DayCellRoot, { date: startDate, dateProfile: dateProfile, todayRange: todayRange, elRef: this.handleRootEl }, function (rootElRef, dayClassNames, dataAttrs) { return (createElement(Popover, { elRef: rootElRef, id: props.id, title: title, extraClassNames: ['fc-more-popover'].concat(dayClassNames), extraAttrs: dataAttrs /* TODO: make these time-based when not whole-day? */, parentEl: props.parentEl, alignmentEl: props.alignmentEl, alignGridTop: props.alignGridTop, onClose: props.onClose },
                createElement(DayCellContent, { date: startDate, dateProfile: dateProfile, todayRange: todayRange }, function (innerElRef, innerContent) { return (innerContent &&
                    createElement("div", { className: "fc-more-popover-misc", ref: innerElRef }, innerContent)); }),
                props.children)); }));
        };
        MorePopover.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
            var _a = this, rootEl = _a.rootEl, props = _a.props;
            if (positionLeft >= 0 && positionLeft < elWidth &&
                positionTop >= 0 && positionTop < elHeight) {
                return {
                    dateProfile: props.dateProfile,
                    dateSpan: __assign({ allDay: true, range: {
                            start: props.startDate,
                            end: props.endDate,
                        } }, props.extraDateSpan),
                    dayEl: rootEl,
                    rect: {
                        left: 0,
                        top: 0,
                        right: elWidth,
                        bottom: elHeight,
                    },
                    layer: 1, // important when comparing with hits from other components
                };
            }
            return null;
        };
        return MorePopover;
    }(DateComponent));

    var MoreLinkRoot = /** @class */ (function (_super) {
        __extends(MoreLinkRoot, _super);
        function MoreLinkRoot() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.linkElRef = createRef();
            _this.state = {
                isPopoverOpen: false,
                popoverId: getUniqueDomId(),
            };
            _this.handleClick = function (ev) {
                var _a = _this, props = _a.props, context = _a.context;
                var moreLinkClick = context.options.moreLinkClick;
                var date = computeRange(props).start;
                function buildPublicSeg(seg) {
                    var _a = seg.eventRange, def = _a.def, instance = _a.instance, range = _a.range;
                    return {
                        event: new EventApi(context, def, instance),
                        start: context.dateEnv.toDate(range.start),
                        end: context.dateEnv.toDate(range.end),
                        isStart: seg.isStart,
                        isEnd: seg.isEnd,
                    };
                }
                if (typeof moreLinkClick === 'function') {
                    moreLinkClick = moreLinkClick({
                        date: date,
                        allDay: Boolean(props.allDayDate),
                        allSegs: props.allSegs.map(buildPublicSeg),
                        hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
                        jsEvent: ev,
                        view: context.viewApi,
                    });
                }
                if (!moreLinkClick || moreLinkClick === 'popover') {
                    _this.setState({ isPopoverOpen: true });
                }
                else if (typeof moreLinkClick === 'string') { // a view name
                    context.calendarApi.zoomTo(date, moreLinkClick);
                }
            };
            _this.handlePopoverClose = function () {
                _this.setState({ isPopoverOpen: false });
            };
            return _this;
        }
        MoreLinkRoot.prototype.render = function () {
            var _this = this;
            var _a = this, props = _a.props, state = _a.state;
            return (createElement(ViewContextType.Consumer, null, function (context) {
                var viewApi = context.viewApi, options = context.options, calendarApi = context.calendarApi;
                var moreLinkText = options.moreLinkText;
                var moreCnt = props.moreCnt;
                var range = computeRange(props);
                var text = typeof moreLinkText === 'function' // TODO: eventually use formatWithOrdinals
                    ? moreLinkText.call(calendarApi, moreCnt)
                    : "+" + moreCnt + " " + moreLinkText;
                var title = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);
                var hookProps = {
                    num: moreCnt,
                    shortText: "+" + moreCnt,
                    text: text,
                    view: viewApi,
                };
                return (createElement(Fragment, null,
                    Boolean(props.moreCnt) && (createElement(RenderHook, { elRef: _this.linkElRef, hookProps: hookProps, classNames: options.moreLinkClassNames, content: options.moreLinkContent, defaultContent: props.defaultContent || renderMoreLinkInner, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, function (rootElRef, customClassNames, innerElRef, innerContent) { return props.children(rootElRef, ['fc-more-link'].concat(customClassNames), innerElRef, innerContent, _this.handleClick, title, state.isPopoverOpen, state.isPopoverOpen ? state.popoverId : ''); })),
                    state.isPopoverOpen && (createElement(MorePopover, { id: state.popoverId, startDate: range.start, endDate: range.end, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: props.extraDateSpan, parentEl: _this.parentEl, alignmentEl: props.alignmentElRef.current, alignGridTop: props.alignGridTop, onClose: _this.handlePopoverClose }, props.popoverContent()))));
            }));
        };
        MoreLinkRoot.prototype.componentDidMount = function () {
            this.updateParentEl();
        };
        MoreLinkRoot.prototype.componentDidUpdate = function () {
            this.updateParentEl();
        };
        MoreLinkRoot.prototype.updateParentEl = function () {
            if (this.linkElRef.current) {
                this.parentEl = elementClosest(this.linkElRef.current, '.fc-view-harness');
            }
        };
        return MoreLinkRoot;
    }(BaseComponent));
    function renderMoreLinkInner(props) {
        return props.text;
    }
    function computeRange(props) {
        if (props.allDayDate) {
            return {
                start: props.allDayDate,
                end: addDays(props.allDayDate, 1),
            };
        }
        var hiddenSegs = props.hiddenSegs;
        return {
            start: computeEarliestSegStart(hiddenSegs),
            end: computeLatestSegEnd(hiddenSegs),
        };
    }
    function computeEarliestSegStart(segs) {
        return segs.reduce(pickEarliestStart).eventRange.range.start;
    }
    function pickEarliestStart(seg0, seg1) {
        return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
    }
    function computeLatestSegEnd(segs) {
        return segs.reduce(pickLatestEnd).eventRange.range.end;
    }
    function pickLatestEnd(seg0, seg1) {
        return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
    }

    /*!
    FullCalendar v5.10.1
    Docs & License: https://fullcalendar.io/
    (c) 2021 Adam Shaw
    */

    var Calendar = /** @class */ (function (_super) {
        __extends(Calendar, _super);
        function Calendar(el, optionOverrides) {
            if (optionOverrides === void 0) { optionOverrides = {}; }
            var _this = _super.call(this) || this;
            _this.isRendering = false;
            _this.isRendered = false;
            _this.currentClassNames = [];
            _this.customContentRenderId = 0; // will affect custom generated classNames?
            _this.handleAction = function (action) {
                // actions we know we want to render immediately
                switch (action.type) {
                    case 'SET_EVENT_DRAG':
                    case 'SET_EVENT_RESIZE':
                        _this.renderRunner.tryDrain();
                }
            };
            _this.handleData = function (data) {
                _this.currentData = data;
                _this.renderRunner.request(data.calendarOptions.rerenderDelay);
            };
            _this.handleRenderRequest = function () {
                if (_this.isRendering) {
                    _this.isRendered = true;
                    var currentData_1 = _this.currentData;
                    render(createElement(CalendarRoot, { options: currentData_1.calendarOptions, theme: currentData_1.theme, emitter: currentData_1.emitter }, function (classNames, height, isHeightAuto, forPrint) {
                        _this.setClassNames(classNames);
                        _this.setHeight(height);
                        return (createElement(CustomContentRenderContext.Provider, { value: _this.customContentRenderId },
                            createElement(CalendarContent, __assign({ isHeightAuto: isHeightAuto, forPrint: forPrint }, currentData_1))));
                    }), _this.el);
                }
                else if (_this.isRendered) {
                    _this.isRendered = false;
                    unmountComponentAtNode$1(_this.el);
                    _this.setClassNames([]);
                    _this.setHeight('');
                }
                flushToDom$1();
            };
            _this.el = el;
            _this.renderRunner = new DelayedRunner(_this.handleRenderRequest);
            new CalendarDataManager({
                optionOverrides: optionOverrides,
                calendarApi: _this,
                onAction: _this.handleAction,
                onData: _this.handleData,
            });
            return _this;
        }
        Object.defineProperty(Calendar.prototype, "view", {
            get: function () { return this.currentData.viewApi; } // for public API
            ,
            enumerable: false,
            configurable: true
        });
        Calendar.prototype.render = function () {
            var wasRendering = this.isRendering;
            if (!wasRendering) {
                this.isRendering = true;
            }
            else {
                this.customContentRenderId += 1;
            }
            this.renderRunner.request();
            if (wasRendering) {
                this.updateSize();
            }
        };
        Calendar.prototype.destroy = function () {
            if (this.isRendering) {
                this.isRendering = false;
                this.renderRunner.request();
            }
        };
        Calendar.prototype.updateSize = function () {
            _super.prototype.updateSize.call(this);
            flushToDom$1();
        };
        Calendar.prototype.batchRendering = function (func) {
            this.renderRunner.pause('batchRendering');
            func();
            this.renderRunner.resume('batchRendering');
        };
        Calendar.prototype.pauseRendering = function () {
            this.renderRunner.pause('pauseRendering');
        };
        Calendar.prototype.resumeRendering = function () {
            this.renderRunner.resume('pauseRendering', true);
        };
        Calendar.prototype.resetOptions = function (optionOverrides, append) {
            this.currentDataManager.resetOptions(optionOverrides, append);
        };
        Calendar.prototype.setClassNames = function (classNames) {
            if (!isArraysEqual(classNames, this.currentClassNames)) {
                var classList = this.el.classList;
                for (var _i = 0, _a = this.currentClassNames; _i < _a.length; _i++) {
                    var className = _a[_i];
                    classList.remove(className);
                }
                for (var _b = 0, classNames_1 = classNames; _b < classNames_1.length; _b++) {
                    var className = classNames_1[_b];
                    classList.add(className);
                }
                this.currentClassNames = classNames;
            }
        };
        Calendar.prototype.setHeight = function (height) {
            applyStyleProp(this.el, 'height', height);
        };
        return Calendar;
    }(CalendarApi));

    /* node_modules\svelte-fullcalendar\src\FullCalendar.svelte generated by Svelte v3.29.0 */
    const file$B = "node_modules\\svelte-fullcalendar\\src\\FullCalendar.svelte";

    function create_fragment$D(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", /*classes*/ ctx[0]);
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			add_location(div, file$B, 62, 0, 1156);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[5](div);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*classes*/ 1) {
    				attr_dev(div, "class", /*classes*/ ctx[0]);
    			}

    			if (dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[5](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("FullCalendar", slots, []);
    	let { class: classes = null } = $$props;
    	let { style = null } = $$props;
    	let { options } = $$props;

    	function getAPI() {
    		return calendar;
    	}

    	let calendarEl;

    	/** @type {import('@fullcalendar/core').Calendar}  */
    	let calendar;

    	onMount(async () => {
    		await Promise.resolve().then(function () { return vdom; });
    		if (!canBeInitiated) return;
    		initCalendar();

    		return () => {
    			calendar && calendar.destroy();
    		};
    	});

    	function initCalendar() {
    		$$invalidate(6, calendar = new Calendar(calendarEl, options));
    		calendar.render();
    	}

    	function updateCalendarOptions() {
    		calendar.pauseRendering();
    		calendar.resetOptions(options);
    		calendar.resumeRendering();
    	}

    	const writable_props = ["class", "style", "options"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FullCalendar> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			calendarEl = $$value;
    			$$invalidate(2, calendarEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("class" in $$props) $$invalidate(0, classes = $$props.class);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("options" in $$props) $$invalidate(3, options = $$props.options);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Calendar,
    		classes,
    		style,
    		options,
    		getAPI,
    		calendarEl,
    		calendar,
    		initCalendar,
    		updateCalendarOptions,
    		canBeInitiated
    	});

    	$$self.$inject_state = $$props => {
    		if ("classes" in $$props) $$invalidate(0, classes = $$props.classes);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("options" in $$props) $$invalidate(3, options = $$props.options);
    		if ("calendarEl" in $$props) $$invalidate(2, calendarEl = $$props.calendarEl);
    		if ("calendar" in $$props) $$invalidate(6, calendar = $$props.calendar);
    		if ("canBeInitiated" in $$props) $$invalidate(7, canBeInitiated = $$props.canBeInitiated);
    	};

    	let canBeInitiated;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*options, calendarEl, calendar*/ 76) {
    			 $$invalidate(7, canBeInitiated = options && options.plugins && options.plugins.length && calendarEl && !calendar);
    		}

    		if ($$self.$$.dirty & /*calendar, options, canBeInitiated*/ 200) {
    			 {
    				if (calendar && options && options.plugins && options.plugins.length) updateCalendarOptions();

    				if (canBeInitiated) {
    					initCalendar();
    				}
    			}
    		}
    	};

    	return [classes, style, calendarEl, options, getAPI, div_binding];
    }

    class FullCalendar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {
    			class: 0,
    			style: 1,
    			options: 3,
    			getAPI: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FullCalendar",
    			options,
    			id: create_fragment$D.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*options*/ ctx[3] === undefined && !("options" in props)) {
    			console.warn("<FullCalendar> was created without expected prop 'options'");
    		}
    	}

    	get class() {
    		throw new Error("<FullCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<FullCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<FullCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getAPI() {
    		return this.$$.ctx[4];
    	}

    	set getAPI(value) {
    		throw new Error("<FullCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var css_248z$1 = "\n:root {\n  --fc-daygrid-event-dot-width: 8px;\n}\n/* help things clear margins of inner content */\n.fc-daygrid-day-frame,\n.fc-daygrid-day-events,\n.fc-daygrid-event-harness { /* for event top/bottom margins */\n}\n.fc-daygrid-day-frame:before, .fc-daygrid-day-events:before, .fc-daygrid-event-harness:before {\n  content: \"\";\n  clear: both;\n  display: table; }\n.fc-daygrid-day-frame:after, .fc-daygrid-day-events:after, .fc-daygrid-event-harness:after {\n  content: \"\";\n  clear: both;\n  display: table; }\n.fc .fc-daygrid-body { /* a <div> that wraps the table */\n    position: relative;\n    z-index: 1; /* container inner z-index's because <tr>s can't do it */\n  }\n.fc .fc-daygrid-day.fc-day-today {\n      background-color: rgba(255, 220, 40, 0.15);\n      background-color: var(--fc-today-bg-color, rgba(255, 220, 40, 0.15));\n    }\n.fc .fc-daygrid-day-frame {\n    position: relative;\n    min-height: 100%; /* seems to work better than `height` because sets height after rows/cells naturally do it */\n  }\n.fc {\n\n  /* cell top */\n\n}\n.fc .fc-daygrid-day-top {\n    display: flex;\n    flex-direction: row-reverse;\n  }\n.fc .fc-day-other .fc-daygrid-day-top {\n    opacity: 0.3;\n  }\n.fc {\n\n  /* day number (within cell top) */\n\n}\n.fc .fc-daygrid-day-number {\n    position: relative;\n    z-index: 4;\n    padding: 4px;\n  }\n.fc {\n\n  /* event container */\n\n}\n.fc .fc-daygrid-day-events {\n    margin-top: 1px; /* needs to be margin, not padding, so that available cell height can be computed */\n  }\n.fc {\n\n  /* positioning for balanced vs natural */\n\n}\n.fc .fc-daygrid-body-balanced .fc-daygrid-day-events {\n      position: absolute;\n      left: 0;\n      right: 0;\n    }\n.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events {\n      position: relative; /* for containing abs positioned event harnesses */\n      min-height: 2em; /* in addition to being a min-height during natural height, equalizes the heights a little bit */\n    }\n.fc .fc-daygrid-body-natural { /* can coexist with -unbalanced */\n  }\n.fc .fc-daygrid-body-natural .fc-daygrid-day-events {\n      margin-bottom: 1em;\n    }\n.fc {\n\n  /* event harness */\n\n}\n.fc .fc-daygrid-event-harness {\n    position: relative;\n  }\n.fc .fc-daygrid-event-harness-abs {\n    position: absolute;\n    top: 0; /* fallback coords for when cannot yet be computed */\n    left: 0; /* */\n    right: 0; /* */\n  }\n.fc .fc-daygrid-bg-harness {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n  }\n.fc {\n\n  /* bg content */\n\n}\n.fc .fc-daygrid-day-bg .fc-non-business { z-index: 1 }\n.fc .fc-daygrid-day-bg .fc-bg-event { z-index: 2 }\n.fc .fc-daygrid-day-bg .fc-highlight { z-index: 3 }\n.fc {\n\n  /* events */\n\n}\n.fc .fc-daygrid-event {\n    z-index: 6;\n    margin-top: 1px;\n  }\n.fc .fc-daygrid-event.fc-event-mirror {\n    z-index: 7;\n  }\n.fc {\n\n  /* cell bottom (within day-events) */\n\n}\n.fc .fc-daygrid-day-bottom {\n    font-size: .85em;\n    padding: 2px 3px 0\n  }\n.fc .fc-daygrid-day-bottom:before {\n  content: \"\";\n  clear: both;\n  display: table; }\n.fc .fc-daygrid-more-link {\n    position: relative;\n    z-index: 4;\n    cursor: pointer;\n  }\n.fc {\n\n  /* week number (within frame) */\n\n}\n.fc .fc-daygrid-week-number {\n    position: absolute;\n    z-index: 5;\n    top: 0;\n    padding: 2px;\n    min-width: 1.5em;\n    text-align: center;\n    background-color: rgba(208, 208, 208, 0.3);\n    background-color: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n    color: #808080;\n    color: var(--fc-neutral-text-color, #808080);\n  }\n.fc {\n\n  /* popover */\n\n}\n.fc .fc-more-popover .fc-popover-body {\n    min-width: 220px;\n    padding: 10px;\n  }\n.fc-direction-ltr .fc-daygrid-event.fc-event-start,\n.fc-direction-rtl .fc-daygrid-event.fc-event-end {\n  margin-left: 2px;\n}\n.fc-direction-ltr .fc-daygrid-event.fc-event-end,\n.fc-direction-rtl .fc-daygrid-event.fc-event-start {\n  margin-right: 2px;\n}\n.fc-direction-ltr .fc-daygrid-week-number {\n    left: 0;\n    border-radius: 0 0 3px 0;\n  }\n.fc-direction-rtl .fc-daygrid-week-number {\n    right: 0;\n    border-radius: 0 0 0 3px;\n  }\n.fc-liquid-hack .fc-daygrid-day-frame {\n    position: static; /* will cause inner absolute stuff to expand to <td> */\n  }\n.fc-daygrid-event { /* make root-level, because will be dragged-and-dropped outside of a component root */\n  position: relative; /* for z-indexes assigned later */\n  white-space: nowrap;\n  border-radius: 3px; /* dot event needs this to when selected */\n  font-size: .85em;\n  font-size: var(--fc-small-font-size, .85em);\n}\n/* --- the rectangle (\"block\") style of event --- */\n.fc-daygrid-block-event .fc-event-time {\n    font-weight: bold;\n  }\n.fc-daygrid-block-event .fc-event-time,\n  .fc-daygrid-block-event .fc-event-title {\n    padding: 1px;\n  }\n/* --- the dot style of event --- */\n.fc-daygrid-dot-event {\n  display: flex;\n  align-items: center;\n  padding: 2px 0\n\n}\n.fc-daygrid-dot-event .fc-event-title {\n    flex-grow: 1;\n    flex-shrink: 1;\n    min-width: 0; /* important for allowing to shrink all the way */\n    overflow: hidden;\n    font-weight: bold;\n  }\n.fc-daygrid-dot-event:hover,\n  .fc-daygrid-dot-event.fc-event-mirror {\n    background: rgba(0, 0, 0, 0.1);\n  }\n.fc-daygrid-dot-event.fc-event-selected:before {\n    /* expand hit area */\n    top: -10px;\n    bottom: -10px;\n  }\n.fc-daygrid-event-dot { /* the actual dot */\n  margin: 0 4px;\n  box-sizing: content-box;\n  width: 0;\n  height: 0;\n  border: 4px solid #3788d8;\n  border: calc(var(--fc-daygrid-event-dot-width, 8px) / 2) solid var(--fc-event-border-color, #3788d8);\n  border-radius: 4px;\n  border-radius: calc(var(--fc-daygrid-event-dot-width, 8px) / 2);\n}\n/* --- spacing between time and title --- */\n.fc-direction-ltr .fc-daygrid-event .fc-event-time {\n    margin-right: 3px;\n  }\n.fc-direction-rtl .fc-daygrid-event .fc-event-time {\n    margin-left: 3px;\n  }\n";
    styleInject(css_248z$1);

    /*!
    FullCalendar v5.10.1
    Docs & License: https://fullcalendar.io/
    (c) 2021 Adam Shaw
    */

    /* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.
    ----------------------------------------------------------------------------------------------------------------------*/
    // It is a manager for a Table subcomponent, which does most of the heavy lifting.
    // It is responsible for managing width/height.
    var TableView = /** @class */ (function (_super) {
        __extends(TableView, _super);
        function TableView() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.headerElRef = createRef();
            return _this;
        }
        TableView.prototype.renderSimpleLayout = function (headerRowContent, bodyContent) {
            var _a = this, props = _a.props, context = _a.context;
            var sections = [];
            var stickyHeaderDates = getStickyHeaderDates(context.options);
            if (headerRowContent) {
                sections.push({
                    type: 'header',
                    key: 'header',
                    isSticky: stickyHeaderDates,
                    chunk: {
                        elRef: this.headerElRef,
                        tableClassName: 'fc-col-header',
                        rowContent: headerRowContent,
                    },
                });
            }
            sections.push({
                type: 'body',
                key: 'body',
                liquid: true,
                chunk: { content: bodyContent },
            });
            return (createElement(ViewRoot, { viewSpec: context.viewSpec }, function (rootElRef, classNames) { return (createElement("div", { ref: rootElRef, className: ['fc-daygrid'].concat(classNames).join(' ') },
                createElement(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [] /* TODO: make optional? */, sections: sections }))); }));
        };
        TableView.prototype.renderHScrollLayout = function (headerRowContent, bodyContent, colCnt, dayMinWidth) {
            var ScrollGrid = this.context.pluginHooks.scrollGridImpl;
            if (!ScrollGrid) {
                throw new Error('No ScrollGrid implementation');
            }
            var _a = this, props = _a.props, context = _a.context;
            var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
            var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
            var sections = [];
            if (headerRowContent) {
                sections.push({
                    type: 'header',
                    key: 'header',
                    isSticky: stickyHeaderDates,
                    chunks: [{
                            key: 'main',
                            elRef: this.headerElRef,
                            tableClassName: 'fc-col-header',
                            rowContent: headerRowContent,
                        }],
                });
            }
            sections.push({
                type: 'body',
                key: 'body',
                liquid: true,
                chunks: [{
                        key: 'main',
                        content: bodyContent,
                    }],
            });
            if (stickyFooterScrollbar) {
                sections.push({
                    type: 'footer',
                    key: 'footer',
                    isSticky: true,
                    chunks: [{
                            key: 'main',
                            content: renderScrollShim,
                        }],
                });
            }
            return (createElement(ViewRoot, { viewSpec: context.viewSpec }, function (rootElRef, classNames) { return (createElement("div", { ref: rootElRef, className: ['fc-daygrid'].concat(classNames).join(' ') },
                createElement(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections: sections }))); }));
        };
        return TableView;
    }(DateComponent));

    function splitSegsByRow(segs, rowCnt) {
        var byRow = [];
        for (var i = 0; i < rowCnt; i += 1) {
            byRow[i] = [];
        }
        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
            var seg = segs_1[_i];
            byRow[seg.row].push(seg);
        }
        return byRow;
    }
    function splitSegsByFirstCol(segs, colCnt) {
        var byCol = [];
        for (var i = 0; i < colCnt; i += 1) {
            byCol[i] = [];
        }
        for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
            var seg = segs_2[_i];
            byCol[seg.firstCol].push(seg);
        }
        return byCol;
    }
    function splitInteractionByRow(ui, rowCnt) {
        var byRow = [];
        if (!ui) {
            for (var i = 0; i < rowCnt; i += 1) {
                byRow[i] = null;
            }
        }
        else {
            for (var i = 0; i < rowCnt; i += 1) {
                byRow[i] = {
                    affectedInstances: ui.affectedInstances,
                    isEvent: ui.isEvent,
                    segs: [],
                };
            }
            for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {
                var seg = _a[_i];
                byRow[seg.row].segs.push(seg);
            }
        }
        return byRow;
    }

    var TableCellTop = /** @class */ (function (_super) {
        __extends(TableCellTop, _super);
        function TableCellTop() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableCellTop.prototype.render = function () {
            var props = this.props;
            var navLinkAttrs = buildNavLinkAttrs(this.context, props.date);
            return (createElement(DayCellContent, { date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, extraHookProps: props.extraHookProps, defaultContent: renderTopInner }, function (innerElRef, innerContent) { return ((innerContent || props.forceDayTop) && (createElement("div", { className: "fc-daygrid-day-top", ref: innerElRef },
                createElement("a", __assign({ id: props.dayNumberId, className: "fc-daygrid-day-number" }, navLinkAttrs), innerContent || createElement(Fragment, null, "\u00A0"))))); }));
        };
        return TableCellTop;
    }(BaseComponent));
    function renderTopInner(props) {
        return props.dayNumberText;
    }

    var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
        hour: 'numeric',
        minute: '2-digit',
        omitZeroMinute: true,
        meridiem: 'narrow',
    });
    function hasListItemDisplay(seg) {
        var display = seg.eventRange.ui.display;
        return display === 'list-item' || (display === 'auto' &&
            !seg.eventRange.def.allDay &&
            seg.firstCol === seg.lastCol && // can't be multi-day
            seg.isStart && // "
            seg.isEnd // "
        );
    }

    var TableBlockEvent = /** @class */ (function (_super) {
        __extends(TableBlockEvent, _super);
        function TableBlockEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableBlockEvent.prototype.render = function () {
            var props = this.props;
            return (createElement(StandardEvent, __assign({}, props, { extraClassNames: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay })));
        };
        return TableBlockEvent;
    }(BaseComponent));

    var TableListItemEvent = /** @class */ (function (_super) {
        __extends(TableListItemEvent, _super);
        function TableListItemEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableListItemEvent.prototype.render = function () {
            var _a = this, props = _a.props, context = _a.context;
            var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
            var timeText = buildSegTimeText(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);
            return (createElement(EventRoot, { seg: props.seg, timeText: timeText, defaultContent: renderInnerContent$2, isDragging: props.isDragging, isResizing: false, isDateSelecting: false, isSelected: props.isSelected, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday }, function (rootElRef, classNames, innerElRef, innerContent) { return ( // we don't use styles!
            createElement("a", __assign({ className: ['fc-daygrid-event', 'fc-daygrid-dot-event'].concat(classNames).join(' '), ref: rootElRef }, getSegAnchorAttrs(props.seg, context)), innerContent)); }));
        };
        return TableListItemEvent;
    }(BaseComponent));
    function renderInnerContent$2(innerProps) {
        return (createElement(Fragment, null,
            createElement("div", { className: "fc-daygrid-event-dot", style: { borderColor: innerProps.borderColor || innerProps.backgroundColor } }),
            innerProps.timeText && (createElement("div", { className: "fc-event-time" }, innerProps.timeText)),
            createElement("div", { className: "fc-event-title" }, innerProps.event.title || createElement(Fragment, null, "\u00A0"))));
    }

    var TableCellMoreLink = /** @class */ (function (_super) {
        __extends(TableCellMoreLink, _super);
        function TableCellMoreLink() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.compileSegs = memoize(compileSegs);
            return _this;
        }
        TableCellMoreLink.prototype.render = function () {
            var props = this.props;
            var _a = this.compileSegs(props.singlePlacements), allSegs = _a.allSegs, invisibleSegs = _a.invisibleSegs;
            return (createElement(MoreLinkRoot, { dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs: allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: function () {
                    var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) ||
                        (props.eventResize ? props.eventResize.affectedInstances : null) ||
                        {};
                    return (createElement(Fragment, null, allSegs.map(function (seg) {
                        var instanceId = seg.eventRange.instance.instanceId;
                        return (createElement("div", { className: "fc-daygrid-event-harness", key: instanceId, style: {
                                visibility: isForcedInvisible[instanceId] ? 'hidden' : '',
                            } }, hasListItemDisplay(seg) ? (createElement(TableListItemEvent, __assign({ seg: seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange)))) : (createElement(TableBlockEvent, __assign({ seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))))));
                    })));
                } }, function (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) { return (createElement("a", __assign({ ref: rootElRef, className: ['fc-daygrid-more-link'].concat(classNames).join(' '), title: title, "aria-expanded": isExpanded, "aria-controls": popoverId }, createAriaClickAttrs(handleClick)), innerContent)); }));
        };
        return TableCellMoreLink;
    }(BaseComponent));
    function compileSegs(singlePlacements) {
        var allSegs = [];
        var invisibleSegs = [];
        for (var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++) {
            var placement = singlePlacements_1[_i];
            allSegs.push(placement.seg);
            if (!placement.isVisible) {
                invisibleSegs.push(placement.seg);
            }
        }
        return { allSegs: allSegs, invisibleSegs: invisibleSegs };
    }

    var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: 'narrow' });
    var TableCell = /** @class */ (function (_super) {
        __extends(TableCell, _super);
        function TableCell() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.rootElRef = createRef();
            _this.state = {
                dayNumberId: getUniqueDomId(),
            };
            _this.handleRootEl = function (el) {
                setRef(_this.rootElRef, el);
                setRef(_this.props.elRef, el);
            };
            return _this;
        }
        TableCell.prototype.render = function () {
            var _a = this, context = _a.context, props = _a.props, state = _a.state, rootElRef = _a.rootElRef;
            var date = props.date, dateProfile = props.dateProfile;
            var navLinkAttrs = buildNavLinkAttrs(context, date, 'week');
            return (createElement(DayCellRoot, { date: date, dateProfile: dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, extraHookProps: props.extraHookProps, elRef: this.handleRootEl }, function (dayElRef, dayClassNames, rootDataAttrs, isDisabled) { return (createElement("td", __assign({ ref: dayElRef, role: "gridcell", className: ['fc-daygrid-day'].concat(dayClassNames, props.extraClassNames || []).join(' ') }, rootDataAttrs, props.extraDataAttrs, (props.showDayNumber ? { 'aria-labelledby': state.dayNumberId } : {})),
                createElement("div", { className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", ref: props.innerElRef /* different from hook system! RENAME */ },
                    props.showWeekNumber && (createElement(WeekNumberRoot, { date: date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }, function (weekElRef, weekClassNames, innerElRef, innerContent) { return (createElement("a", __assign({ ref: weekElRef, className: ['fc-daygrid-week-number'].concat(weekClassNames).join(' ') }, navLinkAttrs), innerContent)); })),
                    !isDisabled && (createElement(TableCellTop, { date: date, dateProfile: dateProfile, showDayNumber: props.showDayNumber, dayNumberId: state.dayNumberId, forceDayTop: props.forceDayTop, todayRange: props.todayRange, extraHookProps: props.extraHookProps })),
                    createElement("div", { className: "fc-daygrid-day-events", ref: props.fgContentElRef },
                        props.fgContent,
                        createElement("div", { className: "fc-daygrid-day-bottom", style: { marginTop: props.moreMarginTop } },
                            createElement(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange }))),
                    createElement("div", { className: "fc-daygrid-day-bg" }, props.bgContent)))); }));
        };
        return TableCell;
    }(DateComponent));

    function computeFgSegPlacement(segs, // assumed already sorted
    dayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {
        var hierarchy = new DayGridSegHierarchy();
        hierarchy.allowReslicing = true;
        hierarchy.strictOrder = strictOrder;
        if (dayMaxEvents === true || dayMaxEventRows === true) {
            hierarchy.maxCoord = maxContentHeight;
            hierarchy.hiddenConsumes = true;
        }
        else if (typeof dayMaxEvents === 'number') {
            hierarchy.maxStackCnt = dayMaxEvents;
        }
        else if (typeof dayMaxEventRows === 'number') {
            hierarchy.maxStackCnt = dayMaxEventRows;
            hierarchy.hiddenConsumes = true;
        }
        // create segInputs only for segs with known heights
        var segInputs = [];
        var unknownHeightSegs = [];
        for (var i = 0; i < segs.length; i += 1) {
            var seg = segs[i];
            var instanceId = seg.eventRange.instance.instanceId;
            var eventHeight = eventInstanceHeights[instanceId];
            if (eventHeight != null) {
                segInputs.push({
                    index: i,
                    thickness: eventHeight,
                    span: {
                        start: seg.firstCol,
                        end: seg.lastCol + 1,
                    },
                });
            }
            else {
                unknownHeightSegs.push(seg);
            }
        }
        var hiddenEntries = hierarchy.addSegs(segInputs);
        var segRects = hierarchy.toRects();
        var _a = placeRects(segRects, segs, cells), singleColPlacements = _a.singleColPlacements, multiColPlacements = _a.multiColPlacements, leftoverMargins = _a.leftoverMargins;
        var moreCnts = [];
        var moreMarginTops = [];
        // add segs with unknown heights
        for (var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++) {
            var seg = unknownHeightSegs_1[_i];
            multiColPlacements[seg.firstCol].push({
                seg: seg,
                isVisible: false,
                isAbsolute: true,
                absoluteTop: 0,
                marginTop: 0,
            });
            for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {
                singleColPlacements[col].push({
                    seg: resliceSeg(seg, col, col + 1, cells),
                    isVisible: false,
                    isAbsolute: false,
                    absoluteTop: 0,
                    marginTop: 0,
                });
            }
        }
        // add the hidden entries
        for (var col = 0; col < cells.length; col += 1) {
            moreCnts.push(0);
        }
        for (var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++) {
            var hiddenEntry = hiddenEntries_1[_b];
            var seg = segs[hiddenEntry.index];
            var hiddenSpan = hiddenEntry.span;
            multiColPlacements[hiddenSpan.start].push({
                seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
                isVisible: false,
                isAbsolute: true,
                absoluteTop: 0,
                marginTop: 0,
            });
            for (var col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
                moreCnts[col] += 1;
                singleColPlacements[col].push({
                    seg: resliceSeg(seg, col, col + 1, cells),
                    isVisible: false,
                    isAbsolute: false,
                    absoluteTop: 0,
                    marginTop: 0,
                });
            }
        }
        // deal with leftover margins
        for (var col = 0; col < cells.length; col += 1) {
            moreMarginTops.push(leftoverMargins[col]);
        }
        return { singleColPlacements: singleColPlacements, multiColPlacements: multiColPlacements, moreCnts: moreCnts, moreMarginTops: moreMarginTops };
    }
    // rects ordered by top coord, then left
    function placeRects(allRects, segs, cells) {
        var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
        var singleColPlacements = [];
        var multiColPlacements = [];
        var leftoverMargins = [];
        for (var col = 0; col < cells.length; col += 1) {
            var rects = rectsByEachCol[col];
            // compute all static segs in singlePlacements
            var singlePlacements = [];
            var currentHeight = 0;
            var currentMarginTop = 0;
            for (var _i = 0, rects_1 = rects; _i < rects_1.length; _i++) {
                var rect = rects_1[_i];
                var seg = segs[rect.index];
                singlePlacements.push({
                    seg: resliceSeg(seg, col, col + 1, cells),
                    isVisible: true,
                    isAbsolute: false,
                    absoluteTop: rect.levelCoord,
                    marginTop: rect.levelCoord - currentHeight,
                });
                currentHeight = rect.levelCoord + rect.thickness;
            }
            // compute mixed static/absolute segs in multiPlacements
            var multiPlacements = [];
            currentHeight = 0;
            currentMarginTop = 0;
            for (var _a = 0, rects_2 = rects; _a < rects_2.length; _a++) {
                var rect = rects_2[_a];
                var seg = segs[rect.index];
                var isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?
                var isFirstCol = rect.span.start === col;
                currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg
                currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg
                if (isAbsolute) {
                    currentMarginTop += rect.thickness;
                    if (isFirstCol) {
                        multiPlacements.push({
                            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
                            isVisible: true,
                            isAbsolute: true,
                            absoluteTop: rect.levelCoord,
                            marginTop: 0,
                        });
                    }
                }
                else if (isFirstCol) {
                    multiPlacements.push({
                        seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
                        isVisible: true,
                        isAbsolute: false,
                        absoluteTop: rect.levelCoord,
                        marginTop: currentMarginTop, // claim the margin
                    });
                    currentMarginTop = 0;
                }
            }
            singleColPlacements.push(singlePlacements);
            multiColPlacements.push(multiPlacements);
            leftoverMargins.push(currentMarginTop);
        }
        return { singleColPlacements: singleColPlacements, multiColPlacements: multiColPlacements, leftoverMargins: leftoverMargins };
    }
    function groupRectsByEachCol(rects, colCnt) {
        var rectsByEachCol = [];
        for (var col = 0; col < colCnt; col += 1) {
            rectsByEachCol.push([]);
        }
        for (var _i = 0, rects_3 = rects; _i < rects_3.length; _i++) {
            var rect = rects_3[_i];
            for (var col = rect.span.start; col < rect.span.end; col += 1) {
                rectsByEachCol[col].push(rect);
            }
        }
        return rectsByEachCol;
    }
    function resliceSeg(seg, spanStart, spanEnd, cells) {
        if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
            return seg;
        }
        var eventRange = seg.eventRange;
        var origRange = eventRange.range;
        var slicedRange = intersectRanges(origRange, {
            start: cells[spanStart].date,
            end: addDays(cells[spanEnd - 1].date, 1),
        });
        return __assign(__assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {
                def: eventRange.def,
                ui: __assign(__assign({}, eventRange.ui), { durationEditable: false }),
                instance: eventRange.instance,
                range: slicedRange,
            }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });
    }
    var DayGridSegHierarchy = /** @class */ (function (_super) {
        __extends(DayGridSegHierarchy, _super);
        function DayGridSegHierarchy() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            // config
            _this.hiddenConsumes = false;
            // allows us to keep hidden entries in the hierarchy so they take up space
            _this.forceHidden = {};
            return _this;
        }
        DayGridSegHierarchy.prototype.addSegs = function (segInputs) {
            var _this = this;
            var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);
            var entriesByLevel = this.entriesByLevel;
            var excludeHidden = function (entry) { return !_this.forceHidden[buildEntryKey(entry)]; };
            // remove the forced-hidden segs
            for (var level = 0; level < entriesByLevel.length; level += 1) {
                entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
            }
            return hiddenSegs;
        };
        DayGridSegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {
            var _a = this, entriesByLevel = _a.entriesByLevel, forceHidden = _a.forceHidden;
            var touchingEntry = insertion.touchingEntry, touchingLevel = insertion.touchingLevel, touchingLateral = insertion.touchingLateral;
            if (this.hiddenConsumes && touchingEntry) {
                var touchingEntryId = buildEntryKey(touchingEntry);
                // if not already hidden
                if (!forceHidden[touchingEntryId]) {
                    if (this.allowReslicing) {
                        var placeholderEntry = __assign(__assign({}, touchingEntry), { span: intersectSpans(touchingEntry.span, entry.span) });
                        var placeholderEntryId = buildEntryKey(placeholderEntry);
                        forceHidden[placeholderEntryId] = true;
                        entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder
                        this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it
                    }
                    else {
                        forceHidden[touchingEntryId] = true;
                        hiddenEntries.push(touchingEntry);
                    }
                }
            }
            return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);
        };
        return DayGridSegHierarchy;
    }(SegHierarchy));

    var TableRow = /** @class */ (function (_super) {
        __extends(TableRow, _super);
        function TableRow() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.cellElRefs = new RefMap(); // the <td>
            _this.frameElRefs = new RefMap(); // the fc-daygrid-day-frame
            _this.fgElRefs = new RefMap(); // the fc-daygrid-day-events
            _this.segHarnessRefs = new RefMap(); // indexed by "instanceId:firstCol"
            _this.rootElRef = createRef();
            _this.state = {
                framePositions: null,
                maxContentHeight: null,
                eventInstanceHeights: {},
            };
            return _this;
        }
        TableRow.prototype.render = function () {
            var _this = this;
            var _a = this, props = _a.props, state = _a.state, context = _a.context;
            var options = context.options;
            var colCnt = props.cells.length;
            var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
            var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
            var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
            var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
            var _b = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells), singleColPlacements = _b.singleColPlacements, multiColPlacements = _b.multiColPlacements, moreCnts = _b.moreCnts, moreMarginTops = _b.moreMarginTops;
            var isForcedInvisible = // TODO: messy way to compute this
             (props.eventDrag && props.eventDrag.affectedInstances) ||
                (props.eventResize && props.eventResize.affectedInstances) ||
                {};
            return (createElement("tr", { ref: this.rootElRef, role: "row" },
                props.renderIntro && props.renderIntro(),
                props.cells.map(function (cell, col) {
                    var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
                    var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
                    return (createElement(TableCell, { key: cell.key, elRef: _this.cellElRefs.createRef(cell.key), innerElRef: _this.frameElRefs.createRef(cell.key) /* FF <td> problem, but okay to use for left/right. TODO: rename prop */, dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraHookProps: cell.extraHookProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: _this.fgElRefs.createRef(cell.key), fgContent: ( // Fragment scopes the keys
                        createElement(Fragment, null,
                            createElement(Fragment, null, normalFgNodes),
                            createElement(Fragment, null, mirrorFgNodes))), bgContent: ( // Fragment scopes the keys
                        createElement(Fragment, null,
                            _this.renderFillSegs(highlightSegsByCol[col], 'highlight'),
                            _this.renderFillSegs(businessHoursByCol[col], 'non-business'),
                            _this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))) }));
                })));
        };
        TableRow.prototype.componentDidMount = function () {
            this.updateSizing(true);
        };
        TableRow.prototype.componentDidUpdate = function (prevProps, prevState) {
            var currentProps = this.props;
            this.updateSizing(!isPropsEqual(prevProps, currentProps));
        };
        TableRow.prototype.getHighlightSegs = function () {
            var props = this.props;
            if (props.eventDrag && props.eventDrag.segs.length) { // messy check
                return props.eventDrag.segs;
            }
            if (props.eventResize && props.eventResize.segs.length) { // messy check
                return props.eventResize.segs;
            }
            return props.dateSelectionSegs;
        };
        TableRow.prototype.getMirrorSegs = function () {
            var props = this.props;
            if (props.eventResize && props.eventResize.segs.length) { // messy check
                return props.eventResize.segs;
            }
            return [];
        };
        TableRow.prototype.renderFgSegs = function (col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
            var context = this.context;
            var eventSelection = this.props.eventSelection;
            var framePositions = this.state.framePositions;
            var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1
            var isMirror = isDragging || isResizing || isDateSelecting;
            var nodes = [];
            if (framePositions) {
                for (var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++) {
                    var placement = segPlacements_1[_i];
                    var seg = placement.seg;
                    var instanceId = seg.eventRange.instance.instanceId;
                    var key = instanceId + ':' + col;
                    var isVisible = placement.isVisible && !isForcedInvisible[instanceId];
                    var isAbsolute = placement.isAbsolute;
                    var left = '';
                    var right = '';
                    if (isAbsolute) {
                        if (context.isRtl) {
                            right = 0;
                            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
                        }
                        else {
                            left = 0;
                            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
                        }
                    }
                    /*
                    known bug: events that are force to be list-item but span multiple days still take up space in later columns
                    todo: in print view, for multi-day events, don't display title within non-start/end segs
                    */
                    nodes.push(createElement("div", { className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''), key: key, ref: isMirror ? null : this.segHarnessRefs.createRef(key), style: {
                            visibility: isVisible ? '' : 'hidden',
                            marginTop: isAbsolute ? '' : placement.marginTop,
                            top: isAbsolute ? placement.absoluteTop : '',
                            left: left,
                            right: right,
                        } }, hasListItemDisplay(seg) ? (createElement(TableListItemEvent, __assign({ seg: seg, isDragging: isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd: defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))) : (createElement(TableBlockEvent, __assign({ seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd: defaultDisplayEventEnd }, getSegMeta(seg, todayRange))))));
                }
            }
            return nodes;
        };
        TableRow.prototype.renderFillSegs = function (segs, fillType) {
            var isRtl = this.context.isRtl;
            var todayRange = this.props.todayRange;
            var framePositions = this.state.framePositions;
            var nodes = [];
            if (framePositions) {
                for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
                    var seg = segs_1[_i];
                    var leftRightCss = isRtl ? {
                        right: 0,
                        left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol],
                    } : {
                        left: 0,
                        right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol],
                    };
                    nodes.push(createElement("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-daygrid-bg-harness", style: leftRightCss }, fillType === 'bg-event' ?
                        createElement(BgEvent, __assign({ seg: seg }, getSegMeta(seg, todayRange))) :
                        renderFill(fillType)));
                }
            }
            return createElement.apply(void 0, __spreadArray([Fragment, {}], nodes));
        };
        TableRow.prototype.updateSizing = function (isExternalSizingChange) {
            var _a = this, props = _a.props, frameElRefs = _a.frameElRefs;
            if (!props.forPrint &&
                props.clientWidth !== null // positioning ready?
            ) {
                if (isExternalSizingChange) {
                    var frameEls = props.cells.map(function (cell) { return frameElRefs.currentMap[cell.key]; });
                    if (frameEls.length) {
                        var originEl = this.rootElRef.current;
                        this.setState({
                            framePositions: new PositionCache(originEl, frameEls, true, // isHorizontal
                            false),
                        });
                    }
                }
                var oldInstanceHeights = this.state.eventInstanceHeights;
                var newInstanceHeights = this.queryEventInstanceHeights();
                var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
                this.setState({
                    // HACK to prevent oscillations of events being shown/hidden from max-event-rows
                    // Essentially, once you compute an element's height, never null-out.
                    // TODO: always display all events, as visibility:hidden?
                    eventInstanceHeights: __assign(__assign({}, oldInstanceHeights), newInstanceHeights),
                    maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null,
                });
            }
        };
        TableRow.prototype.queryEventInstanceHeights = function () {
            var segElMap = this.segHarnessRefs.currentMap;
            var eventInstanceHeights = {};
            // get the max height amongst instance segs
            for (var key in segElMap) {
                var height = Math.round(segElMap[key].getBoundingClientRect().height);
                var instanceId = key.split(':')[0]; // deconstruct how renderFgSegs makes the key
                eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);
            }
            return eventInstanceHeights;
        };
        TableRow.prototype.computeMaxContentHeight = function () {
            var firstKey = this.props.cells[0].key;
            var cellEl = this.cellElRefs.currentMap[firstKey];
            var fcContainerEl = this.fgElRefs.currentMap[firstKey];
            return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
        };
        TableRow.prototype.getCellEls = function () {
            var elMap = this.cellElRefs.currentMap;
            return this.props.cells.map(function (cell) { return elMap[cell.key]; });
        };
        return TableRow;
    }(DateComponent));
    TableRow.addStateEquality({
        eventInstanceHeights: isPropsEqual,
    });
    function buildMirrorPlacements(mirrorSegs, colPlacements) {
        if (!mirrorSegs.length) {
            return [];
        }
        var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?
        return mirrorSegs.map(function (seg) { return ({
            seg: seg,
            isVisible: true,
            isAbsolute: true,
            absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
            marginTop: 0,
        }); });
    }
    function buildAbsoluteTopHash(colPlacements) {
        var topsByInstanceId = {};
        for (var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++) {
            var placements = colPlacements_1[_i];
            for (var _a = 0, placements_1 = placements; _a < placements_1.length; _a++) {
                var placement = placements_1[_a];
                topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
            }
        }
        return topsByInstanceId;
    }

    var Table = /** @class */ (function (_super) {
        __extends(Table, _super);
        function Table() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.splitBusinessHourSegs = memoize(splitSegsByRow);
            _this.splitBgEventSegs = memoize(splitSegsByRow);
            _this.splitFgEventSegs = memoize(splitSegsByRow);
            _this.splitDateSelectionSegs = memoize(splitSegsByRow);
            _this.splitEventDrag = memoize(splitInteractionByRow);
            _this.splitEventResize = memoize(splitInteractionByRow);
            _this.rowRefs = new RefMap();
            _this.handleRootEl = function (rootEl) {
                _this.rootEl = rootEl;
                if (rootEl) {
                    _this.context.registerInteractiveComponent(_this, {
                        el: rootEl,
                        isHitComboAllowed: _this.props.isHitComboAllowed,
                    });
                }
                else {
                    _this.context.unregisterInteractiveComponent(_this);
                }
            };
            return _this;
        }
        Table.prototype.render = function () {
            var _this = this;
            var props = this.props;
            var dateProfile = props.dateProfile, dayMaxEventRows = props.dayMaxEventRows, dayMaxEvents = props.dayMaxEvents, expandRows = props.expandRows;
            var rowCnt = props.cells.length;
            var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
            var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
            var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
            var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
            var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
            var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
            var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
            // if rows can't expand to fill fixed height, can't do balanced-height event limit
            // TODO: best place to normalize these options?
            if (limitViaBalanced && !expandRows) {
                limitViaBalanced = false;
                dayMaxEventRows = null;
                dayMaxEvents = null;
            }
            var classNames = [
                'fc-daygrid-body',
                limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced',
                expandRows ? '' : 'fc-daygrid-body-natural', // will height of one row depend on the others?
            ];
            return (createElement("div", { className: classNames.join(' '), ref: this.handleRootEl, style: {
                    // these props are important to give this wrapper correct dimensions for interactions
                    // TODO: if we set it here, can we avoid giving to inner tables?
                    width: props.clientWidth,
                    minWidth: props.tableMinWidth,
                } },
                createElement(NowTimer, { unit: "day" }, function (nowDate, todayRange) { return (createElement(Fragment, null,
                    createElement("table", { role: "presentation", className: "fc-scrollgrid-sync-table", style: {
                            width: props.clientWidth,
                            minWidth: props.tableMinWidth,
                            height: expandRows ? props.clientHeight : '',
                        } },
                        props.colGroupNode,
                        createElement("tbody", { role: "presentation" }, props.cells.map(function (cells, row) { return (createElement(TableRow, { ref: _this.rowRefs.createRef(row), key: cells.length
                                ? cells[0].date.toISOString() /* best? or put key on cell? or use diff formatter? */
                                : row // in case there are no cells (like when resource view is loading)
                            , showDayNumbers: rowCnt > 1, showWeekNumbers: props.showWeekNumbers, todayRange: todayRange, dateProfile: dateProfile, cells: cells, renderIntro: props.renderRowIntro, businessHourSegs: businessHourSegsByRow[row], eventSelection: props.eventSelection, bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay) /* hack */, fgEventSegs: fgEventSegsByRow[row], dateSelectionSegs: dateSelectionSegsByRow[row], eventDrag: eventDragByRow[row], eventResize: eventResizeByRow[row], dayMaxEvents: dayMaxEvents, dayMaxEventRows: dayMaxEventRows, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint })); }))))); })));
        };
        // Hit System
        // ----------------------------------------------------------------------------------------------------
        Table.prototype.prepareHits = function () {
            this.rowPositions = new PositionCache(this.rootEl, this.rowRefs.collect().map(function (rowObj) { return rowObj.getCellEls()[0]; }), // first cell el in each row. TODO: not optimal
            false, true);
            this.colPositions = new PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row
            true, // horizontal
            false);
        };
        Table.prototype.queryHit = function (positionLeft, positionTop) {
            var _a = this, colPositions = _a.colPositions, rowPositions = _a.rowPositions;
            var col = colPositions.leftToIndex(positionLeft);
            var row = rowPositions.topToIndex(positionTop);
            if (row != null && col != null) {
                var cell = this.props.cells[row][col];
                return {
                    dateProfile: this.props.dateProfile,
                    dateSpan: __assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),
                    dayEl: this.getCellEl(row, col),
                    rect: {
                        left: colPositions.lefts[col],
                        right: colPositions.rights[col],
                        top: rowPositions.tops[row],
                        bottom: rowPositions.bottoms[row],
                    },
                    layer: 0,
                };
            }
            return null;
        };
        Table.prototype.getCellEl = function (row, col) {
            return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal
        };
        Table.prototype.getCellRange = function (row, col) {
            var start = this.props.cells[row][col].date;
            var end = addDays(start, 1);
            return { start: start, end: end };
        };
        return Table;
    }(DateComponent));
    function isSegAllDay(seg) {
        return seg.eventRange.def.allDay;
    }

    var DayTableSlicer = /** @class */ (function (_super) {
        __extends(DayTableSlicer, _super);
        function DayTableSlicer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.forceDayIfListItem = true;
            return _this;
        }
        DayTableSlicer.prototype.sliceRange = function (dateRange, dayTableModel) {
            return dayTableModel.sliceRange(dateRange);
        };
        return DayTableSlicer;
    }(Slicer));

    var DayTable = /** @class */ (function (_super) {
        __extends(DayTable, _super);
        function DayTable() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.slicer = new DayTableSlicer();
            _this.tableRef = createRef();
            return _this;
        }
        DayTable.prototype.render = function () {
            var _a = this, props = _a.props, context = _a.context;
            return (createElement(Table, __assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint })));
        };
        return DayTable;
    }(DateComponent));

    var DayTableView = /** @class */ (function (_super) {
        __extends(DayTableView, _super);
        function DayTableView() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.buildDayTableModel = memoize(buildDayTableModel);
            _this.headerRef = createRef();
            _this.tableRef = createRef();
            return _this;
        }
        DayTableView.prototype.render = function () {
            var _this = this;
            var _a = this.context, options = _a.options, dateProfileGenerator = _a.dateProfileGenerator;
            var props = this.props;
            var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
            var headerContent = options.dayHeaders && (createElement(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 }));
            var bodyContent = function (contentArg) { return (createElement(DayTable, { ref: _this.tableRef, dateProfile: props.dateProfile, dayTableModel: dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: _this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint })); };
            return options.dayMinWidth
                ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth)
                : this.renderSimpleLayout(headerContent, bodyContent);
        };
        return DayTableView;
    }(TableView));
    function buildDayTableModel(dateProfile, dateProfileGenerator) {
        var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
        return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
    }

    var TableDateProfileGenerator = /** @class */ (function (_super) {
        __extends(TableDateProfileGenerator, _super);
        function TableDateProfileGenerator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // Computes the date range that will be rendered.
        TableDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
            var dateEnv = this.props.dateEnv;
            var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);
            var start = renderRange.start;
            var end = renderRange.end;
            var endOfWeek;
            // year and month views should be aligned with weeks. this is already done for week
            if (/^(year|month)$/.test(currentRangeUnit)) {
                start = dateEnv.startOfWeek(start);
                // make end-of-week if not already
                endOfWeek = dateEnv.startOfWeek(end);
                if (endOfWeek.valueOf() !== end.valueOf()) {
                    end = addWeeks(endOfWeek, 1);
                }
            }
            // ensure 6 weeks
            if (this.props.monthMode &&
                this.props.fixedWeekCount) {
                var rowCnt = Math.ceil(// could be partial weeks due to hiddenDays
                diffWeeks(start, end));
                end = addWeeks(end, 6 - rowCnt);
            }
            return { start: start, end: end };
        };
        return TableDateProfileGenerator;
    }(DateProfileGenerator));

    var main = createPlugin({
        initialView: 'dayGridMonth',
        views: {
            dayGrid: {
                component: DayTableView,
                dateProfileGeneratorClass: TableDateProfileGenerator,
            },
            dayGridDay: {
                type: 'dayGrid',
                duration: { days: 1 },
            },
            dayGridWeek: {
                type: 'dayGrid',
                duration: { weeks: 1 },
            },
            dayGridMonth: {
                type: 'dayGrid',
                duration: { months: 1 },
                monthMode: true,
                fixedWeekCount: true,
            },
        },
    });

    /*!
    FullCalendar v5.10.1
    Docs & License: https://fullcalendar.io/
    (c) 2021 Adam Shaw
    */

    config.touchMouseIgnoreWait = 500;
    var ignoreMouseDepth = 0;
    var listenerCnt = 0;
    var isWindowTouchMoveCancelled = false;
    /*
    Uses a "pointer" abstraction, which monitors UI events for both mouse and touch.
    Tracks when the pointer "drags" on a certain element, meaning down+move+up.

    Also, tracks if there was touch-scrolling.
    Also, can prevent touch-scrolling from happening.
    Also, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.

    emits:
    - pointerdown
    - pointermove
    - pointerup
    */
    var PointerDragging = /** @class */ (function () {
        function PointerDragging(containerEl) {
            var _this = this;
            this.subjectEl = null;
            // options that can be directly assigned by caller
            this.selector = ''; // will cause subjectEl in all emitted events to be this element
            this.handleSelector = '';
            this.shouldIgnoreMove = false;
            this.shouldWatchScroll = true; // for simulating pointermove on scroll
            // internal states
            this.isDragging = false;
            this.isTouchDragging = false;
            this.wasTouchScroll = false;
            // Mouse
            // ----------------------------------------------------------------------------------------------------
            this.handleMouseDown = function (ev) {
                if (!_this.shouldIgnoreMouse() &&
                    isPrimaryMouseButton(ev) &&
                    _this.tryStart(ev)) {
                    var pev = _this.createEventFromMouse(ev, true);
                    _this.emitter.trigger('pointerdown', pev);
                    _this.initScrollWatch(pev);
                    if (!_this.shouldIgnoreMove) {
                        document.addEventListener('mousemove', _this.handleMouseMove);
                    }
                    document.addEventListener('mouseup', _this.handleMouseUp);
                }
            };
            this.handleMouseMove = function (ev) {
                var pev = _this.createEventFromMouse(ev);
                _this.recordCoords(pev);
                _this.emitter.trigger('pointermove', pev);
            };
            this.handleMouseUp = function (ev) {
                document.removeEventListener('mousemove', _this.handleMouseMove);
                document.removeEventListener('mouseup', _this.handleMouseUp);
                _this.emitter.trigger('pointerup', _this.createEventFromMouse(ev));
                _this.cleanup(); // call last so that pointerup has access to props
            };
            // Touch
            // ----------------------------------------------------------------------------------------------------
            this.handleTouchStart = function (ev) {
                if (_this.tryStart(ev)) {
                    _this.isTouchDragging = true;
                    var pev = _this.createEventFromTouch(ev, true);
                    _this.emitter.trigger('pointerdown', pev);
                    _this.initScrollWatch(pev);
                    // unlike mouse, need to attach to target, not document
                    // https://stackoverflow.com/a/45760014
                    var targetEl = ev.target;
                    if (!_this.shouldIgnoreMove) {
                        targetEl.addEventListener('touchmove', _this.handleTouchMove);
                    }
                    targetEl.addEventListener('touchend', _this.handleTouchEnd);
                    targetEl.addEventListener('touchcancel', _this.handleTouchEnd); // treat it as a touch end
                    // attach a handler to get called when ANY scroll action happens on the page.
                    // this was impossible to do with normal on/off because 'scroll' doesn't bubble.
                    // http://stackoverflow.com/a/32954565/96342
                    window.addEventListener('scroll', _this.handleTouchScroll, true);
                }
            };
            this.handleTouchMove = function (ev) {
                var pev = _this.createEventFromTouch(ev);
                _this.recordCoords(pev);
                _this.emitter.trigger('pointermove', pev);
            };
            this.handleTouchEnd = function (ev) {
                if (_this.isDragging) { // done to guard against touchend followed by touchcancel
                    var targetEl = ev.target;
                    targetEl.removeEventListener('touchmove', _this.handleTouchMove);
                    targetEl.removeEventListener('touchend', _this.handleTouchEnd);
                    targetEl.removeEventListener('touchcancel', _this.handleTouchEnd);
                    window.removeEventListener('scroll', _this.handleTouchScroll, true); // useCaptured=true
                    _this.emitter.trigger('pointerup', _this.createEventFromTouch(ev));
                    _this.cleanup(); // call last so that pointerup has access to props
                    _this.isTouchDragging = false;
                    startIgnoringMouse();
                }
            };
            this.handleTouchScroll = function () {
                _this.wasTouchScroll = true;
            };
            this.handleScroll = function (ev) {
                if (!_this.shouldIgnoreMove) {
                    var pageX = (window.pageXOffset - _this.prevScrollX) + _this.prevPageX;
                    var pageY = (window.pageYOffset - _this.prevScrollY) + _this.prevPageY;
                    _this.emitter.trigger('pointermove', {
                        origEvent: ev,
                        isTouch: _this.isTouchDragging,
                        subjectEl: _this.subjectEl,
                        pageX: pageX,
                        pageY: pageY,
                        deltaX: pageX - _this.origPageX,
                        deltaY: pageY - _this.origPageY,
                    });
                }
            };
            this.containerEl = containerEl;
            this.emitter = new Emitter();
            containerEl.addEventListener('mousedown', this.handleMouseDown);
            containerEl.addEventListener('touchstart', this.handleTouchStart, { passive: true });
            listenerCreated();
        }
        PointerDragging.prototype.destroy = function () {
            this.containerEl.removeEventListener('mousedown', this.handleMouseDown);
            this.containerEl.removeEventListener('touchstart', this.handleTouchStart, { passive: true });
            listenerDestroyed();
        };
        PointerDragging.prototype.tryStart = function (ev) {
            var subjectEl = this.querySubjectEl(ev);
            var downEl = ev.target;
            if (subjectEl &&
                (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {
                this.subjectEl = subjectEl;
                this.isDragging = true; // do this first so cancelTouchScroll will work
                this.wasTouchScroll = false;
                return true;
            }
            return false;
        };
        PointerDragging.prototype.cleanup = function () {
            isWindowTouchMoveCancelled = false;
            this.isDragging = false;
            this.subjectEl = null;
            // keep wasTouchScroll around for later access
            this.destroyScrollWatch();
        };
        PointerDragging.prototype.querySubjectEl = function (ev) {
            if (this.selector) {
                return elementClosest(ev.target, this.selector);
            }
            return this.containerEl;
        };
        PointerDragging.prototype.shouldIgnoreMouse = function () {
            return ignoreMouseDepth || this.isTouchDragging;
        };
        // can be called by user of this class, to cancel touch-based scrolling for the current drag
        PointerDragging.prototype.cancelTouchScroll = function () {
            if (this.isDragging) {
                isWindowTouchMoveCancelled = true;
            }
        };
        // Scrolling that simulates pointermoves
        // ----------------------------------------------------------------------------------------------------
        PointerDragging.prototype.initScrollWatch = function (ev) {
            if (this.shouldWatchScroll) {
                this.recordCoords(ev);
                window.addEventListener('scroll', this.handleScroll, true); // useCapture=true
            }
        };
        PointerDragging.prototype.recordCoords = function (ev) {
            if (this.shouldWatchScroll) {
                this.prevPageX = ev.pageX;
                this.prevPageY = ev.pageY;
                this.prevScrollX = window.pageXOffset;
                this.prevScrollY = window.pageYOffset;
            }
        };
        PointerDragging.prototype.destroyScrollWatch = function () {
            if (this.shouldWatchScroll) {
                window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true
            }
        };
        // Event Normalization
        // ----------------------------------------------------------------------------------------------------
        PointerDragging.prototype.createEventFromMouse = function (ev, isFirst) {
            var deltaX = 0;
            var deltaY = 0;
            // TODO: repeat code
            if (isFirst) {
                this.origPageX = ev.pageX;
                this.origPageY = ev.pageY;
            }
            else {
                deltaX = ev.pageX - this.origPageX;
                deltaY = ev.pageY - this.origPageY;
            }
            return {
                origEvent: ev,
                isTouch: false,
                subjectEl: this.subjectEl,
                pageX: ev.pageX,
                pageY: ev.pageY,
                deltaX: deltaX,
                deltaY: deltaY,
            };
        };
        PointerDragging.prototype.createEventFromTouch = function (ev, isFirst) {
            var touches = ev.touches;
            var pageX;
            var pageY;
            var deltaX = 0;
            var deltaY = 0;
            // if touch coords available, prefer,
            // because FF would give bad ev.pageX ev.pageY
            if (touches && touches.length) {
                pageX = touches[0].pageX;
                pageY = touches[0].pageY;
            }
            else {
                pageX = ev.pageX;
                pageY = ev.pageY;
            }
            // TODO: repeat code
            if (isFirst) {
                this.origPageX = pageX;
                this.origPageY = pageY;
            }
            else {
                deltaX = pageX - this.origPageX;
                deltaY = pageY - this.origPageY;
            }
            return {
                origEvent: ev,
                isTouch: true,
                subjectEl: this.subjectEl,
                pageX: pageX,
                pageY: pageY,
                deltaX: deltaX,
                deltaY: deltaY,
            };
        };
        return PointerDragging;
    }());
    // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
    function isPrimaryMouseButton(ev) {
        return ev.button === 0 && !ev.ctrlKey;
    }
    // Ignoring fake mouse events generated by touch
    // ----------------------------------------------------------------------------------------------------
    function startIgnoringMouse() {
        ignoreMouseDepth += 1;
        setTimeout(function () {
            ignoreMouseDepth -= 1;
        }, config.touchMouseIgnoreWait);
    }
    // We want to attach touchmove as early as possible for Safari
    // ----------------------------------------------------------------------------------------------------
    function listenerCreated() {
        listenerCnt += 1;
        if (listenerCnt === 1) {
            window.addEventListener('touchmove', onWindowTouchMove, { passive: false });
        }
    }
    function listenerDestroyed() {
        listenerCnt -= 1;
        if (!listenerCnt) {
            window.removeEventListener('touchmove', onWindowTouchMove, { passive: false });
        }
    }
    function onWindowTouchMove(ev) {
        if (isWindowTouchMoveCancelled) {
            ev.preventDefault();
        }
    }

    /*
    An effect in which an element follows the movement of a pointer across the screen.
    The moving element is a clone of some other element.
    Must call start + handleMove + stop.
    */
    var ElementMirror = /** @class */ (function () {
        function ElementMirror() {
            this.isVisible = false; // must be explicitly enabled
            this.sourceEl = null;
            this.mirrorEl = null;
            this.sourceElRect = null; // screen coords relative to viewport
            // options that can be set directly by caller
            this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues
            this.zIndex = 9999;
            this.revertDuration = 0;
        }
        ElementMirror.prototype.start = function (sourceEl, pageX, pageY) {
            this.sourceEl = sourceEl;
            this.sourceElRect = this.sourceEl.getBoundingClientRect();
            this.origScreenX = pageX - window.pageXOffset;
            this.origScreenY = pageY - window.pageYOffset;
            this.deltaX = 0;
            this.deltaY = 0;
            this.updateElPosition();
        };
        ElementMirror.prototype.handleMove = function (pageX, pageY) {
            this.deltaX = (pageX - window.pageXOffset) - this.origScreenX;
            this.deltaY = (pageY - window.pageYOffset) - this.origScreenY;
            this.updateElPosition();
        };
        // can be called before start
        ElementMirror.prototype.setIsVisible = function (bool) {
            if (bool) {
                if (!this.isVisible) {
                    if (this.mirrorEl) {
                        this.mirrorEl.style.display = '';
                    }
                    this.isVisible = bool; // needs to happen before updateElPosition
                    this.updateElPosition(); // because was not updating the position while invisible
                }
            }
            else if (this.isVisible) {
                if (this.mirrorEl) {
                    this.mirrorEl.style.display = 'none';
                }
                this.isVisible = bool;
            }
        };
        // always async
        ElementMirror.prototype.stop = function (needsRevertAnimation, callback) {
            var _this = this;
            var done = function () {
                _this.cleanup();
                callback();
            };
            if (needsRevertAnimation &&
                this.mirrorEl &&
                this.isVisible &&
                this.revertDuration && // if 0, transition won't work
                (this.deltaX || this.deltaY) // if same coords, transition won't work
            ) {
                this.doRevertAnimation(done, this.revertDuration);
            }
            else {
                setTimeout(done, 0);
            }
        };
        ElementMirror.prototype.doRevertAnimation = function (callback, revertDuration) {
            var mirrorEl = this.mirrorEl;
            var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened
            mirrorEl.style.transition =
                'top ' + revertDuration + 'ms,' +
                    'left ' + revertDuration + 'ms';
            applyStyle(mirrorEl, {
                left: finalSourceElRect.left,
                top: finalSourceElRect.top,
            });
            whenTransitionDone(mirrorEl, function () {
                mirrorEl.style.transition = '';
                callback();
            });
        };
        ElementMirror.prototype.cleanup = function () {
            if (this.mirrorEl) {
                removeElement(this.mirrorEl);
                this.mirrorEl = null;
            }
            this.sourceEl = null;
        };
        ElementMirror.prototype.updateElPosition = function () {
            if (this.sourceEl && this.isVisible) {
                applyStyle(this.getMirrorEl(), {
                    left: this.sourceElRect.left + this.deltaX,
                    top: this.sourceElRect.top + this.deltaY,
                });
            }
        };
        ElementMirror.prototype.getMirrorEl = function () {
            var sourceElRect = this.sourceElRect;
            var mirrorEl = this.mirrorEl;
            if (!mirrorEl) {
                mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true
                // we don't want long taps or any mouse interaction causing selection/menus.
                // would use preventSelection(), but that prevents selectstart, causing problems.
                mirrorEl.classList.add('fc-unselectable');
                mirrorEl.classList.add('fc-event-dragging');
                applyStyle(mirrorEl, {
                    position: 'fixed',
                    zIndex: this.zIndex,
                    visibility: '',
                    boxSizing: 'border-box',
                    width: sourceElRect.right - sourceElRect.left,
                    height: sourceElRect.bottom - sourceElRect.top,
                    right: 'auto',
                    bottom: 'auto',
                    margin: 0,
                });
                this.parentNode.appendChild(mirrorEl);
            }
            return mirrorEl;
        };
        return ElementMirror;
    }());

    /*
    Is a cache for a given element's scroll information (all the info that ScrollController stores)
    in addition the "client rectangle" of the element.. the area within the scrollbars.

    The cache can be in one of two modes:
    - doesListening:false - ignores when the container is scrolled by someone else
    - doesListening:true - watch for scrolling and update the cache
    */
    var ScrollGeomCache = /** @class */ (function (_super) {
        __extends(ScrollGeomCache, _super);
        function ScrollGeomCache(scrollController, doesListening) {
            var _this = _super.call(this) || this;
            _this.handleScroll = function () {
                _this.scrollTop = _this.scrollController.getScrollTop();
                _this.scrollLeft = _this.scrollController.getScrollLeft();
                _this.handleScrollChange();
            };
            _this.scrollController = scrollController;
            _this.doesListening = doesListening;
            _this.scrollTop = _this.origScrollTop = scrollController.getScrollTop();
            _this.scrollLeft = _this.origScrollLeft = scrollController.getScrollLeft();
            _this.scrollWidth = scrollController.getScrollWidth();
            _this.scrollHeight = scrollController.getScrollHeight();
            _this.clientWidth = scrollController.getClientWidth();
            _this.clientHeight = scrollController.getClientHeight();
            _this.clientRect = _this.computeClientRect(); // do last in case it needs cached values
            if (_this.doesListening) {
                _this.getEventTarget().addEventListener('scroll', _this.handleScroll);
            }
            return _this;
        }
        ScrollGeomCache.prototype.destroy = function () {
            if (this.doesListening) {
                this.getEventTarget().removeEventListener('scroll', this.handleScroll);
            }
        };
        ScrollGeomCache.prototype.getScrollTop = function () {
            return this.scrollTop;
        };
        ScrollGeomCache.prototype.getScrollLeft = function () {
            return this.scrollLeft;
        };
        ScrollGeomCache.prototype.setScrollTop = function (top) {
            this.scrollController.setScrollTop(top);
            if (!this.doesListening) {
                // we are not relying on the element to normalize out-of-bounds scroll values
                // so we need to sanitize ourselves
                this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
                this.handleScrollChange();
            }
        };
        ScrollGeomCache.prototype.setScrollLeft = function (top) {
            this.scrollController.setScrollLeft(top);
            if (!this.doesListening) {
                // we are not relying on the element to normalize out-of-bounds scroll values
                // so we need to sanitize ourselves
                this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
                this.handleScrollChange();
            }
        };
        ScrollGeomCache.prototype.getClientWidth = function () {
            return this.clientWidth;
        };
        ScrollGeomCache.prototype.getClientHeight = function () {
            return this.clientHeight;
        };
        ScrollGeomCache.prototype.getScrollWidth = function () {
            return this.scrollWidth;
        };
        ScrollGeomCache.prototype.getScrollHeight = function () {
            return this.scrollHeight;
        };
        ScrollGeomCache.prototype.handleScrollChange = function () {
        };
        return ScrollGeomCache;
    }(ScrollController));

    var ElementScrollGeomCache = /** @class */ (function (_super) {
        __extends(ElementScrollGeomCache, _super);
        function ElementScrollGeomCache(el, doesListening) {
            return _super.call(this, new ElementScrollController(el), doesListening) || this;
        }
        ElementScrollGeomCache.prototype.getEventTarget = function () {
            return this.scrollController.el;
        };
        ElementScrollGeomCache.prototype.computeClientRect = function () {
            return computeInnerRect(this.scrollController.el);
        };
        return ElementScrollGeomCache;
    }(ScrollGeomCache));

    var WindowScrollGeomCache = /** @class */ (function (_super) {
        __extends(WindowScrollGeomCache, _super);
        function WindowScrollGeomCache(doesListening) {
            return _super.call(this, new WindowScrollController(), doesListening) || this;
        }
        WindowScrollGeomCache.prototype.getEventTarget = function () {
            return window;
        };
        WindowScrollGeomCache.prototype.computeClientRect = function () {
            return {
                left: this.scrollLeft,
                right: this.scrollLeft + this.clientWidth,
                top: this.scrollTop,
                bottom: this.scrollTop + this.clientHeight,
            };
        };
        // the window is the only scroll object that changes it's rectangle relative
        // to the document's topleft as it scrolls
        WindowScrollGeomCache.prototype.handleScrollChange = function () {
            this.clientRect = this.computeClientRect();
        };
        return WindowScrollGeomCache;
    }(ScrollGeomCache));

    // If available we are using native "performance" API instead of "Date"
    // Read more about it on MDN:
    // https://developer.mozilla.org/en-US/docs/Web/API/Performance
    var getTime = typeof performance === 'function' ? performance.now : Date.now;
    /*
    For a pointer interaction, automatically scrolls certain scroll containers when the pointer
    approaches the edge.

    The caller must call start + handleMove + stop.
    */
    var AutoScroller = /** @class */ (function () {
        function AutoScroller() {
            var _this = this;
            // options that can be set by caller
            this.isEnabled = true;
            this.scrollQuery = [window, '.fc-scroller'];
            this.edgeThreshold = 50; // pixels
            this.maxVelocity = 300; // pixels per second
            // internal state
            this.pointerScreenX = null;
            this.pointerScreenY = null;
            this.isAnimating = false;
            this.scrollCaches = null;
            // protect against the initial pointerdown being too close to an edge and starting the scroll
            this.everMovedUp = false;
            this.everMovedDown = false;
            this.everMovedLeft = false;
            this.everMovedRight = false;
            this.animate = function () {
                if (_this.isAnimating) { // wasn't cancelled between animation calls
                    var edge = _this.computeBestEdge(_this.pointerScreenX + window.pageXOffset, _this.pointerScreenY + window.pageYOffset);
                    if (edge) {
                        var now = getTime();
                        _this.handleSide(edge, (now - _this.msSinceRequest) / 1000);
                        _this.requestAnimation(now);
                    }
                    else {
                        _this.isAnimating = false; // will stop animation
                    }
                }
            };
        }
        AutoScroller.prototype.start = function (pageX, pageY, scrollStartEl) {
            if (this.isEnabled) {
                this.scrollCaches = this.buildCaches(scrollStartEl);
                this.pointerScreenX = null;
                this.pointerScreenY = null;
                this.everMovedUp = false;
                this.everMovedDown = false;
                this.everMovedLeft = false;
                this.everMovedRight = false;
                this.handleMove(pageX, pageY);
            }
        };
        AutoScroller.prototype.handleMove = function (pageX, pageY) {
            if (this.isEnabled) {
                var pointerScreenX = pageX - window.pageXOffset;
                var pointerScreenY = pageY - window.pageYOffset;
                var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
                var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
                if (yDelta < 0) {
                    this.everMovedUp = true;
                }
                else if (yDelta > 0) {
                    this.everMovedDown = true;
                }
                if (xDelta < 0) {
                    this.everMovedLeft = true;
                }
                else if (xDelta > 0) {
                    this.everMovedRight = true;
                }
                this.pointerScreenX = pointerScreenX;
                this.pointerScreenY = pointerScreenY;
                if (!this.isAnimating) {
                    this.isAnimating = true;
                    this.requestAnimation(getTime());
                }
            }
        };
        AutoScroller.prototype.stop = function () {
            if (this.isEnabled) {
                this.isAnimating = false; // will stop animation
                for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                    var scrollCache = _a[_i];
                    scrollCache.destroy();
                }
                this.scrollCaches = null;
            }
        };
        AutoScroller.prototype.requestAnimation = function (now) {
            this.msSinceRequest = now;
            requestAnimationFrame(this.animate);
        };
        AutoScroller.prototype.handleSide = function (edge, seconds) {
            var scrollCache = edge.scrollCache;
            var edgeThreshold = this.edgeThreshold;
            var invDistance = edgeThreshold - edge.distance;
            var velocity = // the closer to the edge, the faster we scroll
             ((invDistance * invDistance) / (edgeThreshold * edgeThreshold)) * // quadratic
                this.maxVelocity * seconds;
            var sign = 1;
            switch (edge.name) {
                case 'left':
                    sign = -1;
                // falls through
                case 'right':
                    scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
                    break;
                case 'top':
                    sign = -1;
                // falls through
                case 'bottom':
                    scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
                    break;
            }
        };
        // left/top are relative to document topleft
        AutoScroller.prototype.computeBestEdge = function (left, top) {
            var edgeThreshold = this.edgeThreshold;
            var bestSide = null;
            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                var scrollCache = _a[_i];
                var rect = scrollCache.clientRect;
                var leftDist = left - rect.left;
                var rightDist = rect.right - left;
                var topDist = top - rect.top;
                var bottomDist = rect.bottom - top;
                // completely within the rect?
                if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
                    if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() &&
                        (!bestSide || bestSide.distance > topDist)) {
                        bestSide = { scrollCache: scrollCache, name: 'top', distance: topDist };
                    }
                    if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() &&
                        (!bestSide || bestSide.distance > bottomDist)) {
                        bestSide = { scrollCache: scrollCache, name: 'bottom', distance: bottomDist };
                    }
                    if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() &&
                        (!bestSide || bestSide.distance > leftDist)) {
                        bestSide = { scrollCache: scrollCache, name: 'left', distance: leftDist };
                    }
                    if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() &&
                        (!bestSide || bestSide.distance > rightDist)) {
                        bestSide = { scrollCache: scrollCache, name: 'right', distance: rightDist };
                    }
                }
            }
            return bestSide;
        };
        AutoScroller.prototype.buildCaches = function (scrollStartEl) {
            return this.queryScrollEls(scrollStartEl).map(function (el) {
                if (el === window) {
                    return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls
                }
                return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls
            });
        };
        AutoScroller.prototype.queryScrollEls = function (scrollStartEl) {
            var els = [];
            for (var _i = 0, _a = this.scrollQuery; _i < _a.length; _i++) {
                var query = _a[_i];
                if (typeof query === 'object') {
                    els.push(query);
                }
                else {
                    els.push.apply(els, Array.prototype.slice.call(getElRoot(scrollStartEl).querySelectorAll(query)));
                }
            }
            return els;
        };
        return AutoScroller;
    }());

    /*
    Monitors dragging on an element. Has a number of high-level features:
    - minimum distance required before dragging
    - minimum wait time ("delay") before dragging
    - a mirror element that follows the pointer
    */
    var FeaturefulElementDragging = /** @class */ (function (_super) {
        __extends(FeaturefulElementDragging, _super);
        function FeaturefulElementDragging(containerEl, selector) {
            var _this = _super.call(this, containerEl) || this;
            _this.containerEl = containerEl;
            // options that can be directly set by caller
            // the caller can also set the PointerDragging's options as well
            _this.delay = null;
            _this.minDistance = 0;
            _this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag
            _this.mirrorNeedsRevert = false;
            _this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup
            _this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation
            _this.isDelayEnded = false;
            _this.isDistanceSurpassed = false;
            _this.delayTimeoutId = null;
            _this.onPointerDown = function (ev) {
                if (!_this.isDragging) { // so new drag doesn't happen while revert animation is going
                    _this.isInteracting = true;
                    _this.isDelayEnded = false;
                    _this.isDistanceSurpassed = false;
                    preventSelection(document.body);
                    preventContextMenu(document.body);
                    // prevent links from being visited if there's an eventual drag.
                    // also prevents selection in older browsers (maybe?).
                    // not necessary for touch, besides, browser would complain about passiveness.
                    if (!ev.isTouch) {
                        ev.origEvent.preventDefault();
                    }
                    _this.emitter.trigger('pointerdown', ev);
                    if (_this.isInteracting && // not destroyed via pointerdown handler
                        !_this.pointer.shouldIgnoreMove) {
                        // actions related to initiating dragstart+dragmove+dragend...
                        _this.mirror.setIsVisible(false); // reset. caller must set-visible
                        _this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down
                        _this.startDelay(ev);
                        if (!_this.minDistance) {
                            _this.handleDistanceSurpassed(ev);
                        }
                    }
                }
            };
            _this.onPointerMove = function (ev) {
                if (_this.isInteracting) {
                    _this.emitter.trigger('pointermove', ev);
                    if (!_this.isDistanceSurpassed) {
                        var minDistance = _this.minDistance;
                        var distanceSq = void 0; // current distance from the origin, squared
                        var deltaX = ev.deltaX, deltaY = ev.deltaY;
                        distanceSq = deltaX * deltaX + deltaY * deltaY;
                        if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem
                            _this.handleDistanceSurpassed(ev);
                        }
                    }
                    if (_this.isDragging) {
                        // a real pointer move? (not one simulated by scrolling)
                        if (ev.origEvent.type !== 'scroll') {
                            _this.mirror.handleMove(ev.pageX, ev.pageY);
                            _this.autoScroller.handleMove(ev.pageX, ev.pageY);
                        }
                        _this.emitter.trigger('dragmove', ev);
                    }
                }
            };
            _this.onPointerUp = function (ev) {
                if (_this.isInteracting) {
                    _this.isInteracting = false;
                    allowSelection(document.body);
                    allowContextMenu(document.body);
                    _this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert
                    if (_this.isDragging) {
                        _this.autoScroller.stop();
                        _this.tryStopDrag(ev); // which will stop the mirror
                    }
                    if (_this.delayTimeoutId) {
                        clearTimeout(_this.delayTimeoutId);
                        _this.delayTimeoutId = null;
                    }
                }
            };
            var pointer = _this.pointer = new PointerDragging(containerEl);
            pointer.emitter.on('pointerdown', _this.onPointerDown);
            pointer.emitter.on('pointermove', _this.onPointerMove);
            pointer.emitter.on('pointerup', _this.onPointerUp);
            if (selector) {
                pointer.selector = selector;
            }
            _this.mirror = new ElementMirror();
            _this.autoScroller = new AutoScroller();
            return _this;
        }
        FeaturefulElementDragging.prototype.destroy = function () {
            this.pointer.destroy();
            // HACK: simulate a pointer-up to end the current drag
            // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)
            this.onPointerUp({});
        };
        FeaturefulElementDragging.prototype.startDelay = function (ev) {
            var _this = this;
            if (typeof this.delay === 'number') {
                this.delayTimeoutId = setTimeout(function () {
                    _this.delayTimeoutId = null;
                    _this.handleDelayEnd(ev);
                }, this.delay); // not assignable to number!
            }
            else {
                this.handleDelayEnd(ev);
            }
        };
        FeaturefulElementDragging.prototype.handleDelayEnd = function (ev) {
            this.isDelayEnded = true;
            this.tryStartDrag(ev);
        };
        FeaturefulElementDragging.prototype.handleDistanceSurpassed = function (ev) {
            this.isDistanceSurpassed = true;
            this.tryStartDrag(ev);
        };
        FeaturefulElementDragging.prototype.tryStartDrag = function (ev) {
            if (this.isDelayEnded && this.isDistanceSurpassed) {
                if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
                    this.isDragging = true;
                    this.mirrorNeedsRevert = false;
                    this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
                    this.emitter.trigger('dragstart', ev);
                    if (this.touchScrollAllowed === false) {
                        this.pointer.cancelTouchScroll();
                    }
                }
            }
        };
        FeaturefulElementDragging.prototype.tryStopDrag = function (ev) {
            // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events
            // that come from the document to fire beforehand. much more convenient this way.
            this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
        };
        FeaturefulElementDragging.prototype.stopDrag = function (ev) {
            this.isDragging = false;
            this.emitter.trigger('dragend', ev);
        };
        // fill in the implementations...
        FeaturefulElementDragging.prototype.setIgnoreMove = function (bool) {
            this.pointer.shouldIgnoreMove = bool;
        };
        FeaturefulElementDragging.prototype.setMirrorIsVisible = function (bool) {
            this.mirror.setIsVisible(bool);
        };
        FeaturefulElementDragging.prototype.setMirrorNeedsRevert = function (bool) {
            this.mirrorNeedsRevert = bool;
        };
        FeaturefulElementDragging.prototype.setAutoScrollEnabled = function (bool) {
            this.autoScroller.isEnabled = bool;
        };
        return FeaturefulElementDragging;
    }(ElementDragging));

    /*
    When this class is instantiated, it records the offset of an element (relative to the document topleft),
    and continues to monitor scrolling, updating the cached coordinates if it needs to.
    Does not access the DOM after instantiation, so highly performant.

    Also keeps track of all scrolling/overflow:hidden containers that are parents of the given element
    and an determine if a given point is inside the combined clipping rectangle.
    */
    var OffsetTracker = /** @class */ (function () {
        function OffsetTracker(el) {
            this.origRect = computeRect(el);
            // will work fine for divs that have overflow:hidden
            this.scrollCaches = getClippingParents(el).map(function (scrollEl) { return new ElementScrollGeomCache(scrollEl, true); });
        }
        OffsetTracker.prototype.destroy = function () {
            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                var scrollCache = _a[_i];
                scrollCache.destroy();
            }
        };
        OffsetTracker.prototype.computeLeft = function () {
            var left = this.origRect.left;
            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                var scrollCache = _a[_i];
                left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
            }
            return left;
        };
        OffsetTracker.prototype.computeTop = function () {
            var top = this.origRect.top;
            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                var scrollCache = _a[_i];
                top += scrollCache.origScrollTop - scrollCache.getScrollTop();
            }
            return top;
        };
        OffsetTracker.prototype.isWithinClipping = function (pageX, pageY) {
            var point = { left: pageX, top: pageY };
            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {
                var scrollCache = _a[_i];
                if (!isIgnoredClipping(scrollCache.getEventTarget()) &&
                    !pointInsideRect(point, scrollCache.clientRect)) {
                    return false;
                }
            }
            return true;
        };
        return OffsetTracker;
    }());
    // certain clipping containers should never constrain interactions, like <html> and <body>
    // https://github.com/fullcalendar/fullcalendar/issues/3615
    function isIgnoredClipping(node) {
        var tagName = node.tagName;
        return tagName === 'HTML' || tagName === 'BODY';
    }

    /*
    Tracks movement over multiple droppable areas (aka "hits")
    that exist in one or more DateComponents.
    Relies on an existing draggable.

    emits:
    - pointerdown
    - dragstart
    - hitchange - fires initially, even if not over a hit
    - pointerup
    - (hitchange - again, to null, if ended over a hit)
    - dragend
    */
    var HitDragging = /** @class */ (function () {
        function HitDragging(dragging, droppableStore) {
            var _this = this;
            // options that can be set by caller
            this.useSubjectCenter = false;
            this.requireInitial = true; // if doesn't start out on a hit, won't emit any events
            this.initialHit = null;
            this.movingHit = null;
            this.finalHit = null; // won't ever be populated if shouldIgnoreMove
            this.handlePointerDown = function (ev) {
                var dragging = _this.dragging;
                _this.initialHit = null;
                _this.movingHit = null;
                _this.finalHit = null;
                _this.prepareHits();
                _this.processFirstCoord(ev);
                if (_this.initialHit || !_this.requireInitial) {
                    dragging.setIgnoreMove(false);
                    // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(
                    _this.emitter.trigger('pointerdown', ev);
                }
                else {
                    dragging.setIgnoreMove(true);
                }
            };
            this.handleDragStart = function (ev) {
                _this.emitter.trigger('dragstart', ev);
                _this.handleMove(ev, true); // force = fire even if initially null
            };
            this.handleDragMove = function (ev) {
                _this.emitter.trigger('dragmove', ev);
                _this.handleMove(ev);
            };
            this.handlePointerUp = function (ev) {
                _this.releaseHits();
                _this.emitter.trigger('pointerup', ev);
            };
            this.handleDragEnd = function (ev) {
                if (_this.movingHit) {
                    _this.emitter.trigger('hitupdate', null, true, ev);
                }
                _this.finalHit = _this.movingHit;
                _this.movingHit = null;
                _this.emitter.trigger('dragend', ev);
            };
            this.droppableStore = droppableStore;
            dragging.emitter.on('pointerdown', this.handlePointerDown);
            dragging.emitter.on('dragstart', this.handleDragStart);
            dragging.emitter.on('dragmove', this.handleDragMove);
            dragging.emitter.on('pointerup', this.handlePointerUp);
            dragging.emitter.on('dragend', this.handleDragEnd);
            this.dragging = dragging;
            this.emitter = new Emitter();
        }
        // sets initialHit
        // sets coordAdjust
        HitDragging.prototype.processFirstCoord = function (ev) {
            var origPoint = { left: ev.pageX, top: ev.pageY };
            var adjustedPoint = origPoint;
            var subjectEl = ev.subjectEl;
            var subjectRect;
            if (subjectEl instanceof HTMLElement) { // i.e. not a Document/ShadowRoot
                subjectRect = computeRect(subjectEl);
                adjustedPoint = constrainPoint(adjustedPoint, subjectRect);
            }
            var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
            if (initialHit) {
                if (this.useSubjectCenter && subjectRect) {
                    var slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);
                    if (slicedSubjectRect) {
                        adjustedPoint = getRectCenter(slicedSubjectRect);
                    }
                }
                this.coordAdjust = diffPoints(adjustedPoint, origPoint);
            }
            else {
                this.coordAdjust = { left: 0, top: 0 };
            }
        };
        HitDragging.prototype.handleMove = function (ev, forceHandle) {
            var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
            if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
                this.movingHit = hit;
                this.emitter.trigger('hitupdate', hit, false, ev);
            }
        };
        HitDragging.prototype.prepareHits = function () {
            this.offsetTrackers = mapHash(this.droppableStore, function (interactionSettings) {
                interactionSettings.component.prepareHits();
                return new OffsetTracker(interactionSettings.el);
            });
        };
        HitDragging.prototype.releaseHits = function () {
            var offsetTrackers = this.offsetTrackers;
            for (var id in offsetTrackers) {
                offsetTrackers[id].destroy();
            }
            this.offsetTrackers = {};
        };
        HitDragging.prototype.queryHitForOffset = function (offsetLeft, offsetTop) {
            var _a = this, droppableStore = _a.droppableStore, offsetTrackers = _a.offsetTrackers;
            var bestHit = null;
            for (var id in droppableStore) {
                var component = droppableStore[id].component;
                var offsetTracker = offsetTrackers[id];
                if (offsetTracker && // wasn't destroyed mid-drag
                    offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
                    var originLeft = offsetTracker.computeLeft();
                    var originTop = offsetTracker.computeTop();
                    var positionLeft = offsetLeft - originLeft;
                    var positionTop = offsetTop - originTop;
                    var origRect = offsetTracker.origRect;
                    var width = origRect.right - origRect.left;
                    var height = origRect.bottom - origRect.top;
                    if (
                    // must be within the element's bounds
                    positionLeft >= 0 && positionLeft < width &&
                        positionTop >= 0 && positionTop < height) {
                        var hit = component.queryHit(positionLeft, positionTop, width, height);
                        if (hit && (
                        // make sure the hit is within activeRange, meaning it's not a dead cell
                        rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range)) &&
                            (!bestHit || hit.layer > bestHit.layer)) {
                            hit.componentId = id;
                            hit.context = component.context;
                            // TODO: better way to re-orient rectangle
                            hit.rect.left += originLeft;
                            hit.rect.right += originLeft;
                            hit.rect.top += originTop;
                            hit.rect.bottom += originTop;
                            bestHit = hit;
                        }
                    }
                }
            }
            return bestHit;
        };
        return HitDragging;
    }());
    function isHitsEqual(hit0, hit1) {
        if (!hit0 && !hit1) {
            return true;
        }
        if (Boolean(hit0) !== Boolean(hit1)) {
            return false;
        }
        return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
    }

    function buildDatePointApiWithContext(dateSpan, context) {
        var props = {};
        for (var _i = 0, _a = context.pluginHooks.datePointTransforms; _i < _a.length; _i++) {
            var transform = _a[_i];
            __assign(props, transform(dateSpan, context));
        }
        __assign(props, buildDatePointApi(dateSpan, context.dateEnv));
        return props;
    }
    function buildDatePointApi(span, dateEnv) {
        return {
            date: dateEnv.toDate(span.range.start),
            dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
            allDay: span.allDay,
        };
    }

    /*
    Monitors when the user clicks on a specific date/time of a component.
    A pointerdown+pointerup on the same "hit" constitutes a click.
    */
    var DateClicking = /** @class */ (function (_super) {
        __extends(DateClicking, _super);
        function DateClicking(settings) {
            var _this = _super.call(this, settings) || this;
            _this.handlePointerDown = function (pev) {
                var dragging = _this.dragging;
                var downEl = pev.origEvent.target;
                // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired
                dragging.setIgnoreMove(!_this.component.isValidDateDownEl(downEl));
            };
            // won't even fire if moving was ignored
            _this.handleDragEnd = function (ev) {
                var component = _this.component;
                var pointer = _this.dragging.pointer;
                if (!pointer.wasTouchScroll) {
                    var _a = _this.hitDragging, initialHit = _a.initialHit, finalHit = _a.finalHit;
                    if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
                        var context = component.context;
                        var arg = __assign(__assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context.viewApi || context.calendarApi.view });
                        context.emitter.trigger('dateClick', arg);
                    }
                }
            };
            // we DO want to watch pointer moves because otherwise finalHit won't get populated
            _this.dragging = new FeaturefulElementDragging(settings.el);
            _this.dragging.autoScroller.isEnabled = false;
            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsToStore(settings));
            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
            hitDragging.emitter.on('dragend', _this.handleDragEnd);
            return _this;
        }
        DateClicking.prototype.destroy = function () {
            this.dragging.destroy();
        };
        return DateClicking;
    }(Interaction));

    /*
    Tracks when the user selects a portion of time of a component,
    constituted by a drag over date cells, with a possible delay at the beginning of the drag.
    */
    var DateSelecting = /** @class */ (function (_super) {
        __extends(DateSelecting, _super);
        function DateSelecting(settings) {
            var _this = _super.call(this, settings) || this;
            _this.dragSelection = null;
            _this.handlePointerDown = function (ev) {
                var _a = _this, component = _a.component, dragging = _a.dragging;
                var options = component.context.options;
                var canSelect = options.selectable &&
                    component.isValidDateDownEl(ev.origEvent.target);
                // don't bother to watch expensive moves if component won't do selection
                dragging.setIgnoreMove(!canSelect);
                // if touch, require user to hold down
                dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;
            };
            _this.handleDragStart = function (ev) {
                _this.component.context.calendarApi.unselect(ev); // unselect previous selections
            };
            _this.handleHitUpdate = function (hit, isFinal) {
                var context = _this.component.context;
                var dragSelection = null;
                var isInvalid = false;
                if (hit) {
                    var initialHit = _this.hitDragging.initialHit;
                    var disallowed = hit.componentId === initialHit.componentId
                        && _this.isHitComboAllowed
                        && !_this.isHitComboAllowed(initialHit, hit);
                    if (!disallowed) {
                        dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);
                    }
                    if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {
                        isInvalid = true;
                        dragSelection = null;
                    }
                }
                if (dragSelection) {
                    context.dispatch({ type: 'SELECT_DATES', selection: dragSelection });
                }
                else if (!isFinal) { // only unselect if moved away while dragging
                    context.dispatch({ type: 'UNSELECT_DATES' });
                }
                if (!isInvalid) {
                    enableCursor();
                }
                else {
                    disableCursor();
                }
                if (!isFinal) {
                    _this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging
                }
            };
            _this.handlePointerUp = function (pev) {
                if (_this.dragSelection) {
                    // selection is already rendered, so just need to report selection
                    triggerDateSelect(_this.dragSelection, pev, _this.component.context);
                    _this.dragSelection = null;
                }
            };
            var component = settings.component;
            var options = component.context.options;
            var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);
            dragging.touchScrollAllowed = false;
            dragging.minDistance = options.selectMinDistance || 0;
            dragging.autoScroller.isEnabled = options.dragScroll;
            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsToStore(settings));
            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
            hitDragging.emitter.on('dragstart', _this.handleDragStart);
            hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
            hitDragging.emitter.on('pointerup', _this.handlePointerUp);
            return _this;
        }
        DateSelecting.prototype.destroy = function () {
            this.dragging.destroy();
        };
        return DateSelecting;
    }(Interaction));
    function getComponentTouchDelay$1(component) {
        var options = component.context.options;
        var delay = options.selectLongPressDelay;
        if (delay == null) {
            delay = options.longPressDelay;
        }
        return delay;
    }
    function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
        var dateSpan0 = hit0.dateSpan;
        var dateSpan1 = hit1.dateSpan;
        var ms = [
            dateSpan0.range.start,
            dateSpan0.range.end,
            dateSpan1.range.start,
            dateSpan1.range.end,
        ];
        ms.sort(compareNumbers);
        var props = {};
        for (var _i = 0, dateSelectionTransformers_1 = dateSelectionTransformers; _i < dateSelectionTransformers_1.length; _i++) {
            var transformer = dateSelectionTransformers_1[_i];
            var res = transformer(hit0, hit1);
            if (res === false) {
                return null;
            }
            if (res) {
                __assign(props, res);
            }
        }
        props.range = { start: ms[0], end: ms[3] };
        props.allDay = dateSpan0.allDay;
        return props;
    }

    var EventDragging = /** @class */ (function (_super) {
        __extends(EventDragging, _super);
        function EventDragging(settings) {
            var _this = _super.call(this, settings) || this;
            // internal state
            _this.subjectEl = null;
            _this.subjectSeg = null; // the seg being selected/dragged
            _this.isDragging = false;
            _this.eventRange = null;
            _this.relevantEvents = null; // the events being dragged
            _this.receivingContext = null;
            _this.validMutation = null;
            _this.mutatedRelevantEvents = null;
            _this.handlePointerDown = function (ev) {
                var origTarget = ev.origEvent.target;
                var _a = _this, component = _a.component, dragging = _a.dragging;
                var mirror = dragging.mirror;
                var options = component.context.options;
                var initialContext = component.context;
                _this.subjectEl = ev.subjectEl;
                var subjectSeg = _this.subjectSeg = getElSeg(ev.subjectEl);
                var eventRange = _this.eventRange = subjectSeg.eventRange;
                var eventInstanceId = eventRange.instance.instanceId;
                _this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
                dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;
                dragging.delay =
                    // only do a touch delay if touch and this event hasn't been selected yet
                    (ev.isTouch && eventInstanceId !== component.props.eventSelection) ?
                        getComponentTouchDelay(component) :
                        null;
                if (options.fixedMirrorParent) {
                    mirror.parentNode = options.fixedMirrorParent;
                }
                else {
                    mirror.parentNode = elementClosest(origTarget, '.fc');
                }
                mirror.revertDuration = options.dragRevertDuration;
                var isValid = component.isValidSegDownEl(origTarget) &&
                    !elementClosest(origTarget, '.fc-event-resizer'); // NOT on a resizer
                dragging.setIgnoreMove(!isValid);
                // disable dragging for elements that are resizable (ie, selectable)
                // but are not draggable
                _this.isDragging = isValid &&
                    ev.subjectEl.classList.contains('fc-event-draggable');
            };
            _this.handleDragStart = function (ev) {
                var initialContext = _this.component.context;
                var eventRange = _this.eventRange;
                var eventInstanceId = eventRange.instance.instanceId;
                if (ev.isTouch) {
                    // need to select a different event?
                    if (eventInstanceId !== _this.component.props.eventSelection) {
                        initialContext.dispatch({ type: 'SELECT_EVENT', eventInstanceId: eventInstanceId });
                    }
                }
                else {
                    // if now using mouse, but was previous touch interaction, clear selected event
                    initialContext.dispatch({ type: 'UNSELECT_EVENT' });
                }
                if (_this.isDragging) {
                    initialContext.calendarApi.unselect(ev); // unselect *date* selection
                    initialContext.emitter.trigger('eventDragStart', {
                        el: _this.subjectEl,
                        event: new EventApi(initialContext, eventRange.def, eventRange.instance),
                        jsEvent: ev.origEvent,
                        view: initialContext.viewApi,
                    });
                }
            };
            _this.handleHitUpdate = function (hit, isFinal) {
                if (!_this.isDragging) {
                    return;
                }
                var relevantEvents = _this.relevantEvents;
                var initialHit = _this.hitDragging.initialHit;
                var initialContext = _this.component.context;
                // states based on new hit
                var receivingContext = null;
                var mutation = null;
                var mutatedRelevantEvents = null;
                var isInvalid = false;
                var interaction = {
                    affectedEvents: relevantEvents,
                    mutatedEvents: createEmptyEventStore(),
                    isEvent: true,
                };
                if (hit) {
                    receivingContext = hit.context;
                    var receivingOptions = receivingContext.options;
                    if (initialContext === receivingContext ||
                        (receivingOptions.editable && receivingOptions.droppable)) {
                        mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);
                        if (mutation) {
                            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
                            interaction.mutatedEvents = mutatedRelevantEvents;
                            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
                                isInvalid = true;
                                mutation = null;
                                mutatedRelevantEvents = null;
                                interaction.mutatedEvents = createEmptyEventStore();
                            }
                        }
                    }
                    else {
                        receivingContext = null;
                    }
                }
                _this.displayDrag(receivingContext, interaction);
                if (!isInvalid) {
                    enableCursor();
                }
                else {
                    disableCursor();
                }
                if (!isFinal) {
                    if (initialContext === receivingContext && // TODO: write test for this
                        isHitsEqual(initialHit, hit)) {
                        mutation = null;
                    }
                    _this.dragging.setMirrorNeedsRevert(!mutation);
                    // render the mirror if no already-rendered mirror
                    // TODO: wish we could somehow wait for dispatch to guarantee render
                    _this.dragging.setMirrorIsVisible(!hit || !getElRoot(_this.subjectEl).querySelector('.fc-event-mirror'));
                    // assign states based on new hit
                    _this.receivingContext = receivingContext;
                    _this.validMutation = mutation;
                    _this.mutatedRelevantEvents = mutatedRelevantEvents;
                }
            };
            _this.handlePointerUp = function () {
                if (!_this.isDragging) {
                    _this.cleanup(); // because handleDragEnd won't fire
                }
            };
            _this.handleDragEnd = function (ev) {
                if (_this.isDragging) {
                    var initialContext_1 = _this.component.context;
                    var initialView = initialContext_1.viewApi;
                    var _a = _this, receivingContext_1 = _a.receivingContext, validMutation = _a.validMutation;
                    var eventDef = _this.eventRange.def;
                    var eventInstance = _this.eventRange.instance;
                    var eventApi = new EventApi(initialContext_1, eventDef, eventInstance);
                    var relevantEvents_1 = _this.relevantEvents;
                    var mutatedRelevantEvents_1 = _this.mutatedRelevantEvents;
                    var finalHit = _this.hitDragging.finalHit;
                    _this.clearDrag(); // must happen after revert animation
                    initialContext_1.emitter.trigger('eventDragStop', {
                        el: _this.subjectEl,
                        event: eventApi,
                        jsEvent: ev.origEvent,
                        view: initialView,
                    });
                    if (validMutation) {
                        // dropped within same calendar
                        if (receivingContext_1 === initialContext_1) {
                            var updatedEventApi = new EventApi(initialContext_1, mutatedRelevantEvents_1.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents_1.instances[eventInstance.instanceId] : null);
                            initialContext_1.dispatch({
                                type: 'MERGE_EVENTS',
                                eventStore: mutatedRelevantEvents_1,
                            });
                            var eventChangeArg = {
                                oldEvent: eventApi,
                                event: updatedEventApi,
                                relatedEvents: buildEventApis(mutatedRelevantEvents_1, initialContext_1, eventInstance),
                                revert: function () {
                                    initialContext_1.dispatch({
                                        type: 'MERGE_EVENTS',
                                        eventStore: relevantEvents_1, // the pre-change data
                                    });
                                },
                            };
                            var transformed = {};
                            for (var _i = 0, _b = initialContext_1.getCurrentData().pluginHooks.eventDropTransformers; _i < _b.length; _i++) {
                                var transformer = _b[_i];
                                __assign(transformed, transformer(validMutation, initialContext_1));
                            }
                            initialContext_1.emitter.trigger('eventDrop', __assign(__assign(__assign({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));
                            initialContext_1.emitter.trigger('eventChange', eventChangeArg);
                            // dropped in different calendar
                        }
                        else if (receivingContext_1) {
                            var eventRemoveArg = {
                                event: eventApi,
                                relatedEvents: buildEventApis(relevantEvents_1, initialContext_1, eventInstance),
                                revert: function () {
                                    initialContext_1.dispatch({
                                        type: 'MERGE_EVENTS',
                                        eventStore: relevantEvents_1,
                                    });
                                },
                            };
                            initialContext_1.emitter.trigger('eventLeave', __assign(__assign({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));
                            initialContext_1.dispatch({
                                type: 'REMOVE_EVENTS',
                                eventStore: relevantEvents_1,
                            });
                            initialContext_1.emitter.trigger('eventRemove', eventRemoveArg);
                            var addedEventDef = mutatedRelevantEvents_1.defs[eventDef.defId];
                            var addedEventInstance = mutatedRelevantEvents_1.instances[eventInstance.instanceId];
                            var addedEventApi = new EventApi(receivingContext_1, addedEventDef, addedEventInstance);
                            receivingContext_1.dispatch({
                                type: 'MERGE_EVENTS',
                                eventStore: mutatedRelevantEvents_1,
                            });
                            var eventAddArg = {
                                event: addedEventApi,
                                relatedEvents: buildEventApis(mutatedRelevantEvents_1, receivingContext_1, addedEventInstance),
                                revert: function () {
                                    receivingContext_1.dispatch({
                                        type: 'REMOVE_EVENTS',
                                        eventStore: mutatedRelevantEvents_1,
                                    });
                                },
                            };
                            receivingContext_1.emitter.trigger('eventAdd', eventAddArg);
                            if (ev.isTouch) {
                                receivingContext_1.dispatch({
                                    type: 'SELECT_EVENT',
                                    eventInstanceId: eventInstance.instanceId,
                                });
                            }
                            receivingContext_1.emitter.trigger('drop', __assign(__assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext_1)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.context.viewApi }));
                            receivingContext_1.emitter.trigger('eventReceive', __assign(__assign({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.context.viewApi }));
                        }
                    }
                    else {
                        initialContext_1.emitter.trigger('_noEventDrop');
                    }
                }
                _this.cleanup();
            };
            var component = _this.component;
            var options = component.context.options;
            var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);
            dragging.pointer.selector = EventDragging.SELECTOR;
            dragging.touchScrollAllowed = false;
            dragging.autoScroller.isEnabled = options.dragScroll;
            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsStore);
            hitDragging.useSubjectCenter = settings.useEventCenter;
            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
            hitDragging.emitter.on('dragstart', _this.handleDragStart);
            hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
            hitDragging.emitter.on('pointerup', _this.handlePointerUp);
            hitDragging.emitter.on('dragend', _this.handleDragEnd);
            return _this;
        }
        EventDragging.prototype.destroy = function () {
            this.dragging.destroy();
        };
        // render a drag state on the next receivingCalendar
        EventDragging.prototype.displayDrag = function (nextContext, state) {
            var initialContext = this.component.context;
            var prevContext = this.receivingContext;
            // does the previous calendar need to be cleared?
            if (prevContext && prevContext !== nextContext) {
                // does the initial calendar need to be cleared?
                // if so, don't clear all the way. we still need to to hide the affectedEvents
                if (prevContext === initialContext) {
                    prevContext.dispatch({
                        type: 'SET_EVENT_DRAG',
                        state: {
                            affectedEvents: state.affectedEvents,
                            mutatedEvents: createEmptyEventStore(),
                            isEvent: true,
                        },
                    });
                    // completely clear the old calendar if it wasn't the initial
                }
                else {
                    prevContext.dispatch({ type: 'UNSET_EVENT_DRAG' });
                }
            }
            if (nextContext) {
                nextContext.dispatch({ type: 'SET_EVENT_DRAG', state: state });
            }
        };
        EventDragging.prototype.clearDrag = function () {
            var initialCalendar = this.component.context;
            var receivingContext = this.receivingContext;
            if (receivingContext) {
                receivingContext.dispatch({ type: 'UNSET_EVENT_DRAG' });
            }
            // the initial calendar might have an dummy drag state from displayDrag
            if (initialCalendar !== receivingContext) {
                initialCalendar.dispatch({ type: 'UNSET_EVENT_DRAG' });
            }
        };
        EventDragging.prototype.cleanup = function () {
            this.subjectSeg = null;
            this.isDragging = false;
            this.eventRange = null;
            this.relevantEvents = null;
            this.receivingContext = null;
            this.validMutation = null;
            this.mutatedRelevantEvents = null;
        };
        // TODO: test this in IE11
        // QUESTION: why do we need it on the resizable???
        EventDragging.SELECTOR = '.fc-event-draggable, .fc-event-resizable';
        return EventDragging;
    }(Interaction));
    function computeEventMutation(hit0, hit1, massagers) {
        var dateSpan0 = hit0.dateSpan;
        var dateSpan1 = hit1.dateSpan;
        var date0 = dateSpan0.range.start;
        var date1 = dateSpan1.range.start;
        var standardProps = {};
        if (dateSpan0.allDay !== dateSpan1.allDay) {
            standardProps.allDay = dateSpan1.allDay;
            standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;
            if (dateSpan1.allDay) {
                // means date1 is already start-of-day,
                // but date0 needs to be converted
                date0 = startOfDay$1(date0);
            }
        }
        var delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ?
            hit0.largeUnit :
            null);
        if (delta.milliseconds) { // has hours/minutes/seconds
            standardProps.allDay = false;
        }
        var mutation = {
            datesDelta: delta,
            standardProps: standardProps,
        };
        for (var _i = 0, massagers_1 = massagers; _i < massagers_1.length; _i++) {
            var massager = massagers_1[_i];
            massager(mutation, hit0, hit1);
        }
        return mutation;
    }
    function getComponentTouchDelay(component) {
        var options = component.context.options;
        var delay = options.eventLongPressDelay;
        if (delay == null) {
            delay = options.longPressDelay;
        }
        return delay;
    }

    var EventResizing = /** @class */ (function (_super) {
        __extends(EventResizing, _super);
        function EventResizing(settings) {
            var _this = _super.call(this, settings) || this;
            // internal state
            _this.draggingSegEl = null;
            _this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?
            _this.eventRange = null;
            _this.relevantEvents = null;
            _this.validMutation = null;
            _this.mutatedRelevantEvents = null;
            _this.handlePointerDown = function (ev) {
                var component = _this.component;
                var segEl = _this.querySegEl(ev);
                var seg = getElSeg(segEl);
                var eventRange = _this.eventRange = seg.eventRange;
                _this.dragging.minDistance = component.context.options.eventDragMinDistance;
                // if touch, need to be working with a selected event
                _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target) ||
                    (ev.isTouch && _this.component.props.eventSelection !== eventRange.instance.instanceId));
            };
            _this.handleDragStart = function (ev) {
                var context = _this.component.context;
                var eventRange = _this.eventRange;
                _this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, _this.eventRange.instance.instanceId);
                var segEl = _this.querySegEl(ev);
                _this.draggingSegEl = segEl;
                _this.draggingSeg = getElSeg(segEl);
                context.calendarApi.unselect();
                context.emitter.trigger('eventResizeStart', {
                    el: segEl,
                    event: new EventApi(context, eventRange.def, eventRange.instance),
                    jsEvent: ev.origEvent,
                    view: context.viewApi,
                });
            };
            _this.handleHitUpdate = function (hit, isFinal, ev) {
                var context = _this.component.context;
                var relevantEvents = _this.relevantEvents;
                var initialHit = _this.hitDragging.initialHit;
                var eventInstance = _this.eventRange.instance;
                var mutation = null;
                var mutatedRelevantEvents = null;
                var isInvalid = false;
                var interaction = {
                    affectedEvents: relevantEvents,
                    mutatedEvents: createEmptyEventStore(),
                    isEvent: true,
                };
                if (hit) {
                    var disallowed = hit.componentId === initialHit.componentId
                        && _this.isHitComboAllowed
                        && !_this.isHitComboAllowed(initialHit, hit);
                    if (!disallowed) {
                        mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-event-resizer-start'), eventInstance.range);
                    }
                }
                if (mutation) {
                    mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);
                    interaction.mutatedEvents = mutatedRelevantEvents;
                    if (!isInteractionValid(interaction, hit.dateProfile, context)) {
                        isInvalid = true;
                        mutation = null;
                        mutatedRelevantEvents = null;
                        interaction.mutatedEvents = null;
                    }
                }
                if (mutatedRelevantEvents) {
                    context.dispatch({
                        type: 'SET_EVENT_RESIZE',
                        state: interaction,
                    });
                }
                else {
                    context.dispatch({ type: 'UNSET_EVENT_RESIZE' });
                }
                if (!isInvalid) {
                    enableCursor();
                }
                else {
                    disableCursor();
                }
                if (!isFinal) {
                    if (mutation && isHitsEqual(initialHit, hit)) {
                        mutation = null;
                    }
                    _this.validMutation = mutation;
                    _this.mutatedRelevantEvents = mutatedRelevantEvents;
                }
            };
            _this.handleDragEnd = function (ev) {
                var context = _this.component.context;
                var eventDef = _this.eventRange.def;
                var eventInstance = _this.eventRange.instance;
                var eventApi = new EventApi(context, eventDef, eventInstance);
                var relevantEvents = _this.relevantEvents;
                var mutatedRelevantEvents = _this.mutatedRelevantEvents;
                context.emitter.trigger('eventResizeStop', {
                    el: _this.draggingSegEl,
                    event: eventApi,
                    jsEvent: ev.origEvent,
                    view: context.viewApi,
                });
                if (_this.validMutation) {
                    var updatedEventApi = new EventApi(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
                    context.dispatch({
                        type: 'MERGE_EVENTS',
                        eventStore: mutatedRelevantEvents,
                    });
                    var eventChangeArg = {
                        oldEvent: eventApi,
                        event: updatedEventApi,
                        relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),
                        revert: function () {
                            context.dispatch({
                                type: 'MERGE_EVENTS',
                                eventStore: relevantEvents, // the pre-change events
                            });
                        },
                    };
                    context.emitter.trigger('eventResize', __assign(__assign({}, eventChangeArg), { el: _this.draggingSegEl, startDelta: _this.validMutation.startDelta || createDuration(0), endDelta: _this.validMutation.endDelta || createDuration(0), jsEvent: ev.origEvent, view: context.viewApi }));
                    context.emitter.trigger('eventChange', eventChangeArg);
                }
                else {
                    context.emitter.trigger('_noEventResize');
                }
                // reset all internal state
                _this.draggingSeg = null;
                _this.relevantEvents = null;
                _this.validMutation = null;
                // okay to keep eventInstance around. useful to set it in handlePointerDown
            };
            var component = settings.component;
            var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);
            dragging.pointer.selector = '.fc-event-resizer';
            dragging.touchScrollAllowed = false;
            dragging.autoScroller.isEnabled = component.context.options.dragScroll;
            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsToStore(settings));
            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);
            hitDragging.emitter.on('dragstart', _this.handleDragStart);
            hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);
            hitDragging.emitter.on('dragend', _this.handleDragEnd);
            return _this;
        }
        EventResizing.prototype.destroy = function () {
            this.dragging.destroy();
        };
        EventResizing.prototype.querySegEl = function (ev) {
            return elementClosest(ev.subjectEl, '.fc-event');
        };
        return EventResizing;
    }(Interaction));
    function computeMutation(hit0, hit1, isFromStart, instanceRange) {
        var dateEnv = hit0.context.dateEnv;
        var date0 = hit0.dateSpan.range.start;
        var date1 = hit1.dateSpan.range.start;
        var delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);
        if (isFromStart) {
            if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
                return { startDelta: delta };
            }
        }
        else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
            return { endDelta: delta };
        }
        return null;
    }

    var UnselectAuto = /** @class */ (function () {
        function UnselectAuto(context) {
            var _this = this;
            this.context = context;
            this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system
            this.matchesCancel = false;
            this.matchesEvent = false;
            this.onSelect = function (selectInfo) {
                if (selectInfo.jsEvent) {
                    _this.isRecentPointerDateSelect = true;
                }
            };
            this.onDocumentPointerDown = function (pev) {
                var unselectCancel = _this.context.options.unselectCancel;
                var downEl = getEventTargetViaRoot(pev.origEvent);
                _this.matchesCancel = !!elementClosest(downEl, unselectCancel);
                _this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR); // interaction started on an event?
            };
            this.onDocumentPointerUp = function (pev) {
                var context = _this.context;
                var documentPointer = _this.documentPointer;
                var calendarState = context.getCurrentData();
                // touch-scrolling should never unfocus any type of selection
                if (!documentPointer.wasTouchScroll) {
                    if (calendarState.dateSelection && // an existing date selection?
                        !_this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?
                    ) {
                        var unselectAuto = context.options.unselectAuto;
                        if (unselectAuto && (!unselectAuto || !_this.matchesCancel)) {
                            context.calendarApi.unselect(pev);
                        }
                    }
                    if (calendarState.eventSelection && // an existing event selected?
                        !_this.matchesEvent // interaction DIDN'T start on an event
                    ) {
                        context.dispatch({ type: 'UNSELECT_EVENT' });
                    }
                }
                _this.isRecentPointerDateSelect = false;
            };
            var documentPointer = this.documentPointer = new PointerDragging(document);
            documentPointer.shouldIgnoreMove = true;
            documentPointer.shouldWatchScroll = false;
            documentPointer.emitter.on('pointerdown', this.onDocumentPointerDown);
            documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);
            /*
            TODO: better way to know about whether there was a selection with the pointer
            */
            context.emitter.on('select', this.onSelect);
        }
        UnselectAuto.prototype.destroy = function () {
            this.context.emitter.off('select', this.onSelect);
            this.documentPointer.destroy();
        };
        return UnselectAuto;
    }());

    var OPTION_REFINERS = {
        fixedMirrorParent: identity$1,
    };
    var LISTENER_REFINERS = {
        dateClick: identity$1,
        eventDragStart: identity$1,
        eventDragStop: identity$1,
        eventDrop: identity$1,
        eventResizeStart: identity$1,
        eventResizeStop: identity$1,
        eventResize: identity$1,
        drop: identity$1,
        eventReceive: identity$1,
        eventLeave: identity$1,
    };
    config.dataAttrPrefix = '';

    /*
    Detects when a *THIRD-PARTY* drag-n-drop system interacts with elements.
    The third-party system is responsible for drawing the visuals effects of the drag.
    This class simply monitors for pointer movements and fires events.
    It also has the ability to hide the moving element (the "mirror") during the drag.
    */
    var InferredElementDragging = /** @class */ (function (_super) {
        __extends(InferredElementDragging, _super);
        function InferredElementDragging(containerEl) {
            var _this = _super.call(this, containerEl) || this;
            _this.shouldIgnoreMove = false;
            _this.mirrorSelector = '';
            _this.currentMirrorEl = null;
            _this.handlePointerDown = function (ev) {
                _this.emitter.trigger('pointerdown', ev);
                if (!_this.shouldIgnoreMove) {
                    // fire dragstart right away. does not support delay or min-distance
                    _this.emitter.trigger('dragstart', ev);
                }
            };
            _this.handlePointerMove = function (ev) {
                if (!_this.shouldIgnoreMove) {
                    _this.emitter.trigger('dragmove', ev);
                }
            };
            _this.handlePointerUp = function (ev) {
                _this.emitter.trigger('pointerup', ev);
                if (!_this.shouldIgnoreMove) {
                    // fire dragend right away. does not support a revert animation
                    _this.emitter.trigger('dragend', ev);
                }
            };
            var pointer = _this.pointer = new PointerDragging(containerEl);
            pointer.emitter.on('pointerdown', _this.handlePointerDown);
            pointer.emitter.on('pointermove', _this.handlePointerMove);
            pointer.emitter.on('pointerup', _this.handlePointerUp);
            return _this;
        }
        InferredElementDragging.prototype.destroy = function () {
            this.pointer.destroy();
        };
        InferredElementDragging.prototype.setIgnoreMove = function (bool) {
            this.shouldIgnoreMove = bool;
        };
        InferredElementDragging.prototype.setMirrorIsVisible = function (bool) {
            if (bool) {
                // restore a previously hidden element.
                // use the reference in case the selector class has already been removed.
                if (this.currentMirrorEl) {
                    this.currentMirrorEl.style.visibility = '';
                    this.currentMirrorEl = null;
                }
            }
            else {
                var mirrorEl = this.mirrorSelector
                    // TODO: somehow query FullCalendars WITHIN shadow-roots
                    ? document.querySelector(this.mirrorSelector)
                    : null;
                if (mirrorEl) {
                    this.currentMirrorEl = mirrorEl;
                    mirrorEl.style.visibility = 'hidden';
                }
            }
        };
        return InferredElementDragging;
    }(ElementDragging));

    var main$1 = createPlugin({
        componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],
        calendarInteractions: [UnselectAuto],
        elementDraggingImpl: FeaturefulElementDragging,
        optionRefiners: OPTION_REFINERS,
        listenerRefiners: LISTENER_REFINERS,
    });

    var es_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, '__esModule', { value: true });

    var es = {
      code: 'es',
      week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
      buttonText: {
        prev: 'Ant',
        next: 'Sig',
        today: 'Hoy',
        month: 'Mes',
        week: 'Semana',
        day: 'Da',
        list: 'Agenda',
      },
      buttonHints: {
        prev: '$0 antes',
        next: '$0 siguiente',
        today(buttonText) {
          return (buttonText === 'Da') ? 'Hoy' :
            ((buttonText === 'Semana') ? 'Esta' : 'Este') + ' ' + buttonText.toLocaleLowerCase()
        },
      },
      viewHint(buttonText) {
        return 'Vista ' + (buttonText === 'Semana' ? 'de la' : 'del') + ' ' + buttonText.toLocaleLowerCase()
      },
      weekText: 'Sm',
      weekTextLong: 'Semana',
      allDayText: 'Todo el da',
      moreLinkText: 'ms',
      moreLinkHint(eventCnt) {
        return `Mostrar ${eventCnt} eventos ms`
      },
      noEventsText: 'No hay eventos para mostrar',
      navLinkHint: 'Ir al $0',
      closeHint: 'Cerrar',
      timeHint: 'La hora',
      eventHint: 'Evento',
    };

    exports.default = es;
    });

    /* src\componentes\Modals\ModalCitaCalendario.svelte generated by Svelte v3.29.0 */

    const { console: console_1$l } = globals;
    const file$C = "src\\componentes\\Modals\\ModalCitaCalendario.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[32] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	return child_ctx;
    }

    // (233:20) {#if cargando}
    function create_if_block_4$5(ctx) {
    	let div;
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loading.$$.fragment);
    			attr_dev(div, "class", "cargando");
    			add_location(div, file$C, 233, 24, 7435);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loading, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(233:20) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    // (262:32) {#each pacientes as paciente}
    function create_each_block_2$5(ctx) {
    	let li;
    	let div;
    	let span;
    	let t0_value = /*paciente*/ ctx[15].cedula + "";
    	let t0;
    	let t1;
    	let t2_value = /*paciente*/ ctx[15].nombres + "";
    	let t2;
    	let t3;
    	let t4_value = /*paciente*/ ctx[15].apellidos + "";
    	let t4;
    	let t5;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[19](/*paciente*/ ctx[15], ...args);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			div = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(span, "class", "badge badge-primary");
    			add_location(span, file$C, 267, 45, 9270);
    			attr_dev(div, "class", "p-2");
    			add_location(div, file$C, 264, 41, 9117);
    			add_location(li, file$C, 263, 37, 9023);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div);
    			append_dev(div, span);
    			append_dev(span, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			append_dev(div, t4);
    			append_dev(li, t5);

    			if (!mounted) {
    				dispose = listen_dev(li, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*pacientes*/ 256 && t0_value !== (t0_value = /*paciente*/ ctx[15].cedula + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*pacientes*/ 256 && t2_value !== (t2_value = /*paciente*/ ctx[15].nombres + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*pacientes*/ 256 && t4_value !== (t4_value = /*paciente*/ ctx[15].apellidos + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$5.name,
    		type: "each",
    		source: "(262:32) {#each pacientes as paciente}",
    		ctx
    	});

    	return block;
    }

    // (317:32) {#each tandas as tanda}
    function create_each_block_1$6(ctx) {
    	let option;
    	let t_value = /*tanda*/ ctx[32].descripcion + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*tanda*/ ctx[32].id;
    			option.value = option.__value;
    			add_location(option, file$C, 317, 36, 11872);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*tandas*/ 1 && t_value !== (t_value = /*tanda*/ ctx[32].descripcion + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*tandas*/ 1 && option_value_value !== (option_value_value = /*tanda*/ ctx[32].id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(317:32) {#each tandas as tanda}",
    		ctx
    	});

    	return block;
    }

    // (336:20) {#if msgError}
    function create_if_block_3$5(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*msgError*/ ctx[4]);
    			attr_dev(div, "class", "alert alert-danger");
    			attr_dev(div, "role", "alert");
    			add_location(div, file$C, 336, 24, 12678);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*msgError*/ 16) set_data_dev(t, /*msgError*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(336:20) {#if msgError}",
    		ctx
    	});

    	return block;
    }

    // (353:36) {#if cita.estado === "R"}
    function create_if_block_2$b(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "icon mdi mdi-check-circle-outline");
    			add_location(i, file$C, 353, 40, 13502);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(353:36) {#if cita.estado === \\\"R\\\"}",
    		ctx
    	});

    	return block;
    }

    // (358:36) {#if cita.estado === "X"}
    function create_if_block_1$g(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "icon mdi mdi-alert-octagram");
    			add_location(i, file$C, 358, 40, 13783);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(358:36) {#if cita.estado === \\\"X\\\"}",
    		ctx
    	});

    	return block;
    }

    // (363:36) {#if cita.estado === "N"}
    function create_if_block$o(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "icon mdi mdi-alert-circle-outline");
    			add_location(i, file$C, 363, 40, 14058);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(363:36) {#if cita.estado === \\\"N\\\"}",
    		ctx
    	});

    	return block;
    }

    // (343:20) {#each citas as cita}
    function create_each_block$h(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let t0;
    	let t1;
    	let t2;
    	let div4;
    	let div3;
    	let div1;
    	let span0;
    	let t3_value = new Date(/*cita*/ ctx[29].fechaCita).getDate() + 1 + "";
    	let t3;
    	let t4;
    	let span1;
    	let t5_value = /*meses*/ ctx[10][new Date(/*cita*/ ctx[29].fechaCita).getMonth()] + "";
    	let t5;
    	let t6;
    	let span2;
    	let t7_value = new Date(/*cita*/ ctx[29].fechaCita).getFullYear() + "";
    	let t7;
    	let t8;
    	let div2;
    	let t9_value = /*cita*/ ctx[29].observaciones + "";
    	let t9;
    	let t10;
    	let if_block0 = /*cita*/ ctx[29].estado === "R" && create_if_block_2$b(ctx);
    	let if_block1 = /*cita*/ ctx[29].estado === "X" && create_if_block_1$g(ctx);
    	let if_block2 = /*cita*/ ctx[29].estado === "N" && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			span0 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			span1 = element("span");
    			t5 = text(t5_value);
    			t6 = space();
    			span2 = element("span");
    			t7 = text(t7_value);
    			t8 = space();
    			div2 = element("div");
    			t9 = text(t9_value);
    			t10 = space();
    			attr_dev(div0, "class", "icon");
    			add_location(div0, file$C, 351, 32, 13379);
    			attr_dev(span0, "class", "svelte-qxlgux");
    			add_location(span0, file$C, 371, 44, 14496);
    			attr_dev(span1, "class", "svelte-qxlgux");
    			add_location(span1, file$C, 376, 44, 14795);
    			attr_dev(span2, "class", "svelte-qxlgux");
    			add_location(span2, file$C, 383, 44, 15210);
    			attr_dev(div1, "class", "fecha svelte-qxlgux");
    			add_location(div1, file$C, 370, 40, 14431);
    			attr_dev(div2, "class", "observaciones svelte-qxlgux");
    			add_location(div2, file$C, 389, 40, 15553);
    			attr_dev(div3, "class", "calendar svelte-qxlgux");
    			add_location(div3, file$C, 369, 36, 14367);
    			attr_dev(div4, "class", "content");
    			add_location(div4, file$C, 368, 32, 14308);
    			attr_dev(div5, "class", "d-flex");
    			add_location(div5, file$C, 350, 28, 13325);
    			attr_dev(div6, "class", "alert alert-dismissible fade show");
    			attr_dev(div6, "role", "alert");
    			toggle_class(div6, "alert-border-success", /*cita*/ ctx[29].estado === "R");
    			toggle_class(div6, "alert-border-danger", /*cita*/ ctx[29].estado === "X");
    			toggle_class(div6, "alert-border-info", /*cita*/ ctx[29].estado === "N");
    			add_location(div6, file$C, 343, 24, 12921);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div0, t1);
    			if (if_block2) if_block2.m(div0, null);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, span0);
    			append_dev(span0, t3);
    			append_dev(div1, t4);
    			append_dev(div1, span1);
    			append_dev(span1, t5);
    			append_dev(div1, t6);
    			append_dev(div1, span2);
    			append_dev(span2, t7);
    			append_dev(div3, t8);
    			append_dev(div3, div2);
    			append_dev(div2, t9);
    			append_dev(div6, t10);
    		},
    		p: function update(ctx, dirty) {
    			if (/*cita*/ ctx[29].estado === "R") {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_2$b(ctx);
    					if_block0.c();
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*cita*/ ctx[29].estado === "X") {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$g(ctx);
    					if_block1.c();
    					if_block1.m(div0, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*cita*/ ctx[29].estado === "N") {
    				if (if_block2) ; else {
    					if_block2 = create_if_block$o(ctx);
    					if_block2.c();
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty[0] & /*citas*/ 2 && t3_value !== (t3_value = new Date(/*cita*/ ctx[29].fechaCita).getDate() + 1 + "")) set_data_dev(t3, t3_value);
    			if (dirty[0] & /*citas*/ 2 && t5_value !== (t5_value = /*meses*/ ctx[10][new Date(/*cita*/ ctx[29].fechaCita).getMonth()] + "")) set_data_dev(t5, t5_value);
    			if (dirty[0] & /*citas*/ 2 && t7_value !== (t7_value = new Date(/*cita*/ ctx[29].fechaCita).getFullYear() + "")) set_data_dev(t7, t7_value);
    			if (dirty[0] & /*citas*/ 2 && t9_value !== (t9_value = /*cita*/ ctx[29].observaciones + "")) set_data_dev(t9, t9_value);

    			if (dirty[0] & /*citas*/ 2) {
    				toggle_class(div6, "alert-border-success", /*cita*/ ctx[29].estado === "R");
    			}

    			if (dirty[0] & /*citas*/ 2) {
    				toggle_class(div6, "alert-border-danger", /*cita*/ ctx[29].estado === "X");
    			}

    			if (dirty[0] & /*citas*/ 2) {
    				toggle_class(div6, "alert-border-info", /*cita*/ ctx[29].estado === "N");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(343:20) {#each citas as cita}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let form;
    	let div16;
    	let div15;
    	let div14;
    	let div0;
    	let h5;
    	let span0;
    	let t1;
    	let button0;
    	let span1;
    	let t3;
    	let div7;
    	let t4;
    	let div6;
    	let div2;
    	let label0;
    	let t6;
    	let input0;
    	let t7;
    	let ul;
    	let div1;
    	let t8;
    	let div3;
    	let label1;
    	let t10;
    	let input1;
    	let t11;
    	let div4;
    	let label2;
    	let t13;
    	let select;
    	let option;
    	let t15;
    	let div5;
    	let label3;
    	let t17;
    	let textarea;
    	let t18;
    	let t19;
    	let br;
    	let t20;
    	let t21;
    	let div13;
    	let div12;
    	let div9;
    	let a;
    	let h30;
    	let t22;
    	let div8;
    	let t24;
    	let div11;
    	let button1;
    	let h31;
    	let t25;
    	let div10;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*cargando*/ ctx[6] && create_if_block_4$5(ctx);
    	let each_value_2 = /*pacientes*/ ctx[8];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$5(get_each_context_2$5(ctx, each_value_2, i));
    	}

    	let each_value_1 = /*tandas*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	let if_block1 = /*msgError*/ ctx[4] && create_if_block_3$5(ctx);
    	let each_value = /*citas*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			form = element("form");
    			div16 = element("div");
    			div15 = element("div");
    			div14 = element("div");
    			div0 = element("div");
    			h5 = element("h5");
    			span0 = element("span");
    			span0.textContent = "Citas";
    			t1 = space();
    			button0 = element("button");
    			span1 = element("span");
    			span1.textContent = "";
    			t3 = space();
    			div7 = element("div");
    			if (if_block0) if_block0.c();
    			t4 = space();
    			div6 = element("div");
    			div2 = element("div");
    			label0 = element("label");
    			label0.textContent = "Buscar paciente";
    			t6 = space();
    			input0 = element("input");
    			t7 = space();
    			ul = element("ul");
    			div1 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t8 = space();
    			div3 = element("div");
    			label1 = element("label");
    			label1.textContent = "Fecha de la cita";
    			t10 = space();
    			input1 = element("input");
    			t11 = space();
    			div4 = element("div");
    			label2 = element("label");
    			label2.textContent = "Tanda";
    			t13 = space();
    			select = element("select");
    			option = element("option");
    			option.textContent = "- seleccionar tanda -\r\n                                ";

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t15 = space();
    			div5 = element("div");
    			label3 = element("label");
    			label3.textContent = "Observaciones";
    			t17 = space();
    			textarea = element("textarea");
    			t18 = space();
    			if (if_block1) if_block1.c();
    			t19 = space();
    			br = element("br");
    			t20 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t21 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div9 = element("div");
    			a = element("a");
    			h30 = element("h3");
    			t22 = space();
    			div8 = element("div");
    			div8.textContent = "Cerrar";
    			t24 = space();
    			div11 = element("div");
    			button1 = element("button");
    			h31 = element("h3");
    			t25 = space();
    			div10 = element("div");
    			div10.textContent = "Crear";
    			attr_dev(span0, "class", "badge bg-primary text-white");
    			add_location(span0, file$C, 220, 24, 6916);
    			attr_dev(h5, "class", "modal-title");
    			attr_dev(h5, "id", "modalInterconsulta");
    			add_location(h5, file$C, 219, 20, 6842);
    			attr_dev(span1, "aria-hidden", "true");
    			add_location(span1, file$C, 228, 24, 7243);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "close");
    			attr_dev(button0, "data-dismiss", "modal");
    			attr_dev(button0, "aria-label", "Close");
    			add_location(button0, file$C, 222, 20, 7019);
    			attr_dev(div0, "class", "modal-header");
    			add_location(div0, file$C, 218, 16, 6794);
    			attr_dev(label0, "for", "");
    			attr_dev(label0, "class", "text-primary");
    			add_location(label0, file$C, 242, 24, 7812);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "id", "txtBusquedaProblemaMedico");
    			attr_dev(input0, "data-toggle", "dropdown");
    			attr_dev(input0, "aria-haspopup", "true");
    			attr_dev(input0, "aria-expanded", "true");
    			attr_dev(input0, "autocomplete", "off");
    			add_location(input0, file$C, 243, 24, 7896);
    			attr_dev(div1, "class", "contenidoLista");
    			add_location(div1, file$C, 260, 28, 8833);
    			attr_dev(ul, "class", "lista-buscador dropdown-menu");
    			attr_dev(ul, "id", "buscador");
    			attr_dev(ul, "x-placement", "top-start");
    			set_style(ul, "position", "absolute");
    			set_style(ul, "will-change", "transform");
    			set_style(ul, "top", "0px");
    			set_style(ul, "left", "0px");
    			set_style(ul, "transform", "translate3d(0px, -128px, 0px)");
    			set_style(ul, "border-radius", "5px");
    			add_location(ul, file$C, 254, 24, 8447);
    			attr_dev(div2, "class", "form-group buscardor dropdown dropdown-vnc");
    			set_style(div2, "width", "100%");
    			add_location(div2, file$C, 238, 24, 7626);
    			attr_dev(label1, "for", "");
    			attr_dev(label1, "class", "text-primary");
    			add_location(label1, file$C, 295, 28, 10795);
    			attr_dev(input1, "type", "date");
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "min", /*fechaMinima*/ ctx[9]);
    			input1.required = true;
    			add_location(input1, file$C, 298, 28, 10948);
    			attr_dev(div3, "class", "form-group col-md-12");
    			add_location(div3, file$C, 294, 24, 10731);
    			attr_dev(label2, "for", "");
    			attr_dev(label2, "class", "text-primary");
    			add_location(label2, file$C, 307, 28, 11356);
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$C, 313, 32, 11658);
    			attr_dev(select, "class", "form-control");
    			select.required = true;
    			if (/*tandaCita*/ ctx[3] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[21].call(select));
    			add_location(select, file$C, 308, 28, 11434);
    			attr_dev(div4, "class", "form-group col-md-12");
    			add_location(div4, file$C, 306, 24, 11292);
    			attr_dev(label3, "for", "");
    			attr_dev(label3, "class", "text-primary");
    			add_location(label3, file$C, 324, 28, 12207);
    			attr_dev(textarea, "class", "form-control");
    			attr_dev(textarea, "rows", "3");
    			add_location(textarea, file$C, 327, 28, 12357);
    			attr_dev(div5, "class", "form-group col-md-12");
    			add_location(div5, file$C, 323, 24, 12143);
    			attr_dev(div6, "class", "form-row");
    			add_location(div6, file$C, 237, 20, 7578);
    			add_location(br, file$C, 340, 20, 12844);
    			attr_dev(div7, "class", "modal-body");
    			add_location(div7, file$C, 231, 16, 7349);
    			attr_dev(h30, "class", "mdi mdi-close-outline");
    			add_location(h30, file$C, 407, 32, 16367);
    			attr_dev(div8, "class", "text-overline");
    			add_location(div8, file$C, 408, 32, 16437);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "text-danger");
    			attr_dev(a, "data-dismiss", "modal");
    			add_location(a, file$C, 401, 28, 16074);
    			attr_dev(div9, "class", "col");
    			add_location(div9, file$C, 400, 24, 16027);
    			attr_dev(h31, "class", "mdi mdi-send");
    			add_location(h31, file$C, 417, 32, 16904);
    			attr_dev(div10, "class", "text-overline");
    			add_location(div10, file$C, 418, 32, 16965);
    			attr_dev(button1, "class", "text-success");
    			set_style(button1, "border", "none");
    			set_style(button1, "background-color", "transparent");
    			add_location(button1, file$C, 412, 28, 16615);
    			attr_dev(div11, "class", "col");
    			add_location(div11, file$C, 411, 24, 16568);
    			attr_dev(div12, "class", "row text-center p-b-10");
    			add_location(div12, file$C, 399, 20, 15965);
    			attr_dev(div13, "class", "modal-footer");
    			add_location(div13, file$C, 398, 16, 15917);
    			attr_dev(div14, "class", "modal-content");
    			add_location(div14, file$C, 217, 12, 6749);
    			attr_dev(div15, "class", "modal-dialog");
    			attr_dev(div15, "role", "document");
    			add_location(div15, file$C, 216, 8, 6693);
    			attr_dev(div16, "class", "modal fade modal-slide-right");
    			attr_dev(div16, "id", "modalCitaCalendario");
    			attr_dev(div16, "tabindex", "-1");
    			attr_dev(div16, "role", "dialog");
    			attr_dev(div16, "aria-labelledby", "modalInterconsulta");
    			set_style(div16, "display", "none");
    			set_style(div16, "padding-right", "16px");
    			attr_dev(div16, "aria-modal", "true");
    			add_location(div16, file$C, 207, 4, 6420);
    			attr_dev(form, "class", "col-md-12");
    			add_location(form, file$C, 206, 0, 6345);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div16);
    			append_dev(div16, div15);
    			append_dev(div15, div14);
    			append_dev(div14, div0);
    			append_dev(div0, h5);
    			append_dev(h5, span0);
    			append_dev(div0, t1);
    			append_dev(div0, button0);
    			append_dev(button0, span1);
    			append_dev(div14, t3);
    			append_dev(div14, div7);
    			if (if_block0) if_block0.m(div7, null);
    			append_dev(div7, t4);
    			append_dev(div7, div6);
    			append_dev(div6, div2);
    			append_dev(div2, label0);
    			append_dev(div2, t6);
    			append_dev(div2, input0);
    			set_input_value(input0, /*sltBuscarPacientes*/ ctx[7]);
    			append_dev(div2, t7);
    			append_dev(div2, ul);
    			append_dev(ul, div1);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div1, null);
    			}

    			append_dev(div6, t8);
    			append_dev(div6, div3);
    			append_dev(div3, label1);
    			append_dev(div3, t10);
    			append_dev(div3, input1);
    			set_input_value(input1, /*fechaCita*/ ctx[2]);
    			append_dev(div6, t11);
    			append_dev(div6, div4);
    			append_dev(div4, label2);
    			append_dev(div4, t13);
    			append_dev(div4, select);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select, null);
    			}

    			select_option(select, /*tandaCita*/ ctx[3]);
    			append_dev(div6, t15);
    			append_dev(div6, div5);
    			append_dev(div5, label3);
    			append_dev(div5, t17);
    			append_dev(div5, textarea);
    			set_input_value(textarea, /*observaciones*/ ctx[5]);
    			append_dev(div7, t18);
    			if (if_block1) if_block1.m(div7, null);
    			append_dev(div7, t19);
    			append_dev(div7, br);
    			append_dev(div7, t20);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div7, null);
    			}

    			append_dev(div14, t21);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div9);
    			append_dev(div9, a);
    			append_dev(a, h30);
    			append_dev(a, t22);
    			append_dev(a, div8);
    			append_dev(div12, t24);
    			append_dev(div12, div11);
    			append_dev(div11, button1);
    			append_dev(button1, h31);
    			append_dev(button1, t25);
    			append_dev(button1, div10);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[17]),
    					listen_dev(input0, "input", /*input_handler*/ ctx[18], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[20]),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[21]),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[22]),
    					listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[23]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*cargando*/ ctx[6]) {
    				if (if_block0) {
    					if (dirty[0] & /*cargando*/ 64) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div7, t4);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*sltBuscarPacientes*/ 128 && input0.value !== /*sltBuscarPacientes*/ ctx[7]) {
    				set_input_value(input0, /*sltBuscarPacientes*/ ctx[7]);
    			}

    			if (dirty[0] & /*seleccionarPaciente, pacientes*/ 4352) {
    				each_value_2 = /*pacientes*/ ctx[8];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$5(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2$5(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (dirty[0] & /*fechaCita*/ 4) {
    				set_input_value(input1, /*fechaCita*/ ctx[2]);
    			}

    			if (dirty[0] & /*tandas*/ 1) {
    				each_value_1 = /*tandas*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$6(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty[0] & /*tandaCita, tandas*/ 9) {
    				select_option(select, /*tandaCita*/ ctx[3]);
    			}

    			if (dirty[0] & /*observaciones*/ 32) {
    				set_input_value(textarea, /*observaciones*/ ctx[5]);
    			}

    			if (/*msgError*/ ctx[4]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$5(ctx);
    					if_block1.c();
    					if_block1.m(div7, t19);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*citas, meses*/ 1026) {
    				each_value = /*citas*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div7, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ModalCitaCalendario", slots, []);
    	let fechaMinima = new Date().toISOString().split("T")[0];
    	let { dateStr } = $$props;
    	const dispatch = createEventDispatcher();
    	let pacienteSeleccionado = {};
    	let tandas = [];
    	let citas = [];
    	let fechaCita = dateStr;
    	let tandaCita = "";
    	let msgError = "";
    	let observaciones = "";

    	let meses = {
    		0: "Enero",
    		1: "Febrero",
    		2: "Marzo",
    		3: "Abril",
    		4: "Mayo",
    		5: "Junio",
    		6: "Julio",
    		7: "Agosto",
    		8: "Septiembre",
    		9: "Octubre",
    		10: "Noviembre",
    		11: "Diciembre"
    	};

    	let cargando = false;
    	let tiempoCita = "";
    	let sltBuscarPacientes = "";
    	let pacientes = [];
    	let timeout = null;
    	let paciente = {};

    	const seleccionarPaciente = paciente => {
    		$$invalidate(24, pacienteSeleccionado = pacientes.filter(p => p.id == paciente.id)[0]);
    		$$invalidate(7, sltBuscarPacientes = paciente.nombres + " " + paciente.apellidos);
    	};

    	function cargarPacientes() {
    		const config = {
    			method: "get",
    			url: `${url}/pacientes?b=${sltBuscarPacientes}`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		try {
    			axios$1(config).then(res => {
    				if (res.status === 200) {
    					let { data } = res;
    					$$invalidate(8, pacientes = data);
    				}

    				if (res.status === 500) {
    					errorServer = true;
    				}
    			}).catch(err => {
    				console.error(err);

    				if (err) {
    					errorServer = true;
    				}
    			});
    		} catch(error) {
    			if (error) {
    				errorServer = true;
    			}
    		}
    	}

    	const cargarCitasPorPaciente = () => {
    		const config = {
    			method: "get",
    			url: `${url}/citas/paciente/${pacienteSeleccionado.id}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(1, citas = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarTandas = () => {
    		const config = {
    			method: "get",
    			url: `${url}/tandas`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(0, tandas = res.data);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const crearCita = () => {
    		$$invalidate(6, cargando = true);
    		$$invalidate(4, msgError = "");

    		const data = {
    			fechaCita,
    			tanda: tandaCita,
    			observaciones,
    			paciente: {
    				id: pacienteSeleccionado.id,
    				nombres: pacienteSeleccionado.nombres,
    				apellidos: pacienteSeleccionado.apellidos,
    				sexo: pacienteSeleccionado.sexo,
    				fechaNacimiento: pacienteSeleccionado.fechaNacimiento,
    				telefono: pacienteSeleccionado.telefono,
    				cedula: pacienteSeleccionado.cedula,
    				celular: pacienteSeleccionado.celular
    			}
    		};

    		const config = {
    			method: "post",
    			url: `${url}/citas`,
    			data,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		if (!fechaCita || !tandaCita || !observaciones) {
    			return $$invalidate(4, msgError = "Algunos campos estan vacios");
    		}

    		axios$1(config).then(res => {
    			$$invalidate(6, cargando = false);

    			if (res.status === 200) {
    				$$invalidate(2, fechaCita = "");
    				$$invalidate(3, tandaCita = "");
    				$$invalidate(5, observaciones = "");
    				dispatch("cargarCitasPorMes");
    				dispatch("cargarCitas");
    				location.reload();
    			}
    		}).catch(err => {
    			$$invalidate(2, fechaCita = "");
    			$$invalidate(3, tandaCita = "");
    			$$invalidate(5, observaciones = "");
    			$$invalidate(25, tiempoCita = "");
    			$$invalidate(6, cargando = false);

    			if (err) {
    				$$invalidate(4, msgError = "Ocurrio un error al registrar la cita, intentalo de nuevo mas tarde o comunicate con el administrador");
    			}

    			if (err.response.data !== undefined) {
    				if (err.response.data.err === 900) {
    					$$invalidate(4, msgError = "No hay horarios disponibles para este consultorio");
    				}

    				if (err.response.data.err === 800) {
    					$$invalidate(4, msgError = "No hay cupos disponibles");
    				}
    			}
    		});
    	};

    	onMount(() => {
    		cargarTandas();
    		cargarPacientes();
    	});

    	const writable_props = ["dateStr"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$l.warn(`<ModalCitaCalendario> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		sltBuscarPacientes = this.value;
    		$$invalidate(7, sltBuscarPacientes);
    	}

    	const input_handler = () => search(timeout, cargarPacientes);
    	const click_handler = paciente => seleccionarPaciente(paciente);

    	function input1_input_handler() {
    		fechaCita = this.value;
    		(($$invalidate(2, fechaCita), $$invalidate(16, dateStr)), $$invalidate(25, tiempoCita));
    	}

    	function select_change_handler() {
    		tandaCita = select_value(this);
    		$$invalidate(3, tandaCita);
    		$$invalidate(0, tandas);
    	}

    	function textarea_input_handler() {
    		observaciones = this.value;
    		$$invalidate(5, observaciones);
    	}

    	const submit_handler = () => crearCita();

    	$$self.$$set = $$props => {
    		if ("dateStr" in $$props) $$invalidate(16, dateStr = $$props.dateStr);
    	};

    	$$self.$capture_state = () => ({
    		axios: axios$1,
    		createEventDispatcher,
    		onMount,
    		url,
    		search,
    		Loading,
    		fechaMinima,
    		dateStr,
    		dispatch,
    		pacienteSeleccionado,
    		tandas,
    		citas,
    		fechaCita,
    		tandaCita,
    		msgError,
    		observaciones,
    		meses,
    		cargando,
    		tiempoCita,
    		sltBuscarPacientes,
    		pacientes,
    		timeout,
    		paciente,
    		seleccionarPaciente,
    		cargarPacientes,
    		cargarCitasPorPaciente,
    		cargarTandas,
    		crearCita
    	});

    	$$self.$inject_state = $$props => {
    		if ("fechaMinima" in $$props) $$invalidate(9, fechaMinima = $$props.fechaMinima);
    		if ("dateStr" in $$props) $$invalidate(16, dateStr = $$props.dateStr);
    		if ("pacienteSeleccionado" in $$props) $$invalidate(24, pacienteSeleccionado = $$props.pacienteSeleccionado);
    		if ("tandas" in $$props) $$invalidate(0, tandas = $$props.tandas);
    		if ("citas" in $$props) $$invalidate(1, citas = $$props.citas);
    		if ("fechaCita" in $$props) $$invalidate(2, fechaCita = $$props.fechaCita);
    		if ("tandaCita" in $$props) $$invalidate(3, tandaCita = $$props.tandaCita);
    		if ("msgError" in $$props) $$invalidate(4, msgError = $$props.msgError);
    		if ("observaciones" in $$props) $$invalidate(5, observaciones = $$props.observaciones);
    		if ("meses" in $$props) $$invalidate(10, meses = $$props.meses);
    		if ("cargando" in $$props) $$invalidate(6, cargando = $$props.cargando);
    		if ("tiempoCita" in $$props) $$invalidate(25, tiempoCita = $$props.tiempoCita);
    		if ("sltBuscarPacientes" in $$props) $$invalidate(7, sltBuscarPacientes = $$props.sltBuscarPacientes);
    		if ("pacientes" in $$props) $$invalidate(8, pacientes = $$props.pacientes);
    		if ("timeout" in $$props) $$invalidate(11, timeout = $$props.timeout);
    		if ("paciente" in $$props) $$invalidate(15, paciente = $$props.paciente);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*dateStr*/ 65536) {
    			 $$invalidate(2, fechaCita = dateStr);
    		}

    		if ($$self.$$.dirty[0] & /*pacienteSeleccionado*/ 16777216) {
    			 if (pacienteSeleccionado) {
    				cargarCitasPorPaciente();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*tiempoCita*/ 33554432) {
    			 if (tiempoCita === "S") {
    				let fecha = new Date();
    				fecha.setDate(fecha.getDate() + 7);
    				$$invalidate(2, fechaCita = fecha.toISOString().split("T")[0]);
    			} else if (tiempoCita === "D") {
    				let fecha = new Date();
    				fecha.setDate(fecha.getDate() + 15);
    				$$invalidate(2, fechaCita = fecha.toISOString().split("T")[0]);
    			} else if (tiempoCita === "M") {
    				let fecha = new Date();
    				fecha.setMonth(fecha.getMonth() + 1);
    				$$invalidate(2, fechaCita = fecha.toISOString().split("T")[0]);
    			} else if (tiempoCita === "T") {
    				let fecha = new Date();
    				fecha.setMonth(fecha.getMonth() + 6);
    				$$invalidate(2, fechaCita = fecha.toISOString().split("T")[0]);
    			} else if (tiempoCita === "A") {
    				let fecha = new Date();
    				fecha.setFullYear(fecha.getFullYear() + 1);
    				$$invalidate(2, fechaCita = fecha.toISOString().split("T")[0]);
    			}
    		}
    	};

    	return [
    		tandas,
    		citas,
    		fechaCita,
    		tandaCita,
    		msgError,
    		observaciones,
    		cargando,
    		sltBuscarPacientes,
    		pacientes,
    		fechaMinima,
    		meses,
    		timeout,
    		seleccionarPaciente,
    		cargarPacientes,
    		crearCita,
    		paciente,
    		dateStr,
    		input0_input_handler,
    		input_handler,
    		click_handler,
    		input1_input_handler,
    		select_change_handler,
    		textarea_input_handler,
    		submit_handler
    	];
    }

    class ModalCitaCalendario extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, { dateStr: 16 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalCitaCalendario",
    			options,
    			id: create_fragment$E.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dateStr*/ ctx[16] === undefined && !("dateStr" in props)) {
    			console_1$l.warn("<ModalCitaCalendario> was created without expected prop 'dateStr'");
    		}
    	}

    	get dateStr() {
    		throw new Error("<ModalCitaCalendario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dateStr(value) {
    		throw new Error("<ModalCitaCalendario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    let viewTable = writable(false);

    /* src\Pages\Citas\Index.svelte generated by Svelte v3.29.0 */

    const { console: console_1$m } = globals;
    const file$D = "src\\Pages\\Citas\\Index.svelte";

    function get_each_context$i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[30] = list[i];
    	child_ctx[32] = i;
    	return child_ctx;
    }

    // (251:2) {#if errorServer}
    function create_if_block_7$1(ctx) {
    	let errorserver;
    	let current;

    	errorserver = new ErrorConexion({
    			props: {
    				msgError: "Ocurrio un error al conectar con el servidor, vuelva a intentar o contacte al administrador"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(errorserver.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorserver, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorserver.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorserver.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorserver, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(251:2) {#if errorServer}",
    		ctx
    	});

    	return block;
    }

    // (283:37) {:else}
    function create_else_block$3(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "mdi mdi-view-list mdi-16px");
    			add_location(i, file$D, 283, 37, 10756);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(283:37) {:else}",
    		ctx
    	});

    	return block;
    }

    // (280:32) {#if $viewTable}
    function create_if_block_6$2(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "mdi mdi-calendar-multiselect mdi-16px");
    			add_location(i, file$D, 281, 37, 10618);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(280:32) {#if $viewTable}",
    		ctx
    	});

    	return block;
    }

    // (293:12) {#if !$viewTable}
    function create_if_block_5$4(ctx) {
    	let div8;
    	let div7;
    	let div6;
    	let div5;
    	let div3;
    	let div0;
    	let div0_style_value;
    	let t0;
    	let p0;
    	let t2;
    	let div1;
    	let div1_style_value;
    	let t3;
    	let p1;
    	let t5;
    	let div2;
    	let div2_style_value;
    	let t6;
    	let p2;
    	let t8;
    	let div4;
    	let t9;
    	let fullcalendar;
    	let current;
    	let fullcalendar_props = { options: /*options*/ ctx[6] };

    	fullcalendar = new FullCalendar({
    			props: fullcalendar_props,
    			$$inline: true
    		});

    	/*fullcalendar_binding*/ ctx[20](fullcalendar);

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			t0 = space();
    			p0 = element("p");
    			p0.textContent = "Nueva";
    			t2 = space();
    			div1 = element("div");
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "Cancelada";
    			t5 = space();
    			div2 = element("div");
    			t6 = space();
    			p2 = element("p");
    			p2.textContent = "Realizada";
    			t8 = space();
    			div4 = element("div");
    			t9 = space();
    			create_component(fullcalendar.$$.fragment);
    			attr_dev(div0, "style", div0_style_value = `width:15px; height: 15px; border-radius: 3px; background-color: ${/*citasColor*/ ctx[12]["N"]}`);
    			add_location(div0, file$D, 298, 36, 11353);
    			attr_dev(p0, "class", "ml-1 mr-3");
    			set_style(p0, "margin-bottom", "0");
    			set_style(p0, "margin-top", "-3px");
    			add_location(p0, file$D, 301, 36, 11535);
    			attr_dev(div1, "style", div1_style_value = `width:15px; height: 15px; border-radius: 3px; background-color: ${/*citasColor*/ ctx[12]["X"]}`);
    			add_location(div1, file$D, 302, 36, 11646);
    			attr_dev(p1, "class", "ml-1 mr-3");
    			set_style(p1, "margin-bottom", "0");
    			set_style(p1, "margin-top", "-3px");
    			add_location(p1, file$D, 305, 36, 11828);
    			attr_dev(div2, "style", div2_style_value = `width:15px; height: 15px; border-radius: 3px; background-color: ${/*citasColor*/ ctx[12]["R"]}`);
    			add_location(div2, file$D, 306, 36, 11943);
    			attr_dev(p2, "class", "ml-1 mr-3");
    			set_style(p2, "margin-bottom", "0");
    			set_style(p2, "margin-top", "-3px");
    			add_location(p2, file$D, 309, 36, 12125);
    			attr_dev(div3, "class", "d-flex mb-2");
    			add_location(div3, file$D, 297, 33, 11290);
    			attr_dev(div4, "class", "row");
    			add_location(div4, file$D, 311, 33, 12278);
    			attr_dev(div5, "class", "col-lg-12");
    			add_location(div5, file$D, 296, 29, 11232);
    			attr_dev(div6, "class", "row");
    			add_location(div6, file$D, 295, 25, 11184);
    			attr_dev(div7, "class", "card-body");
    			add_location(div7, file$D, 294, 21, 11134);
    			attr_dev(div8, "class", "card m-b-30");
    			add_location(div8, file$D, 293, 17, 11086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div3, div0);
    			append_dev(div3, t0);
    			append_dev(div3, p0);
    			append_dev(div3, t2);
    			append_dev(div3, div1);
    			append_dev(div3, t3);
    			append_dev(div3, p1);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div3, t6);
    			append_dev(div3, p2);
    			append_dev(div5, t8);
    			append_dev(div5, div4);
    			append_dev(div5, t9);
    			mount_component(fullcalendar, div5, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const fullcalendar_changes = {};
    			if (dirty[0] & /*options*/ 64) fullcalendar_changes.options = /*options*/ ctx[6];
    			fullcalendar.$set(fullcalendar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fullcalendar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fullcalendar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			/*fullcalendar_binding*/ ctx[20](null);
    			destroy_component(fullcalendar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(293:12) {#if !$viewTable}",
    		ctx
    	});

    	return block;
    }

    // (320:12) {#if $viewTable}
    function create_if_block_1$h(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let th1;
    	let t2;
    	let th2;
    	let t4;
    	let th3;
    	let t6;
    	let th4;
    	let t8;
    	let th5;
    	let t10;
    	let th6;
    	let t12;
    	let th7;
    	let t13;
    	let tbody;
    	let each_value = /*citas*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = space();
    			th1 = element("th");
    			th1.textContent = "#";
    			t2 = space();
    			th2 = element("th");
    			th2.textContent = "Nombre";
    			t4 = space();
    			th3 = element("th");
    			th3.textContent = "Fecha Cita";
    			t6 = space();
    			th4 = element("th");
    			th4.textContent = "Cedula";
    			t8 = space();
    			th5 = element("th");
    			th5.textContent = "Edad";
    			t10 = space();
    			th6 = element("th");
    			th6.textContent = "Estado";
    			t12 = space();
    			th7 = element("th");
    			t13 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$D, 324, 25, 12785);
    			add_location(th1, file$D, 325, 25, 12821);
    			add_location(th2, file$D, 326, 25, 12858);
    			add_location(th3, file$D, 327, 25, 12900);
    			add_location(th4, file$D, 328, 25, 12946);
    			add_location(th5, file$D, 329, 25, 12988);
    			add_location(th6, file$D, 330, 25, 13028);
    			add_location(th7, file$D, 331, 25, 13070);
    			add_location(tr, file$D, 323, 21, 12754);
    			add_location(thead, file$D, 322, 21, 12724);
    			add_location(tbody, file$D, 334, 21, 13161);
    			attr_dev(table, "class", "table align-td-middle table-card");
    			add_location(table, file$D, 321, 17, 12653);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t0);
    			append_dev(tr, th1);
    			append_dev(tr, t2);
    			append_dev(tr, th2);
    			append_dev(tr, t4);
    			append_dev(tr, th3);
    			append_dev(tr, t6);
    			append_dev(tr, th4);
    			append_dev(tr, t8);
    			append_dev(tr, th5);
    			append_dev(tr, t10);
    			append_dev(tr, th6);
    			append_dev(tr, t12);
    			append_dev(tr, th7);
    			append_dev(table, t13);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*citas, cambiarEstadoCita, cambiandoEstado, estados, tandas*/ 35874) {
    				each_value = /*citas*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$i(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$i(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(320:12) {#if $viewTable}",
    		ctx
    	});

    	return block;
    }

    // (337:25) {#if cita.activo}
    function create_if_block_2$c(ctx) {
    	let tr;
    	let td0;
    	let div;
    	let span0;
    	let t0_value = /*cita*/ ctx[30].paciente.nombres[0] + "";
    	let t0;
    	let t1_value = /*cita*/ ctx[30].paciente.apellidos[0] + "";
    	let t1;
    	let t2;
    	let td1;
    	let t3_value = /*i*/ ctx[32] + 1 + "";
    	let t3;
    	let t4;
    	let td2;
    	let t5_value = /*cita*/ ctx[30].paciente.nombres + "";
    	let t5;
    	let t6;
    	let t7_value = /*cita*/ ctx[30].paciente.apellidos + "";
    	let t7;
    	let t8;
    	let td3;
    	let t9_value = new Date(/*cita*/ ctx[30].fechaCita).toLocaleDateString("es-DO") + "";
    	let t9;
    	let t10;
    	let span1;
    	let t11_value = /*tandas*/ ctx[11][/*cita*/ ctx[30].tanda] + "";
    	let t11;
    	let t12;
    	let td4;
    	let t13_value = /*cita*/ ctx[30].paciente.cedula + "";
    	let t13;
    	let t14;
    	let td5;
    	let t15_value = calcularEdad(/*cita*/ ctx[30].paciente.fechaNacimiento) + "";
    	let t15;
    	let t16;
    	let t17;
    	let td6;
    	let span2;
    	let t18_value = /*estados*/ ctx[10][/*cita*/ ctx[30].estado] + "";
    	let t18;
    	let t19;
    	let td7;
    	let t20;
    	let t21;
    	let if_block0 = /*cambiandoEstado*/ ctx[5] && create_if_block_4$6(ctx);
    	let if_block1 = /*cita*/ ctx[30].estado !== "R" && /*cita*/ ctx[30].estado !== "X" && create_if_block_3$6(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			div = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = space();
    			td1 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			td2 = element("td");
    			t5 = text(t5_value);
    			t6 = space();
    			t7 = text(t7_value);
    			t8 = space();
    			td3 = element("td");
    			t9 = text(t9_value);
    			t10 = space();
    			span1 = element("span");
    			t11 = text(t11_value);
    			t12 = space();
    			td4 = element("td");
    			t13 = text(t13_value);
    			t14 = space();
    			td5 = element("td");
    			t15 = text(t15_value);
    			t16 = text(" aos");
    			t17 = space();
    			td6 = element("td");
    			span2 = element("span");
    			t18 = text(t18_value);
    			t19 = space();
    			td7 = element("td");
    			if (if_block0) if_block0.c();
    			t20 = space();
    			if (if_block1) if_block1.c();
    			t21 = space();
    			attr_dev(span0, "class", "avatar-title rounded-circle ");
    			add_location(span0, file$D, 340, 37, 13516);
    			attr_dev(div, "class", "avatar avatar-sm");
    			add_location(div, file$D, 339, 33, 13447);
    			add_location(td0, file$D, 338, 29, 13408);
    			add_location(td1, file$D, 343, 29, 13728);
    			add_location(td2, file$D, 344, 29, 13773);
    			attr_dev(span1, "class", "badge text-white");
    			toggle_class(span1, "bg-primary", /*cita*/ ctx[30].tanda === "M");
    			toggle_class(span1, "bg-warning", /*cita*/ ctx[30].tanda === "V");
    			add_location(span1, file$D, 346, 33, 13956);
    			add_location(td3, file$D, 345, 29, 13862);
    			add_location(td4, file$D, 354, 29, 14384);
    			add_location(td5, file$D, 355, 29, 14446);
    			attr_dev(span2, "class", "badge text-white");
    			toggle_class(span2, "bg-success", /*cita*/ ctx[30].estado === "N");
    			toggle_class(span2, "bg-secondary", /*cita*/ ctx[30].estado === "R");
    			toggle_class(span2, "bg-danger", /*cita*/ ctx[30].estado === "X");
    			add_location(span2, file$D, 357, 33, 14575);
    			add_location(td6, file$D, 356, 29, 14536);
    			attr_dev(td7, "class", "text-right");
    			add_location(td7, file$D, 366, 29, 15081);
    			toggle_class(tr, "bg-soft-success", /*cita*/ ctx[30].estado === "R");
    			toggle_class(tr, "bg-soft-danger", /*cita*/ ctx[30].estado === "X");
    			add_location(tr, file$D, 337, 25, 13286);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, div);
    			append_dev(div, span0);
    			append_dev(span0, t0);
    			append_dev(span0, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td1);
    			append_dev(td1, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td2);
    			append_dev(td2, t5);
    			append_dev(td2, t6);
    			append_dev(td2, t7);
    			append_dev(tr, t8);
    			append_dev(tr, td3);
    			append_dev(td3, t9);
    			append_dev(td3, t10);
    			append_dev(td3, span1);
    			append_dev(span1, t11);
    			append_dev(tr, t12);
    			append_dev(tr, td4);
    			append_dev(td4, t13);
    			append_dev(tr, t14);
    			append_dev(tr, td5);
    			append_dev(td5, t15);
    			append_dev(td5, t16);
    			append_dev(tr, t17);
    			append_dev(tr, td6);
    			append_dev(td6, span2);
    			append_dev(span2, t18);
    			append_dev(tr, t19);
    			append_dev(tr, td7);
    			if (if_block0) if_block0.m(td7, null);
    			append_dev(td7, t20);
    			if (if_block1) if_block1.m(td7, null);
    			append_dev(tr, t21);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*citas*/ 2 && t0_value !== (t0_value = /*cita*/ ctx[30].paciente.nombres[0] + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*citas*/ 2 && t1_value !== (t1_value = /*cita*/ ctx[30].paciente.apellidos[0] + "")) set_data_dev(t1, t1_value);
    			if (dirty[0] & /*citas*/ 2 && t5_value !== (t5_value = /*cita*/ ctx[30].paciente.nombres + "")) set_data_dev(t5, t5_value);
    			if (dirty[0] & /*citas*/ 2 && t7_value !== (t7_value = /*cita*/ ctx[30].paciente.apellidos + "")) set_data_dev(t7, t7_value);
    			if (dirty[0] & /*citas*/ 2 && t9_value !== (t9_value = new Date(/*cita*/ ctx[30].fechaCita).toLocaleDateString("es-DO") + "")) set_data_dev(t9, t9_value);
    			if (dirty[0] & /*citas*/ 2 && t11_value !== (t11_value = /*tandas*/ ctx[11][/*cita*/ ctx[30].tanda] + "")) set_data_dev(t11, t11_value);

    			if (dirty[0] & /*citas*/ 2) {
    				toggle_class(span1, "bg-primary", /*cita*/ ctx[30].tanda === "M");
    			}

    			if (dirty[0] & /*citas*/ 2) {
    				toggle_class(span1, "bg-warning", /*cita*/ ctx[30].tanda === "V");
    			}

    			if (dirty[0] & /*citas*/ 2 && t13_value !== (t13_value = /*cita*/ ctx[30].paciente.cedula + "")) set_data_dev(t13, t13_value);
    			if (dirty[0] & /*citas*/ 2 && t15_value !== (t15_value = calcularEdad(/*cita*/ ctx[30].paciente.fechaNacimiento) + "")) set_data_dev(t15, t15_value);
    			if (dirty[0] & /*citas*/ 2 && t18_value !== (t18_value = /*estados*/ ctx[10][/*cita*/ ctx[30].estado] + "")) set_data_dev(t18, t18_value);

    			if (dirty[0] & /*citas*/ 2) {
    				toggle_class(span2, "bg-success", /*cita*/ ctx[30].estado === "N");
    			}

    			if (dirty[0] & /*citas*/ 2) {
    				toggle_class(span2, "bg-secondary", /*cita*/ ctx[30].estado === "R");
    			}

    			if (dirty[0] & /*citas*/ 2) {
    				toggle_class(span2, "bg-danger", /*cita*/ ctx[30].estado === "X");
    			}

    			if (/*cambiandoEstado*/ ctx[5]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_4$6(ctx);
    					if_block0.c();
    					if_block0.m(td7, t20);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*cita*/ ctx[30].estado !== "R" && /*cita*/ ctx[30].estado !== "X") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$6(ctx);
    					if_block1.c();
    					if_block1.m(td7, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*citas*/ 2) {
    				toggle_class(tr, "bg-soft-success", /*cita*/ ctx[30].estado === "R");
    			}

    			if (dirty[0] & /*citas*/ 2) {
    				toggle_class(tr, "bg-soft-danger", /*cita*/ ctx[30].estado === "X");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$c.name,
    		type: "if",
    		source: "(337:25) {#if cita.activo}",
    		ctx
    	});

    	return block;
    }

    // (368:33) {#if cambiandoEstado}
    function create_if_block_4$6(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "Loading...";
    			attr_dev(span, "class", "sr-only");
    			add_location(span, file$D, 369, 41, 15315);
    			attr_dev(div, "class", "spinner-border spinner-border-sm text-primary");
    			attr_dev(div, "role", "status");
    			add_location(div, file$D, 368, 37, 15199);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$6.name,
    		type: "if",
    		source: "(368:33) {#if cambiandoEstado}",
    		ctx
    	});

    	return block;
    }

    // (374:33) {#if cita.estado !== 'R' && cita.estado !== 'X'}
    function create_if_block_3$6(ctx) {
    	let a0;
    	let i0;
    	let t0;
    	let a1;
    	let i1;
    	let t1;
    	let a2;
    	let i2;
    	let a2_href_value;
    	let link_action;
    	let mounted;
    	let dispose;

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[21](/*cita*/ ctx[30], ...args);
    	}

    	function click_handler_2(...args) {
    		return /*click_handler_2*/ ctx[22](/*cita*/ ctx[30], ...args);
    	}

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			i0 = element("i");
    			t0 = space();
    			a1 = element("a");
    			i1 = element("i");
    			t1 = space();
    			a2 = element("a");
    			i2 = element("i");
    			attr_dev(i0, "class", "mdi mdi-close");
    			add_location(i0, file$D, 381, 41, 16084);
    			attr_dev(a0, "href", "#!");
    			attr_dev(a0, "class", "btn btn-outline-danger");
    			attr_dev(a0, "data-tooltip", "Cancelar");
    			add_location(a0, file$D, 375, 37, 15702);
    			attr_dev(i1, "class", "mdi mdi-check-all");
    			add_location(i1, file$D, 389, 40, 16585);
    			attr_dev(a1, "href", "#!");
    			attr_dev(a1, "class", "btn btn-outline-success");
    			attr_dev(a1, "data-tooltip", "Marcar realizada");
    			add_location(a1, file$D, 383, 37, 16195);
    			attr_dev(i2, "class", "mdi mdi-send");
    			add_location(i2, file$D, 397, 42, 17067);
    			attr_dev(a2, "href", a2_href_value = `/pacientes/perfil/${/*cita*/ ctx[30].paciente.id}`);
    			attr_dev(a2, "class", "btn btn-outline-primary");
    			attr_dev(a2, "data-tooltip", "Ver");
    			add_location(a2, file$D, 391, 38, 16701);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			append_dev(a0, i0);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, a1, anchor);
    			append_dev(a1, i1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a2, anchor);
    			append_dev(a2, i2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", prevent_default(click_handler_1), false, true, false),
    					listen_dev(a1, "click", prevent_default(click_handler_2), false, true, false),
    					action_destroyer(link_action = link.call(null, a2))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*citas*/ 2 && a2_href_value !== (a2_href_value = `/pacientes/perfil/${/*cita*/ ctx[30].paciente.id}`)) {
    				attr_dev(a2, "href", a2_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(a1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(374:33) {#if cita.estado !== 'R' && cita.estado !== 'X'}",
    		ctx
    	});

    	return block;
    }

    // (336:21) {#each citas as cita, i}
    function create_each_block$i(ctx) {
    	let if_block_anchor;
    	let if_block = /*cita*/ ctx[30].activo && create_if_block_2$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*cita*/ ctx[30].activo) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$c(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$i.name,
    		type: "each",
    		source: "(336:21) {#each citas as cita, i}",
    		ctx
    	});

    	return block;
    }

    // (411:8) {#if cargando}
    function create_if_block$p(ctx) {
    	let div1;
    	let div0;
    	let span;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span = element("span");
    			span.textContent = "Loading...";
    			attr_dev(span, "class", "sr-only");
    			add_location(span, file$D, 413, 21, 17585);
    			attr_dev(div0, "class", "spinner-border text-secondary");
    			attr_dev(div0, "role", "status");
    			add_location(div0, file$D, 412, 17, 17505);
    			attr_dev(div1, "class", "text-center");
    			add_location(div1, file$D, 411, 13, 17461);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(411:8) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let aside;
    	let t0;
    	let main;
    	let header;
    	let t1;
    	let t2;
    	let section;
    	let div13;
    	let div0;
    	let t3;
    	let div12;
    	let h5;
    	let t5;
    	let div10;
    	let div9;
    	let div8;
    	let div1;
    	let t6;
    	let div7;
    	let div3;
    	let div2;
    	let label0;
    	let t8;
    	let input0;
    	let t9;
    	let div5;
    	let div4;
    	let label1;
    	let t11;
    	let input1;
    	let t12;
    	let div6;
    	let button;
    	let t13;
    	let div11;
    	let t14;
    	let t15;
    	let t16;
    	let modalcitacalendario;
    	let current;
    	let mounted;
    	let dispose;
    	aside = new Aside({ $$inline: true });
    	header = new Header({ $$inline: true });
    	let if_block0 = /*errorServer*/ ctx[9] && create_if_block_7$1(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*$viewTable*/ ctx[8]) return create_if_block_6$2;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block1 = current_block_type(ctx);
    	let if_block2 = !/*$viewTable*/ ctx[8] && create_if_block_5$4(ctx);
    	let if_block3 = /*$viewTable*/ ctx[8] && create_if_block_1$h(ctx);
    	let if_block4 = /*cargando*/ ctx[4] && create_if_block$p(ctx);

    	modalcitacalendario = new ModalCitaCalendario({
    			props: { dateStr: /*dateStr*/ ctx[2] },
    			$$inline: true
    		});

    	modalcitacalendario.$on("cargarCitasPorMes", /*cargarCitasPorMes*/ ctx[14]);
    	modalcitacalendario.$on("cargarCitas", /*cargarCitas*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(aside.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(header.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			section = element("section");
    			div13 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div12 = element("div");
    			h5 = element("h5");
    			h5.textContent = "Citas";
    			t5 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div1 = element("div");
    			t6 = space();
    			div7 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			label0 = element("label");
    			label0.textContent = "Buscar citas";
    			t8 = space();
    			input0 = element("input");
    			t9 = space();
    			div5 = element("div");
    			div4 = element("div");
    			label1 = element("label");
    			label1.textContent = "Buscar citas";
    			t11 = space();
    			input1 = element("input");
    			t12 = space();
    			div6 = element("div");
    			button = element("button");
    			if_block1.c();
    			t13 = space();
    			div11 = element("div");
    			if (if_block2) if_block2.c();
    			t14 = space();
    			if (if_block3) if_block3.c();
    			t15 = space();
    			if (if_block4) if_block4.c();
    			t16 = space();
    			create_component(modalcitacalendario.$$.fragment);
    			attr_dev(div0, "class", "row");
    			add_location(div0, file$D, 257, 6, 9181);
    			add_location(h5, file$D, 259, 8, 9253);
    			attr_dev(div1, "class", "calendar");
    			add_location(div1, file$D, 263, 20, 9412);
    			attr_dev(label0, "for", "Buscar");
    			add_location(label0, file$D, 267, 32, 9615);
    			attr_dev(input0, "type", "search");
    			attr_dev(input0, "class", "form-control");
    			attr_dev(input0, "placeholder", "Nombres, Apelidos o Cedula");
    			add_location(input0, file$D, 268, 32, 9689);
    			attr_dev(div2, "class", "form-group");
    			add_location(div2, file$D, 266, 28, 9557);
    			attr_dev(div3, "class", "col-lg-4");
    			add_location(div3, file$D, 265, 24, 9505);
    			attr_dev(label1, "for", "Buscar");
    			add_location(label1, file$D, 273, 32, 10027);
    			attr_dev(input1, "type", "date");
    			attr_dev(input1, "class", "form-control");
    			attr_dev(input1, "placeholder", "Nombres o Apelidos");
    			add_location(input1, file$D, 274, 32, 10101);
    			attr_dev(div4, "class", "form-group");
    			add_location(div4, file$D, 272, 28, 9969);
    			attr_dev(div5, "class", "col-lg-3");
    			add_location(div5, file$D, 271, 24, 9917);
    			attr_dev(button, "class", "btn btn-outline-primary");
    			set_style(button, "margin-top", "30px");
    			add_location(button, file$D, 278, 28, 10361);
    			attr_dev(div6, "class", "col");
    			add_location(div6, file$D, 277, 24, 10314);
    			attr_dev(div7, "class", "row");
    			add_location(div7, file$D, 264, 20, 9462);
    			attr_dev(div8, "class", "col-12");
    			add_location(div8, file$D, 262, 16, 9370);
    			attr_dev(div9, "class", "row");
    			add_location(div9, file$D, 261, 8, 9335);
    			attr_dev(div10, "class", "alert alert-secondary");
    			attr_dev(div10, "role", "alert");
    			add_location(div10, file$D, 260, 8, 9277);
    			attr_dev(div11, "class", "table-responsive");
    			add_location(div11, file$D, 291, 8, 11006);
    			attr_dev(div12, "class", "col-md-12 mt-3 m-b-30");
    			add_location(div12, file$D, 258, 6, 9208);
    			attr_dev(div13, "class", "p-2");
    			add_location(div13, file$D, 256, 4, 9156);
    			attr_dev(section, "class", "admin-content");
    			add_location(section, file$D, 255, 2, 9119);
    			attr_dev(main, "class", "admin-main");
    			add_location(main, file$D, 248, 0, 8897);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(aside, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t2);
    			append_dev(main, section);
    			append_dev(section, div13);
    			append_dev(div13, div0);
    			append_dev(div13, t3);
    			append_dev(div13, div12);
    			append_dev(div12, h5);
    			append_dev(div12, t5);
    			append_dev(div12, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div1);
    			append_dev(div8, t6);
    			append_dev(div8, div7);
    			append_dev(div7, div3);
    			append_dev(div3, div2);
    			append_dev(div2, label0);
    			append_dev(div2, t8);
    			append_dev(div2, input0);
    			set_input_value(input0, /*sltBuscarCitas*/ ctx[3]);
    			append_dev(div7, t9);
    			append_dev(div7, div5);
    			append_dev(div5, div4);
    			append_dev(div4, label1);
    			append_dev(div4, t11);
    			append_dev(div4, input1);
    			set_input_value(input1, /*txtFecha*/ ctx[7]);
    			append_dev(div7, t12);
    			append_dev(div7, div6);
    			append_dev(div6, button);
    			if_block1.m(button, null);
    			append_dev(div12, t13);
    			append_dev(div12, div11);
    			if (if_block2) if_block2.m(div11, null);
    			append_dev(div11, t14);
    			if (if_block3) if_block3.m(div11, null);
    			append_dev(div12, t15);
    			if (if_block4) if_block4.m(div12, null);
    			insert_dev(target, t16, anchor);
    			mount_component(modalcitacalendario, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[17]),
    					listen_dev(input0, "input", /*searchCitas*/ ctx[13], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[18]),
    					listen_dev(input1, "change", /*searchCitas*/ ctx[13], false, false, false),
    					listen_dev(button, "click", /*click_handler*/ ctx[19], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*sltBuscarCitas*/ 8) {
    				set_input_value(input0, /*sltBuscarCitas*/ ctx[3]);
    			}

    			if (dirty[0] & /*txtFecha*/ 128) {
    				set_input_value(input1, /*txtFecha*/ ctx[7]);
    			}

    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(button, null);
    				}
    			}

    			if (!/*$viewTable*/ ctx[8]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*$viewTable*/ 256) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_5$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div11, t14);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$viewTable*/ ctx[8]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_1$h(ctx);
    					if_block3.c();
    					if_block3.m(div11, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (/*cargando*/ ctx[4]) {
    				if (if_block4) ; else {
    					if_block4 = create_if_block$p(ctx);
    					if_block4.c();
    					if_block4.m(div12, null);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			const modalcitacalendario_changes = {};
    			if (dirty[0] & /*dateStr*/ 4) modalcitacalendario_changes.dateStr = /*dateStr*/ ctx[2];
    			modalcitacalendario.$set(modalcitacalendario_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(aside.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block2);
    			transition_in(modalcitacalendario.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(aside.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block2);
    			transition_out(modalcitacalendario.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(aside, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (detaching) detach_dev(t16);
    			destroy_component(modalcitacalendario, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let $viewTable;
    	validate_store(viewTable, "viewTable");
    	component_subscribe($$self, viewTable, $$value => $$invalidate(8, $viewTable = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Index", slots, []);
    	let calendarRef;

    	function next() {
    		let calendarApi = calendarRef.getAPI();
    		calendarApi.next();
    	}

    	function prev() {
    		let calendarApi = calendarRef.getAPI();
    		calendarApi.prev();
    	}

    	let citas = [];
    	let mesCita = new Date().getMonth() + 1;
    	let anioCita = new Date().getFullYear();
    	let dateStr = "";
    	let citasPorMes = [];
    	let citasCalendar = [];
    	let errorServer = false;
    	let sltBuscarCitas = "";
    	let timeout = null;
    	let cargando = false;
    	let cambiandoEstado = false;
    	let options = {};

    	let estados = {
    		N: "Nuevo",
    		X: "Cancelada",
    		R: "Realizada"
    	};

    	let tandas = { M: "Maana", V: "Tarde", N: "Noche" };
    	let citasColor = { N: "#00cc99", X: "#f2545b", R: "#95aac9" };
    	let txtFecha = new Date().toISOString().split("T")[0];

    	const searchCitas = () => {
    		if (timeout) {
    			window.clearTimeout(timeout);
    		}

    		timeout = setTimeout(
    			function () {
    				cargarCitas();
    			},
    			300
    		);
    	};

    	const cargarCitasPorMes = (mes, anio) => {
    		$$invalidate(4, cargando = true);

    		const config = {
    			method: "get",
    			url: `${url}/citas/mes/${mes}/anio/${anio}`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(4, cargando = false);

    			if (res.status === 200) {
    				citasPorMes = res.data;

    				citasCalendar = citasPorMes.map(cita => {
    					return {
    						title: `${cita.paciente.nombres} ${cita.paciente.apellidos}`,
    						start: cita.fechaCita,
    						end: cita.fechaCita,
    						color: citasColor[cita.estado],
    						textColor: "#fff",
    						extendedProps: {
    							tanda: cita.tanda === "V"
    							? "Tarde"
    							: cita.tanda === "N" ? "Noche" : "Maana"
    						}
    					};
    				});

    				citasCalendar = citasCalendar;

    				$$invalidate(6, options = {
    					dayMaxEventRows: false,
    					headerToolbar: { right: "prev,next" },
    					locales: [es_1],
    					selectable: true,
    					selectHelper: true,
    					viewRender(view, element) {
    						
    					},
    					eventRender(event, element) {
    						jQuery(element).title({ title: event.title });
    					},
    					editable: false,
    					dateClick(info) {
    						$$invalidate(2, dateStr = info.dateStr); //info.dayEl.style.backgroundColor = 'red';
    						jQuery("#modalCitaCalendario").modal("show");
    					}, //info.dayEl.style.backgroundColor = 'red';
    					eventMouseover(event, jsEvent, view) {
    						
    					},
    					eventClick(info, element) {
    						alert("Event: " + info.event.title); // change the border color just for fun
    						// info.el.style.borderColor = 'red';

    						alert("Coordinates: " + info.jsEvent.pageX + "," + info.jsEvent.pageY);
    						alert("View: " + info.view.type);
    					}, // change the border color just for fun
    					customButtons: {
    						prev: {
    							text: "Prev",
    							click(event, element, view) {
    								if (mesCita === 1) {
    									mesCita = 12;
    									anioCita = anioCita - 1;
    								} else {
    									mesCita = mesCita - 1;
    								}

    								prev();
    								cargarCitasPorMes(mesCita, anioCita);
    							}
    						},
    						next: {
    							text: "Next",
    							click(event, element, view) {
    								if (mesCita === 12) {
    									mesCita = 1;
    									anioCita = anioCita + 1;
    								} else {
    									mesCita = mesCita + 1;
    								}

    								next();
    								cargarCitasPorMes(mesCita, anioCita);
    							}
    						}
    					},
    					events: citasCalendar,
    					initialView: sltBuscarCitas,
    					plugins: [main, main$1]
    				});
    			}
    		}).catch(err => {
    			$$invalidate(4, cargando = false);
    			console.error(err);
    		});
    	};

    	const cambiarEstadoCita = (idCita, estado) => {
    		$$invalidate(5, cambiandoEstado = true);
    		const cita = { estado };

    		const config = {
    			method: "put",
    			url: `${url}/citas/${idCita}`,
    			data: cita,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		if (estado === "X") {
    			Swal.fire({
    				title: "Estas seguro?",
    				text: "La cita se va a cancelar y este cupo estara disponible!",
    				icon: "warning",
    				showCancelButton: true,
    				confirmButtonColor: "#3085d6",
    				cancelButtonColor: "#d33",
    				confirmButtonText: "Si, Estoy seguro!",
    				cancelButtonText: "No"
    			}).then(result => {
    				$$invalidate(5, cambiandoEstado = false);

    				if (result.isConfirmed) {
    					axios$1(config).then(res => {
    						if (res.data) {
    							$$invalidate(5, cambiandoEstado = false);
    							cargarCitas();
    						}

    						$$invalidate(5, cambiandoEstado = false);
    					}).catch(err => {
    						$$invalidate(5, cambiandoEstado = false);
    						console.error(err);
    					});
    				}
    			});

    			return;
    		}

    		axios$1(config).then(res => {
    			if (res.data) {
    				$$invalidate(5, cambiandoEstado = false);
    				cargarCitas();
    			}

    			$$invalidate(5, cambiandoEstado = false);
    		}).catch(err => {
    			$$invalidate(5, cambiandoEstado = false);
    			console.error(err);
    		});
    	};

    	const cargarCitas = () => {
    		$$invalidate(4, cargando = true);

    		const config = {
    			method: "get",
    			url: `${url}/citas?fechaBusqueda=${txtFecha}&busqueda=${sltBuscarCitas}`,
    			headers: {
    				"Authorization": `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(4, cargando = false);

    			if (res.status === 200) {
    				$$invalidate(1, citas = res.data);
    			}
    		}).catch(err => {
    			$$invalidate(4, cargando = false);
    			console.error(err);
    		});
    	};

    	onMount(() => {
    		cargarCitas();
    		cargarCitasPorMes(mesCita, anioCita);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$m.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		sltBuscarCitas = this.value;
    		$$invalidate(3, sltBuscarCitas);
    	}

    	function input1_input_handler() {
    		txtFecha = this.value;
    		$$invalidate(7, txtFecha);
    	}

    	const click_handler = () => set_store_value(viewTable, $viewTable = !$viewTable, $viewTable);

    	function fullcalendar_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			calendarRef = $$value;
    			$$invalidate(0, calendarRef);
    		});
    	}

    	const click_handler_1 = cita => cambiarEstadoCita(cita.id, "X");
    	const click_handler_2 = cita => cambiarEstadoCita(cita.id, "R");

    	$$self.$capture_state = () => ({
    		FullCalendar,
    		dayGridPlugin: main,
    		interactionPlugin: main$1,
    		esLocale: es_1,
    		ModalCitaCalendario,
    		link,
    		onMount,
    		viewTable,
    		axios: axios$1,
    		url,
    		calcularEdad,
    		Header,
    		Aside,
    		ErrorServer: ErrorConexion,
    		calendarRef,
    		next,
    		prev,
    		citas,
    		mesCita,
    		anioCita,
    		dateStr,
    		citasPorMes,
    		citasCalendar,
    		errorServer,
    		sltBuscarCitas,
    		timeout,
    		cargando,
    		cambiandoEstado,
    		options,
    		estados,
    		tandas,
    		citasColor,
    		txtFecha,
    		searchCitas,
    		cargarCitasPorMes,
    		cambiarEstadoCita,
    		cargarCitas,
    		$viewTable
    	});

    	$$self.$inject_state = $$props => {
    		if ("calendarRef" in $$props) $$invalidate(0, calendarRef = $$props.calendarRef);
    		if ("citas" in $$props) $$invalidate(1, citas = $$props.citas);
    		if ("mesCita" in $$props) mesCita = $$props.mesCita;
    		if ("anioCita" in $$props) anioCita = $$props.anioCita;
    		if ("dateStr" in $$props) $$invalidate(2, dateStr = $$props.dateStr);
    		if ("citasPorMes" in $$props) citasPorMes = $$props.citasPorMes;
    		if ("citasCalendar" in $$props) citasCalendar = $$props.citasCalendar;
    		if ("errorServer" in $$props) $$invalidate(9, errorServer = $$props.errorServer);
    		if ("sltBuscarCitas" in $$props) $$invalidate(3, sltBuscarCitas = $$props.sltBuscarCitas);
    		if ("timeout" in $$props) timeout = $$props.timeout;
    		if ("cargando" in $$props) $$invalidate(4, cargando = $$props.cargando);
    		if ("cambiandoEstado" in $$props) $$invalidate(5, cambiandoEstado = $$props.cambiandoEstado);
    		if ("options" in $$props) $$invalidate(6, options = $$props.options);
    		if ("estados" in $$props) $$invalidate(10, estados = $$props.estados);
    		if ("tandas" in $$props) $$invalidate(11, tandas = $$props.tandas);
    		if ("citasColor" in $$props) $$invalidate(12, citasColor = $$props.citasColor);
    		if ("txtFecha" in $$props) $$invalidate(7, txtFecha = $$props.txtFecha);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		calendarRef,
    		citas,
    		dateStr,
    		sltBuscarCitas,
    		cargando,
    		cambiandoEstado,
    		options,
    		txtFecha,
    		$viewTable,
    		errorServer,
    		estados,
    		tandas,
    		citasColor,
    		searchCitas,
    		cargarCitasPorMes,
    		cambiarEstadoCita,
    		cargarCitas,
    		input0_input_handler,
    		input1_input_handler,
    		click_handler,
    		fullcalendar_binding,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class Index$5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    /* src\Pages\Reportes\HistoriaClinica\Actual.svelte generated by Svelte v3.29.0 */

    const { console: console_1$n } = globals;
    const file$E = "src\\Pages\\Reportes\\HistoriaClinica\\Actual.svelte";

    function get_each_context$j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context_4$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context_5$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    // (205:21) {:else}
    function create_else_block_5(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Sin hallazgos positivos";
    			attr_dev(p, "class", "svelte-t6vuo7");
    			add_location(p, file$E, 205, 26, 7341);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_5.name,
    		type: "else",
    		source: "(205:21) {:else}",
    		ctx
    	});

    	return block;
    }

    // (198:21) {#if item.activo}
    function create_if_block_4$7(ctx) {
    	let div;
    	let p0;
    	let strong;
    	let t0_value = /*item*/ ctx[20].nombre + "";
    	let t0;
    	let t1;
    	let p1;
    	let t2_value = /*item*/ ctx[20].text + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p0 = element("p");
    			strong = element("strong");
    			t0 = text(t0_value);
    			t1 = space();
    			p1 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			add_location(strong, file$E, 200, 33, 7137);
    			attr_dev(p0, "class", "svelte-t6vuo7");
    			add_location(p0, file$E, 200, 30, 7134);
    			attr_dev(p1, "class", "svelte-t6vuo7");
    			add_location(p1, file$E, 201, 30, 7203);
    			attr_dev(div, "class", "col-md-6 mb-2");
    			add_location(div, file$E, 199, 26, 7075);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);
    			append_dev(p0, strong);
    			append_dev(strong, t0);
    			append_dev(div, t1);
    			append_dev(div, p1);
    			append_dev(p1, t2);
    			append_dev(div, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*exploracionFisica*/ 512 && t0_value !== (t0_value = /*item*/ ctx[20].nombre + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*exploracionFisica*/ 512 && t2_value !== (t2_value = /*item*/ ctx[20].text + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$7.name,
    		type: "if",
    		source: "(198:21) {#if item.activo}",
    		ctx
    	});

    	return block;
    }

    // (196:16) {#each exploracionFisica as item}
    function create_each_block_5$1(ctx) {
    	let if_block_anchor;
    	let if_block = /*item*/ ctx[20].activo && create_if_block_4$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*item*/ ctx[20].activo) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$7(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5$1.name,
    		type: "each",
    		source: "(196:16) {#each exploracionFisica as item}",
    		ctx
    	});

    	return block;
    }

    // (224:21) {:else}
    function create_else_block_4(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No tiene antecedentes";
    			attr_dev(p, "class", "svelte-t6vuo7");
    			add_location(p, file$E, 224, 26, 8040);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(224:21) {:else}",
    		ctx
    	});

    	return block;
    }

    // (217:21) {#if item.activo}
    function create_if_block_3$7(ctx) {
    	let div;
    	let p0;
    	let strong;
    	let t0_value = /*item*/ ctx[20].nombre + "";
    	let t0;
    	let t1;
    	let p1;
    	let t2_value = /*item*/ ctx[20].descripcion + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p0 = element("p");
    			strong = element("strong");
    			t0 = text(t0_value);
    			t1 = space();
    			p1 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			add_location(strong, file$E, 219, 33, 7829);
    			attr_dev(p0, "class", "svelte-t6vuo7");
    			add_location(p0, file$E, 219, 30, 7826);
    			attr_dev(p1, "class", "svelte-t6vuo7");
    			add_location(p1, file$E, 220, 30, 7895);
    			attr_dev(div, "class", "col-md-6 mb-2");
    			add_location(div, file$E, 218, 26, 7767);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);
    			append_dev(p0, strong);
    			append_dev(strong, t0);
    			append_dev(div, t1);
    			append_dev(div, p1);
    			append_dev(p1, t2);
    			append_dev(div, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*antecedentes*/ 1024 && t0_value !== (t0_value = /*item*/ ctx[20].nombre + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*antecedentes*/ 1024 && t2_value !== (t2_value = /*item*/ ctx[20].descripcion + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(217:21) {#if item.activo}",
    		ctx
    	});

    	return block;
    }

    // (215:16) {#each antecedentes as item}
    function create_each_block_4$2(ctx) {
    	let if_block_anchor;
    	let if_block = /*item*/ ctx[20].activo && create_if_block_3$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*item*/ ctx[20].activo) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$7(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4$2.name,
    		type: "each",
    		source: "(215:16) {#each antecedentes as item}",
    		ctx
    	});

    	return block;
    }

    // (245:21) {:else}
    function create_else_block_3(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No tiene antecedentes";
    			attr_dev(p, "class", "svelte-t6vuo7");
    			add_location(p, file$E, 245, 26, 8861);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(245:21) {:else}",
    		ctx
    	});

    	return block;
    }

    // (239:32) {#if item.comentario}
    function create_if_block_2$d(ctx) {
    	let t0;
    	let t1_value = /*item*/ ctx[20].comentario + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text("(");
    			t1 = text(t1_value);
    			t2 = text(")");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*diagnosticos*/ 2048 && t1_value !== (t1_value = /*item*/ ctx[20].comentario + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$d.name,
    		type: "if",
    		source: "(239:32) {#if item.comentario}",
    		ctx
    	});

    	return block;
    }

    // (234:16) {#each diagnosticos as item}
    function create_each_block_3$4(ctx) {
    	let div;
    	let p;
    	let strong;
    	let t0_value = /*item*/ ctx[20].c + "";
    	let t0;
    	let t1;
    	let t2_value = /*item*/ ctx[20].d + "";
    	let t2;
    	let t3;
    	let t4;
    	let if_block = /*item*/ ctx[20].comentario && create_if_block_2$d(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			strong = element("strong");
    			t0 = text(t0_value);
    			t1 = text(" - ");
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();
    			add_location(strong, file$E, 237, 33, 8486);
    			attr_dev(p, "class", "svelte-t6vuo7");
    			add_location(p, file$E, 237, 30, 8483);
    			attr_dev(div, "class", "col-md-6 mb-2");
    			add_location(div, file$E, 236, 26, 8424);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, strong);
    			append_dev(strong, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(p, t3);
    			if (if_block) if_block.m(p, null);
    			append_dev(div, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*diagnosticos*/ 2048 && t0_value !== (t0_value = /*item*/ ctx[20].c + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*diagnosticos*/ 2048 && t2_value !== (t2_value = /*item*/ ctx[20].d + "")) set_data_dev(t2, t2_value);

    			if (/*item*/ ctx[20].comentario) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$d(ctx);
    					if_block.c();
    					if_block.m(p, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$4.name,
    		type: "each",
    		source: "(234:16) {#each diagnosticos as item}",
    		ctx
    	});

    	return block;
    }

    // (259:20) {:else}
    function create_else_block_2$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No se indicaron medicamentos";
    			attr_dev(p, "class", "svelte-t6vuo7");
    			add_location(p, file$E, 259, 24, 9402);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(259:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (255:16) {#each medicamentos as item}
    function create_each_block_2$6(ctx) {
    	let div;
    	let p;
    	let strong;
    	let t0_value = /*item*/ ctx[20].concentracion + "";
    	let t0;
    	let t1;
    	let t2_value = /*item*/ ctx[20].nombre + "";
    	let t2;
    	let t3;
    	let t4_value = /*item*/ ctx[20].cantidad + "";
    	let t4;
    	let t5;
    	let t6_value = /*item*/ ctx[20].frecuencia + "";
    	let t6;
    	let t7;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			strong = element("strong");
    			t0 = text(t0_value);
    			t1 = text(" de: ");
    			t2 = text(t2_value);
    			t3 = text(", Cantidad: ");
    			t4 = text(t4_value);
    			t5 = text(" frecuencia: ");
    			t6 = text(t6_value);
    			t7 = space();
    			add_location(strong, file$E, 256, 27, 9203);
    			attr_dev(p, "class", "svelte-t6vuo7");
    			add_location(p, file$E, 256, 24, 9200);
    			attr_dev(div, "class", "col-md-12 mb-2");
    			add_location(div, file$E, 255, 20, 9146);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, strong);
    			append_dev(strong, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(p, t3);
    			append_dev(p, t4);
    			append_dev(p, t5);
    			append_dev(p, t6);
    			append_dev(div, t7);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*medicamentos*/ 4096 && t0_value !== (t0_value = /*item*/ ctx[20].concentracion + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*medicamentos*/ 4096 && t2_value !== (t2_value = /*item*/ ctx[20].nombre + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*medicamentos*/ 4096 && t4_value !== (t4_value = /*item*/ ctx[20].cantidad + "")) set_data_dev(t4, t4_value);
    			if (dirty[0] & /*medicamentos*/ 4096 && t6_value !== (t6_value = /*item*/ ctx[20].frecuencia + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$6.name,
    		type: "each",
    		source: "(255:16) {#each medicamentos as item}",
    		ctx
    	});

    	return block;
    }

    // (277:20) {:else}
    function create_else_block_1$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No se indicaron medicamentos";
    			attr_dev(p, "class", "svelte-t6vuo7");
    			add_location(p, file$E, 277, 24, 10066);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(277:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (271:20) {#if item.tipo === 'LAB'}
    function create_if_block_1$i(ctx) {
    	let div;
    	let p;
    	let t0;
    	let t1_value = /*item*/ ctx[20].descripcion + "";
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text("- ");
    			t1 = text(t1_value);
    			attr_dev(p, "class", "svelte-t6vuo7");
    			add_location(p, file$E, 273, 29, 9924);
    			attr_dev(div, "class", "col-md-12 mb-2");
    			add_location(div, file$E, 272, 25, 9865);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*estudios*/ 8 && t1_value !== (t1_value = /*item*/ ctx[20].descripcion + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(271:20) {#if item.tipo === 'LAB'}",
    		ctx
    	});

    	return block;
    }

    // (270:16) {#each estudios as item}
    function create_each_block_1$7(ctx) {
    	let if_block_anchor;
    	let if_block = /*item*/ ctx[20].tipo === "LAB" && create_if_block_1$i(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*item*/ ctx[20].tipo === "LAB") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$i(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$7.name,
    		type: "each",
    		source: "(270:16) {#each estudios as item}",
    		ctx
    	});

    	return block;
    }

    // (288:20) {:else}
    function create_else_block$4(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No se indicaron medicamentos";
    			attr_dev(p, "class", "svelte-t6vuo7");
    			add_location(p, file$E, 288, 24, 10567);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(288:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (282:20) {#if item.tipo === 'IMG'}
    function create_if_block$q(ctx) {
    	let div;
    	let p;
    	let t0;
    	let t1_value = /*item*/ ctx[20].descripcion + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text("- ");
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(p, "class", "svelte-t6vuo7");
    			add_location(p, file$E, 284, 29, 10425);
    			attr_dev(div, "class", "col-md-12 mb-2");
    			add_location(div, file$E, 283, 25, 10366);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(div, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*estudios*/ 8 && t1_value !== (t1_value = /*item*/ ctx[20].descripcion + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(282:20) {#if item.tipo === 'IMG'}",
    		ctx
    	});

    	return block;
    }

    // (281:16) {#each estudios as item}
    function create_each_block$j(ctx) {
    	let if_block_anchor;
    	let if_block = /*item*/ ctx[20].tipo === "IMG" && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*item*/ ctx[20].tipo === "IMG") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$j.name,
    		type: "each",
    		source: "(281:16) {#each estudios as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let div27;
    	let button;
    	let i;
    	let t0;
    	let header;
    	let div0;
    	let img;
    	let img_src_value;
    	let t1;
    	let div1;
    	let p0;
    	let strong0;
    	let t2_value = /*empresa*/ ctx[2].nombre + "";
    	let t2;
    	let t3;
    	let p1;
    	let t4_value = /*empresa*/ ctx[2].direccion + "";
    	let t4;
    	let t5;
    	let p2;
    	let strong1;
    	let t7;
    	let t8_value = /*empresa*/ ctx[2].telefono + "";
    	let t8;
    	let t9;
    	let strong2;
    	let t11;
    	let t12_value = /*empresa*/ ctx[2].correo + "";
    	let t12;
    	let t13;
    	let p3;
    	let strong3;
    	let t15;
    	let t16_value = new Date(/*historia*/ ctx[1].fechaHora).toLocaleDateString("es-DO") + "";
    	let t16;
    	let t17;
    	let h2;
    	let t19;
    	let section0;
    	let h30;
    	let t21;
    	let div4;
    	let div2;
    	let p4;
    	let strong4;
    	let t23_value = /*paciente*/ ctx[0].nombres + "";
    	let t23;
    	let t24;
    	let t25_value = /*paciente*/ ctx[0].apellidos + "";
    	let t25;
    	let t26;
    	let p5;
    	let strong5;
    	let t28_value = /*paciente*/ ctx[0].cedula + "";
    	let t28;
    	let t29;
    	let p6;
    	let strong6;
    	let t31_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "";
    	let t31;
    	let t32;
    	let t33;
    	let p7;
    	let strong7;
    	let t35_value = /*paciente*/ ctx[0].sexo + "";
    	let t35;
    	let t36;
    	let div3;
    	let p8;
    	let strong8;
    	let t38_value = new Date(/*historia*/ ctx[1].fechaHora).toLocaleDateString("es-DO") + "";
    	let t38;
    	let t39;
    	let p9;
    	let strong9;
    	let t41_value = /*seguroMedico*/ ctx[5].nombre + "";
    	let t41;
    	let t42;
    	let p10;
    	let strong10;
    	let t44_value = /*paciente*/ ctx[0].numeroSeguro + "";
    	let t44;
    	let t45;
    	let section1;
    	let h31;
    	let t47;
    	let p11;
    	let t48_value = /*historia*/ ctx[1].motivoConsulta + "";
    	let t48;
    	let t49;
    	let section2;
    	let h32;
    	let t51;
    	let p12;
    	let t52_value = /*historia*/ ctx[1].historiaEnfermedad + "";
    	let t52;
    	let t53;
    	let section3;
    	let h33;
    	let t55;
    	let div9;
    	let div5;
    	let strong11;
    	let t57;
    	let t58_value = (/*presionAlterial*/ ctx[7].mm || 0) + "";
    	let t58;
    	let t59;
    	let t60_value = (/*presionAlterial*/ ctx[7].Hg || 0) + "";
    	let t60;
    	let t61;
    	let t62;
    	let div6;
    	let strong12;
    	let t64;
    	let t65_value = (/*historia*/ ctx[1].frecuenciaCardiaca || 0) + "";
    	let t65;
    	let t66;
    	let t67;
    	let div7;
    	let strong13;
    	let t69;
    	let t70_value = (/*historia*/ ctx[1].frecuenciaRespiratoria || 0) + "";
    	let t70;
    	let t71;
    	let t72;
    	let div8;
    	let strong14;
    	let t74;
    	let t75_value = (/*temperatura*/ ctx[6].valor || 0) + "";
    	let t75;
    	let t76;
    	let t77_value = (/*temperatura*/ ctx[6].tipo || "C") + "";
    	let t77;
    	let t78;
    	let section4;
    	let h34;
    	let t80;
    	let div15;
    	let div10;
    	let strong15;
    	let t82;
    	let t83_value = (/*peso*/ ctx[8].valor || 0) + "";
    	let t83;
    	let t84;
    	let t85_value = (/*peso*/ ctx[8].tipo || "Lb") + "";
    	let t85;
    	let t86;
    	let div11;
    	let strong16;
    	let t88;
    	let t89_value = (/*historia*/ ctx[1].saturacionOxigeno || 0) + "";
    	let t89;
    	let t90;
    	let t91;
    	let div12;
    	let strong17;
    	let t93;
    	let t94_value = (/*historia*/ ctx[1].escalaDolor || 0) + "";
    	let t94;
    	let t95;
    	let t96;
    	let div13;
    	let strong18;
    	let t98;
    	let t99_value = (/*historia*/ ctx[1].escalaGalsgow || 0) + "";
    	let t99;
    	let t100;
    	let t101;
    	let div14;
    	let strong19;
    	let t103;
    	let t104_value = /*historia*/ ctx[1].otrosParametros + "";
    	let t104;
    	let t105;
    	let section5;
    	let h35;
    	let t107;
    	let p13;
    	let t108_value = (/*historia*/ ctx[1].examenFisico || "Sin hallazgos positivos") + "";
    	let t108;
    	let t109;
    	let section6;
    	let h36;
    	let t111;
    	let div17;
    	let div16;
    	let t112;
    	let section7;
    	let h37;
    	let t114;
    	let div19;
    	let div18;
    	let t115;
    	let section8;
    	let h38;
    	let t117;
    	let div21;
    	let div20;
    	let t118;
    	let section9;
    	let h39;
    	let t120;
    	let div23;
    	let div22;
    	let t121;
    	let section10;
    	let h310;
    	let t123;
    	let div25;
    	let div24;
    	let p14;
    	let strong20;
    	let t125;
    	let t126;
    	let p15;
    	let strong21;
    	let t128;
    	let t129;
    	let div26;
    	let hr;
    	let t130;
    	let p16;
    	let t132;
    	let p17;
    	let strong22;
    	let mounted;
    	let dispose;
    	let each_value_5 = /*exploracionFisica*/ ctx[9];
    	validate_each_argument(each_value_5);
    	let each_blocks_5 = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks_5[i] = create_each_block_5$1(get_each_context_5$1(ctx, each_value_5, i));
    	}

    	let each0_else = null;

    	if (!each_value_5.length) {
    		each0_else = create_else_block_5(ctx);
    	}

    	let each_value_4 = /*antecedentes*/ ctx[10];
    	validate_each_argument(each_value_4);
    	let each_blocks_4 = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks_4[i] = create_each_block_4$2(get_each_context_4$2(ctx, each_value_4, i));
    	}

    	let each1_else = null;

    	if (!each_value_4.length) {
    		each1_else = create_else_block_4(ctx);
    	}

    	let each_value_3 = /*diagnosticos*/ ctx[11];
    	validate_each_argument(each_value_3);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_3[i] = create_each_block_3$4(get_each_context_3$4(ctx, each_value_3, i));
    	}

    	let each2_else = null;

    	if (!each_value_3.length) {
    		each2_else = create_else_block_3(ctx);
    	}

    	let each_value_2 = /*medicamentos*/ ctx[12];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$6(get_each_context_2$6(ctx, each_value_2, i));
    	}

    	let each3_else = null;

    	if (!each_value_2.length) {
    		each3_else = create_else_block_2$1(ctx);
    	}

    	let each_value_1 = /*estudios*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i));
    	}

    	let each4_else = null;

    	if (!each_value_1.length) {
    		each4_else = create_else_block_1$1(ctx);
    	}

    	let each_value = /*estudios*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
    	}

    	let each5_else = null;

    	if (!each_value.length) {
    		each5_else = create_else_block$4(ctx);
    	}

    	const block = {
    		c: function create() {
    			div27 = element("div");
    			button = element("button");
    			i = element("i");
    			t0 = space();
    			header = element("header");
    			div0 = element("div");
    			img = element("img");
    			t1 = space();
    			div1 = element("div");
    			p0 = element("p");
    			strong0 = element("strong");
    			t2 = text(t2_value);
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			p2 = element("p");
    			strong1 = element("strong");
    			strong1.textContent = "Tel.:";
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			strong2 = element("strong");
    			strong2.textContent = "Email:";
    			t11 = space();
    			t12 = text(t12_value);
    			t13 = space();
    			p3 = element("p");
    			strong3 = element("strong");
    			strong3.textContent = "Fecha:";
    			t15 = space();
    			t16 = text(t16_value);
    			t17 = space();
    			h2 = element("h2");
    			h2.textContent = "Historia Clinica";
    			t19 = space();
    			section0 = element("section");
    			h30 = element("h3");
    			h30.textContent = "Datos pacientes";
    			t21 = space();
    			div4 = element("div");
    			div2 = element("div");
    			p4 = element("p");
    			strong4 = element("strong");
    			strong4.textContent = "Nombre: ";
    			t23 = text(t23_value);
    			t24 = space();
    			t25 = text(t25_value);
    			t26 = space();
    			p5 = element("p");
    			strong5 = element("strong");
    			strong5.textContent = "Cedula/Pasaporte: ";
    			t28 = text(t28_value);
    			t29 = space();
    			p6 = element("p");
    			strong6 = element("strong");
    			strong6.textContent = "Edad: ";
    			t31 = text(t31_value);
    			t32 = text(" aos");
    			t33 = space();
    			p7 = element("p");
    			strong7 = element("strong");
    			strong7.textContent = "Sexo: ";
    			t35 = text(t35_value);
    			t36 = space();
    			div3 = element("div");
    			p8 = element("p");
    			strong8 = element("strong");
    			strong8.textContent = "Fecha Ingreso: ";
    			t38 = text(t38_value);
    			t39 = space();
    			p9 = element("p");
    			strong9 = element("strong");
    			strong9.textContent = "Aseguradora: ";
    			t41 = text(t41_value);
    			t42 = space();
    			p10 = element("p");
    			strong10 = element("strong");
    			strong10.textContent = "No. Afiliado: ";
    			t44 = text(t44_value);
    			t45 = space();
    			section1 = element("section");
    			h31 = element("h3");
    			h31.textContent = "Motivo de consulta";
    			t47 = space();
    			p11 = element("p");
    			t48 = text(t48_value);
    			t49 = space();
    			section2 = element("section");
    			h32 = element("h3");
    			h32.textContent = "Historia de la enfermedad";
    			t51 = space();
    			p12 = element("p");
    			t52 = text(t52_value);
    			t53 = space();
    			section3 = element("section");
    			h33 = element("h3");
    			h33.textContent = "Signos vitales";
    			t55 = space();
    			div9 = element("div");
    			div5 = element("div");
    			strong11 = element("strong");
    			strong11.textContent = "TA:";
    			t57 = space();
    			t58 = text(t58_value);
    			t59 = text("/");
    			t60 = text(t60_value);
    			t61 = text(" mm/hg");
    			t62 = space();
    			div6 = element("div");
    			strong12 = element("strong");
    			strong12.textContent = "FC:";
    			t64 = space();
    			t65 = text(t65_value);
    			t66 = text(" l/min");
    			t67 = space();
    			div7 = element("div");
    			strong13 = element("strong");
    			strong13.textContent = "FR:";
    			t69 = space();
    			t70 = text(t70_value);
    			t71 = text(" r/min");
    			t72 = space();
    			div8 = element("div");
    			strong14 = element("strong");
    			strong14.textContent = "T:";
    			t74 = space();
    			t75 = text(t75_value);
    			t76 = text(" ");
    			t77 = text(t77_value);
    			t78 = space();
    			section4 = element("section");
    			h34 = element("h3");
    			h34.textContent = "Otros parametros";
    			t80 = space();
    			div15 = element("div");
    			div10 = element("div");
    			strong15 = element("strong");
    			strong15.textContent = "Peso:";
    			t82 = space();
    			t83 = text(t83_value);
    			t84 = space();
    			t85 = text(t85_value);
    			t86 = space();
    			div11 = element("div");
    			strong16 = element("strong");
    			strong16.textContent = "SATO2:";
    			t88 = space();
    			t89 = text(t89_value);
    			t90 = text("%");
    			t91 = space();
    			div12 = element("div");
    			strong17 = element("strong");
    			strong17.textContent = "Esc. Dolor:";
    			t93 = space();
    			t94 = text(t94_value);
    			t95 = text(" / 10");
    			t96 = space();
    			div13 = element("div");
    			strong18 = element("strong");
    			strong18.textContent = "Esc. Glasgow:";
    			t98 = space();
    			t99 = text(t99_value);
    			t100 = text(" / 15");
    			t101 = space();
    			div14 = element("div");
    			strong19 = element("strong");
    			strong19.textContent = "Otros:";
    			t103 = space();
    			t104 = text(t104_value);
    			t105 = space();
    			section5 = element("section");
    			h35 = element("h3");
    			h35.textContent = "Examen Fisico";
    			t107 = space();
    			p13 = element("p");
    			t108 = text(t108_value);
    			t109 = space();
    			section6 = element("section");
    			h36 = element("h3");
    			h36.textContent = "Exploracion Fisica";
    			t111 = space();
    			div17 = element("div");
    			div16 = element("div");

    			for (let i = 0; i < each_blocks_5.length; i += 1) {
    				each_blocks_5[i].c();
    			}

    			if (each0_else) {
    				each0_else.c();
    			}

    			t112 = space();
    			section7 = element("section");
    			h37 = element("h3");
    			h37.textContent = "Antecedentes";
    			t114 = space();
    			div19 = element("div");
    			div18 = element("div");

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].c();
    			}

    			if (each1_else) {
    				each1_else.c();
    			}

    			t115 = space();
    			section8 = element("section");
    			h38 = element("h3");
    			h38.textContent = "Diagnosticos";
    			t117 = space();
    			div21 = element("div");
    			div20 = element("div");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			if (each2_else) {
    				each2_else.c();
    			}

    			t118 = space();
    			section9 = element("section");
    			h39 = element("h3");
    			h39.textContent = "Medicamentos";
    			t120 = space();
    			div23 = element("div");
    			div22 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			if (each3_else) {
    				each3_else.c();
    			}

    			t121 = space();
    			section10 = element("section");
    			h310 = element("h3");
    			h310.textContent = "Estudios";
    			t123 = space();
    			div25 = element("div");
    			div24 = element("div");
    			p14 = element("p");
    			strong20 = element("strong");
    			strong20.textContent = "Estudios de Laboratorio";
    			t125 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			if (each4_else) {
    				each4_else.c();
    			}

    			t126 = space();
    			p15 = element("p");
    			strong21 = element("strong");
    			strong21.textContent = "Estudios de Imagenes";
    			t128 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			if (each5_else) {
    				each5_else.c();
    			}

    			t129 = space();
    			div26 = element("div");
    			hr = element("hr");
    			t130 = space();
    			p16 = element("p");
    			p16.textContent = "Firma del especialista";
    			t132 = space();
    			p17 = element("p");
    			strong22 = element("strong");
    			strong22.textContent = `${user().title}. ${user().name}`;
    			attr_dev(i, "class", "mdi mdi-printer");
    			add_location(i, file$E, 112, 8, 3456);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn m-b-15 ml-2 mr-2 btn-lg btn-rounded-circle btn-success btn-imprimir svelte-t6vuo7");
    			add_location(button, file$E, 107, 4, 3280);
    			if (img.src !== (img_src_value = /*logo*/ ctx[4])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo empresa");
    			attr_dev(img, "class", "svelte-t6vuo7");
    			add_location(img, file$E, 116, 12, 3566);
    			attr_dev(div0, "class", "logo-empresa");
    			add_location(div0, file$E, 115, 8, 3526);
    			add_location(strong0, file$E, 119, 68, 3724);
    			set_style(p0, "font-size", "1.4rem");
    			set_style(p0, "text-transform", "uppercase");
    			attr_dev(p0, "class", "svelte-t6vuo7");
    			add_location(p0, file$E, 119, 12, 3668);
    			attr_dev(p1, "class", "svelte-t6vuo7");
    			add_location(p1, file$E, 120, 12, 3775);
    			add_location(strong1, file$E, 121, 15, 3818);
    			add_location(strong2, file$E, 121, 57, 3860);
    			attr_dev(p2, "class", "svelte-t6vuo7");
    			add_location(p2, file$E, 121, 12, 3815);
    			add_location(strong3, file$E, 122, 15, 3921);
    			attr_dev(p3, "class", "svelte-t6vuo7");
    			add_location(p3, file$E, 122, 12, 3918);
    			attr_dev(div1, "class", "datos-empresa svelte-t6vuo7");
    			add_location(div1, file$E, 118, 8, 3627);
    			attr_dev(header, "class", "svelte-t6vuo7");
    			add_location(header, file$E, 114, 4, 3508);
    			attr_dev(h2, "class", "title svelte-t6vuo7");
    			add_location(h2, file$E, 125, 4, 4044);
    			attr_dev(h30, "class", "svelte-t6vuo7");
    			add_location(h30, file$E, 127, 8, 4108);
    			add_location(strong4, file$E, 130, 19, 4231);
    			attr_dev(p4, "class", "svelte-t6vuo7");
    			add_location(p4, file$E, 130, 16, 4228);
    			add_location(strong5, file$E, 131, 19, 4320);
    			attr_dev(p5, "class", "svelte-t6vuo7");
    			add_location(p5, file$E, 131, 16, 4317);
    			add_location(strong6, file$E, 132, 19, 4397);
    			attr_dev(p6, "class", "svelte-t6vuo7");
    			add_location(p6, file$E, 132, 16, 4394);
    			add_location(strong7, file$E, 133, 19, 4490);
    			attr_dev(p7, "class", "svelte-t6vuo7");
    			add_location(p7, file$E, 133, 16, 4487);
    			attr_dev(div2, "class", "col-md-6 datos-paciente svelte-t6vuo7");
    			add_location(div2, file$E, 129, 12, 4173);
    			add_location(strong8, file$E, 136, 19, 4624);
    			attr_dev(p8, "class", "svelte-t6vuo7");
    			add_location(p8, file$E, 136, 16, 4621);
    			add_location(strong9, file$E, 137, 19, 4739);
    			attr_dev(p9, "class", "svelte-t6vuo7");
    			add_location(p9, file$E, 137, 16, 4736);
    			add_location(strong10, file$E, 138, 19, 4815);
    			attr_dev(p10, "class", "svelte-t6vuo7");
    			add_location(p10, file$E, 138, 16, 4812);
    			attr_dev(div3, "class", "col-md-6 datos-paciente svelte-t6vuo7");
    			add_location(div3, file$E, 135, 12, 4566);
    			attr_dev(div4, "class", "row");
    			add_location(div4, file$E, 128, 8, 4142);
    			attr_dev(section0, "class", "svelte-t6vuo7");
    			add_location(section0, file$E, 126, 4, 4089);
    			attr_dev(h31, "class", "svelte-t6vuo7");
    			add_location(h31, file$E, 143, 8, 4950);
    			attr_dev(p11, "class", "svelte-t6vuo7");
    			add_location(p11, file$E, 144, 8, 4987);
    			attr_dev(section1, "class", "svelte-t6vuo7");
    			add_location(section1, file$E, 142, 4, 4931);
    			attr_dev(h32, "class", "svelte-t6vuo7");
    			add_location(h32, file$E, 147, 8, 5060);
    			attr_dev(p12, "class", "svelte-t6vuo7");
    			add_location(p12, file$E, 148, 8, 5104);
    			attr_dev(section2, "class", "svelte-t6vuo7");
    			add_location(section2, file$E, 146, 4, 5041);
    			attr_dev(h33, "class", "svelte-t6vuo7");
    			add_location(h33, file$E, 151, 8, 5181);
    			add_location(strong11, file$E, 154, 16, 5285);
    			attr_dev(div5, "class", "col-md-3");
    			add_location(div5, file$E, 153, 12, 5245);
    			add_location(strong12, file$E, 157, 16, 5437);
    			attr_dev(div6, "class", "col-md-3");
    			add_location(div6, file$E, 156, 12, 5397);
    			add_location(strong13, file$E, 160, 16, 5572);
    			attr_dev(div7, "class", "col-md-3");
    			add_location(div7, file$E, 159, 12, 5532);
    			add_location(strong14, file$E, 163, 16, 5711);
    			attr_dev(div8, "class", "col-md-3");
    			add_location(div8, file$E, 162, 12, 5671);
    			attr_dev(div9, "class", "row");
    			add_location(div9, file$E, 152, 8, 5214);
    			attr_dev(section3, "class", "svelte-t6vuo7");
    			add_location(section3, file$E, 150, 4, 5162);
    			attr_dev(h34, "class", "svelte-t6vuo7");
    			add_location(h34, file$E, 168, 8, 5859);
    			add_location(strong15, file$E, 171, 16, 5965);
    			attr_dev(div10, "class", "col-md-3");
    			add_location(div10, file$E, 170, 12, 5925);
    			add_location(strong16, file$E, 174, 16, 6099);
    			attr_dev(div11, "class", "col-md-3");
    			add_location(div11, file$E, 173, 12, 6059);
    			add_location(strong17, file$E, 177, 16, 6231);
    			attr_dev(div12, "class", "col-md-3");
    			add_location(div12, file$E, 176, 12, 6191);
    			add_location(strong18, file$E, 180, 16, 6366);
    			attr_dev(div13, "class", "col-md-3");
    			add_location(div13, file$E, 179, 12, 6326);
    			add_location(strong19, file$E, 183, 16, 6510);
    			attr_dev(div14, "class", "col-md-3 mt-2");
    			add_location(div14, file$E, 182, 12, 6465);
    			attr_dev(div15, "class", "row");
    			add_location(div15, file$E, 169, 8, 5894);
    			attr_dev(section4, "class", "svelte-t6vuo7");
    			add_location(section4, file$E, 167, 4, 5840);
    			attr_dev(h35, "class", "svelte-t6vuo7");
    			add_location(h35, file$E, 188, 8, 6638);
    			attr_dev(p13, "class", "svelte-t6vuo7");
    			add_location(p13, file$E, 189, 8, 6670);
    			attr_dev(section5, "class", "svelte-t6vuo7");
    			add_location(section5, file$E, 187, 4, 6619);
    			attr_dev(h36, "class", "svelte-t6vuo7");
    			add_location(h36, file$E, 192, 8, 6770);
    			attr_dev(div16, "class", "row");
    			add_location(div16, file$E, 194, 12, 6846);
    			attr_dev(div17, "class", "exploracion");
    			add_location(div17, file$E, 193, 8, 6807);
    			attr_dev(section6, "class", "svelte-t6vuo7");
    			add_location(section6, file$E, 191, 4, 6751);
    			attr_dev(h37, "class", "svelte-t6vuo7");
    			add_location(h37, file$E, 211, 8, 7473);
    			attr_dev(div18, "class", "row");
    			add_location(div18, file$E, 213, 12, 7543);
    			attr_dev(div19, "class", "exploracion");
    			add_location(div19, file$E, 212, 8, 7504);
    			attr_dev(section7, "class", "svelte-t6vuo7");
    			add_location(section7, file$E, 210, 4, 7454);
    			attr_dev(h38, "class", "svelte-t6vuo7");
    			add_location(h38, file$E, 230, 8, 8170);
    			attr_dev(div20, "class", "row");
    			add_location(div20, file$E, 232, 12, 8240);
    			attr_dev(div21, "class", "exploracion");
    			add_location(div21, file$E, 231, 8, 8201);
    			attr_dev(section8, "class", "svelte-t6vuo7");
    			add_location(section8, file$E, 229, 4, 8151);
    			attr_dev(h39, "class", "svelte-t6vuo7");
    			add_location(h39, file$E, 251, 8, 8991);
    			attr_dev(div22, "class", "row");
    			add_location(div22, file$E, 253, 12, 9061);
    			attr_dev(div23, "class", "exploracion");
    			add_location(div23, file$E, 252, 8, 9022);
    			attr_dev(section9, "class", "svelte-t6vuo7");
    			add_location(section9, file$E, 250, 4, 8972);
    			attr_dev(h310, "class", "svelte-t6vuo7");
    			add_location(h310, file$E, 265, 8, 9539);
    			add_location(strong20, file$E, 268, 33, 9657);
    			attr_dev(p14, "class", "col-6 svelte-t6vuo7");
    			add_location(p14, file$E, 268, 16, 9640);
    			add_location(strong21, file$E, 279, 33, 10161);
    			attr_dev(p15, "class", "col-6 svelte-t6vuo7");
    			add_location(p15, file$E, 279, 16, 10144);
    			attr_dev(div24, "class", "row");
    			add_location(div24, file$E, 267, 12, 9605);
    			attr_dev(div25, "class", "exploracion");
    			add_location(div25, file$E, 266, 8, 9566);
    			attr_dev(section10, "class", "svelte-t6vuo7");
    			add_location(section10, file$E, 264, 4, 9520);
    			add_location(hr, file$E, 294, 8, 10714);
    			attr_dev(p16, "class", "svelte-t6vuo7");
    			add_location(p16, file$E, 295, 8, 10728);
    			add_location(strong22, file$E, 296, 11, 10770);
    			attr_dev(p17, "class", "svelte-t6vuo7");
    			add_location(p17, file$E, 296, 8, 10767);
    			attr_dev(div26, "class", "firma svelte-t6vuo7");
    			add_location(div26, file$E, 293, 4, 10685);
    			attr_dev(div27, "class", "reporte svelte-t6vuo7");
    			add_location(div27, file$E, 106, 0, 3253);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div27, anchor);
    			append_dev(div27, button);
    			append_dev(button, i);
    			append_dev(div27, t0);
    			append_dev(div27, header);
    			append_dev(header, div0);
    			append_dev(div0, img);
    			append_dev(header, t1);
    			append_dev(header, div1);
    			append_dev(div1, p0);
    			append_dev(p0, strong0);
    			append_dev(strong0, t2);
    			append_dev(div1, t3);
    			append_dev(div1, p1);
    			append_dev(p1, t4);
    			append_dev(div1, t5);
    			append_dev(div1, p2);
    			append_dev(p2, strong1);
    			append_dev(p2, t7);
    			append_dev(p2, t8);
    			append_dev(p2, t9);
    			append_dev(p2, strong2);
    			append_dev(p2, t11);
    			append_dev(p2, t12);
    			append_dev(div1, t13);
    			append_dev(div1, p3);
    			append_dev(p3, strong3);
    			append_dev(p3, t15);
    			append_dev(p3, t16);
    			append_dev(div27, t17);
    			append_dev(div27, h2);
    			append_dev(div27, t19);
    			append_dev(div27, section0);
    			append_dev(section0, h30);
    			append_dev(section0, t21);
    			append_dev(section0, div4);
    			append_dev(div4, div2);
    			append_dev(div2, p4);
    			append_dev(p4, strong4);
    			append_dev(p4, t23);
    			append_dev(p4, t24);
    			append_dev(p4, t25);
    			append_dev(div2, t26);
    			append_dev(div2, p5);
    			append_dev(p5, strong5);
    			append_dev(p5, t28);
    			append_dev(div2, t29);
    			append_dev(div2, p6);
    			append_dev(p6, strong6);
    			append_dev(p6, t31);
    			append_dev(p6, t32);
    			append_dev(div2, t33);
    			append_dev(div2, p7);
    			append_dev(p7, strong7);
    			append_dev(p7, t35);
    			append_dev(div4, t36);
    			append_dev(div4, div3);
    			append_dev(div3, p8);
    			append_dev(p8, strong8);
    			append_dev(p8, t38);
    			append_dev(div3, t39);
    			append_dev(div3, p9);
    			append_dev(p9, strong9);
    			append_dev(p9, t41);
    			append_dev(div3, t42);
    			append_dev(div3, p10);
    			append_dev(p10, strong10);
    			append_dev(p10, t44);
    			append_dev(div27, t45);
    			append_dev(div27, section1);
    			append_dev(section1, h31);
    			append_dev(section1, t47);
    			append_dev(section1, p11);
    			append_dev(p11, t48);
    			append_dev(div27, t49);
    			append_dev(div27, section2);
    			append_dev(section2, h32);
    			append_dev(section2, t51);
    			append_dev(section2, p12);
    			append_dev(p12, t52);
    			append_dev(div27, t53);
    			append_dev(div27, section3);
    			append_dev(section3, h33);
    			append_dev(section3, t55);
    			append_dev(section3, div9);
    			append_dev(div9, div5);
    			append_dev(div5, strong11);
    			append_dev(div5, t57);
    			append_dev(div5, t58);
    			append_dev(div5, t59);
    			append_dev(div5, t60);
    			append_dev(div5, t61);
    			append_dev(div9, t62);
    			append_dev(div9, div6);
    			append_dev(div6, strong12);
    			append_dev(div6, t64);
    			append_dev(div6, t65);
    			append_dev(div6, t66);
    			append_dev(div9, t67);
    			append_dev(div9, div7);
    			append_dev(div7, strong13);
    			append_dev(div7, t69);
    			append_dev(div7, t70);
    			append_dev(div7, t71);
    			append_dev(div9, t72);
    			append_dev(div9, div8);
    			append_dev(div8, strong14);
    			append_dev(div8, t74);
    			append_dev(div8, t75);
    			append_dev(div8, t76);
    			append_dev(div8, t77);
    			append_dev(div27, t78);
    			append_dev(div27, section4);
    			append_dev(section4, h34);
    			append_dev(section4, t80);
    			append_dev(section4, div15);
    			append_dev(div15, div10);
    			append_dev(div10, strong15);
    			append_dev(div10, t82);
    			append_dev(div10, t83);
    			append_dev(div10, t84);
    			append_dev(div10, t85);
    			append_dev(div15, t86);
    			append_dev(div15, div11);
    			append_dev(div11, strong16);
    			append_dev(div11, t88);
    			append_dev(div11, t89);
    			append_dev(div11, t90);
    			append_dev(div15, t91);
    			append_dev(div15, div12);
    			append_dev(div12, strong17);
    			append_dev(div12, t93);
    			append_dev(div12, t94);
    			append_dev(div12, t95);
    			append_dev(div15, t96);
    			append_dev(div15, div13);
    			append_dev(div13, strong18);
    			append_dev(div13, t98);
    			append_dev(div13, t99);
    			append_dev(div13, t100);
    			append_dev(div15, t101);
    			append_dev(div15, div14);
    			append_dev(div14, strong19);
    			append_dev(div14, t103);
    			append_dev(div14, t104);
    			append_dev(div27, t105);
    			append_dev(div27, section5);
    			append_dev(section5, h35);
    			append_dev(section5, t107);
    			append_dev(section5, p13);
    			append_dev(p13, t108);
    			append_dev(div27, t109);
    			append_dev(div27, section6);
    			append_dev(section6, h36);
    			append_dev(section6, t111);
    			append_dev(section6, div17);
    			append_dev(div17, div16);

    			for (let i = 0; i < each_blocks_5.length; i += 1) {
    				each_blocks_5[i].m(div16, null);
    			}

    			if (each0_else) {
    				each0_else.m(div16, null);
    			}

    			append_dev(div27, t112);
    			append_dev(div27, section7);
    			append_dev(section7, h37);
    			append_dev(section7, t114);
    			append_dev(section7, div19);
    			append_dev(div19, div18);

    			for (let i = 0; i < each_blocks_4.length; i += 1) {
    				each_blocks_4[i].m(div18, null);
    			}

    			if (each1_else) {
    				each1_else.m(div18, null);
    			}

    			append_dev(div27, t115);
    			append_dev(div27, section8);
    			append_dev(section8, h38);
    			append_dev(section8, t117);
    			append_dev(section8, div21);
    			append_dev(div21, div20);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(div20, null);
    			}

    			if (each2_else) {
    				each2_else.m(div20, null);
    			}

    			append_dev(div27, t118);
    			append_dev(div27, section9);
    			append_dev(section9, h39);
    			append_dev(section9, t120);
    			append_dev(section9, div23);
    			append_dev(div23, div22);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div22, null);
    			}

    			if (each3_else) {
    				each3_else.m(div22, null);
    			}

    			append_dev(div27, t121);
    			append_dev(div27, section10);
    			append_dev(section10, h310);
    			append_dev(section10, t123);
    			append_dev(section10, div25);
    			append_dev(div25, div24);
    			append_dev(div24, p14);
    			append_dev(p14, strong20);
    			append_dev(div24, t125);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div24, null);
    			}

    			if (each4_else) {
    				each4_else.m(div24, null);
    			}

    			append_dev(div24, t126);
    			append_dev(div24, p15);
    			append_dev(p15, strong21);
    			append_dev(div24, t128);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div24, null);
    			}

    			if (each5_else) {
    				each5_else.m(div24, null);
    			}

    			append_dev(div27, t129);
    			append_dev(div27, div26);
    			append_dev(div26, hr);
    			append_dev(div26, t130);
    			append_dev(div26, p16);
    			append_dev(div26, t132);
    			append_dev(div26, p17);
    			append_dev(p17, strong22);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[14], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*logo*/ 16 && img.src !== (img_src_value = /*logo*/ ctx[4])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty[0] & /*empresa*/ 4 && t2_value !== (t2_value = /*empresa*/ ctx[2].nombre + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*empresa*/ 4 && t4_value !== (t4_value = /*empresa*/ ctx[2].direccion + "")) set_data_dev(t4, t4_value);
    			if (dirty[0] & /*empresa*/ 4 && t8_value !== (t8_value = /*empresa*/ ctx[2].telefono + "")) set_data_dev(t8, t8_value);
    			if (dirty[0] & /*empresa*/ 4 && t12_value !== (t12_value = /*empresa*/ ctx[2].correo + "")) set_data_dev(t12, t12_value);
    			if (dirty[0] & /*historia*/ 2 && t16_value !== (t16_value = new Date(/*historia*/ ctx[1].fechaHora).toLocaleDateString("es-DO") + "")) set_data_dev(t16, t16_value);
    			if (dirty[0] & /*paciente*/ 1 && t23_value !== (t23_value = /*paciente*/ ctx[0].nombres + "")) set_data_dev(t23, t23_value);
    			if (dirty[0] & /*paciente*/ 1 && t25_value !== (t25_value = /*paciente*/ ctx[0].apellidos + "")) set_data_dev(t25, t25_value);
    			if (dirty[0] & /*paciente*/ 1 && t28_value !== (t28_value = /*paciente*/ ctx[0].cedula + "")) set_data_dev(t28, t28_value);
    			if (dirty[0] & /*paciente*/ 1 && t31_value !== (t31_value = calcularEdad(/*paciente*/ ctx[0].fechaNacimiento) + "")) set_data_dev(t31, t31_value);
    			if (dirty[0] & /*paciente*/ 1 && t35_value !== (t35_value = /*paciente*/ ctx[0].sexo + "")) set_data_dev(t35, t35_value);
    			if (dirty[0] & /*historia*/ 2 && t38_value !== (t38_value = new Date(/*historia*/ ctx[1].fechaHora).toLocaleDateString("es-DO") + "")) set_data_dev(t38, t38_value);
    			if (dirty[0] & /*seguroMedico*/ 32 && t41_value !== (t41_value = /*seguroMedico*/ ctx[5].nombre + "")) set_data_dev(t41, t41_value);
    			if (dirty[0] & /*paciente*/ 1 && t44_value !== (t44_value = /*paciente*/ ctx[0].numeroSeguro + "")) set_data_dev(t44, t44_value);
    			if (dirty[0] & /*historia*/ 2 && t48_value !== (t48_value = /*historia*/ ctx[1].motivoConsulta + "")) set_data_dev(t48, t48_value);
    			if (dirty[0] & /*historia*/ 2 && t52_value !== (t52_value = /*historia*/ ctx[1].historiaEnfermedad + "")) set_data_dev(t52, t52_value);
    			if (dirty[0] & /*presionAlterial*/ 128 && t58_value !== (t58_value = (/*presionAlterial*/ ctx[7].mm || 0) + "")) set_data_dev(t58, t58_value);
    			if (dirty[0] & /*presionAlterial*/ 128 && t60_value !== (t60_value = (/*presionAlterial*/ ctx[7].Hg || 0) + "")) set_data_dev(t60, t60_value);
    			if (dirty[0] & /*historia*/ 2 && t65_value !== (t65_value = (/*historia*/ ctx[1].frecuenciaCardiaca || 0) + "")) set_data_dev(t65, t65_value);
    			if (dirty[0] & /*historia*/ 2 && t70_value !== (t70_value = (/*historia*/ ctx[1].frecuenciaRespiratoria || 0) + "")) set_data_dev(t70, t70_value);
    			if (dirty[0] & /*temperatura*/ 64 && t75_value !== (t75_value = (/*temperatura*/ ctx[6].valor || 0) + "")) set_data_dev(t75, t75_value);
    			if (dirty[0] & /*temperatura*/ 64 && t77_value !== (t77_value = (/*temperatura*/ ctx[6].tipo || "C") + "")) set_data_dev(t77, t77_value);
    			if (dirty[0] & /*peso*/ 256 && t83_value !== (t83_value = (/*peso*/ ctx[8].valor || 0) + "")) set_data_dev(t83, t83_value);
    			if (dirty[0] & /*peso*/ 256 && t85_value !== (t85_value = (/*peso*/ ctx[8].tipo || "Lb") + "")) set_data_dev(t85, t85_value);
    			if (dirty[0] & /*historia*/ 2 && t89_value !== (t89_value = (/*historia*/ ctx[1].saturacionOxigeno || 0) + "")) set_data_dev(t89, t89_value);
    			if (dirty[0] & /*historia*/ 2 && t94_value !== (t94_value = (/*historia*/ ctx[1].escalaDolor || 0) + "")) set_data_dev(t94, t94_value);
    			if (dirty[0] & /*historia*/ 2 && t99_value !== (t99_value = (/*historia*/ ctx[1].escalaGalsgow || 0) + "")) set_data_dev(t99, t99_value);
    			if (dirty[0] & /*historia*/ 2 && t104_value !== (t104_value = /*historia*/ ctx[1].otrosParametros + "")) set_data_dev(t104, t104_value);
    			if (dirty[0] & /*historia*/ 2 && t108_value !== (t108_value = (/*historia*/ ctx[1].examenFisico || "Sin hallazgos positivos") + "")) set_data_dev(t108, t108_value);

    			if (dirty[0] & /*exploracionFisica*/ 512) {
    				each_value_5 = /*exploracionFisica*/ ctx[9];
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5$1(ctx, each_value_5, i);

    					if (each_blocks_5[i]) {
    						each_blocks_5[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_5[i] = create_each_block_5$1(child_ctx);
    						each_blocks_5[i].c();
    						each_blocks_5[i].m(div16, null);
    					}
    				}

    				for (; i < each_blocks_5.length; i += 1) {
    					each_blocks_5[i].d(1);
    				}

    				each_blocks_5.length = each_value_5.length;

    				if (each_value_5.length) {
    					if (each0_else) {
    						each0_else.d(1);
    						each0_else = null;
    					}
    				} else if (!each0_else) {
    					each0_else = create_else_block_5(ctx);
    					each0_else.c();
    					each0_else.m(div16, null);
    				}
    			}

    			if (dirty[0] & /*antecedentes*/ 1024) {
    				each_value_4 = /*antecedentes*/ ctx[10];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4$2(ctx, each_value_4, i);

    					if (each_blocks_4[i]) {
    						each_blocks_4[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_4[i] = create_each_block_4$2(child_ctx);
    						each_blocks_4[i].c();
    						each_blocks_4[i].m(div18, null);
    					}
    				}

    				for (; i < each_blocks_4.length; i += 1) {
    					each_blocks_4[i].d(1);
    				}

    				each_blocks_4.length = each_value_4.length;

    				if (each_value_4.length) {
    					if (each1_else) {
    						each1_else.d(1);
    						each1_else = null;
    					}
    				} else if (!each1_else) {
    					each1_else = create_else_block_4(ctx);
    					each1_else.c();
    					each1_else.m(div18, null);
    				}
    			}

    			if (dirty[0] & /*diagnosticos*/ 2048) {
    				each_value_3 = /*diagnosticos*/ ctx[11];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$4(ctx, each_value_3, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_3$4(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(div20, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_3.length;

    				if (each_value_3.length) {
    					if (each2_else) {
    						each2_else.d(1);
    						each2_else = null;
    					}
    				} else if (!each2_else) {
    					each2_else = create_else_block_3(ctx);
    					each2_else.c();
    					each2_else.m(div20, null);
    				}
    			}

    			if (dirty[0] & /*medicamentos*/ 4096) {
    				each_value_2 = /*medicamentos*/ ctx[12];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$6(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2$6(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(div22, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;

    				if (each_value_2.length) {
    					if (each3_else) {
    						each3_else.d(1);
    						each3_else = null;
    					}
    				} else if (!each3_else) {
    					each3_else = create_else_block_2$1(ctx);
    					each3_else.c();
    					each3_else.m(div22, null);
    				}
    			}

    			if (dirty[0] & /*estudios*/ 8) {
    				each_value_1 = /*estudios*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$7(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$7(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div24, t126);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;

    				if (each_value_1.length) {
    					if (each4_else) {
    						each4_else.d(1);
    						each4_else = null;
    					}
    				} else if (!each4_else) {
    					each4_else = create_else_block_1$1(ctx);
    					each4_else.c();
    					each4_else.m(div24, t126);
    				}
    			}

    			if (dirty[0] & /*estudios*/ 8) {
    				each_value = /*estudios*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$j(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$j(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div24, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;

    				if (each_value.length) {
    					if (each5_else) {
    						each5_else.d(1);
    						each5_else = null;
    					}
    				} else if (!each5_else) {
    					each5_else = create_else_block$4(ctx);
    					each5_else.c();
    					each5_else.m(div24, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div27);
    			destroy_each(each_blocks_5, detaching);
    			if (each0_else) each0_else.d();
    			destroy_each(each_blocks_4, detaching);
    			if (each1_else) each1_else.d();
    			destroy_each(each_blocks_3, detaching);
    			if (each2_else) each2_else.d();
    			destroy_each(each_blocks_2, detaching);
    			if (each3_else) each3_else.d();
    			destroy_each(each_blocks_1, detaching);
    			if (each4_else) each4_else.d();
    			destroy_each(each_blocks, detaching);
    			if (each5_else) each5_else.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Actual", slots, []);
    	let { params } = $$props;
    	let errorServer = false;
    	let paciente = {};
    	let historia = {};
    	let empresa = {};
    	let estudios = [];
    	let logo = "";
    	let seguroMedico = "";
    	let temperatura = {};
    	let presionAlterial = {};
    	let peso = {};
    	let exploracionFisica = [];
    	let antecedentes = [];
    	let diagnosticos = [];
    	let medicamentos = [];

    	const cargarImagenEmpresa = (idConsultorio, idImagen) => {
    		const config = {
    			method: "get",
    			url: `${url}/imagenes/${idConsultorio}/${idImagen}`,
    			responseType: "blob",
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(4, logo = URL.createObjectURL(res.data));
    			console.log(logo);
    		}).catch(err => {
    			console.error(err);
    		});
    	};

    	const cargarPaciente = () => {
    		const config = {
    			method: "get",
    			url: `${url}/pacientes/${params.idPaciente}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(0, paciente = res.data);

    			if (res.data.seguroMedico) {
    				$$invalidate(5, seguroMedico = res.data.seguroMedico[0]);
    			}

    			$$invalidate(10, antecedentes = res.data.antecedentes);
    			console.log(paciente);
    		});
    	};

    	const cargarHistoria = () => {
    		const config = {
    			method: "get",
    			url: `${url}/historias/${params.idHistoria}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(1, historia = res.data);
    			$$invalidate(3, estudios = res.data.estudios);
    			$$invalidate(6, temperatura = res.data.temperatura);
    			$$invalidate(7, presionAlterial = res.data.presionAlterial);
    			$$invalidate(8, peso = res.data.peso);
    			$$invalidate(9, exploracionFisica = res.data.exploracionFisica);
    			$$invalidate(11, diagnosticos = res.data.diagnosticos);
    			$$invalidate(12, medicamentos = res.data.medicamentos);
    			$$invalidate(3, estudios = res.data.estudios);
    			console.log(historia);
    		});
    	};

    	const cargarEmpresa = () => {
    		const config = {
    			method: "get",
    			url: `${url}/empresas/${user().empresa}`,
    			headers: {
    				Authorization: `${localStorage.getItem("auth")}`
    			}
    		};

    		axios$1(config).then(res => {
    			$$invalidate(2, empresa = res.data);
    			cargarImagenEmpresa(empresa.id, empresa.logo);
    			console.log(empresa);
    		});
    	};

    	onMount(() => {
    		jQuery("html, body").animate({ scrollTop: 0 }, "slow");
    		cargarPaciente();
    		cargarHistoria();
    		cargarEmpresa();
    		document.title = "Consultorio Medico | Reporte";
    	});

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$n.warn(`<Actual> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => window.print();

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(13, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		url,
    		user,
    		calcularEdad,
    		axios: axios$1,
    		params,
    		errorServer,
    		paciente,
    		historia,
    		empresa,
    		estudios,
    		logo,
    		seguroMedico,
    		temperatura,
    		presionAlterial,
    		peso,
    		exploracionFisica,
    		antecedentes,
    		diagnosticos,
    		medicamentos,
    		cargarImagenEmpresa,
    		cargarPaciente,
    		cargarHistoria,
    		cargarEmpresa
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(13, params = $$props.params);
    		if ("errorServer" in $$props) errorServer = $$props.errorServer;
    		if ("paciente" in $$props) $$invalidate(0, paciente = $$props.paciente);
    		if ("historia" in $$props) $$invalidate(1, historia = $$props.historia);
    		if ("empresa" in $$props) $$invalidate(2, empresa = $$props.empresa);
    		if ("estudios" in $$props) $$invalidate(3, estudios = $$props.estudios);
    		if ("logo" in $$props) $$invalidate(4, logo = $$props.logo);
    		if ("seguroMedico" in $$props) $$invalidate(5, seguroMedico = $$props.seguroMedico);
    		if ("temperatura" in $$props) $$invalidate(6, temperatura = $$props.temperatura);
    		if ("presionAlterial" in $$props) $$invalidate(7, presionAlterial = $$props.presionAlterial);
    		if ("peso" in $$props) $$invalidate(8, peso = $$props.peso);
    		if ("exploracionFisica" in $$props) $$invalidate(9, exploracionFisica = $$props.exploracionFisica);
    		if ("antecedentes" in $$props) $$invalidate(10, antecedentes = $$props.antecedentes);
    		if ("diagnosticos" in $$props) $$invalidate(11, diagnosticos = $$props.diagnosticos);
    		if ("medicamentos" in $$props) $$invalidate(12, medicamentos = $$props.medicamentos);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		paciente,
    		historia,
    		empresa,
    		estudios,
    		logo,
    		seguroMedico,
    		temperatura,
    		presionAlterial,
    		peso,
    		exploracionFisica,
    		antecedentes,
    		diagnosticos,
    		medicamentos,
    		params,
    		click_handler
    	];
    }

    class Actual extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { params: 13 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Actual",
    			options,
    			id: create_fragment$G.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*params*/ ctx[13] === undefined && !("params" in props)) {
    			console_1$n.warn("<Actual> was created without expected prop 'params'");
    		}
    	}

    	get params() {
    		throw new Error("<Actual>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Actual>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const routes = {
        "/": wrap({
            component: Index,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/prueba": Prueba,
        "/login": Login,
        "/register": Register,
        "/pacientes": wrap({
            component: Index$1,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/pacientes/perfil/:id": wrap({
            component: PacientePerfil,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/pacientes/crear": wrap({
            component: PacienteCrear,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/pacientes/:idPaciente/editar": wrap({
            component: PacienteEditar,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/pacientes/:idPaciente/historias/:idHistoria": wrap({
            component: HistoriaClinica,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/historias": wrap({
            component: Index$3,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/usuarios": wrap({
            component: Index$2,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/impresion/pacientes/:idPaciente/historias/:idHistoria/medicamentos": wrap({
            component: Medicamentos,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/impresion/pacientes/:idPaciente/historias/:idHistoria/estudios/laboratorios": wrap({
            component: Estudios,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/impresion/pacientes/:idPaciente/historias/:idHistoria/estudios/imagenes": wrap({
            component: Imagenes,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/pacientes/:idPaciente/historias/:idHistoria/imprimir/estudios": wrap({
            component: ImprimirRecetas,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/empresa/detalles": wrap({
            component: Detalle,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/recetas": wrap({
            component: Index$4,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/citas": wrap({
            component: Index$5,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
        "/pacientes/:idPaciente/historias/:idHistoria/imprimir": wrap({
            component: Actual,
            conditions: [
                async (detail) => {
                    if(isLogin()){
                        return true
                    }else {
                        return push('/login')
                    }
                }
            ]
        }),
    };

    /* src\App.svelte generated by Svelte v3.29.0 */

    function create_fragment$H(ctx) {
    	let router;
    	let current;
    	router = new Router({ props: { routes }, $$inline: true });
    	router.$on("routeLoaded", /*event*/ ctx[0]);

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);

    	const event = e => {
    		jQuery("body").removeClass("sidebar-open");
    	};

    	onMount(() => {
    		
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Router, routes, onMount, event });
    	return [event];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    const app = new App({
    	target: document.getElementById("app"),
    	props: {}
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
